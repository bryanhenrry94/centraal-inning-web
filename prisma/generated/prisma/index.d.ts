
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model TenantRegistry
 * 
 */
export type TenantRegistry = $Result.DefaultSelection<Prisma.$TenantRegistryPayload>
/**
 * Model TenantInvitation
 * 
 */
export type TenantInvitation = $Result.DefaultSelection<Prisma.$TenantInvitationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Membership
 * 
 */
export type Membership = $Result.DefaultSelection<Prisma.$MembershipPayload>
/**
 * Model GlobalParameter
 * 
 */
export type GlobalParameter = $Result.DefaultSelection<Prisma.$GlobalParameterPayload>
/**
 * Model Verdict
 * 
 */
export type Verdict = $Result.DefaultSelection<Prisma.$VerdictPayload>
/**
 * Model VerdictInterest
 * 
 */
export type VerdictInterest = $Result.DefaultSelection<Prisma.$VerdictInterestPayload>
/**
 * Model VerdictInterestDetails
 * 
 */
export type VerdictInterestDetails = $Result.DefaultSelection<Prisma.$VerdictInterestDetailsPayload>
/**
 * Model VerdictEmbargo
 * 
 */
export type VerdictEmbargo = $Result.DefaultSelection<Prisma.$VerdictEmbargoPayload>
/**
 * Model VerdictBailiffServices
 * 
 */
export type VerdictBailiffServices = $Result.DefaultSelection<Prisma.$VerdictBailiffServicesPayload>
/**
 * Model VerdictAttachment
 * 
 */
export type VerdictAttachment = $Result.DefaultSelection<Prisma.$VerdictAttachmentPayload>
/**
 * Model InterestType
 * 
 */
export type InterestType = $Result.DefaultSelection<Prisma.$InterestTypePayload>
/**
 * Model InterestDetail
 * 
 */
export type InterestDetail = $Result.DefaultSelection<Prisma.$InterestDetailPayload>
/**
 * Model BillingInvoice
 * 
 */
export type BillingInvoice = $Result.DefaultSelection<Prisma.$BillingInvoicePayload>
/**
 * Model BillingInvoiceDetail
 * 
 */
export type BillingInvoiceDetail = $Result.DefaultSelection<Prisma.$BillingInvoiceDetailPayload>
/**
 * Model BillingPlan
 * 
 */
export type BillingPlan = $Result.DefaultSelection<Prisma.$BillingPlanPayload>
/**
 * Model BillingSubscription
 * 
 */
export type BillingSubscription = $Result.DefaultSelection<Prisma.$BillingSubscriptionPayload>
/**
 * Model BillingPayment
 * 
 */
export type BillingPayment = $Result.DefaultSelection<Prisma.$BillingPaymentPayload>
/**
 * Model CollectionCase
 * 
 */
export type CollectionCase = $Result.DefaultSelection<Prisma.$CollectionCasePayload>
/**
 * Model Penalty
 * 
 */
export type Penalty = $Result.DefaultSelection<Prisma.$PenaltyPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model PaymentAgreement
 * 
 */
export type PaymentAgreement = $Result.DefaultSelection<Prisma.$PaymentAgreementPayload>
/**
 * Model Debtor
 * 
 */
export type Debtor = $Result.DefaultSelection<Prisma.$DebtorPayload>
/**
 * Model DebtorIncome
 * 
 */
export type DebtorIncome = $Result.DefaultSelection<Prisma.$DebtorIncomePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CalculationTypeEnum: {
  FIXED: 'FIXED',
  VARIABLE: 'VARIABLE'
};

export type CalculationTypeEnum = (typeof CalculationTypeEnum)[keyof typeof CalculationTypeEnum]


export const VerdictStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type VerdictStatus = (typeof VerdictStatus)[keyof typeof VerdictStatus]


export const NotificationType: {
  AANMANING: 'AANMANING',
  SOMMATIE: 'SOMMATIE',
  INGEBREKESTELLING: 'INGEBREKESTELLING',
  BLOKKADE: 'BLOKKADE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const IdentificationType: {
  DNI: 'DNI',
  PASSPORT: 'PASSPORT',
  NIE: 'NIE',
  CIF: 'CIF',
  KVK: 'KVK',
  OTHER: 'OTHER'
};

export type IdentificationType = (typeof IdentificationType)[keyof typeof IdentificationType]


export const MembershipStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type MembershipStatus = (typeof MembershipStatus)[keyof typeof MembershipStatus]


export const BillingSubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  CANCELED: 'CANCELED',
  EXPIRED: 'EXPIRED'
};

export type BillingSubscriptionStatus = (typeof BillingSubscriptionStatus)[keyof typeof BillingSubscriptionStatus]


export const roleEnum: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  ACCOUNTANT: 'ACCOUNTANT',
  BAILIFF: 'BAILIFF',
  VIEWER: 'VIEWER'
};

export type roleEnum = (typeof roleEnum)[keyof typeof roleEnum]


export const PaymentMethod: {
  CASH: 'CASH',
  TRANSFER: 'TRANSFER',
  CREDIT_CARD: 'CREDIT_CARD',
  CHECK: 'CHECK',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const AgreementStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type AgreementStatus = (typeof AgreementStatus)[keyof typeof AgreementStatus]


export const CollectionStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type CollectionStatus = (typeof CollectionStatus)[keyof typeof CollectionStatus]

}

export type CalculationTypeEnum = $Enums.CalculationTypeEnum

export const CalculationTypeEnum: typeof $Enums.CalculationTypeEnum

export type VerdictStatus = $Enums.VerdictStatus

export const VerdictStatus: typeof $Enums.VerdictStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type IdentificationType = $Enums.IdentificationType

export const IdentificationType: typeof $Enums.IdentificationType

export type MembershipStatus = $Enums.MembershipStatus

export const MembershipStatus: typeof $Enums.MembershipStatus

export type BillingSubscriptionStatus = $Enums.BillingSubscriptionStatus

export const BillingSubscriptionStatus: typeof $Enums.BillingSubscriptionStatus

export type roleEnum = $Enums.roleEnum

export const roleEnum: typeof $Enums.roleEnum

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type AgreementStatus = $Enums.AgreementStatus

export const AgreementStatus: typeof $Enums.AgreementStatus

export type CollectionStatus = $Enums.CollectionStatus

export const CollectionStatus: typeof $Enums.CollectionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantRegistry`: Exposes CRUD operations for the **TenantRegistry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantRegistries
    * const tenantRegistries = await prisma.tenantRegistry.findMany()
    * ```
    */
  get tenantRegistry(): Prisma.TenantRegistryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantInvitation`: Exposes CRUD operations for the **TenantInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantInvitations
    * const tenantInvitations = await prisma.tenantInvitation.findMany()
    * ```
    */
  get tenantInvitation(): Prisma.TenantInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membership`: Exposes CRUD operations for the **Membership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memberships
    * const memberships = await prisma.membership.findMany()
    * ```
    */
  get membership(): Prisma.MembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.globalParameter`: Exposes CRUD operations for the **GlobalParameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GlobalParameters
    * const globalParameters = await prisma.globalParameter.findMany()
    * ```
    */
  get globalParameter(): Prisma.GlobalParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdict`: Exposes CRUD operations for the **Verdict** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verdicts
    * const verdicts = await prisma.verdict.findMany()
    * ```
    */
  get verdict(): Prisma.VerdictDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictInterest`: Exposes CRUD operations for the **VerdictInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictInterests
    * const verdictInterests = await prisma.verdictInterest.findMany()
    * ```
    */
  get verdictInterest(): Prisma.VerdictInterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictInterestDetails`: Exposes CRUD operations for the **VerdictInterestDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictInterestDetails
    * const verdictInterestDetails = await prisma.verdictInterestDetails.findMany()
    * ```
    */
  get verdictInterestDetails(): Prisma.VerdictInterestDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictEmbargo`: Exposes CRUD operations for the **VerdictEmbargo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictEmbargos
    * const verdictEmbargos = await prisma.verdictEmbargo.findMany()
    * ```
    */
  get verdictEmbargo(): Prisma.VerdictEmbargoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictBailiffServices`: Exposes CRUD operations for the **VerdictBailiffServices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictBailiffServices
    * const verdictBailiffServices = await prisma.verdictBailiffServices.findMany()
    * ```
    */
  get verdictBailiffServices(): Prisma.VerdictBailiffServicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictAttachment`: Exposes CRUD operations for the **VerdictAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictAttachments
    * const verdictAttachments = await prisma.verdictAttachment.findMany()
    * ```
    */
  get verdictAttachment(): Prisma.VerdictAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interestType`: Exposes CRUD operations for the **InterestType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterestTypes
    * const interestTypes = await prisma.interestType.findMany()
    * ```
    */
  get interestType(): Prisma.InterestTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interestDetail`: Exposes CRUD operations for the **InterestDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterestDetails
    * const interestDetails = await prisma.interestDetail.findMany()
    * ```
    */
  get interestDetail(): Prisma.InterestDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingInvoice`: Exposes CRUD operations for the **BillingInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingInvoices
    * const billingInvoices = await prisma.billingInvoice.findMany()
    * ```
    */
  get billingInvoice(): Prisma.BillingInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingInvoiceDetail`: Exposes CRUD operations for the **BillingInvoiceDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingInvoiceDetails
    * const billingInvoiceDetails = await prisma.billingInvoiceDetail.findMany()
    * ```
    */
  get billingInvoiceDetail(): Prisma.BillingInvoiceDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingPlan`: Exposes CRUD operations for the **BillingPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingPlans
    * const billingPlans = await prisma.billingPlan.findMany()
    * ```
    */
  get billingPlan(): Prisma.BillingPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingSubscription`: Exposes CRUD operations for the **BillingSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingSubscriptions
    * const billingSubscriptions = await prisma.billingSubscription.findMany()
    * ```
    */
  get billingSubscription(): Prisma.BillingSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingPayment`: Exposes CRUD operations for the **BillingPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingPayments
    * const billingPayments = await prisma.billingPayment.findMany()
    * ```
    */
  get billingPayment(): Prisma.BillingPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionCase`: Exposes CRUD operations for the **CollectionCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionCases
    * const collectionCases = await prisma.collectionCase.findMany()
    * ```
    */
  get collectionCase(): Prisma.CollectionCaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.penalty`: Exposes CRUD operations for the **Penalty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Penalties
    * const penalties = await prisma.penalty.findMany()
    * ```
    */
  get penalty(): Prisma.PenaltyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentAgreement`: Exposes CRUD operations for the **PaymentAgreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentAgreements
    * const paymentAgreements = await prisma.paymentAgreement.findMany()
    * ```
    */
  get paymentAgreement(): Prisma.PaymentAgreementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debtor`: Exposes CRUD operations for the **Debtor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Debtors
    * const debtors = await prisma.debtor.findMany()
    * ```
    */
  get debtor(): Prisma.DebtorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debtorIncome`: Exposes CRUD operations for the **DebtorIncome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DebtorIncomes
    * const debtorIncomes = await prisma.debtorIncome.findMany()
    * ```
    */
  get debtorIncome(): Prisma.DebtorIncomeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    TenantRegistry: 'TenantRegistry',
    TenantInvitation: 'TenantInvitation',
    User: 'User',
    Membership: 'Membership',
    GlobalParameter: 'GlobalParameter',
    Verdict: 'Verdict',
    VerdictInterest: 'VerdictInterest',
    VerdictInterestDetails: 'VerdictInterestDetails',
    VerdictEmbargo: 'VerdictEmbargo',
    VerdictBailiffServices: 'VerdictBailiffServices',
    VerdictAttachment: 'VerdictAttachment',
    InterestType: 'InterestType',
    InterestDetail: 'InterestDetail',
    BillingInvoice: 'BillingInvoice',
    BillingInvoiceDetail: 'BillingInvoiceDetail',
    BillingPlan: 'BillingPlan',
    BillingSubscription: 'BillingSubscription',
    BillingPayment: 'BillingPayment',
    CollectionCase: 'CollectionCase',
    Penalty: 'Penalty',
    Notification: 'Notification',
    Payment: 'Payment',
    PaymentAgreement: 'PaymentAgreement',
    Debtor: 'Debtor',
    DebtorIncome: 'DebtorIncome'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "tenantRegistry" | "tenantInvitation" | "user" | "membership" | "globalParameter" | "verdict" | "verdictInterest" | "verdictInterestDetails" | "verdictEmbargo" | "verdictBailiffServices" | "verdictAttachment" | "interestType" | "interestDetail" | "billingInvoice" | "billingInvoiceDetail" | "billingPlan" | "billingSubscription" | "billingPayment" | "collectionCase" | "penalty" | "notification" | "payment" | "paymentAgreement" | "debtor" | "debtorIncome"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      TenantRegistry: {
        payload: Prisma.$TenantRegistryPayload<ExtArgs>
        fields: Prisma.TenantRegistryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantRegistryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantRegistryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          findFirst: {
            args: Prisma.TenantRegistryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantRegistryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          findMany: {
            args: Prisma.TenantRegistryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>[]
          }
          create: {
            args: Prisma.TenantRegistryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          createMany: {
            args: Prisma.TenantRegistryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantRegistryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>[]
          }
          delete: {
            args: Prisma.TenantRegistryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          update: {
            args: Prisma.TenantRegistryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          deleteMany: {
            args: Prisma.TenantRegistryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantRegistryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantRegistryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>[]
          }
          upsert: {
            args: Prisma.TenantRegistryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          aggregate: {
            args: Prisma.TenantRegistryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantRegistry>
          }
          groupBy: {
            args: Prisma.TenantRegistryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantRegistryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantRegistryCountArgs<ExtArgs>
            result: $Utils.Optional<TenantRegistryCountAggregateOutputType> | number
          }
        }
      }
      TenantInvitation: {
        payload: Prisma.$TenantInvitationPayload<ExtArgs>
        fields: Prisma.TenantInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantInvitationPayload>
          }
          findFirst: {
            args: Prisma.TenantInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantInvitationPayload>
          }
          findMany: {
            args: Prisma.TenantInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantInvitationPayload>[]
          }
          create: {
            args: Prisma.TenantInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantInvitationPayload>
          }
          createMany: {
            args: Prisma.TenantInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantInvitationPayload>[]
          }
          delete: {
            args: Prisma.TenantInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantInvitationPayload>
          }
          update: {
            args: Prisma.TenantInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantInvitationPayload>
          }
          deleteMany: {
            args: Prisma.TenantInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantInvitationPayload>[]
          }
          upsert: {
            args: Prisma.TenantInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantInvitationPayload>
          }
          aggregate: {
            args: Prisma.TenantInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantInvitation>
          }
          groupBy: {
            args: Prisma.TenantInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<TenantInvitationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Membership: {
        payload: Prisma.$MembershipPayload<ExtArgs>
        fields: Prisma.MembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findFirst: {
            args: Prisma.MembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findMany: {
            args: Prisma.MembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          create: {
            args: Prisma.MembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          createMany: {
            args: Prisma.MembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          delete: {
            args: Prisma.MembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          update: {
            args: Prisma.MembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          deleteMany: {
            args: Prisma.MembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          upsert: {
            args: Prisma.MembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          aggregate: {
            args: Prisma.MembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembership>
          }
          groupBy: {
            args: Prisma.MembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipCountAggregateOutputType> | number
          }
        }
      }
      GlobalParameter: {
        payload: Prisma.$GlobalParameterPayload<ExtArgs>
        fields: Prisma.GlobalParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GlobalParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GlobalParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalParameterPayload>
          }
          findFirst: {
            args: Prisma.GlobalParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GlobalParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalParameterPayload>
          }
          findMany: {
            args: Prisma.GlobalParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalParameterPayload>[]
          }
          create: {
            args: Prisma.GlobalParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalParameterPayload>
          }
          createMany: {
            args: Prisma.GlobalParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GlobalParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalParameterPayload>[]
          }
          delete: {
            args: Prisma.GlobalParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalParameterPayload>
          }
          update: {
            args: Prisma.GlobalParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalParameterPayload>
          }
          deleteMany: {
            args: Prisma.GlobalParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GlobalParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GlobalParameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalParameterPayload>[]
          }
          upsert: {
            args: Prisma.GlobalParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GlobalParameterPayload>
          }
          aggregate: {
            args: Prisma.GlobalParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGlobalParameter>
          }
          groupBy: {
            args: Prisma.GlobalParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<GlobalParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.GlobalParameterCountArgs<ExtArgs>
            result: $Utils.Optional<GlobalParameterCountAggregateOutputType> | number
          }
        }
      }
      Verdict: {
        payload: Prisma.$VerdictPayload<ExtArgs>
        fields: Prisma.VerdictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          findFirst: {
            args: Prisma.VerdictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          findMany: {
            args: Prisma.VerdictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          create: {
            args: Prisma.VerdictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          createMany: {
            args: Prisma.VerdictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          delete: {
            args: Prisma.VerdictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          update: {
            args: Prisma.VerdictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          deleteMany: {
            args: Prisma.VerdictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          upsert: {
            args: Prisma.VerdictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          aggregate: {
            args: Prisma.VerdictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdict>
          }
          groupBy: {
            args: Prisma.VerdictGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictCountAggregateOutputType> | number
          }
        }
      }
      VerdictInterest: {
        payload: Prisma.$VerdictInterestPayload<ExtArgs>
        fields: Prisma.VerdictInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          findFirst: {
            args: Prisma.VerdictInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          findMany: {
            args: Prisma.VerdictInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>[]
          }
          create: {
            args: Prisma.VerdictInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          createMany: {
            args: Prisma.VerdictInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>[]
          }
          delete: {
            args: Prisma.VerdictInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          update: {
            args: Prisma.VerdictInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          deleteMany: {
            args: Prisma.VerdictInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictInterestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>[]
          }
          upsert: {
            args: Prisma.VerdictInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          aggregate: {
            args: Prisma.VerdictInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictInterest>
          }
          groupBy: {
            args: Prisma.VerdictInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictInterestCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestCountAggregateOutputType> | number
          }
        }
      }
      VerdictInterestDetails: {
        payload: Prisma.$VerdictInterestDetailsPayload<ExtArgs>
        fields: Prisma.VerdictInterestDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictInterestDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictInterestDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          findFirst: {
            args: Prisma.VerdictInterestDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictInterestDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          findMany: {
            args: Prisma.VerdictInterestDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>[]
          }
          create: {
            args: Prisma.VerdictInterestDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          createMany: {
            args: Prisma.VerdictInterestDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictInterestDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>[]
          }
          delete: {
            args: Prisma.VerdictInterestDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          update: {
            args: Prisma.VerdictInterestDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          deleteMany: {
            args: Prisma.VerdictInterestDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictInterestDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictInterestDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>[]
          }
          upsert: {
            args: Prisma.VerdictInterestDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          aggregate: {
            args: Prisma.VerdictInterestDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictInterestDetails>
          }
          groupBy: {
            args: Prisma.VerdictInterestDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictInterestDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestDetailsCountAggregateOutputType> | number
          }
        }
      }
      VerdictEmbargo: {
        payload: Prisma.$VerdictEmbargoPayload<ExtArgs>
        fields: Prisma.VerdictEmbargoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictEmbargoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictEmbargoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          findFirst: {
            args: Prisma.VerdictEmbargoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictEmbargoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          findMany: {
            args: Prisma.VerdictEmbargoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>[]
          }
          create: {
            args: Prisma.VerdictEmbargoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          createMany: {
            args: Prisma.VerdictEmbargoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictEmbargoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>[]
          }
          delete: {
            args: Prisma.VerdictEmbargoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          update: {
            args: Prisma.VerdictEmbargoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          deleteMany: {
            args: Prisma.VerdictEmbargoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictEmbargoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictEmbargoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>[]
          }
          upsert: {
            args: Prisma.VerdictEmbargoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          aggregate: {
            args: Prisma.VerdictEmbargoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictEmbargo>
          }
          groupBy: {
            args: Prisma.VerdictEmbargoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictEmbargoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictEmbargoCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictEmbargoCountAggregateOutputType> | number
          }
        }
      }
      VerdictBailiffServices: {
        payload: Prisma.$VerdictBailiffServicesPayload<ExtArgs>
        fields: Prisma.VerdictBailiffServicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictBailiffServicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictBailiffServicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          findFirst: {
            args: Prisma.VerdictBailiffServicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictBailiffServicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          findMany: {
            args: Prisma.VerdictBailiffServicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>[]
          }
          create: {
            args: Prisma.VerdictBailiffServicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          createMany: {
            args: Prisma.VerdictBailiffServicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictBailiffServicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>[]
          }
          delete: {
            args: Prisma.VerdictBailiffServicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          update: {
            args: Prisma.VerdictBailiffServicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          deleteMany: {
            args: Prisma.VerdictBailiffServicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictBailiffServicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictBailiffServicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>[]
          }
          upsert: {
            args: Prisma.VerdictBailiffServicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          aggregate: {
            args: Prisma.VerdictBailiffServicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictBailiffServices>
          }
          groupBy: {
            args: Prisma.VerdictBailiffServicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictBailiffServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictBailiffServicesCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictBailiffServicesCountAggregateOutputType> | number
          }
        }
      }
      VerdictAttachment: {
        payload: Prisma.$VerdictAttachmentPayload<ExtArgs>
        fields: Prisma.VerdictAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          findFirst: {
            args: Prisma.VerdictAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          findMany: {
            args: Prisma.VerdictAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>[]
          }
          create: {
            args: Prisma.VerdictAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          createMany: {
            args: Prisma.VerdictAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>[]
          }
          delete: {
            args: Prisma.VerdictAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          update: {
            args: Prisma.VerdictAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.VerdictAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.VerdictAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          aggregate: {
            args: Prisma.VerdictAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictAttachment>
          }
          groupBy: {
            args: Prisma.VerdictAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictAttachmentCountAggregateOutputType> | number
          }
        }
      }
      InterestType: {
        payload: Prisma.$InterestTypePayload<ExtArgs>
        fields: Prisma.InterestTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          findFirst: {
            args: Prisma.InterestTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          findMany: {
            args: Prisma.InterestTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>[]
          }
          create: {
            args: Prisma.InterestTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          createMany: {
            args: Prisma.InterestTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>[]
          }
          delete: {
            args: Prisma.InterestTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          update: {
            args: Prisma.InterestTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          deleteMany: {
            args: Prisma.InterestTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterestTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>[]
          }
          upsert: {
            args: Prisma.InterestTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          aggregate: {
            args: Prisma.InterestTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterestType>
          }
          groupBy: {
            args: Prisma.InterestTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestTypeCountArgs<ExtArgs>
            result: $Utils.Optional<InterestTypeCountAggregateOutputType> | number
          }
        }
      }
      InterestDetail: {
        payload: Prisma.$InterestDetailPayload<ExtArgs>
        fields: Prisma.InterestDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          findFirst: {
            args: Prisma.InterestDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          findMany: {
            args: Prisma.InterestDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>[]
          }
          create: {
            args: Prisma.InterestDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          createMany: {
            args: Prisma.InterestDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>[]
          }
          delete: {
            args: Prisma.InterestDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          update: {
            args: Prisma.InterestDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          deleteMany: {
            args: Prisma.InterestDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterestDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>[]
          }
          upsert: {
            args: Prisma.InterestDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          aggregate: {
            args: Prisma.InterestDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterestDetail>
          }
          groupBy: {
            args: Prisma.InterestDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestDetailCountArgs<ExtArgs>
            result: $Utils.Optional<InterestDetailCountAggregateOutputType> | number
          }
        }
      }
      BillingInvoice: {
        payload: Prisma.$BillingInvoicePayload<ExtArgs>
        fields: Prisma.BillingInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          findFirst: {
            args: Prisma.BillingInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          findMany: {
            args: Prisma.BillingInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>[]
          }
          create: {
            args: Prisma.BillingInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          createMany: {
            args: Prisma.BillingInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>[]
          }
          delete: {
            args: Prisma.BillingInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          update: {
            args: Prisma.BillingInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          deleteMany: {
            args: Prisma.BillingInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>[]
          }
          upsert: {
            args: Prisma.BillingInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          aggregate: {
            args: Prisma.BillingInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingInvoice>
          }
          groupBy: {
            args: Prisma.BillingInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceCountAggregateOutputType> | number
          }
        }
      }
      BillingInvoiceDetail: {
        payload: Prisma.$BillingInvoiceDetailPayload<ExtArgs>
        fields: Prisma.BillingInvoiceDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingInvoiceDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingInvoiceDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          findFirst: {
            args: Prisma.BillingInvoiceDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingInvoiceDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          findMany: {
            args: Prisma.BillingInvoiceDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>[]
          }
          create: {
            args: Prisma.BillingInvoiceDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          createMany: {
            args: Prisma.BillingInvoiceDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingInvoiceDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>[]
          }
          delete: {
            args: Prisma.BillingInvoiceDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          update: {
            args: Prisma.BillingInvoiceDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          deleteMany: {
            args: Prisma.BillingInvoiceDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingInvoiceDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingInvoiceDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>[]
          }
          upsert: {
            args: Prisma.BillingInvoiceDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          aggregate: {
            args: Prisma.BillingInvoiceDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingInvoiceDetail>
          }
          groupBy: {
            args: Prisma.BillingInvoiceDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingInvoiceDetailCountArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceDetailCountAggregateOutputType> | number
          }
        }
      }
      BillingPlan: {
        payload: Prisma.$BillingPlanPayload<ExtArgs>
        fields: Prisma.BillingPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          findFirst: {
            args: Prisma.BillingPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          findMany: {
            args: Prisma.BillingPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>[]
          }
          create: {
            args: Prisma.BillingPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          createMany: {
            args: Prisma.BillingPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>[]
          }
          delete: {
            args: Prisma.BillingPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          update: {
            args: Prisma.BillingPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          deleteMany: {
            args: Prisma.BillingPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>[]
          }
          upsert: {
            args: Prisma.BillingPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPlanPayload>
          }
          aggregate: {
            args: Prisma.BillingPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingPlan>
          }
          groupBy: {
            args: Prisma.BillingPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingPlanCountArgs<ExtArgs>
            result: $Utils.Optional<BillingPlanCountAggregateOutputType> | number
          }
        }
      }
      BillingSubscription: {
        payload: Prisma.$BillingSubscriptionPayload<ExtArgs>
        fields: Prisma.BillingSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.BillingSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSubscriptionPayload>
          }
          findMany: {
            args: Prisma.BillingSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSubscriptionPayload>[]
          }
          create: {
            args: Prisma.BillingSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSubscriptionPayload>
          }
          createMany: {
            args: Prisma.BillingSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.BillingSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSubscriptionPayload>
          }
          update: {
            args: Prisma.BillingSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.BillingSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.BillingSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.BillingSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingSubscription>
          }
          groupBy: {
            args: Prisma.BillingSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<BillingSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      BillingPayment: {
        payload: Prisma.$BillingPaymentPayload<ExtArgs>
        fields: Prisma.BillingPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          findFirst: {
            args: Prisma.BillingPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          findMany: {
            args: Prisma.BillingPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>[]
          }
          create: {
            args: Prisma.BillingPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          createMany: {
            args: Prisma.BillingPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>[]
          }
          delete: {
            args: Prisma.BillingPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          update: {
            args: Prisma.BillingPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          deleteMany: {
            args: Prisma.BillingPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>[]
          }
          upsert: {
            args: Prisma.BillingPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          aggregate: {
            args: Prisma.BillingPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingPayment>
          }
          groupBy: {
            args: Prisma.BillingPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<BillingPaymentCountAggregateOutputType> | number
          }
        }
      }
      CollectionCase: {
        payload: Prisma.$CollectionCasePayload<ExtArgs>
        fields: Prisma.CollectionCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          findFirst: {
            args: Prisma.CollectionCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          findMany: {
            args: Prisma.CollectionCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>[]
          }
          create: {
            args: Prisma.CollectionCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          createMany: {
            args: Prisma.CollectionCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>[]
          }
          delete: {
            args: Prisma.CollectionCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          update: {
            args: Prisma.CollectionCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          deleteMany: {
            args: Prisma.CollectionCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionCaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>[]
          }
          upsert: {
            args: Prisma.CollectionCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          aggregate: {
            args: Prisma.CollectionCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionCase>
          }
          groupBy: {
            args: Prisma.CollectionCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCaseCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseCountAggregateOutputType> | number
          }
        }
      }
      Penalty: {
        payload: Prisma.$PenaltyPayload<ExtArgs>
        fields: Prisma.PenaltyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PenaltyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PenaltyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          findFirst: {
            args: Prisma.PenaltyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PenaltyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          findMany: {
            args: Prisma.PenaltyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>[]
          }
          create: {
            args: Prisma.PenaltyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          createMany: {
            args: Prisma.PenaltyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PenaltyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>[]
          }
          delete: {
            args: Prisma.PenaltyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          update: {
            args: Prisma.PenaltyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          deleteMany: {
            args: Prisma.PenaltyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PenaltyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PenaltyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>[]
          }
          upsert: {
            args: Prisma.PenaltyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          aggregate: {
            args: Prisma.PenaltyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePenalty>
          }
          groupBy: {
            args: Prisma.PenaltyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PenaltyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PenaltyCountArgs<ExtArgs>
            result: $Utils.Optional<PenaltyCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      PaymentAgreement: {
        payload: Prisma.$PaymentAgreementPayload<ExtArgs>
        fields: Prisma.PaymentAgreementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentAgreementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentAgreementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          findFirst: {
            args: Prisma.PaymentAgreementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentAgreementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          findMany: {
            args: Prisma.PaymentAgreementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>[]
          }
          create: {
            args: Prisma.PaymentAgreementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          createMany: {
            args: Prisma.PaymentAgreementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentAgreementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>[]
          }
          delete: {
            args: Prisma.PaymentAgreementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          update: {
            args: Prisma.PaymentAgreementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          deleteMany: {
            args: Prisma.PaymentAgreementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentAgreementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentAgreementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>[]
          }
          upsert: {
            args: Prisma.PaymentAgreementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          aggregate: {
            args: Prisma.PaymentAgreementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentAgreement>
          }
          groupBy: {
            args: Prisma.PaymentAgreementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentAgreementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentAgreementCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentAgreementCountAggregateOutputType> | number
          }
        }
      }
      Debtor: {
        payload: Prisma.$DebtorPayload<ExtArgs>
        fields: Prisma.DebtorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          findFirst: {
            args: Prisma.DebtorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          findMany: {
            args: Prisma.DebtorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>[]
          }
          create: {
            args: Prisma.DebtorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          createMany: {
            args: Prisma.DebtorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DebtorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>[]
          }
          delete: {
            args: Prisma.DebtorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          update: {
            args: Prisma.DebtorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          deleteMany: {
            args: Prisma.DebtorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DebtorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>[]
          }
          upsert: {
            args: Prisma.DebtorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          aggregate: {
            args: Prisma.DebtorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebtor>
          }
          groupBy: {
            args: Prisma.DebtorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DebtorCountArgs<ExtArgs>
            result: $Utils.Optional<DebtorCountAggregateOutputType> | number
          }
        }
      }
      DebtorIncome: {
        payload: Prisma.$DebtorIncomePayload<ExtArgs>
        fields: Prisma.DebtorIncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtorIncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtorIncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          findFirst: {
            args: Prisma.DebtorIncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtorIncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          findMany: {
            args: Prisma.DebtorIncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>[]
          }
          create: {
            args: Prisma.DebtorIncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          createMany: {
            args: Prisma.DebtorIncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DebtorIncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>[]
          }
          delete: {
            args: Prisma.DebtorIncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          update: {
            args: Prisma.DebtorIncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          deleteMany: {
            args: Prisma.DebtorIncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtorIncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DebtorIncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>[]
          }
          upsert: {
            args: Prisma.DebtorIncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          aggregate: {
            args: Prisma.DebtorIncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebtorIncome>
          }
          groupBy: {
            args: Prisma.DebtorIncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtorIncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DebtorIncomeCountArgs<ExtArgs>
            result: $Utils.Optional<DebtorIncomeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    tenantRegistry?: TenantRegistryOmit
    tenantInvitation?: TenantInvitationOmit
    user?: UserOmit
    membership?: MembershipOmit
    globalParameter?: GlobalParameterOmit
    verdict?: VerdictOmit
    verdictInterest?: VerdictInterestOmit
    verdictInterestDetails?: VerdictInterestDetailsOmit
    verdictEmbargo?: VerdictEmbargoOmit
    verdictBailiffServices?: VerdictBailiffServicesOmit
    verdictAttachment?: VerdictAttachmentOmit
    interestType?: InterestTypeOmit
    interestDetail?: InterestDetailOmit
    billingInvoice?: BillingInvoiceOmit
    billingInvoiceDetail?: BillingInvoiceDetailOmit
    billingPlan?: BillingPlanOmit
    billingSubscription?: BillingSubscriptionOmit
    billingPayment?: BillingPaymentOmit
    collectionCase?: CollectionCaseOmit
    penalty?: PenaltyOmit
    notification?: NotificationOmit
    payment?: PaymentOmit
    paymentAgreement?: PaymentAgreementOmit
    debtor?: DebtorOmit
    debtorIncome?: DebtorIncomeOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    billingInvoice: number
    subscription: number
    collectionCases: number
    debtors: number
    memberships: number
    tenantInvitations: number
    verdicts: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingInvoice?: boolean | TenantCountOutputTypeCountBillingInvoiceArgs
    subscription?: boolean | TenantCountOutputTypeCountSubscriptionArgs
    collectionCases?: boolean | TenantCountOutputTypeCountCollectionCasesArgs
    debtors?: boolean | TenantCountOutputTypeCountDebtorsArgs
    memberships?: boolean | TenantCountOutputTypeCountMembershipsArgs
    tenantInvitations?: boolean | TenantCountOutputTypeCountTenantInvitationsArgs
    verdicts?: boolean | TenantCountOutputTypeCountVerdictsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBillingInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingSubscriptionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCollectionCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDebtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTenantInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantInvitationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVerdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    debtors: number
    memberships: number
    tenantInvitations: number
    verdictBailiffs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtors?: boolean | UserCountOutputTypeCountDebtorsArgs
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
    tenantInvitations?: boolean | UserCountOutputTypeCountTenantInvitationsArgs
    verdictBailiffs?: boolean | UserCountOutputTypeCountVerdictBailiffsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDebtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTenantInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerdictBailiffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
  }


  /**
   * Count Type VerdictCountOutputType
   */

  export type VerdictCountOutputType = {
    attachments: number
    bailiffServices: number
    verdictEmbargo: number
    verdictInterest: number
  }

  export type VerdictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | VerdictCountOutputTypeCountAttachmentsArgs
    bailiffServices?: boolean | VerdictCountOutputTypeCountBailiffServicesArgs
    verdictEmbargo?: boolean | VerdictCountOutputTypeCountVerdictEmbargoArgs
    verdictInterest?: boolean | VerdictCountOutputTypeCountVerdictInterestArgs
  }

  // Custom InputTypes
  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictCountOutputType
     */
    select?: VerdictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictAttachmentWhereInput
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountBailiffServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictBailiffServicesWhereInput
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountVerdictEmbargoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictEmbargoWhereInput
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountVerdictInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestWhereInput
  }


  /**
   * Count Type VerdictInterestCountOutputType
   */

  export type VerdictInterestCountOutputType = {
    details: number
  }

  export type VerdictInterestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | VerdictInterestCountOutputTypeCountDetailsArgs
  }

  // Custom InputTypes
  /**
   * VerdictInterestCountOutputType without action
   */
  export type VerdictInterestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestCountOutputType
     */
    select?: VerdictInterestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VerdictInterestCountOutputType without action
   */
  export type VerdictInterestCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestDetailsWhereInput
  }


  /**
   * Count Type InterestTypeCountOutputType
   */

  export type InterestTypeCountOutputType = {
    details: number
  }

  export type InterestTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | InterestTypeCountOutputTypeCountDetailsArgs
  }

  // Custom InputTypes
  /**
   * InterestTypeCountOutputType without action
   */
  export type InterestTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestTypeCountOutputType
     */
    select?: InterestTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterestTypeCountOutputType without action
   */
  export type InterestTypeCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestDetailWhereInput
  }


  /**
   * Count Type BillingInvoiceCountOutputType
   */

  export type BillingInvoiceCountOutputType = {
    details: number
    payments: number
    subscription: number
  }

  export type BillingInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | BillingInvoiceCountOutputTypeCountDetailsArgs
    payments?: boolean | BillingInvoiceCountOutputTypeCountPaymentsArgs
    subscription?: boolean | BillingInvoiceCountOutputTypeCountSubscriptionArgs
  }

  // Custom InputTypes
  /**
   * BillingInvoiceCountOutputType without action
   */
  export type BillingInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceCountOutputType
     */
    select?: BillingInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillingInvoiceCountOutputType without action
   */
  export type BillingInvoiceCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceDetailWhereInput
  }

  /**
   * BillingInvoiceCountOutputType without action
   */
  export type BillingInvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingPaymentWhereInput
  }

  /**
   * BillingInvoiceCountOutputType without action
   */
  export type BillingInvoiceCountOutputTypeCountSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingSubscriptionWhereInput
  }


  /**
   * Count Type BillingPlanCountOutputType
   */

  export type BillingPlanCountOutputType = {
    subscriptions: number
  }

  export type BillingPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | BillingPlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * BillingPlanCountOutputType without action
   */
  export type BillingPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlanCountOutputType
     */
    select?: BillingPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillingPlanCountOutputType without action
   */
  export type BillingPlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingSubscriptionWhereInput
  }


  /**
   * Count Type CollectionCaseCountOutputType
   */

  export type CollectionCaseCountOutputType = {
    notifications: number
    payments: number
    agreements: number
    penalties: number
  }

  export type CollectionCaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | CollectionCaseCountOutputTypeCountNotificationsArgs
    payments?: boolean | CollectionCaseCountOutputTypeCountPaymentsArgs
    agreements?: boolean | CollectionCaseCountOutputTypeCountAgreementsArgs
    penalties?: boolean | CollectionCaseCountOutputTypeCountPenaltiesArgs
  }

  // Custom InputTypes
  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseCountOutputType
     */
    select?: CollectionCaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAgreementWhereInput
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountPenaltiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PenaltyWhereInput
  }


  /**
   * Count Type DebtorCountOutputType
   */

  export type DebtorCountOutputType = {
    collectionCases: number
    incomes: number
    paymentAgreements: number
    verdicts: number
  }

  export type DebtorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCases?: boolean | DebtorCountOutputTypeCountCollectionCasesArgs
    incomes?: boolean | DebtorCountOutputTypeCountIncomesArgs
    paymentAgreements?: boolean | DebtorCountOutputTypeCountPaymentAgreementsArgs
    verdicts?: boolean | DebtorCountOutputTypeCountVerdictsArgs
  }

  // Custom InputTypes
  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorCountOutputType
     */
    select?: DebtorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountCollectionCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseWhereInput
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountIncomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorIncomeWhereInput
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountPaymentAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAgreementWhereInput
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountVerdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    numberOfEmployees: number | null
  }

  export type TenantSumAggregateOutputType = {
    numberOfEmployees: number | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    subdomain: string | null
    createdAt: Date | null
    updatedAt: Date | null
    contactEmail: string | null
    countryCode: string | null
    name: string | null
    planStatus: string | null
    termsAccepted: boolean | null
    address: string | null
    city: string | null
    logoUrl: string | null
    numberOfEmployees: number | null
    phone: string | null
    website: string | null
    isActive: boolean | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    subdomain: string | null
    createdAt: Date | null
    updatedAt: Date | null
    contactEmail: string | null
    countryCode: string | null
    name: string | null
    planStatus: string | null
    termsAccepted: boolean | null
    address: string | null
    city: string | null
    logoUrl: string | null
    numberOfEmployees: number | null
    phone: string | null
    website: string | null
    isActive: boolean | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    subdomain: number
    createdAt: number
    updatedAt: number
    contactEmail: number
    countryCode: number
    name: number
    planStatus: number
    termsAccepted: number
    address: number
    city: number
    logoUrl: number
    numberOfEmployees: number
    phone: number
    website: number
    isActive: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    numberOfEmployees?: true
  }

  export type TenantSumAggregateInputType = {
    numberOfEmployees?: true
  }

  export type TenantMinAggregateInputType = {
    id?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
    contactEmail?: true
    countryCode?: true
    name?: true
    planStatus?: true
    termsAccepted?: true
    address?: true
    city?: true
    logoUrl?: true
    numberOfEmployees?: true
    phone?: true
    website?: true
    isActive?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
    contactEmail?: true
    countryCode?: true
    name?: true
    planStatus?: true
    termsAccepted?: true
    address?: true
    city?: true
    logoUrl?: true
    numberOfEmployees?: true
    phone?: true
    website?: true
    isActive?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
    contactEmail?: true
    countryCode?: true
    name?: true
    planStatus?: true
    termsAccepted?: true
    address?: true
    city?: true
    logoUrl?: true
    numberOfEmployees?: true
    phone?: true
    website?: true
    isActive?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    subdomain: string
    createdAt: Date
    updatedAt: Date
    contactEmail: string
    countryCode: string
    name: string
    planStatus: string
    termsAccepted: boolean
    address: string | null
    city: string | null
    logoUrl: string | null
    numberOfEmployees: number | null
    phone: string | null
    website: string | null
    isActive: boolean
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactEmail?: boolean
    countryCode?: boolean
    name?: boolean
    planStatus?: boolean
    termsAccepted?: boolean
    address?: boolean
    city?: boolean
    logoUrl?: boolean
    numberOfEmployees?: boolean
    phone?: boolean
    website?: boolean
    isActive?: boolean
    billingInvoice?: boolean | Tenant$billingInvoiceArgs<ExtArgs>
    subscription?: boolean | Tenant$subscriptionArgs<ExtArgs>
    collectionCases?: boolean | Tenant$collectionCasesArgs<ExtArgs>
    debtors?: boolean | Tenant$debtorsArgs<ExtArgs>
    memberships?: boolean | Tenant$membershipsArgs<ExtArgs>
    tenantInvitations?: boolean | Tenant$tenantInvitationsArgs<ExtArgs>
    registry?: boolean | Tenant$registryArgs<ExtArgs>
    verdicts?: boolean | Tenant$verdictsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactEmail?: boolean
    countryCode?: boolean
    name?: boolean
    planStatus?: boolean
    termsAccepted?: boolean
    address?: boolean
    city?: boolean
    logoUrl?: boolean
    numberOfEmployees?: boolean
    phone?: boolean
    website?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactEmail?: boolean
    countryCode?: boolean
    name?: boolean
    planStatus?: boolean
    termsAccepted?: boolean
    address?: boolean
    city?: boolean
    logoUrl?: boolean
    numberOfEmployees?: boolean
    phone?: boolean
    website?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactEmail?: boolean
    countryCode?: boolean
    name?: boolean
    planStatus?: boolean
    termsAccepted?: boolean
    address?: boolean
    city?: boolean
    logoUrl?: boolean
    numberOfEmployees?: boolean
    phone?: boolean
    website?: boolean
    isActive?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subdomain" | "createdAt" | "updatedAt" | "contactEmail" | "countryCode" | "name" | "planStatus" | "termsAccepted" | "address" | "city" | "logoUrl" | "numberOfEmployees" | "phone" | "website" | "isActive", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingInvoice?: boolean | Tenant$billingInvoiceArgs<ExtArgs>
    subscription?: boolean | Tenant$subscriptionArgs<ExtArgs>
    collectionCases?: boolean | Tenant$collectionCasesArgs<ExtArgs>
    debtors?: boolean | Tenant$debtorsArgs<ExtArgs>
    memberships?: boolean | Tenant$membershipsArgs<ExtArgs>
    tenantInvitations?: boolean | Tenant$tenantInvitationsArgs<ExtArgs>
    registry?: boolean | Tenant$registryArgs<ExtArgs>
    verdicts?: boolean | Tenant$verdictsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      billingInvoice: Prisma.$BillingInvoicePayload<ExtArgs>[]
      subscription: Prisma.$BillingSubscriptionPayload<ExtArgs>[]
      collectionCases: Prisma.$CollectionCasePayload<ExtArgs>[]
      debtors: Prisma.$DebtorPayload<ExtArgs>[]
      memberships: Prisma.$MembershipPayload<ExtArgs>[]
      tenantInvitations: Prisma.$TenantInvitationPayload<ExtArgs>[]
      registry: Prisma.$TenantRegistryPayload<ExtArgs> | null
      verdicts: Prisma.$VerdictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subdomain: string
      createdAt: Date
      updatedAt: Date
      contactEmail: string
      countryCode: string
      name: string
      planStatus: string
      termsAccepted: boolean
      address: string | null
      city: string | null
      logoUrl: string | null
      numberOfEmployees: number | null
      phone: string | null
      website: string | null
      isActive: boolean
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billingInvoice<T extends Tenant$billingInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$billingInvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Tenant$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$subscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collectionCases<T extends Tenant$collectionCasesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$collectionCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    debtors<T extends Tenant$debtorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$debtorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberships<T extends Tenant$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenantInvitations<T extends Tenant$tenantInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tenantInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registry<T extends Tenant$registryArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$registryArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    verdicts<T extends Tenant$verdictsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$verdictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly subdomain: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
    readonly contactEmail: FieldRef<"Tenant", 'String'>
    readonly countryCode: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly planStatus: FieldRef<"Tenant", 'String'>
    readonly termsAccepted: FieldRef<"Tenant", 'Boolean'>
    readonly address: FieldRef<"Tenant", 'String'>
    readonly city: FieldRef<"Tenant", 'String'>
    readonly logoUrl: FieldRef<"Tenant", 'String'>
    readonly numberOfEmployees: FieldRef<"Tenant", 'Int'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly website: FieldRef<"Tenant", 'String'>
    readonly isActive: FieldRef<"Tenant", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.billingInvoice
   */
  export type Tenant$billingInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    where?: BillingInvoiceWhereInput
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    cursor?: BillingInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.subscription
   */
  export type Tenant$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    where?: BillingSubscriptionWhereInput
    orderBy?: BillingSubscriptionOrderByWithRelationInput | BillingSubscriptionOrderByWithRelationInput[]
    cursor?: BillingSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingSubscriptionScalarFieldEnum | BillingSubscriptionScalarFieldEnum[]
  }

  /**
   * Tenant.collectionCases
   */
  export type Tenant$collectionCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    where?: CollectionCaseWhereInput
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    cursor?: CollectionCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * Tenant.debtors
   */
  export type Tenant$debtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    where?: DebtorWhereInput
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    cursor?: DebtorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Tenant.memberships
   */
  export type Tenant$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    cursor?: MembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Tenant.tenantInvitations
   */
  export type Tenant$tenantInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
    where?: TenantInvitationWhereInput
    orderBy?: TenantInvitationOrderByWithRelationInput | TenantInvitationOrderByWithRelationInput[]
    cursor?: TenantInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantInvitationScalarFieldEnum | TenantInvitationScalarFieldEnum[]
  }

  /**
   * Tenant.registry
   */
  export type Tenant$registryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    where?: TenantRegistryWhereInput
  }

  /**
   * Tenant.verdicts
   */
  export type Tenant$verdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    cursor?: VerdictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model TenantRegistry
   */

  export type AggregateTenantRegistry = {
    _count: TenantRegistryCountAggregateOutputType | null
    _min: TenantRegistryMinAggregateOutputType | null
    _max: TenantRegistryMaxAggregateOutputType | null
  }

  export type TenantRegistryMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    kvk: string | null
    crib: string | null
    taxId: string | null
    vatNumber: string | null
    legalName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantRegistryMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    kvk: string | null
    crib: string | null
    taxId: string | null
    vatNumber: string | null
    legalName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantRegistryCountAggregateOutputType = {
    id: number
    tenantId: number
    kvk: number
    crib: number
    taxId: number
    vatNumber: number
    legalName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantRegistryMinAggregateInputType = {
    id?: true
    tenantId?: true
    kvk?: true
    crib?: true
    taxId?: true
    vatNumber?: true
    legalName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantRegistryMaxAggregateInputType = {
    id?: true
    tenantId?: true
    kvk?: true
    crib?: true
    taxId?: true
    vatNumber?: true
    legalName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantRegistryCountAggregateInputType = {
    id?: true
    tenantId?: true
    kvk?: true
    crib?: true
    taxId?: true
    vatNumber?: true
    legalName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantRegistryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantRegistry to aggregate.
     */
    where?: TenantRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantRegistries to fetch.
     */
    orderBy?: TenantRegistryOrderByWithRelationInput | TenantRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantRegistries
    **/
    _count?: true | TenantRegistryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantRegistryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantRegistryMaxAggregateInputType
  }

  export type GetTenantRegistryAggregateType<T extends TenantRegistryAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantRegistry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantRegistry[P]>
      : GetScalarType<T[P], AggregateTenantRegistry[P]>
  }




  export type TenantRegistryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantRegistryWhereInput
    orderBy?: TenantRegistryOrderByWithAggregationInput | TenantRegistryOrderByWithAggregationInput[]
    by: TenantRegistryScalarFieldEnum[] | TenantRegistryScalarFieldEnum
    having?: TenantRegistryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantRegistryCountAggregateInputType | true
    _min?: TenantRegistryMinAggregateInputType
    _max?: TenantRegistryMaxAggregateInputType
  }

  export type TenantRegistryGroupByOutputType = {
    id: string
    tenantId: string
    kvk: string | null
    crib: string | null
    taxId: string | null
    vatNumber: string | null
    legalName: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantRegistryCountAggregateOutputType | null
    _min: TenantRegistryMinAggregateOutputType | null
    _max: TenantRegistryMaxAggregateOutputType | null
  }

  type GetTenantRegistryGroupByPayload<T extends TenantRegistryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantRegistryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantRegistryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantRegistryGroupByOutputType[P]>
            : GetScalarType<T[P], TenantRegistryGroupByOutputType[P]>
        }
      >
    >


  export type TenantRegistrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kvk?: boolean
    crib?: boolean
    taxId?: boolean
    vatNumber?: boolean
    legalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantRegistry"]>

  export type TenantRegistrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kvk?: boolean
    crib?: boolean
    taxId?: boolean
    vatNumber?: boolean
    legalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantRegistry"]>

  export type TenantRegistrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kvk?: boolean
    crib?: boolean
    taxId?: boolean
    vatNumber?: boolean
    legalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantRegistry"]>

  export type TenantRegistrySelectScalar = {
    id?: boolean
    tenantId?: boolean
    kvk?: boolean
    crib?: boolean
    taxId?: boolean
    vatNumber?: boolean
    legalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantRegistryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "kvk" | "crib" | "taxId" | "vatNumber" | "legalName" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantRegistry"]>
  export type TenantRegistryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantRegistryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantRegistryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantRegistryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantRegistry"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      kvk: string | null
      crib: string | null
      taxId: string | null
      vatNumber: string | null
      legalName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantRegistry"]>
    composites: {}
  }

  type TenantRegistryGetPayload<S extends boolean | null | undefined | TenantRegistryDefaultArgs> = $Result.GetResult<Prisma.$TenantRegistryPayload, S>

  type TenantRegistryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantRegistryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantRegistryCountAggregateInputType | true
    }

  export interface TenantRegistryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantRegistry'], meta: { name: 'TenantRegistry' } }
    /**
     * Find zero or one TenantRegistry that matches the filter.
     * @param {TenantRegistryFindUniqueArgs} args - Arguments to find a TenantRegistry
     * @example
     * // Get one TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantRegistryFindUniqueArgs>(args: SelectSubset<T, TenantRegistryFindUniqueArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantRegistry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantRegistryFindUniqueOrThrowArgs} args - Arguments to find a TenantRegistry
     * @example
     * // Get one TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantRegistryFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantRegistryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantRegistry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryFindFirstArgs} args - Arguments to find a TenantRegistry
     * @example
     * // Get one TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantRegistryFindFirstArgs>(args?: SelectSubset<T, TenantRegistryFindFirstArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantRegistry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryFindFirstOrThrowArgs} args - Arguments to find a TenantRegistry
     * @example
     * // Get one TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantRegistryFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantRegistryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantRegistries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantRegistries
     * const tenantRegistries = await prisma.tenantRegistry.findMany()
     * 
     * // Get first 10 TenantRegistries
     * const tenantRegistries = await prisma.tenantRegistry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantRegistryWithIdOnly = await prisma.tenantRegistry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantRegistryFindManyArgs>(args?: SelectSubset<T, TenantRegistryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantRegistry.
     * @param {TenantRegistryCreateArgs} args - Arguments to create a TenantRegistry.
     * @example
     * // Create one TenantRegistry
     * const TenantRegistry = await prisma.tenantRegistry.create({
     *   data: {
     *     // ... data to create a TenantRegistry
     *   }
     * })
     * 
     */
    create<T extends TenantRegistryCreateArgs>(args: SelectSubset<T, TenantRegistryCreateArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantRegistries.
     * @param {TenantRegistryCreateManyArgs} args - Arguments to create many TenantRegistries.
     * @example
     * // Create many TenantRegistries
     * const tenantRegistry = await prisma.tenantRegistry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantRegistryCreateManyArgs>(args?: SelectSubset<T, TenantRegistryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantRegistries and returns the data saved in the database.
     * @param {TenantRegistryCreateManyAndReturnArgs} args - Arguments to create many TenantRegistries.
     * @example
     * // Create many TenantRegistries
     * const tenantRegistry = await prisma.tenantRegistry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantRegistries and only return the `id`
     * const tenantRegistryWithIdOnly = await prisma.tenantRegistry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantRegistryCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantRegistryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantRegistry.
     * @param {TenantRegistryDeleteArgs} args - Arguments to delete one TenantRegistry.
     * @example
     * // Delete one TenantRegistry
     * const TenantRegistry = await prisma.tenantRegistry.delete({
     *   where: {
     *     // ... filter to delete one TenantRegistry
     *   }
     * })
     * 
     */
    delete<T extends TenantRegistryDeleteArgs>(args: SelectSubset<T, TenantRegistryDeleteArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantRegistry.
     * @param {TenantRegistryUpdateArgs} args - Arguments to update one TenantRegistry.
     * @example
     * // Update one TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantRegistryUpdateArgs>(args: SelectSubset<T, TenantRegistryUpdateArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantRegistries.
     * @param {TenantRegistryDeleteManyArgs} args - Arguments to filter TenantRegistries to delete.
     * @example
     * // Delete a few TenantRegistries
     * const { count } = await prisma.tenantRegistry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantRegistryDeleteManyArgs>(args?: SelectSubset<T, TenantRegistryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantRegistries
     * const tenantRegistry = await prisma.tenantRegistry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantRegistryUpdateManyArgs>(args: SelectSubset<T, TenantRegistryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantRegistries and returns the data updated in the database.
     * @param {TenantRegistryUpdateManyAndReturnArgs} args - Arguments to update many TenantRegistries.
     * @example
     * // Update many TenantRegistries
     * const tenantRegistry = await prisma.tenantRegistry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantRegistries and only return the `id`
     * const tenantRegistryWithIdOnly = await prisma.tenantRegistry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantRegistryUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantRegistryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantRegistry.
     * @param {TenantRegistryUpsertArgs} args - Arguments to update or create a TenantRegistry.
     * @example
     * // Update or create a TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.upsert({
     *   create: {
     *     // ... data to create a TenantRegistry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantRegistry we want to update
     *   }
     * })
     */
    upsert<T extends TenantRegistryUpsertArgs>(args: SelectSubset<T, TenantRegistryUpsertArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryCountArgs} args - Arguments to filter TenantRegistries to count.
     * @example
     * // Count the number of TenantRegistries
     * const count = await prisma.tenantRegistry.count({
     *   where: {
     *     // ... the filter for the TenantRegistries we want to count
     *   }
     * })
    **/
    count<T extends TenantRegistryCountArgs>(
      args?: Subset<T, TenantRegistryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantRegistryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantRegistryAggregateArgs>(args: Subset<T, TenantRegistryAggregateArgs>): Prisma.PrismaPromise<GetTenantRegistryAggregateType<T>>

    /**
     * Group by TenantRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantRegistryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantRegistryGroupByArgs['orderBy'] }
        : { orderBy?: TenantRegistryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantRegistryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantRegistryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantRegistry model
   */
  readonly fields: TenantRegistryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantRegistry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantRegistryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantRegistry model
   */
  interface TenantRegistryFieldRefs {
    readonly id: FieldRef<"TenantRegistry", 'String'>
    readonly tenantId: FieldRef<"TenantRegistry", 'String'>
    readonly kvk: FieldRef<"TenantRegistry", 'String'>
    readonly crib: FieldRef<"TenantRegistry", 'String'>
    readonly taxId: FieldRef<"TenantRegistry", 'String'>
    readonly vatNumber: FieldRef<"TenantRegistry", 'String'>
    readonly legalName: FieldRef<"TenantRegistry", 'String'>
    readonly createdAt: FieldRef<"TenantRegistry", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantRegistry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantRegistry findUnique
   */
  export type TenantRegistryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter, which TenantRegistry to fetch.
     */
    where: TenantRegistryWhereUniqueInput
  }

  /**
   * TenantRegistry findUniqueOrThrow
   */
  export type TenantRegistryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter, which TenantRegistry to fetch.
     */
    where: TenantRegistryWhereUniqueInput
  }

  /**
   * TenantRegistry findFirst
   */
  export type TenantRegistryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter, which TenantRegistry to fetch.
     */
    where?: TenantRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantRegistries to fetch.
     */
    orderBy?: TenantRegistryOrderByWithRelationInput | TenantRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantRegistries.
     */
    cursor?: TenantRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantRegistries.
     */
    distinct?: TenantRegistryScalarFieldEnum | TenantRegistryScalarFieldEnum[]
  }

  /**
   * TenantRegistry findFirstOrThrow
   */
  export type TenantRegistryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter, which TenantRegistry to fetch.
     */
    where?: TenantRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantRegistries to fetch.
     */
    orderBy?: TenantRegistryOrderByWithRelationInput | TenantRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantRegistries.
     */
    cursor?: TenantRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantRegistries.
     */
    distinct?: TenantRegistryScalarFieldEnum | TenantRegistryScalarFieldEnum[]
  }

  /**
   * TenantRegistry findMany
   */
  export type TenantRegistryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter, which TenantRegistries to fetch.
     */
    where?: TenantRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantRegistries to fetch.
     */
    orderBy?: TenantRegistryOrderByWithRelationInput | TenantRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantRegistries.
     */
    cursor?: TenantRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantRegistries.
     */
    skip?: number
    distinct?: TenantRegistryScalarFieldEnum | TenantRegistryScalarFieldEnum[]
  }

  /**
   * TenantRegistry create
   */
  export type TenantRegistryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantRegistry.
     */
    data: XOR<TenantRegistryCreateInput, TenantRegistryUncheckedCreateInput>
  }

  /**
   * TenantRegistry createMany
   */
  export type TenantRegistryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantRegistries.
     */
    data: TenantRegistryCreateManyInput | TenantRegistryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantRegistry createManyAndReturn
   */
  export type TenantRegistryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * The data used to create many TenantRegistries.
     */
    data: TenantRegistryCreateManyInput | TenantRegistryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantRegistry update
   */
  export type TenantRegistryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantRegistry.
     */
    data: XOR<TenantRegistryUpdateInput, TenantRegistryUncheckedUpdateInput>
    /**
     * Choose, which TenantRegistry to update.
     */
    where: TenantRegistryWhereUniqueInput
  }

  /**
   * TenantRegistry updateMany
   */
  export type TenantRegistryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantRegistries.
     */
    data: XOR<TenantRegistryUpdateManyMutationInput, TenantRegistryUncheckedUpdateManyInput>
    /**
     * Filter which TenantRegistries to update
     */
    where?: TenantRegistryWhereInput
    /**
     * Limit how many TenantRegistries to update.
     */
    limit?: number
  }

  /**
   * TenantRegistry updateManyAndReturn
   */
  export type TenantRegistryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * The data used to update TenantRegistries.
     */
    data: XOR<TenantRegistryUpdateManyMutationInput, TenantRegistryUncheckedUpdateManyInput>
    /**
     * Filter which TenantRegistries to update
     */
    where?: TenantRegistryWhereInput
    /**
     * Limit how many TenantRegistries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantRegistry upsert
   */
  export type TenantRegistryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantRegistry to update in case it exists.
     */
    where: TenantRegistryWhereUniqueInput
    /**
     * In case the TenantRegistry found by the `where` argument doesn't exist, create a new TenantRegistry with this data.
     */
    create: XOR<TenantRegistryCreateInput, TenantRegistryUncheckedCreateInput>
    /**
     * In case the TenantRegistry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantRegistryUpdateInput, TenantRegistryUncheckedUpdateInput>
  }

  /**
   * TenantRegistry delete
   */
  export type TenantRegistryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter which TenantRegistry to delete.
     */
    where: TenantRegistryWhereUniqueInput
  }

  /**
   * TenantRegistry deleteMany
   */
  export type TenantRegistryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantRegistries to delete
     */
    where?: TenantRegistryWhereInput
    /**
     * Limit how many TenantRegistries to delete.
     */
    limit?: number
  }

  /**
   * TenantRegistry without action
   */
  export type TenantRegistryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
  }


  /**
   * Model TenantInvitation
   */

  export type AggregateTenantInvitation = {
    _count: TenantInvitationCountAggregateOutputType | null
    _min: TenantInvitationMinAggregateOutputType | null
    _max: TenantInvitationMaxAggregateOutputType | null
  }

  export type TenantInvitationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    status: string | null
    invitedBy: string | null
    createdAt: Date | null
    userId: string | null
    role: $Enums.roleEnum | null
  }

  export type TenantInvitationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    status: string | null
    invitedBy: string | null
    createdAt: Date | null
    userId: string | null
    role: $Enums.roleEnum | null
  }

  export type TenantInvitationCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    status: number
    invitedBy: number
    createdAt: number
    userId: number
    role: number
    _all: number
  }


  export type TenantInvitationMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    status?: true
    invitedBy?: true
    createdAt?: true
    userId?: true
    role?: true
  }

  export type TenantInvitationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    status?: true
    invitedBy?: true
    createdAt?: true
    userId?: true
    role?: true
  }

  export type TenantInvitationCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    status?: true
    invitedBy?: true
    createdAt?: true
    userId?: true
    role?: true
    _all?: true
  }

  export type TenantInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantInvitation to aggregate.
     */
    where?: TenantInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantInvitations to fetch.
     */
    orderBy?: TenantInvitationOrderByWithRelationInput | TenantInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantInvitations
    **/
    _count?: true | TenantInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantInvitationMaxAggregateInputType
  }

  export type GetTenantInvitationAggregateType<T extends TenantInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantInvitation[P]>
      : GetScalarType<T[P], AggregateTenantInvitation[P]>
  }




  export type TenantInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantInvitationWhereInput
    orderBy?: TenantInvitationOrderByWithAggregationInput | TenantInvitationOrderByWithAggregationInput[]
    by: TenantInvitationScalarFieldEnum[] | TenantInvitationScalarFieldEnum
    having?: TenantInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantInvitationCountAggregateInputType | true
    _min?: TenantInvitationMinAggregateInputType
    _max?: TenantInvitationMaxAggregateInputType
  }

  export type TenantInvitationGroupByOutputType = {
    id: string
    tenantId: string
    email: string
    status: string
    invitedBy: string
    createdAt: Date
    userId: string | null
    role: $Enums.roleEnum
    _count: TenantInvitationCountAggregateOutputType | null
    _min: TenantInvitationMinAggregateOutputType | null
    _max: TenantInvitationMaxAggregateOutputType | null
  }

  type GetTenantInvitationGroupByPayload<T extends TenantInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], TenantInvitationGroupByOutputType[P]>
        }
      >
    >


  export type TenantInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    status?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    userId?: boolean
    role?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TenantInvitation$UserArgs<ExtArgs>
  }, ExtArgs["result"]["tenantInvitation"]>

  export type TenantInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    status?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    userId?: boolean
    role?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TenantInvitation$UserArgs<ExtArgs>
  }, ExtArgs["result"]["tenantInvitation"]>

  export type TenantInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    status?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    userId?: boolean
    role?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TenantInvitation$UserArgs<ExtArgs>
  }, ExtArgs["result"]["tenantInvitation"]>

  export type TenantInvitationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    status?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    userId?: boolean
    role?: boolean
  }

  export type TenantInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "email" | "status" | "invitedBy" | "createdAt" | "userId" | "role", ExtArgs["result"]["tenantInvitation"]>
  export type TenantInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TenantInvitation$UserArgs<ExtArgs>
  }
  export type TenantInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TenantInvitation$UserArgs<ExtArgs>
  }
  export type TenantInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    User?: boolean | TenantInvitation$UserArgs<ExtArgs>
  }

  export type $TenantInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantInvitation"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      email: string
      status: string
      invitedBy: string
      createdAt: Date
      userId: string | null
      role: $Enums.roleEnum
    }, ExtArgs["result"]["tenantInvitation"]>
    composites: {}
  }

  type TenantInvitationGetPayload<S extends boolean | null | undefined | TenantInvitationDefaultArgs> = $Result.GetResult<Prisma.$TenantInvitationPayload, S>

  type TenantInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantInvitationCountAggregateInputType | true
    }

  export interface TenantInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantInvitation'], meta: { name: 'TenantInvitation' } }
    /**
     * Find zero or one TenantInvitation that matches the filter.
     * @param {TenantInvitationFindUniqueArgs} args - Arguments to find a TenantInvitation
     * @example
     * // Get one TenantInvitation
     * const tenantInvitation = await prisma.tenantInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantInvitationFindUniqueArgs>(args: SelectSubset<T, TenantInvitationFindUniqueArgs<ExtArgs>>): Prisma__TenantInvitationClient<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantInvitationFindUniqueOrThrowArgs} args - Arguments to find a TenantInvitation
     * @example
     * // Get one TenantInvitation
     * const tenantInvitation = await prisma.tenantInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantInvitationClient<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantInvitationFindFirstArgs} args - Arguments to find a TenantInvitation
     * @example
     * // Get one TenantInvitation
     * const tenantInvitation = await prisma.tenantInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantInvitationFindFirstArgs>(args?: SelectSubset<T, TenantInvitationFindFirstArgs<ExtArgs>>): Prisma__TenantInvitationClient<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantInvitationFindFirstOrThrowArgs} args - Arguments to find a TenantInvitation
     * @example
     * // Get one TenantInvitation
     * const tenantInvitation = await prisma.tenantInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantInvitationClient<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantInvitations
     * const tenantInvitations = await prisma.tenantInvitation.findMany()
     * 
     * // Get first 10 TenantInvitations
     * const tenantInvitations = await prisma.tenantInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantInvitationWithIdOnly = await prisma.tenantInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantInvitationFindManyArgs>(args?: SelectSubset<T, TenantInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantInvitation.
     * @param {TenantInvitationCreateArgs} args - Arguments to create a TenantInvitation.
     * @example
     * // Create one TenantInvitation
     * const TenantInvitation = await prisma.tenantInvitation.create({
     *   data: {
     *     // ... data to create a TenantInvitation
     *   }
     * })
     * 
     */
    create<T extends TenantInvitationCreateArgs>(args: SelectSubset<T, TenantInvitationCreateArgs<ExtArgs>>): Prisma__TenantInvitationClient<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantInvitations.
     * @param {TenantInvitationCreateManyArgs} args - Arguments to create many TenantInvitations.
     * @example
     * // Create many TenantInvitations
     * const tenantInvitation = await prisma.tenantInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantInvitationCreateManyArgs>(args?: SelectSubset<T, TenantInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantInvitations and returns the data saved in the database.
     * @param {TenantInvitationCreateManyAndReturnArgs} args - Arguments to create many TenantInvitations.
     * @example
     * // Create many TenantInvitations
     * const tenantInvitation = await prisma.tenantInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantInvitations and only return the `id`
     * const tenantInvitationWithIdOnly = await prisma.tenantInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantInvitation.
     * @param {TenantInvitationDeleteArgs} args - Arguments to delete one TenantInvitation.
     * @example
     * // Delete one TenantInvitation
     * const TenantInvitation = await prisma.tenantInvitation.delete({
     *   where: {
     *     // ... filter to delete one TenantInvitation
     *   }
     * })
     * 
     */
    delete<T extends TenantInvitationDeleteArgs>(args: SelectSubset<T, TenantInvitationDeleteArgs<ExtArgs>>): Prisma__TenantInvitationClient<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantInvitation.
     * @param {TenantInvitationUpdateArgs} args - Arguments to update one TenantInvitation.
     * @example
     * // Update one TenantInvitation
     * const tenantInvitation = await prisma.tenantInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantInvitationUpdateArgs>(args: SelectSubset<T, TenantInvitationUpdateArgs<ExtArgs>>): Prisma__TenantInvitationClient<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantInvitations.
     * @param {TenantInvitationDeleteManyArgs} args - Arguments to filter TenantInvitations to delete.
     * @example
     * // Delete a few TenantInvitations
     * const { count } = await prisma.tenantInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantInvitationDeleteManyArgs>(args?: SelectSubset<T, TenantInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantInvitations
     * const tenantInvitation = await prisma.tenantInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantInvitationUpdateManyArgs>(args: SelectSubset<T, TenantInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantInvitations and returns the data updated in the database.
     * @param {TenantInvitationUpdateManyAndReturnArgs} args - Arguments to update many TenantInvitations.
     * @example
     * // Update many TenantInvitations
     * const tenantInvitation = await prisma.tenantInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantInvitations and only return the `id`
     * const tenantInvitationWithIdOnly = await prisma.tenantInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantInvitation.
     * @param {TenantInvitationUpsertArgs} args - Arguments to update or create a TenantInvitation.
     * @example
     * // Update or create a TenantInvitation
     * const tenantInvitation = await prisma.tenantInvitation.upsert({
     *   create: {
     *     // ... data to create a TenantInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantInvitation we want to update
     *   }
     * })
     */
    upsert<T extends TenantInvitationUpsertArgs>(args: SelectSubset<T, TenantInvitationUpsertArgs<ExtArgs>>): Prisma__TenantInvitationClient<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantInvitationCountArgs} args - Arguments to filter TenantInvitations to count.
     * @example
     * // Count the number of TenantInvitations
     * const count = await prisma.tenantInvitation.count({
     *   where: {
     *     // ... the filter for the TenantInvitations we want to count
     *   }
     * })
    **/
    count<T extends TenantInvitationCountArgs>(
      args?: Subset<T, TenantInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantInvitationAggregateArgs>(args: Subset<T, TenantInvitationAggregateArgs>): Prisma.PrismaPromise<GetTenantInvitationAggregateType<T>>

    /**
     * Group by TenantInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantInvitationGroupByArgs['orderBy'] }
        : { orderBy?: TenantInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantInvitation model
   */
  readonly fields: TenantInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends TenantInvitation$UserArgs<ExtArgs> = {}>(args?: Subset<T, TenantInvitation$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantInvitation model
   */
  interface TenantInvitationFieldRefs {
    readonly id: FieldRef<"TenantInvitation", 'String'>
    readonly tenantId: FieldRef<"TenantInvitation", 'String'>
    readonly email: FieldRef<"TenantInvitation", 'String'>
    readonly status: FieldRef<"TenantInvitation", 'String'>
    readonly invitedBy: FieldRef<"TenantInvitation", 'String'>
    readonly createdAt: FieldRef<"TenantInvitation", 'DateTime'>
    readonly userId: FieldRef<"TenantInvitation", 'String'>
    readonly role: FieldRef<"TenantInvitation", 'roleEnum'>
  }
    

  // Custom InputTypes
  /**
   * TenantInvitation findUnique
   */
  export type TenantInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
    /**
     * Filter, which TenantInvitation to fetch.
     */
    where: TenantInvitationWhereUniqueInput
  }

  /**
   * TenantInvitation findUniqueOrThrow
   */
  export type TenantInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
    /**
     * Filter, which TenantInvitation to fetch.
     */
    where: TenantInvitationWhereUniqueInput
  }

  /**
   * TenantInvitation findFirst
   */
  export type TenantInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
    /**
     * Filter, which TenantInvitation to fetch.
     */
    where?: TenantInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantInvitations to fetch.
     */
    orderBy?: TenantInvitationOrderByWithRelationInput | TenantInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantInvitations.
     */
    cursor?: TenantInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantInvitations.
     */
    distinct?: TenantInvitationScalarFieldEnum | TenantInvitationScalarFieldEnum[]
  }

  /**
   * TenantInvitation findFirstOrThrow
   */
  export type TenantInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
    /**
     * Filter, which TenantInvitation to fetch.
     */
    where?: TenantInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantInvitations to fetch.
     */
    orderBy?: TenantInvitationOrderByWithRelationInput | TenantInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantInvitations.
     */
    cursor?: TenantInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantInvitations.
     */
    distinct?: TenantInvitationScalarFieldEnum | TenantInvitationScalarFieldEnum[]
  }

  /**
   * TenantInvitation findMany
   */
  export type TenantInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
    /**
     * Filter, which TenantInvitations to fetch.
     */
    where?: TenantInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantInvitations to fetch.
     */
    orderBy?: TenantInvitationOrderByWithRelationInput | TenantInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantInvitations.
     */
    cursor?: TenantInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantInvitations.
     */
    skip?: number
    distinct?: TenantInvitationScalarFieldEnum | TenantInvitationScalarFieldEnum[]
  }

  /**
   * TenantInvitation create
   */
  export type TenantInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantInvitation.
     */
    data: XOR<TenantInvitationCreateInput, TenantInvitationUncheckedCreateInput>
  }

  /**
   * TenantInvitation createMany
   */
  export type TenantInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantInvitations.
     */
    data: TenantInvitationCreateManyInput | TenantInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantInvitation createManyAndReturn
   */
  export type TenantInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many TenantInvitations.
     */
    data: TenantInvitationCreateManyInput | TenantInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantInvitation update
   */
  export type TenantInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantInvitation.
     */
    data: XOR<TenantInvitationUpdateInput, TenantInvitationUncheckedUpdateInput>
    /**
     * Choose, which TenantInvitation to update.
     */
    where: TenantInvitationWhereUniqueInput
  }

  /**
   * TenantInvitation updateMany
   */
  export type TenantInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantInvitations.
     */
    data: XOR<TenantInvitationUpdateManyMutationInput, TenantInvitationUncheckedUpdateManyInput>
    /**
     * Filter which TenantInvitations to update
     */
    where?: TenantInvitationWhereInput
    /**
     * Limit how many TenantInvitations to update.
     */
    limit?: number
  }

  /**
   * TenantInvitation updateManyAndReturn
   */
  export type TenantInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * The data used to update TenantInvitations.
     */
    data: XOR<TenantInvitationUpdateManyMutationInput, TenantInvitationUncheckedUpdateManyInput>
    /**
     * Filter which TenantInvitations to update
     */
    where?: TenantInvitationWhereInput
    /**
     * Limit how many TenantInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantInvitation upsert
   */
  export type TenantInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantInvitation to update in case it exists.
     */
    where: TenantInvitationWhereUniqueInput
    /**
     * In case the TenantInvitation found by the `where` argument doesn't exist, create a new TenantInvitation with this data.
     */
    create: XOR<TenantInvitationCreateInput, TenantInvitationUncheckedCreateInput>
    /**
     * In case the TenantInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantInvitationUpdateInput, TenantInvitationUncheckedUpdateInput>
  }

  /**
   * TenantInvitation delete
   */
  export type TenantInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
    /**
     * Filter which TenantInvitation to delete.
     */
    where: TenantInvitationWhereUniqueInput
  }

  /**
   * TenantInvitation deleteMany
   */
  export type TenantInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantInvitations to delete
     */
    where?: TenantInvitationWhereInput
    /**
     * Limit how many TenantInvitations to delete.
     */
    limit?: number
  }

  /**
   * TenantInvitation.User
   */
  export type TenantInvitation$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TenantInvitation without action
   */
  export type TenantInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullname: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullname: string | null
    phone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    fullname: number
    phone: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullname?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullname?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullname?: true
    phone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    fullname: string | null
    phone: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullname?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtors?: boolean | User$debtorsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    tenantInvitations?: boolean | User$tenantInvitationsArgs<ExtArgs>
    verdictBailiffs?: boolean | User$verdictBailiffsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullname?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullname?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullname?: boolean
    phone?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "fullname" | "phone" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtors?: boolean | User$debtorsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    tenantInvitations?: boolean | User$tenantInvitationsArgs<ExtArgs>
    verdictBailiffs?: boolean | User$verdictBailiffsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      debtors: Prisma.$DebtorPayload<ExtArgs>[]
      memberships: Prisma.$MembershipPayload<ExtArgs>[]
      tenantInvitations: Prisma.$TenantInvitationPayload<ExtArgs>[]
      verdictBailiffs: Prisma.$VerdictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      fullname: string | null
      phone: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    debtors<T extends User$debtorsArgs<ExtArgs> = {}>(args?: Subset<T, User$debtorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenantInvitations<T extends User$tenantInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdictBailiffs<T extends User$verdictBailiffsArgs<ExtArgs> = {}>(args?: Subset<T, User$verdictBailiffsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly fullname: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.debtors
   */
  export type User$debtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    where?: DebtorWhereInput
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    cursor?: DebtorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    cursor?: MembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * User.tenantInvitations
   */
  export type User$tenantInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantInvitation
     */
    select?: TenantInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantInvitation
     */
    omit?: TenantInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInvitationInclude<ExtArgs> | null
    where?: TenantInvitationWhereInput
    orderBy?: TenantInvitationOrderByWithRelationInput | TenantInvitationOrderByWithRelationInput[]
    cursor?: TenantInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantInvitationScalarFieldEnum | TenantInvitationScalarFieldEnum[]
  }

  /**
   * User.verdictBailiffs
   */
  export type User$verdictBailiffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    cursor?: VerdictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Membership
   */

  export type AggregateMembership = {
    _count: MembershipCountAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  export type MembershipMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    status: $Enums.MembershipStatus | null
    joinedAt: Date | null
    role: $Enums.roleEnum | null
  }

  export type MembershipMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    status: $Enums.MembershipStatus | null
    joinedAt: Date | null
    role: $Enums.roleEnum | null
  }

  export type MembershipCountAggregateOutputType = {
    id: number
    userId: number
    tenantId: number
    status: number
    joinedAt: number
    role: number
    _all: number
  }


  export type MembershipMinAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    status?: true
    joinedAt?: true
    role?: true
  }

  export type MembershipMaxAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    status?: true
    joinedAt?: true
    role?: true
  }

  export type MembershipCountAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    status?: true
    joinedAt?: true
    role?: true
    _all?: true
  }

  export type MembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Membership to aggregate.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Memberships
    **/
    _count?: true | MembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipMaxAggregateInputType
  }

  export type GetMembershipAggregateType<T extends MembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembership[P]>
      : GetScalarType<T[P], AggregateMembership[P]>
  }




  export type MembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithAggregationInput | MembershipOrderByWithAggregationInput[]
    by: MembershipScalarFieldEnum[] | MembershipScalarFieldEnum
    having?: MembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipCountAggregateInputType | true
    _min?: MembershipMinAggregateInputType
    _max?: MembershipMaxAggregateInputType
  }

  export type MembershipGroupByOutputType = {
    id: string
    userId: string
    tenantId: string
    status: $Enums.MembershipStatus
    joinedAt: Date
    role: $Enums.roleEnum
    _count: MembershipCountAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  type GetMembershipGroupByPayload<T extends MembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipGroupByOutputType[P]>
        }
      >
    >


  export type MembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    status?: boolean
    joinedAt?: boolean
    role?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    status?: boolean
    joinedAt?: boolean
    role?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    status?: boolean
    joinedAt?: boolean
    role?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectScalar = {
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    status?: boolean
    joinedAt?: boolean
    role?: boolean
  }

  export type MembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tenantId" | "status" | "joinedAt" | "role", ExtArgs["result"]["membership"]>
  export type MembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Membership"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tenantId: string
      status: $Enums.MembershipStatus
      joinedAt: Date
      role: $Enums.roleEnum
    }, ExtArgs["result"]["membership"]>
    composites: {}
  }

  type MembershipGetPayload<S extends boolean | null | undefined | MembershipDefaultArgs> = $Result.GetResult<Prisma.$MembershipPayload, S>

  type MembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipCountAggregateInputType | true
    }

  export interface MembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Membership'], meta: { name: 'Membership' } }
    /**
     * Find zero or one Membership that matches the filter.
     * @param {MembershipFindUniqueArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipFindUniqueArgs>(args: SelectSubset<T, MembershipFindUniqueArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Membership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipFindUniqueOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Membership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipFindFirstArgs>(args?: SelectSubset<T, MembershipFindFirstArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Membership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memberships
     * const memberships = await prisma.membership.findMany()
     * 
     * // Get first 10 Memberships
     * const memberships = await prisma.membership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipWithIdOnly = await prisma.membership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipFindManyArgs>(args?: SelectSubset<T, MembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Membership.
     * @param {MembershipCreateArgs} args - Arguments to create a Membership.
     * @example
     * // Create one Membership
     * const Membership = await prisma.membership.create({
     *   data: {
     *     // ... data to create a Membership
     *   }
     * })
     * 
     */
    create<T extends MembershipCreateArgs>(args: SelectSubset<T, MembershipCreateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Memberships.
     * @param {MembershipCreateManyArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipCreateManyArgs>(args?: SelectSubset<T, MembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Memberships and returns the data saved in the database.
     * @param {MembershipCreateManyAndReturnArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Membership.
     * @param {MembershipDeleteArgs} args - Arguments to delete one Membership.
     * @example
     * // Delete one Membership
     * const Membership = await prisma.membership.delete({
     *   where: {
     *     // ... filter to delete one Membership
     *   }
     * })
     * 
     */
    delete<T extends MembershipDeleteArgs>(args: SelectSubset<T, MembershipDeleteArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Membership.
     * @param {MembershipUpdateArgs} args - Arguments to update one Membership.
     * @example
     * // Update one Membership
     * const membership = await prisma.membership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipUpdateArgs>(args: SelectSubset<T, MembershipUpdateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Memberships.
     * @param {MembershipDeleteManyArgs} args - Arguments to filter Memberships to delete.
     * @example
     * // Delete a few Memberships
     * const { count } = await prisma.membership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipDeleteManyArgs>(args?: SelectSubset<T, MembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipUpdateManyArgs>(args: SelectSubset<T, MembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships and returns the data updated in the database.
     * @param {MembershipUpdateManyAndReturnArgs} args - Arguments to update many Memberships.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, MembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Membership.
     * @param {MembershipUpsertArgs} args - Arguments to update or create a Membership.
     * @example
     * // Update or create a Membership
     * const membership = await prisma.membership.upsert({
     *   create: {
     *     // ... data to create a Membership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Membership we want to update
     *   }
     * })
     */
    upsert<T extends MembershipUpsertArgs>(args: SelectSubset<T, MembershipUpsertArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipCountArgs} args - Arguments to filter Memberships to count.
     * @example
     * // Count the number of Memberships
     * const count = await prisma.membership.count({
     *   where: {
     *     // ... the filter for the Memberships we want to count
     *   }
     * })
    **/
    count<T extends MembershipCountArgs>(
      args?: Subset<T, MembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipAggregateArgs>(args: Subset<T, MembershipAggregateArgs>): Prisma.PrismaPromise<GetMembershipAggregateType<T>>

    /**
     * Group by Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipGroupByArgs['orderBy'] }
        : { orderBy?: MembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Membership model
   */
  readonly fields: MembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Membership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Membership model
   */
  interface MembershipFieldRefs {
    readonly id: FieldRef<"Membership", 'String'>
    readonly userId: FieldRef<"Membership", 'String'>
    readonly tenantId: FieldRef<"Membership", 'String'>
    readonly status: FieldRef<"Membership", 'MembershipStatus'>
    readonly joinedAt: FieldRef<"Membership", 'DateTime'>
    readonly role: FieldRef<"Membership", 'roleEnum'>
  }
    

  // Custom InputTypes
  /**
   * Membership findUnique
   */
  export type MembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findUniqueOrThrow
   */
  export type MembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findFirst
   */
  export type MembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findFirstOrThrow
   */
  export type MembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findMany
   */
  export type MembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Memberships to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership create
   */
  export type MembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a Membership.
     */
    data: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
  }

  /**
   * Membership createMany
   */
  export type MembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Membership createManyAndReturn
   */
  export type MembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Membership update
   */
  export type MembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a Membership.
     */
    data: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
    /**
     * Choose, which Membership to update.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership updateMany
   */
  export type MembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to update.
     */
    limit?: number
  }

  /**
   * Membership updateManyAndReturn
   */
  export type MembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Membership upsert
   */
  export type MembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the Membership to update in case it exists.
     */
    where: MembershipWhereUniqueInput
    /**
     * In case the Membership found by the `where` argument doesn't exist, create a new Membership with this data.
     */
    create: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
    /**
     * In case the Membership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
  }

  /**
   * Membership delete
   */
  export type MembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter which Membership to delete.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership deleteMany
   */
  export type MembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memberships to delete
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to delete.
     */
    limit?: number
  }

  /**
   * Membership without action
   */
  export type MembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
  }


  /**
   * Model GlobalParameter
   */

  export type AggregateGlobalParameter = {
    _count: GlobalParameterCountAggregateOutputType | null
    _avg: GlobalParameterAvgAggregateOutputType | null
    _sum: GlobalParameterSumAggregateOutputType | null
    _min: GlobalParameterMinAggregateOutputType | null
    _max: GlobalParameterMaxAggregateOutputType | null
  }

  export type GlobalParameterAvgAggregateOutputType = {
    porcCobranza: number | null
    porcAbb: number | null
    diasPlazoEmpresaAanmaning: number | null
    diasPlazoConsumidorAanmaning: number | null
    diasPlazoEmpresaSommatie: number | null
    diasPlazoConsumidorSommatie: number | null
    precioEmpresaPequena: number | null
    contribucionEmpresaPequenaPfc: number | null
    precioEmpresaGrande: number | null
    contribucionEmpresaGrandePfc: number | null
    multaAanmaningEmpresa: number | null
    multaAanmaningNatural: number | null
    multaSommatieEmpresa: number | null
    multaSommatieNatural: number | null
    limiteDiasReaccionEmpresa: number | null
    multaNoReaccionEmpresa: number | null
    multaNoReaccionNatural: number | null
    multaAcuerdoPagoEmpresa: number | null
    multaAcuerdoPagoNatural: number | null
    invoiceNumberLength: number | null
    invoiceSecuence: number | null
  }

  export type GlobalParameterSumAggregateOutputType = {
    porcCobranza: number | null
    porcAbb: number | null
    diasPlazoEmpresaAanmaning: number | null
    diasPlazoConsumidorAanmaning: number | null
    diasPlazoEmpresaSommatie: number | null
    diasPlazoConsumidorSommatie: number | null
    precioEmpresaPequena: number | null
    contribucionEmpresaPequenaPfc: number | null
    precioEmpresaGrande: number | null
    contribucionEmpresaGrandePfc: number | null
    multaAanmaningEmpresa: number | null
    multaAanmaningNatural: number | null
    multaSommatieEmpresa: number | null
    multaSommatieNatural: number | null
    limiteDiasReaccionEmpresa: number | null
    multaNoReaccionEmpresa: number | null
    multaNoReaccionNatural: number | null
    multaAcuerdoPagoEmpresa: number | null
    multaAcuerdoPagoNatural: number | null
    invoiceNumberLength: number | null
    invoiceSecuence: number | null
  }

  export type GlobalParameterMinAggregateOutputType = {
    id: string | null
    porcCobranza: number | null
    porcAbb: number | null
    diasPlazoEmpresaAanmaning: number | null
    diasPlazoConsumidorAanmaning: number | null
    diasPlazoEmpresaSommatie: number | null
    diasPlazoConsumidorSommatie: number | null
    precioEmpresaPequena: number | null
    contribucionEmpresaPequenaPfc: number | null
    precioEmpresaGrande: number | null
    contribucionEmpresaGrandePfc: number | null
    createdAt: Date | null
    updatedAt: Date | null
    multaAanmaningEmpresa: number | null
    multaAanmaningNatural: number | null
    multaSommatieEmpresa: number | null
    multaSommatieNatural: number | null
    limiteDiasReaccionEmpresa: number | null
    multaNoReaccionEmpresa: number | null
    multaNoReaccionNatural: number | null
    multaAcuerdoPagoEmpresa: number | null
    multaAcuerdoPagoNatural: number | null
    invoiceNumberLength: number | null
    invoicePrefix: string | null
    invoiceSecuence: number | null
    bankAccount: string | null
    bankName: string | null
  }

  export type GlobalParameterMaxAggregateOutputType = {
    id: string | null
    porcCobranza: number | null
    porcAbb: number | null
    diasPlazoEmpresaAanmaning: number | null
    diasPlazoConsumidorAanmaning: number | null
    diasPlazoEmpresaSommatie: number | null
    diasPlazoConsumidorSommatie: number | null
    precioEmpresaPequena: number | null
    contribucionEmpresaPequenaPfc: number | null
    precioEmpresaGrande: number | null
    contribucionEmpresaGrandePfc: number | null
    createdAt: Date | null
    updatedAt: Date | null
    multaAanmaningEmpresa: number | null
    multaAanmaningNatural: number | null
    multaSommatieEmpresa: number | null
    multaSommatieNatural: number | null
    limiteDiasReaccionEmpresa: number | null
    multaNoReaccionEmpresa: number | null
    multaNoReaccionNatural: number | null
    multaAcuerdoPagoEmpresa: number | null
    multaAcuerdoPagoNatural: number | null
    invoiceNumberLength: number | null
    invoicePrefix: string | null
    invoiceSecuence: number | null
    bankAccount: string | null
    bankName: string | null
  }

  export type GlobalParameterCountAggregateOutputType = {
    id: number
    porcCobranza: number
    porcAbb: number
    diasPlazoEmpresaAanmaning: number
    diasPlazoConsumidorAanmaning: number
    diasPlazoEmpresaSommatie: number
    diasPlazoConsumidorSommatie: number
    precioEmpresaPequena: number
    contribucionEmpresaPequenaPfc: number
    precioEmpresaGrande: number
    contribucionEmpresaGrandePfc: number
    createdAt: number
    updatedAt: number
    multaAanmaningEmpresa: number
    multaAanmaningNatural: number
    multaSommatieEmpresa: number
    multaSommatieNatural: number
    limiteDiasReaccionEmpresa: number
    multaNoReaccionEmpresa: number
    multaNoReaccionNatural: number
    multaAcuerdoPagoEmpresa: number
    multaAcuerdoPagoNatural: number
    invoiceNumberLength: number
    invoicePrefix: number
    invoiceSecuence: number
    bankAccount: number
    bankName: number
    _all: number
  }


  export type GlobalParameterAvgAggregateInputType = {
    porcCobranza?: true
    porcAbb?: true
    diasPlazoEmpresaAanmaning?: true
    diasPlazoConsumidorAanmaning?: true
    diasPlazoEmpresaSommatie?: true
    diasPlazoConsumidorSommatie?: true
    precioEmpresaPequena?: true
    contribucionEmpresaPequenaPfc?: true
    precioEmpresaGrande?: true
    contribucionEmpresaGrandePfc?: true
    multaAanmaningEmpresa?: true
    multaAanmaningNatural?: true
    multaSommatieEmpresa?: true
    multaSommatieNatural?: true
    limiteDiasReaccionEmpresa?: true
    multaNoReaccionEmpresa?: true
    multaNoReaccionNatural?: true
    multaAcuerdoPagoEmpresa?: true
    multaAcuerdoPagoNatural?: true
    invoiceNumberLength?: true
    invoiceSecuence?: true
  }

  export type GlobalParameterSumAggregateInputType = {
    porcCobranza?: true
    porcAbb?: true
    diasPlazoEmpresaAanmaning?: true
    diasPlazoConsumidorAanmaning?: true
    diasPlazoEmpresaSommatie?: true
    diasPlazoConsumidorSommatie?: true
    precioEmpresaPequena?: true
    contribucionEmpresaPequenaPfc?: true
    precioEmpresaGrande?: true
    contribucionEmpresaGrandePfc?: true
    multaAanmaningEmpresa?: true
    multaAanmaningNatural?: true
    multaSommatieEmpresa?: true
    multaSommatieNatural?: true
    limiteDiasReaccionEmpresa?: true
    multaNoReaccionEmpresa?: true
    multaNoReaccionNatural?: true
    multaAcuerdoPagoEmpresa?: true
    multaAcuerdoPagoNatural?: true
    invoiceNumberLength?: true
    invoiceSecuence?: true
  }

  export type GlobalParameterMinAggregateInputType = {
    id?: true
    porcCobranza?: true
    porcAbb?: true
    diasPlazoEmpresaAanmaning?: true
    diasPlazoConsumidorAanmaning?: true
    diasPlazoEmpresaSommatie?: true
    diasPlazoConsumidorSommatie?: true
    precioEmpresaPequena?: true
    contribucionEmpresaPequenaPfc?: true
    precioEmpresaGrande?: true
    contribucionEmpresaGrandePfc?: true
    createdAt?: true
    updatedAt?: true
    multaAanmaningEmpresa?: true
    multaAanmaningNatural?: true
    multaSommatieEmpresa?: true
    multaSommatieNatural?: true
    limiteDiasReaccionEmpresa?: true
    multaNoReaccionEmpresa?: true
    multaNoReaccionNatural?: true
    multaAcuerdoPagoEmpresa?: true
    multaAcuerdoPagoNatural?: true
    invoiceNumberLength?: true
    invoicePrefix?: true
    invoiceSecuence?: true
    bankAccount?: true
    bankName?: true
  }

  export type GlobalParameterMaxAggregateInputType = {
    id?: true
    porcCobranza?: true
    porcAbb?: true
    diasPlazoEmpresaAanmaning?: true
    diasPlazoConsumidorAanmaning?: true
    diasPlazoEmpresaSommatie?: true
    diasPlazoConsumidorSommatie?: true
    precioEmpresaPequena?: true
    contribucionEmpresaPequenaPfc?: true
    precioEmpresaGrande?: true
    contribucionEmpresaGrandePfc?: true
    createdAt?: true
    updatedAt?: true
    multaAanmaningEmpresa?: true
    multaAanmaningNatural?: true
    multaSommatieEmpresa?: true
    multaSommatieNatural?: true
    limiteDiasReaccionEmpresa?: true
    multaNoReaccionEmpresa?: true
    multaNoReaccionNatural?: true
    multaAcuerdoPagoEmpresa?: true
    multaAcuerdoPagoNatural?: true
    invoiceNumberLength?: true
    invoicePrefix?: true
    invoiceSecuence?: true
    bankAccount?: true
    bankName?: true
  }

  export type GlobalParameterCountAggregateInputType = {
    id?: true
    porcCobranza?: true
    porcAbb?: true
    diasPlazoEmpresaAanmaning?: true
    diasPlazoConsumidorAanmaning?: true
    diasPlazoEmpresaSommatie?: true
    diasPlazoConsumidorSommatie?: true
    precioEmpresaPequena?: true
    contribucionEmpresaPequenaPfc?: true
    precioEmpresaGrande?: true
    contribucionEmpresaGrandePfc?: true
    createdAt?: true
    updatedAt?: true
    multaAanmaningEmpresa?: true
    multaAanmaningNatural?: true
    multaSommatieEmpresa?: true
    multaSommatieNatural?: true
    limiteDiasReaccionEmpresa?: true
    multaNoReaccionEmpresa?: true
    multaNoReaccionNatural?: true
    multaAcuerdoPagoEmpresa?: true
    multaAcuerdoPagoNatural?: true
    invoiceNumberLength?: true
    invoicePrefix?: true
    invoiceSecuence?: true
    bankAccount?: true
    bankName?: true
    _all?: true
  }

  export type GlobalParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalParameter to aggregate.
     */
    where?: GlobalParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalParameters to fetch.
     */
    orderBy?: GlobalParameterOrderByWithRelationInput | GlobalParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GlobalParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GlobalParameters
    **/
    _count?: true | GlobalParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GlobalParameterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GlobalParameterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GlobalParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GlobalParameterMaxAggregateInputType
  }

  export type GetGlobalParameterAggregateType<T extends GlobalParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateGlobalParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGlobalParameter[P]>
      : GetScalarType<T[P], AggregateGlobalParameter[P]>
  }




  export type GlobalParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GlobalParameterWhereInput
    orderBy?: GlobalParameterOrderByWithAggregationInput | GlobalParameterOrderByWithAggregationInput[]
    by: GlobalParameterScalarFieldEnum[] | GlobalParameterScalarFieldEnum
    having?: GlobalParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GlobalParameterCountAggregateInputType | true
    _avg?: GlobalParameterAvgAggregateInputType
    _sum?: GlobalParameterSumAggregateInputType
    _min?: GlobalParameterMinAggregateInputType
    _max?: GlobalParameterMaxAggregateInputType
  }

  export type GlobalParameterGroupByOutputType = {
    id: string
    porcCobranza: number
    porcAbb: number
    diasPlazoEmpresaAanmaning: number
    diasPlazoConsumidorAanmaning: number
    diasPlazoEmpresaSommatie: number
    diasPlazoConsumidorSommatie: number
    precioEmpresaPequena: number
    contribucionEmpresaPequenaPfc: number
    precioEmpresaGrande: number
    contribucionEmpresaGrandePfc: number
    createdAt: Date
    updatedAt: Date
    multaAanmaningEmpresa: number
    multaAanmaningNatural: number
    multaSommatieEmpresa: number
    multaSommatieNatural: number
    limiteDiasReaccionEmpresa: number
    multaNoReaccionEmpresa: number
    multaNoReaccionNatural: number
    multaAcuerdoPagoEmpresa: number
    multaAcuerdoPagoNatural: number
    invoiceNumberLength: number
    invoicePrefix: string
    invoiceSecuence: number
    bankAccount: string
    bankName: string
    _count: GlobalParameterCountAggregateOutputType | null
    _avg: GlobalParameterAvgAggregateOutputType | null
    _sum: GlobalParameterSumAggregateOutputType | null
    _min: GlobalParameterMinAggregateOutputType | null
    _max: GlobalParameterMaxAggregateOutputType | null
  }

  type GetGlobalParameterGroupByPayload<T extends GlobalParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GlobalParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GlobalParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GlobalParameterGroupByOutputType[P]>
            : GetScalarType<T[P], GlobalParameterGroupByOutputType[P]>
        }
      >
    >


  export type GlobalParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    porcCobranza?: boolean
    porcAbb?: boolean
    diasPlazoEmpresaAanmaning?: boolean
    diasPlazoConsumidorAanmaning?: boolean
    diasPlazoEmpresaSommatie?: boolean
    diasPlazoConsumidorSommatie?: boolean
    precioEmpresaPequena?: boolean
    contribucionEmpresaPequenaPfc?: boolean
    precioEmpresaGrande?: boolean
    contribucionEmpresaGrandePfc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    multaAanmaningEmpresa?: boolean
    multaAanmaningNatural?: boolean
    multaSommatieEmpresa?: boolean
    multaSommatieNatural?: boolean
    limiteDiasReaccionEmpresa?: boolean
    multaNoReaccionEmpresa?: boolean
    multaNoReaccionNatural?: boolean
    multaAcuerdoPagoEmpresa?: boolean
    multaAcuerdoPagoNatural?: boolean
    invoiceNumberLength?: boolean
    invoicePrefix?: boolean
    invoiceSecuence?: boolean
    bankAccount?: boolean
    bankName?: boolean
  }, ExtArgs["result"]["globalParameter"]>

  export type GlobalParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    porcCobranza?: boolean
    porcAbb?: boolean
    diasPlazoEmpresaAanmaning?: boolean
    diasPlazoConsumidorAanmaning?: boolean
    diasPlazoEmpresaSommatie?: boolean
    diasPlazoConsumidorSommatie?: boolean
    precioEmpresaPequena?: boolean
    contribucionEmpresaPequenaPfc?: boolean
    precioEmpresaGrande?: boolean
    contribucionEmpresaGrandePfc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    multaAanmaningEmpresa?: boolean
    multaAanmaningNatural?: boolean
    multaSommatieEmpresa?: boolean
    multaSommatieNatural?: boolean
    limiteDiasReaccionEmpresa?: boolean
    multaNoReaccionEmpresa?: boolean
    multaNoReaccionNatural?: boolean
    multaAcuerdoPagoEmpresa?: boolean
    multaAcuerdoPagoNatural?: boolean
    invoiceNumberLength?: boolean
    invoicePrefix?: boolean
    invoiceSecuence?: boolean
    bankAccount?: boolean
    bankName?: boolean
  }, ExtArgs["result"]["globalParameter"]>

  export type GlobalParameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    porcCobranza?: boolean
    porcAbb?: boolean
    diasPlazoEmpresaAanmaning?: boolean
    diasPlazoConsumidorAanmaning?: boolean
    diasPlazoEmpresaSommatie?: boolean
    diasPlazoConsumidorSommatie?: boolean
    precioEmpresaPequena?: boolean
    contribucionEmpresaPequenaPfc?: boolean
    precioEmpresaGrande?: boolean
    contribucionEmpresaGrandePfc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    multaAanmaningEmpresa?: boolean
    multaAanmaningNatural?: boolean
    multaSommatieEmpresa?: boolean
    multaSommatieNatural?: boolean
    limiteDiasReaccionEmpresa?: boolean
    multaNoReaccionEmpresa?: boolean
    multaNoReaccionNatural?: boolean
    multaAcuerdoPagoEmpresa?: boolean
    multaAcuerdoPagoNatural?: boolean
    invoiceNumberLength?: boolean
    invoicePrefix?: boolean
    invoiceSecuence?: boolean
    bankAccount?: boolean
    bankName?: boolean
  }, ExtArgs["result"]["globalParameter"]>

  export type GlobalParameterSelectScalar = {
    id?: boolean
    porcCobranza?: boolean
    porcAbb?: boolean
    diasPlazoEmpresaAanmaning?: boolean
    diasPlazoConsumidorAanmaning?: boolean
    diasPlazoEmpresaSommatie?: boolean
    diasPlazoConsumidorSommatie?: boolean
    precioEmpresaPequena?: boolean
    contribucionEmpresaPequenaPfc?: boolean
    precioEmpresaGrande?: boolean
    contribucionEmpresaGrandePfc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    multaAanmaningEmpresa?: boolean
    multaAanmaningNatural?: boolean
    multaSommatieEmpresa?: boolean
    multaSommatieNatural?: boolean
    limiteDiasReaccionEmpresa?: boolean
    multaNoReaccionEmpresa?: boolean
    multaNoReaccionNatural?: boolean
    multaAcuerdoPagoEmpresa?: boolean
    multaAcuerdoPagoNatural?: boolean
    invoiceNumberLength?: boolean
    invoicePrefix?: boolean
    invoiceSecuence?: boolean
    bankAccount?: boolean
    bankName?: boolean
  }

  export type GlobalParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "porcCobranza" | "porcAbb" | "diasPlazoEmpresaAanmaning" | "diasPlazoConsumidorAanmaning" | "diasPlazoEmpresaSommatie" | "diasPlazoConsumidorSommatie" | "precioEmpresaPequena" | "contribucionEmpresaPequenaPfc" | "precioEmpresaGrande" | "contribucionEmpresaGrandePfc" | "createdAt" | "updatedAt" | "multaAanmaningEmpresa" | "multaAanmaningNatural" | "multaSommatieEmpresa" | "multaSommatieNatural" | "limiteDiasReaccionEmpresa" | "multaNoReaccionEmpresa" | "multaNoReaccionNatural" | "multaAcuerdoPagoEmpresa" | "multaAcuerdoPagoNatural" | "invoiceNumberLength" | "invoicePrefix" | "invoiceSecuence" | "bankAccount" | "bankName", ExtArgs["result"]["globalParameter"]>

  export type $GlobalParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GlobalParameter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      porcCobranza: number
      porcAbb: number
      diasPlazoEmpresaAanmaning: number
      diasPlazoConsumidorAanmaning: number
      diasPlazoEmpresaSommatie: number
      diasPlazoConsumidorSommatie: number
      precioEmpresaPequena: number
      contribucionEmpresaPequenaPfc: number
      precioEmpresaGrande: number
      contribucionEmpresaGrandePfc: number
      createdAt: Date
      updatedAt: Date
      multaAanmaningEmpresa: number
      multaAanmaningNatural: number
      multaSommatieEmpresa: number
      multaSommatieNatural: number
      limiteDiasReaccionEmpresa: number
      multaNoReaccionEmpresa: number
      multaNoReaccionNatural: number
      multaAcuerdoPagoEmpresa: number
      multaAcuerdoPagoNatural: number
      invoiceNumberLength: number
      invoicePrefix: string
      invoiceSecuence: number
      bankAccount: string
      bankName: string
    }, ExtArgs["result"]["globalParameter"]>
    composites: {}
  }

  type GlobalParameterGetPayload<S extends boolean | null | undefined | GlobalParameterDefaultArgs> = $Result.GetResult<Prisma.$GlobalParameterPayload, S>

  type GlobalParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GlobalParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GlobalParameterCountAggregateInputType | true
    }

  export interface GlobalParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GlobalParameter'], meta: { name: 'GlobalParameter' } }
    /**
     * Find zero or one GlobalParameter that matches the filter.
     * @param {GlobalParameterFindUniqueArgs} args - Arguments to find a GlobalParameter
     * @example
     * // Get one GlobalParameter
     * const globalParameter = await prisma.globalParameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GlobalParameterFindUniqueArgs>(args: SelectSubset<T, GlobalParameterFindUniqueArgs<ExtArgs>>): Prisma__GlobalParameterClient<$Result.GetResult<Prisma.$GlobalParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GlobalParameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GlobalParameterFindUniqueOrThrowArgs} args - Arguments to find a GlobalParameter
     * @example
     * // Get one GlobalParameter
     * const globalParameter = await prisma.globalParameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GlobalParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, GlobalParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GlobalParameterClient<$Result.GetResult<Prisma.$GlobalParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlobalParameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalParameterFindFirstArgs} args - Arguments to find a GlobalParameter
     * @example
     * // Get one GlobalParameter
     * const globalParameter = await prisma.globalParameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GlobalParameterFindFirstArgs>(args?: SelectSubset<T, GlobalParameterFindFirstArgs<ExtArgs>>): Prisma__GlobalParameterClient<$Result.GetResult<Prisma.$GlobalParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GlobalParameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalParameterFindFirstOrThrowArgs} args - Arguments to find a GlobalParameter
     * @example
     * // Get one GlobalParameter
     * const globalParameter = await prisma.globalParameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GlobalParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, GlobalParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__GlobalParameterClient<$Result.GetResult<Prisma.$GlobalParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GlobalParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GlobalParameters
     * const globalParameters = await prisma.globalParameter.findMany()
     * 
     * // Get first 10 GlobalParameters
     * const globalParameters = await prisma.globalParameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const globalParameterWithIdOnly = await prisma.globalParameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GlobalParameterFindManyArgs>(args?: SelectSubset<T, GlobalParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GlobalParameter.
     * @param {GlobalParameterCreateArgs} args - Arguments to create a GlobalParameter.
     * @example
     * // Create one GlobalParameter
     * const GlobalParameter = await prisma.globalParameter.create({
     *   data: {
     *     // ... data to create a GlobalParameter
     *   }
     * })
     * 
     */
    create<T extends GlobalParameterCreateArgs>(args: SelectSubset<T, GlobalParameterCreateArgs<ExtArgs>>): Prisma__GlobalParameterClient<$Result.GetResult<Prisma.$GlobalParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GlobalParameters.
     * @param {GlobalParameterCreateManyArgs} args - Arguments to create many GlobalParameters.
     * @example
     * // Create many GlobalParameters
     * const globalParameter = await prisma.globalParameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GlobalParameterCreateManyArgs>(args?: SelectSubset<T, GlobalParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GlobalParameters and returns the data saved in the database.
     * @param {GlobalParameterCreateManyAndReturnArgs} args - Arguments to create many GlobalParameters.
     * @example
     * // Create many GlobalParameters
     * const globalParameter = await prisma.globalParameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GlobalParameters and only return the `id`
     * const globalParameterWithIdOnly = await prisma.globalParameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GlobalParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, GlobalParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalParameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GlobalParameter.
     * @param {GlobalParameterDeleteArgs} args - Arguments to delete one GlobalParameter.
     * @example
     * // Delete one GlobalParameter
     * const GlobalParameter = await prisma.globalParameter.delete({
     *   where: {
     *     // ... filter to delete one GlobalParameter
     *   }
     * })
     * 
     */
    delete<T extends GlobalParameterDeleteArgs>(args: SelectSubset<T, GlobalParameterDeleteArgs<ExtArgs>>): Prisma__GlobalParameterClient<$Result.GetResult<Prisma.$GlobalParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GlobalParameter.
     * @param {GlobalParameterUpdateArgs} args - Arguments to update one GlobalParameter.
     * @example
     * // Update one GlobalParameter
     * const globalParameter = await prisma.globalParameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GlobalParameterUpdateArgs>(args: SelectSubset<T, GlobalParameterUpdateArgs<ExtArgs>>): Prisma__GlobalParameterClient<$Result.GetResult<Prisma.$GlobalParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GlobalParameters.
     * @param {GlobalParameterDeleteManyArgs} args - Arguments to filter GlobalParameters to delete.
     * @example
     * // Delete a few GlobalParameters
     * const { count } = await prisma.globalParameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GlobalParameterDeleteManyArgs>(args?: SelectSubset<T, GlobalParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GlobalParameters
     * const globalParameter = await prisma.globalParameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GlobalParameterUpdateManyArgs>(args: SelectSubset<T, GlobalParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GlobalParameters and returns the data updated in the database.
     * @param {GlobalParameterUpdateManyAndReturnArgs} args - Arguments to update many GlobalParameters.
     * @example
     * // Update many GlobalParameters
     * const globalParameter = await prisma.globalParameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GlobalParameters and only return the `id`
     * const globalParameterWithIdOnly = await prisma.globalParameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GlobalParameterUpdateManyAndReturnArgs>(args: SelectSubset<T, GlobalParameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GlobalParameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GlobalParameter.
     * @param {GlobalParameterUpsertArgs} args - Arguments to update or create a GlobalParameter.
     * @example
     * // Update or create a GlobalParameter
     * const globalParameter = await prisma.globalParameter.upsert({
     *   create: {
     *     // ... data to create a GlobalParameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GlobalParameter we want to update
     *   }
     * })
     */
    upsert<T extends GlobalParameterUpsertArgs>(args: SelectSubset<T, GlobalParameterUpsertArgs<ExtArgs>>): Prisma__GlobalParameterClient<$Result.GetResult<Prisma.$GlobalParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GlobalParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalParameterCountArgs} args - Arguments to filter GlobalParameters to count.
     * @example
     * // Count the number of GlobalParameters
     * const count = await prisma.globalParameter.count({
     *   where: {
     *     // ... the filter for the GlobalParameters we want to count
     *   }
     * })
    **/
    count<T extends GlobalParameterCountArgs>(
      args?: Subset<T, GlobalParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GlobalParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GlobalParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GlobalParameterAggregateArgs>(args: Subset<T, GlobalParameterAggregateArgs>): Prisma.PrismaPromise<GetGlobalParameterAggregateType<T>>

    /**
     * Group by GlobalParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GlobalParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GlobalParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GlobalParameterGroupByArgs['orderBy'] }
        : { orderBy?: GlobalParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GlobalParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGlobalParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GlobalParameter model
   */
  readonly fields: GlobalParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GlobalParameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GlobalParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GlobalParameter model
   */
  interface GlobalParameterFieldRefs {
    readonly id: FieldRef<"GlobalParameter", 'String'>
    readonly porcCobranza: FieldRef<"GlobalParameter", 'Float'>
    readonly porcAbb: FieldRef<"GlobalParameter", 'Float'>
    readonly diasPlazoEmpresaAanmaning: FieldRef<"GlobalParameter", 'Int'>
    readonly diasPlazoConsumidorAanmaning: FieldRef<"GlobalParameter", 'Int'>
    readonly diasPlazoEmpresaSommatie: FieldRef<"GlobalParameter", 'Int'>
    readonly diasPlazoConsumidorSommatie: FieldRef<"GlobalParameter", 'Int'>
    readonly precioEmpresaPequena: FieldRef<"GlobalParameter", 'Float'>
    readonly contribucionEmpresaPequenaPfc: FieldRef<"GlobalParameter", 'Float'>
    readonly precioEmpresaGrande: FieldRef<"GlobalParameter", 'Float'>
    readonly contribucionEmpresaGrandePfc: FieldRef<"GlobalParameter", 'Float'>
    readonly createdAt: FieldRef<"GlobalParameter", 'DateTime'>
    readonly updatedAt: FieldRef<"GlobalParameter", 'DateTime'>
    readonly multaAanmaningEmpresa: FieldRef<"GlobalParameter", 'Float'>
    readonly multaAanmaningNatural: FieldRef<"GlobalParameter", 'Float'>
    readonly multaSommatieEmpresa: FieldRef<"GlobalParameter", 'Float'>
    readonly multaSommatieNatural: FieldRef<"GlobalParameter", 'Float'>
    readonly limiteDiasReaccionEmpresa: FieldRef<"GlobalParameter", 'Int'>
    readonly multaNoReaccionEmpresa: FieldRef<"GlobalParameter", 'Float'>
    readonly multaNoReaccionNatural: FieldRef<"GlobalParameter", 'Float'>
    readonly multaAcuerdoPagoEmpresa: FieldRef<"GlobalParameter", 'Float'>
    readonly multaAcuerdoPagoNatural: FieldRef<"GlobalParameter", 'Float'>
    readonly invoiceNumberLength: FieldRef<"GlobalParameter", 'Int'>
    readonly invoicePrefix: FieldRef<"GlobalParameter", 'String'>
    readonly invoiceSecuence: FieldRef<"GlobalParameter", 'Int'>
    readonly bankAccount: FieldRef<"GlobalParameter", 'String'>
    readonly bankName: FieldRef<"GlobalParameter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GlobalParameter findUnique
   */
  export type GlobalParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
    /**
     * Filter, which GlobalParameter to fetch.
     */
    where: GlobalParameterWhereUniqueInput
  }

  /**
   * GlobalParameter findUniqueOrThrow
   */
  export type GlobalParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
    /**
     * Filter, which GlobalParameter to fetch.
     */
    where: GlobalParameterWhereUniqueInput
  }

  /**
   * GlobalParameter findFirst
   */
  export type GlobalParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
    /**
     * Filter, which GlobalParameter to fetch.
     */
    where?: GlobalParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalParameters to fetch.
     */
    orderBy?: GlobalParameterOrderByWithRelationInput | GlobalParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalParameters.
     */
    cursor?: GlobalParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalParameters.
     */
    distinct?: GlobalParameterScalarFieldEnum | GlobalParameterScalarFieldEnum[]
  }

  /**
   * GlobalParameter findFirstOrThrow
   */
  export type GlobalParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
    /**
     * Filter, which GlobalParameter to fetch.
     */
    where?: GlobalParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalParameters to fetch.
     */
    orderBy?: GlobalParameterOrderByWithRelationInput | GlobalParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GlobalParameters.
     */
    cursor?: GlobalParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GlobalParameters.
     */
    distinct?: GlobalParameterScalarFieldEnum | GlobalParameterScalarFieldEnum[]
  }

  /**
   * GlobalParameter findMany
   */
  export type GlobalParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
    /**
     * Filter, which GlobalParameters to fetch.
     */
    where?: GlobalParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GlobalParameters to fetch.
     */
    orderBy?: GlobalParameterOrderByWithRelationInput | GlobalParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GlobalParameters.
     */
    cursor?: GlobalParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GlobalParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GlobalParameters.
     */
    skip?: number
    distinct?: GlobalParameterScalarFieldEnum | GlobalParameterScalarFieldEnum[]
  }

  /**
   * GlobalParameter create
   */
  export type GlobalParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
    /**
     * The data needed to create a GlobalParameter.
     */
    data: XOR<GlobalParameterCreateInput, GlobalParameterUncheckedCreateInput>
  }

  /**
   * GlobalParameter createMany
   */
  export type GlobalParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GlobalParameters.
     */
    data: GlobalParameterCreateManyInput | GlobalParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalParameter createManyAndReturn
   */
  export type GlobalParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
    /**
     * The data used to create many GlobalParameters.
     */
    data: GlobalParameterCreateManyInput | GlobalParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GlobalParameter update
   */
  export type GlobalParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
    /**
     * The data needed to update a GlobalParameter.
     */
    data: XOR<GlobalParameterUpdateInput, GlobalParameterUncheckedUpdateInput>
    /**
     * Choose, which GlobalParameter to update.
     */
    where: GlobalParameterWhereUniqueInput
  }

  /**
   * GlobalParameter updateMany
   */
  export type GlobalParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GlobalParameters.
     */
    data: XOR<GlobalParameterUpdateManyMutationInput, GlobalParameterUncheckedUpdateManyInput>
    /**
     * Filter which GlobalParameters to update
     */
    where?: GlobalParameterWhereInput
    /**
     * Limit how many GlobalParameters to update.
     */
    limit?: number
  }

  /**
   * GlobalParameter updateManyAndReturn
   */
  export type GlobalParameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
    /**
     * The data used to update GlobalParameters.
     */
    data: XOR<GlobalParameterUpdateManyMutationInput, GlobalParameterUncheckedUpdateManyInput>
    /**
     * Filter which GlobalParameters to update
     */
    where?: GlobalParameterWhereInput
    /**
     * Limit how many GlobalParameters to update.
     */
    limit?: number
  }

  /**
   * GlobalParameter upsert
   */
  export type GlobalParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
    /**
     * The filter to search for the GlobalParameter to update in case it exists.
     */
    where: GlobalParameterWhereUniqueInput
    /**
     * In case the GlobalParameter found by the `where` argument doesn't exist, create a new GlobalParameter with this data.
     */
    create: XOR<GlobalParameterCreateInput, GlobalParameterUncheckedCreateInput>
    /**
     * In case the GlobalParameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GlobalParameterUpdateInput, GlobalParameterUncheckedUpdateInput>
  }

  /**
   * GlobalParameter delete
   */
  export type GlobalParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
    /**
     * Filter which GlobalParameter to delete.
     */
    where: GlobalParameterWhereUniqueInput
  }

  /**
   * GlobalParameter deleteMany
   */
  export type GlobalParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GlobalParameters to delete
     */
    where?: GlobalParameterWhereInput
    /**
     * Limit how many GlobalParameters to delete.
     */
    limit?: number
  }

  /**
   * GlobalParameter without action
   */
  export type GlobalParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GlobalParameter
     */
    select?: GlobalParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GlobalParameter
     */
    omit?: GlobalParameterOmit<ExtArgs> | null
  }


  /**
   * Model Verdict
   */

  export type AggregateVerdict = {
    _count: VerdictCountAggregateOutputType | null
    _avg: VerdictAvgAggregateOutputType | null
    _sum: VerdictSumAggregateOutputType | null
    _min: VerdictMinAggregateOutputType | null
    _max: VerdictMaxAggregateOutputType | null
  }

  export type VerdictAvgAggregateOutputType = {
    sentenceAmount: number | null
    procesalCost: number | null
  }

  export type VerdictSumAggregateOutputType = {
    sentenceAmount: number | null
    procesalCost: number | null
  }

  export type VerdictMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    creditorName: string | null
    debtorId: string | null
    registrationNumber: string | null
    sentenceAmount: number | null
    sentenceDate: Date | null
    status: $Enums.VerdictStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    procesalCost: number | null
    tenantId: string | null
    notes: string | null
    bailiffId: string | null
  }

  export type VerdictMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    creditorName: string | null
    debtorId: string | null
    registrationNumber: string | null
    sentenceAmount: number | null
    sentenceDate: Date | null
    status: $Enums.VerdictStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    procesalCost: number | null
    tenantId: string | null
    notes: string | null
    bailiffId: string | null
  }

  export type VerdictCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    creditorName: number
    debtorId: number
    registrationNumber: number
    sentenceAmount: number
    sentenceDate: number
    status: number
    createdAt: number
    updatedAt: number
    procesalCost: number
    tenantId: number
    notes: number
    bailiffId: number
    _all: number
  }


  export type VerdictAvgAggregateInputType = {
    sentenceAmount?: true
    procesalCost?: true
  }

  export type VerdictSumAggregateInputType = {
    sentenceAmount?: true
    procesalCost?: true
  }

  export type VerdictMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    creditorName?: true
    debtorId?: true
    registrationNumber?: true
    sentenceAmount?: true
    sentenceDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    procesalCost?: true
    tenantId?: true
    notes?: true
    bailiffId?: true
  }

  export type VerdictMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    creditorName?: true
    debtorId?: true
    registrationNumber?: true
    sentenceAmount?: true
    sentenceDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    procesalCost?: true
    tenantId?: true
    notes?: true
    bailiffId?: true
  }

  export type VerdictCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    creditorName?: true
    debtorId?: true
    registrationNumber?: true
    sentenceAmount?: true
    sentenceDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    procesalCost?: true
    tenantId?: true
    notes?: true
    bailiffId?: true
    _all?: true
  }

  export type VerdictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verdict to aggregate.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verdicts
    **/
    _count?: true | VerdictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictMaxAggregateInputType
  }

  export type GetVerdictAggregateType<T extends VerdictAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdict[P]>
      : GetScalarType<T[P], AggregateVerdict[P]>
  }




  export type VerdictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithAggregationInput | VerdictOrderByWithAggregationInput[]
    by: VerdictScalarFieldEnum[] | VerdictScalarFieldEnum
    having?: VerdictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictCountAggregateInputType | true
    _avg?: VerdictAvgAggregateInputType
    _sum?: VerdictSumAggregateInputType
    _min?: VerdictMinAggregateInputType
    _max?: VerdictMaxAggregateInputType
  }

  export type VerdictGroupByOutputType = {
    id: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date
    status: $Enums.VerdictStatus
    createdAt: Date
    updatedAt: Date
    procesalCost: number | null
    tenantId: string
    notes: string | null
    bailiffId: string | null
    _count: VerdictCountAggregateOutputType | null
    _avg: VerdictAvgAggregateOutputType | null
    _sum: VerdictSumAggregateOutputType | null
    _min: VerdictMinAggregateOutputType | null
    _max: VerdictMaxAggregateOutputType | null
  }

  type GetVerdictGroupByPayload<T extends VerdictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictGroupByOutputType[P]>
        }
      >
    >


  export type VerdictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    creditorName?: boolean
    debtorId?: boolean
    registrationNumber?: boolean
    sentenceAmount?: boolean
    sentenceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    procesalCost?: boolean
    tenantId?: boolean
    notes?: boolean
    bailiffId?: boolean
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    attachments?: boolean | Verdict$attachmentsArgs<ExtArgs>
    bailiffServices?: boolean | Verdict$bailiffServicesArgs<ExtArgs>
    verdictEmbargo?: boolean | Verdict$verdictEmbargoArgs<ExtArgs>
    verdictInterest?: boolean | Verdict$verdictInterestArgs<ExtArgs>
    _count?: boolean | VerdictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    creditorName?: boolean
    debtorId?: boolean
    registrationNumber?: boolean
    sentenceAmount?: boolean
    sentenceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    procesalCost?: boolean
    tenantId?: boolean
    notes?: boolean
    bailiffId?: boolean
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    creditorName?: boolean
    debtorId?: boolean
    registrationNumber?: boolean
    sentenceAmount?: boolean
    sentenceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    procesalCost?: boolean
    tenantId?: boolean
    notes?: boolean
    bailiffId?: boolean
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    creditorName?: boolean
    debtorId?: boolean
    registrationNumber?: boolean
    sentenceAmount?: boolean
    sentenceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    procesalCost?: boolean
    tenantId?: boolean
    notes?: boolean
    bailiffId?: boolean
  }

  export type VerdictOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "creditorName" | "debtorId" | "registrationNumber" | "sentenceAmount" | "sentenceDate" | "status" | "createdAt" | "updatedAt" | "procesalCost" | "tenantId" | "notes" | "bailiffId", ExtArgs["result"]["verdict"]>
  export type VerdictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    attachments?: boolean | Verdict$attachmentsArgs<ExtArgs>
    bailiffServices?: boolean | Verdict$bailiffServicesArgs<ExtArgs>
    verdictEmbargo?: boolean | Verdict$verdictEmbargoArgs<ExtArgs>
    verdictInterest?: boolean | Verdict$verdictInterestArgs<ExtArgs>
    _count?: boolean | VerdictCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VerdictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VerdictIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $VerdictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verdict"
    objects: {
      bailiff: Prisma.$UserPayload<ExtArgs> | null
      debtor: Prisma.$DebtorPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      attachments: Prisma.$VerdictAttachmentPayload<ExtArgs>[]
      bailiffServices: Prisma.$VerdictBailiffServicesPayload<ExtArgs>[]
      verdictEmbargo: Prisma.$VerdictEmbargoPayload<ExtArgs>[]
      verdictInterest: Prisma.$VerdictInterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      creditorName: string
      debtorId: string
      registrationNumber: string
      sentenceAmount: number
      sentenceDate: Date
      status: $Enums.VerdictStatus
      createdAt: Date
      updatedAt: Date
      procesalCost: number | null
      tenantId: string
      notes: string | null
      bailiffId: string | null
    }, ExtArgs["result"]["verdict"]>
    composites: {}
  }

  type VerdictGetPayload<S extends boolean | null | undefined | VerdictDefaultArgs> = $Result.GetResult<Prisma.$VerdictPayload, S>

  type VerdictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictCountAggregateInputType | true
    }

  export interface VerdictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verdict'], meta: { name: 'Verdict' } }
    /**
     * Find zero or one Verdict that matches the filter.
     * @param {VerdictFindUniqueArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictFindUniqueArgs>(args: SelectSubset<T, VerdictFindUniqueArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verdict that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictFindUniqueOrThrowArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verdict that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindFirstArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictFindFirstArgs>(args?: SelectSubset<T, VerdictFindFirstArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verdict that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindFirstOrThrowArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verdicts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verdicts
     * const verdicts = await prisma.verdict.findMany()
     * 
     * // Get first 10 Verdicts
     * const verdicts = await prisma.verdict.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictWithIdOnly = await prisma.verdict.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictFindManyArgs>(args?: SelectSubset<T, VerdictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verdict.
     * @param {VerdictCreateArgs} args - Arguments to create a Verdict.
     * @example
     * // Create one Verdict
     * const Verdict = await prisma.verdict.create({
     *   data: {
     *     // ... data to create a Verdict
     *   }
     * })
     * 
     */
    create<T extends VerdictCreateArgs>(args: SelectSubset<T, VerdictCreateArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verdicts.
     * @param {VerdictCreateManyArgs} args - Arguments to create many Verdicts.
     * @example
     * // Create many Verdicts
     * const verdict = await prisma.verdict.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictCreateManyArgs>(args?: SelectSubset<T, VerdictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verdicts and returns the data saved in the database.
     * @param {VerdictCreateManyAndReturnArgs} args - Arguments to create many Verdicts.
     * @example
     * // Create many Verdicts
     * const verdict = await prisma.verdict.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verdicts and only return the `id`
     * const verdictWithIdOnly = await prisma.verdict.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verdict.
     * @param {VerdictDeleteArgs} args - Arguments to delete one Verdict.
     * @example
     * // Delete one Verdict
     * const Verdict = await prisma.verdict.delete({
     *   where: {
     *     // ... filter to delete one Verdict
     *   }
     * })
     * 
     */
    delete<T extends VerdictDeleteArgs>(args: SelectSubset<T, VerdictDeleteArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verdict.
     * @param {VerdictUpdateArgs} args - Arguments to update one Verdict.
     * @example
     * // Update one Verdict
     * const verdict = await prisma.verdict.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictUpdateArgs>(args: SelectSubset<T, VerdictUpdateArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verdicts.
     * @param {VerdictDeleteManyArgs} args - Arguments to filter Verdicts to delete.
     * @example
     * // Delete a few Verdicts
     * const { count } = await prisma.verdict.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictDeleteManyArgs>(args?: SelectSubset<T, VerdictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verdicts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verdicts
     * const verdict = await prisma.verdict.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictUpdateManyArgs>(args: SelectSubset<T, VerdictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verdicts and returns the data updated in the database.
     * @param {VerdictUpdateManyAndReturnArgs} args - Arguments to update many Verdicts.
     * @example
     * // Update many Verdicts
     * const verdict = await prisma.verdict.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verdicts and only return the `id`
     * const verdictWithIdOnly = await prisma.verdict.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verdict.
     * @param {VerdictUpsertArgs} args - Arguments to update or create a Verdict.
     * @example
     * // Update or create a Verdict
     * const verdict = await prisma.verdict.upsert({
     *   create: {
     *     // ... data to create a Verdict
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verdict we want to update
     *   }
     * })
     */
    upsert<T extends VerdictUpsertArgs>(args: SelectSubset<T, VerdictUpsertArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verdicts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictCountArgs} args - Arguments to filter Verdicts to count.
     * @example
     * // Count the number of Verdicts
     * const count = await prisma.verdict.count({
     *   where: {
     *     // ... the filter for the Verdicts we want to count
     *   }
     * })
    **/
    count<T extends VerdictCountArgs>(
      args?: Subset<T, VerdictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verdict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictAggregateArgs>(args: Subset<T, VerdictAggregateArgs>): Prisma.PrismaPromise<GetVerdictAggregateType<T>>

    /**
     * Group by Verdict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictGroupByArgs['orderBy'] }
        : { orderBy?: VerdictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verdict model
   */
  readonly fields: VerdictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verdict.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bailiff<T extends Verdict$bailiffArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$bailiffArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    debtor<T extends DebtorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtorDefaultArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Verdict$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bailiffServices<T extends Verdict$bailiffServicesArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$bailiffServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdictEmbargo<T extends Verdict$verdictEmbargoArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$verdictEmbargoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdictInterest<T extends Verdict$verdictInterestArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$verdictInterestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verdict model
   */
  interface VerdictFieldRefs {
    readonly id: FieldRef<"Verdict", 'String'>
    readonly invoiceNumber: FieldRef<"Verdict", 'String'>
    readonly creditorName: FieldRef<"Verdict", 'String'>
    readonly debtorId: FieldRef<"Verdict", 'String'>
    readonly registrationNumber: FieldRef<"Verdict", 'String'>
    readonly sentenceAmount: FieldRef<"Verdict", 'Float'>
    readonly sentenceDate: FieldRef<"Verdict", 'DateTime'>
    readonly status: FieldRef<"Verdict", 'VerdictStatus'>
    readonly createdAt: FieldRef<"Verdict", 'DateTime'>
    readonly updatedAt: FieldRef<"Verdict", 'DateTime'>
    readonly procesalCost: FieldRef<"Verdict", 'Float'>
    readonly tenantId: FieldRef<"Verdict", 'String'>
    readonly notes: FieldRef<"Verdict", 'String'>
    readonly bailiffId: FieldRef<"Verdict", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Verdict findUnique
   */
  export type VerdictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict findUniqueOrThrow
   */
  export type VerdictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict findFirst
   */
  export type VerdictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verdicts.
     */
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict findFirstOrThrow
   */
  export type VerdictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verdicts.
     */
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict findMany
   */
  export type VerdictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdicts to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict create
   */
  export type VerdictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The data needed to create a Verdict.
     */
    data: XOR<VerdictCreateInput, VerdictUncheckedCreateInput>
  }

  /**
   * Verdict createMany
   */
  export type VerdictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verdicts.
     */
    data: VerdictCreateManyInput | VerdictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verdict createManyAndReturn
   */
  export type VerdictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * The data used to create many Verdicts.
     */
    data: VerdictCreateManyInput | VerdictCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verdict update
   */
  export type VerdictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The data needed to update a Verdict.
     */
    data: XOR<VerdictUpdateInput, VerdictUncheckedUpdateInput>
    /**
     * Choose, which Verdict to update.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict updateMany
   */
  export type VerdictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verdicts.
     */
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyInput>
    /**
     * Filter which Verdicts to update
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to update.
     */
    limit?: number
  }

  /**
   * Verdict updateManyAndReturn
   */
  export type VerdictUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * The data used to update Verdicts.
     */
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyInput>
    /**
     * Filter which Verdicts to update
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verdict upsert
   */
  export type VerdictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The filter to search for the Verdict to update in case it exists.
     */
    where: VerdictWhereUniqueInput
    /**
     * In case the Verdict found by the `where` argument doesn't exist, create a new Verdict with this data.
     */
    create: XOR<VerdictCreateInput, VerdictUncheckedCreateInput>
    /**
     * In case the Verdict was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictUpdateInput, VerdictUncheckedUpdateInput>
  }

  /**
   * Verdict delete
   */
  export type VerdictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter which Verdict to delete.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict deleteMany
   */
  export type VerdictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verdicts to delete
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to delete.
     */
    limit?: number
  }

  /**
   * Verdict.bailiff
   */
  export type Verdict$bailiffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Verdict.attachments
   */
  export type Verdict$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    where?: VerdictAttachmentWhereInput
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    cursor?: VerdictAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * Verdict.bailiffServices
   */
  export type Verdict$bailiffServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    where?: VerdictBailiffServicesWhereInput
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    cursor?: VerdictBailiffServicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * Verdict.verdictEmbargo
   */
  export type Verdict$verdictEmbargoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    where?: VerdictEmbargoWhereInput
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    cursor?: VerdictEmbargoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * Verdict.verdictInterest
   */
  export type Verdict$verdictInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    where?: VerdictInterestWhereInput
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    cursor?: VerdictInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * Verdict without action
   */
  export type VerdictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
  }


  /**
   * Model VerdictInterest
   */

  export type AggregateVerdictInterest = {
    _count: VerdictInterestCountAggregateOutputType | null
    _avg: VerdictInterestAvgAggregateOutputType | null
    _sum: VerdictInterestSumAggregateOutputType | null
    _min: VerdictInterestMinAggregateOutputType | null
    _max: VerdictInterestMaxAggregateOutputType | null
  }

  export type VerdictInterestAvgAggregateOutputType = {
    interestType: number | null
    baseAmount: number | null
    calculatedInterest: number | null
    totalInterest: number | null
  }

  export type VerdictInterestSumAggregateOutputType = {
    interestType: number | null
    baseAmount: number | null
    calculatedInterest: number | null
    totalInterest: number | null
  }

  export type VerdictInterestMinAggregateOutputType = {
    id: string | null
    interestType: number | null
    baseAmount: number | null
    calculatedInterest: number | null
    calculationStart: Date | null
    calculationEnd: Date | null
    totalInterest: number | null
    createdAt: Date | null
    updatedAt: Date | null
    verdictId: string | null
  }

  export type VerdictInterestMaxAggregateOutputType = {
    id: string | null
    interestType: number | null
    baseAmount: number | null
    calculatedInterest: number | null
    calculationStart: Date | null
    calculationEnd: Date | null
    totalInterest: number | null
    createdAt: Date | null
    updatedAt: Date | null
    verdictId: string | null
  }

  export type VerdictInterestCountAggregateOutputType = {
    id: number
    interestType: number
    baseAmount: number
    calculatedInterest: number
    calculationStart: number
    calculationEnd: number
    totalInterest: number
    createdAt: number
    updatedAt: number
    verdictId: number
    _all: number
  }


  export type VerdictInterestAvgAggregateInputType = {
    interestType?: true
    baseAmount?: true
    calculatedInterest?: true
    totalInterest?: true
  }

  export type VerdictInterestSumAggregateInputType = {
    interestType?: true
    baseAmount?: true
    calculatedInterest?: true
    totalInterest?: true
  }

  export type VerdictInterestMinAggregateInputType = {
    id?: true
    interestType?: true
    baseAmount?: true
    calculatedInterest?: true
    calculationStart?: true
    calculationEnd?: true
    totalInterest?: true
    createdAt?: true
    updatedAt?: true
    verdictId?: true
  }

  export type VerdictInterestMaxAggregateInputType = {
    id?: true
    interestType?: true
    baseAmount?: true
    calculatedInterest?: true
    calculationStart?: true
    calculationEnd?: true
    totalInterest?: true
    createdAt?: true
    updatedAt?: true
    verdictId?: true
  }

  export type VerdictInterestCountAggregateInputType = {
    id?: true
    interestType?: true
    baseAmount?: true
    calculatedInterest?: true
    calculationStart?: true
    calculationEnd?: true
    totalInterest?: true
    createdAt?: true
    updatedAt?: true
    verdictId?: true
    _all?: true
  }

  export type VerdictInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterest to aggregate.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictInterests
    **/
    _count?: true | VerdictInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictInterestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictInterestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictInterestMaxAggregateInputType
  }

  export type GetVerdictInterestAggregateType<T extends VerdictInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictInterest[P]>
      : GetScalarType<T[P], AggregateVerdictInterest[P]>
  }




  export type VerdictInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestWhereInput
    orderBy?: VerdictInterestOrderByWithAggregationInput | VerdictInterestOrderByWithAggregationInput[]
    by: VerdictInterestScalarFieldEnum[] | VerdictInterestScalarFieldEnum
    having?: VerdictInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictInterestCountAggregateInputType | true
    _avg?: VerdictInterestAvgAggregateInputType
    _sum?: VerdictInterestSumAggregateInputType
    _min?: VerdictInterestMinAggregateInputType
    _max?: VerdictInterestMaxAggregateInputType
  }

  export type VerdictInterestGroupByOutputType = {
    id: string
    interestType: number
    baseAmount: number
    calculatedInterest: number | null
    calculationStart: Date
    calculationEnd: Date
    totalInterest: number
    createdAt: Date
    updatedAt: Date
    verdictId: string | null
    _count: VerdictInterestCountAggregateOutputType | null
    _avg: VerdictInterestAvgAggregateOutputType | null
    _sum: VerdictInterestSumAggregateOutputType | null
    _min: VerdictInterestMinAggregateOutputType | null
    _max: VerdictInterestMaxAggregateOutputType | null
  }

  type GetVerdictInterestGroupByPayload<T extends VerdictInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictInterestGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictInterestGroupByOutputType[P]>
        }
      >
    >


  export type VerdictInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interestType?: boolean
    baseAmount?: boolean
    calculatedInterest?: boolean
    calculationStart?: boolean
    calculationEnd?: boolean
    totalInterest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictId?: boolean
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
    details?: boolean | VerdictInterest$detailsArgs<ExtArgs>
    _count?: boolean | VerdictInterestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterest"]>

  export type VerdictInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interestType?: boolean
    baseAmount?: boolean
    calculatedInterest?: boolean
    calculationStart?: boolean
    calculationEnd?: boolean
    totalInterest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictId?: boolean
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterest"]>

  export type VerdictInterestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interestType?: boolean
    baseAmount?: boolean
    calculatedInterest?: boolean
    calculationStart?: boolean
    calculationEnd?: boolean
    totalInterest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictId?: boolean
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterest"]>

  export type VerdictInterestSelectScalar = {
    id?: boolean
    interestType?: boolean
    baseAmount?: boolean
    calculatedInterest?: boolean
    calculationStart?: boolean
    calculationEnd?: boolean
    totalInterest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictId?: boolean
  }

  export type VerdictInterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interestType" | "baseAmount" | "calculatedInterest" | "calculationStart" | "calculationEnd" | "totalInterest" | "createdAt" | "updatedAt" | "verdictId", ExtArgs["result"]["verdictInterest"]>
  export type VerdictInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
    details?: boolean | VerdictInterest$detailsArgs<ExtArgs>
    _count?: boolean | VerdictInterestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VerdictInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }
  export type VerdictInterestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }

  export type $VerdictInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictInterest"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs> | null
      details: Prisma.$VerdictInterestDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      interestType: number
      baseAmount: number
      calculatedInterest: number | null
      calculationStart: Date
      calculationEnd: Date
      totalInterest: number
      createdAt: Date
      updatedAt: Date
      verdictId: string | null
    }, ExtArgs["result"]["verdictInterest"]>
    composites: {}
  }

  type VerdictInterestGetPayload<S extends boolean | null | undefined | VerdictInterestDefaultArgs> = $Result.GetResult<Prisma.$VerdictInterestPayload, S>

  type VerdictInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictInterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictInterestCountAggregateInputType | true
    }

  export interface VerdictInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictInterest'], meta: { name: 'VerdictInterest' } }
    /**
     * Find zero or one VerdictInterest that matches the filter.
     * @param {VerdictInterestFindUniqueArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictInterestFindUniqueArgs>(args: SelectSubset<T, VerdictInterestFindUniqueArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictInterest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictInterestFindUniqueOrThrowArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestFindFirstArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictInterestFindFirstArgs>(args?: SelectSubset<T, VerdictInterestFindFirstArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestFindFirstOrThrowArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictInterests
     * const verdictInterests = await prisma.verdictInterest.findMany()
     * 
     * // Get first 10 VerdictInterests
     * const verdictInterests = await prisma.verdictInterest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictInterestWithIdOnly = await prisma.verdictInterest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictInterestFindManyArgs>(args?: SelectSubset<T, VerdictInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictInterest.
     * @param {VerdictInterestCreateArgs} args - Arguments to create a VerdictInterest.
     * @example
     * // Create one VerdictInterest
     * const VerdictInterest = await prisma.verdictInterest.create({
     *   data: {
     *     // ... data to create a VerdictInterest
     *   }
     * })
     * 
     */
    create<T extends VerdictInterestCreateArgs>(args: SelectSubset<T, VerdictInterestCreateArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictInterests.
     * @param {VerdictInterestCreateManyArgs} args - Arguments to create many VerdictInterests.
     * @example
     * // Create many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictInterestCreateManyArgs>(args?: SelectSubset<T, VerdictInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictInterests and returns the data saved in the database.
     * @param {VerdictInterestCreateManyAndReturnArgs} args - Arguments to create many VerdictInterests.
     * @example
     * // Create many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictInterests and only return the `id`
     * const verdictInterestWithIdOnly = await prisma.verdictInterest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictInterest.
     * @param {VerdictInterestDeleteArgs} args - Arguments to delete one VerdictInterest.
     * @example
     * // Delete one VerdictInterest
     * const VerdictInterest = await prisma.verdictInterest.delete({
     *   where: {
     *     // ... filter to delete one VerdictInterest
     *   }
     * })
     * 
     */
    delete<T extends VerdictInterestDeleteArgs>(args: SelectSubset<T, VerdictInterestDeleteArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictInterest.
     * @param {VerdictInterestUpdateArgs} args - Arguments to update one VerdictInterest.
     * @example
     * // Update one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictInterestUpdateArgs>(args: SelectSubset<T, VerdictInterestUpdateArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictInterests.
     * @param {VerdictInterestDeleteManyArgs} args - Arguments to filter VerdictInterests to delete.
     * @example
     * // Delete a few VerdictInterests
     * const { count } = await prisma.verdictInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictInterestDeleteManyArgs>(args?: SelectSubset<T, VerdictInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictInterestUpdateManyArgs>(args: SelectSubset<T, VerdictInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterests and returns the data updated in the database.
     * @param {VerdictInterestUpdateManyAndReturnArgs} args - Arguments to update many VerdictInterests.
     * @example
     * // Update many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictInterests and only return the `id`
     * const verdictInterestWithIdOnly = await prisma.verdictInterest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictInterestUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictInterestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictInterest.
     * @param {VerdictInterestUpsertArgs} args - Arguments to update or create a VerdictInterest.
     * @example
     * // Update or create a VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.upsert({
     *   create: {
     *     // ... data to create a VerdictInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictInterest we want to update
     *   }
     * })
     */
    upsert<T extends VerdictInterestUpsertArgs>(args: SelectSubset<T, VerdictInterestUpsertArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestCountArgs} args - Arguments to filter VerdictInterests to count.
     * @example
     * // Count the number of VerdictInterests
     * const count = await prisma.verdictInterest.count({
     *   where: {
     *     // ... the filter for the VerdictInterests we want to count
     *   }
     * })
    **/
    count<T extends VerdictInterestCountArgs>(
      args?: Subset<T, VerdictInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictInterestAggregateArgs>(args: Subset<T, VerdictInterestAggregateArgs>): Prisma.PrismaPromise<GetVerdictInterestAggregateType<T>>

    /**
     * Group by VerdictInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictInterestGroupByArgs['orderBy'] }
        : { orderBy?: VerdictInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictInterest model
   */
  readonly fields: VerdictInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictInterest$verdictArgs<ExtArgs> = {}>(args?: Subset<T, VerdictInterest$verdictArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    details<T extends VerdictInterest$detailsArgs<ExtArgs> = {}>(args?: Subset<T, VerdictInterest$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictInterest model
   */
  interface VerdictInterestFieldRefs {
    readonly id: FieldRef<"VerdictInterest", 'String'>
    readonly interestType: FieldRef<"VerdictInterest", 'Int'>
    readonly baseAmount: FieldRef<"VerdictInterest", 'Float'>
    readonly calculatedInterest: FieldRef<"VerdictInterest", 'Float'>
    readonly calculationStart: FieldRef<"VerdictInterest", 'DateTime'>
    readonly calculationEnd: FieldRef<"VerdictInterest", 'DateTime'>
    readonly totalInterest: FieldRef<"VerdictInterest", 'Float'>
    readonly createdAt: FieldRef<"VerdictInterest", 'DateTime'>
    readonly updatedAt: FieldRef<"VerdictInterest", 'DateTime'>
    readonly verdictId: FieldRef<"VerdictInterest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VerdictInterest findUnique
   */
  export type VerdictInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest findUniqueOrThrow
   */
  export type VerdictInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest findFirst
   */
  export type VerdictInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterests.
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterests.
     */
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * VerdictInterest findFirstOrThrow
   */
  export type VerdictInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterests.
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterests.
     */
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * VerdictInterest findMany
   */
  export type VerdictInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterests to fetch.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictInterests.
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * VerdictInterest create
   */
  export type VerdictInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictInterest.
     */
    data: XOR<VerdictInterestCreateInput, VerdictInterestUncheckedCreateInput>
  }

  /**
   * VerdictInterest createMany
   */
  export type VerdictInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictInterests.
     */
    data: VerdictInterestCreateManyInput | VerdictInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictInterest createManyAndReturn
   */
  export type VerdictInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictInterests.
     */
    data: VerdictInterestCreateManyInput | VerdictInterestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterest update
   */
  export type VerdictInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictInterest.
     */
    data: XOR<VerdictInterestUpdateInput, VerdictInterestUncheckedUpdateInput>
    /**
     * Choose, which VerdictInterest to update.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest updateMany
   */
  export type VerdictInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictInterests.
     */
    data: XOR<VerdictInterestUpdateManyMutationInput, VerdictInterestUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterests to update
     */
    where?: VerdictInterestWhereInput
    /**
     * Limit how many VerdictInterests to update.
     */
    limit?: number
  }

  /**
   * VerdictInterest updateManyAndReturn
   */
  export type VerdictInterestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * The data used to update VerdictInterests.
     */
    data: XOR<VerdictInterestUpdateManyMutationInput, VerdictInterestUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterests to update
     */
    where?: VerdictInterestWhereInput
    /**
     * Limit how many VerdictInterests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterest upsert
   */
  export type VerdictInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictInterest to update in case it exists.
     */
    where: VerdictInterestWhereUniqueInput
    /**
     * In case the VerdictInterest found by the `where` argument doesn't exist, create a new VerdictInterest with this data.
     */
    create: XOR<VerdictInterestCreateInput, VerdictInterestUncheckedCreateInput>
    /**
     * In case the VerdictInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictInterestUpdateInput, VerdictInterestUncheckedUpdateInput>
  }

  /**
   * VerdictInterest delete
   */
  export type VerdictInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter which VerdictInterest to delete.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest deleteMany
   */
  export type VerdictInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterests to delete
     */
    where?: VerdictInterestWhereInput
    /**
     * Limit how many VerdictInterests to delete.
     */
    limit?: number
  }

  /**
   * VerdictInterest.verdict
   */
  export type VerdictInterest$verdictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
  }

  /**
   * VerdictInterest.details
   */
  export type VerdictInterest$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    where?: VerdictInterestDetailsWhereInput
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    cursor?: VerdictInterestDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterest without action
   */
  export type VerdictInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
  }


  /**
   * Model VerdictInterestDetails
   */

  export type AggregateVerdictInterestDetails = {
    _count: VerdictInterestDetailsCountAggregateOutputType | null
    _avg: VerdictInterestDetailsAvgAggregateOutputType | null
    _sum: VerdictInterestDetailsSumAggregateOutputType | null
    _min: VerdictInterestDetailsMinAggregateOutputType | null
    _max: VerdictInterestDetailsMaxAggregateOutputType | null
  }

  export type VerdictInterestDetailsAvgAggregateOutputType = {
    days: number | null
    annualRate: number | null
    proportionalRate: number | null
    baseAmount: number | null
    interest: number | null
    total: number | null
  }

  export type VerdictInterestDetailsSumAggregateOutputType = {
    days: number | null
    annualRate: number | null
    proportionalRate: number | null
    baseAmount: number | null
    interest: number | null
    total: number | null
  }

  export type VerdictInterestDetailsMinAggregateOutputType = {
    id: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    days: number | null
    annualRate: number | null
    proportionalRate: number | null
    baseAmount: number | null
    interest: number | null
    total: number | null
    verdictInterestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictInterestDetailsMaxAggregateOutputType = {
    id: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    days: number | null
    annualRate: number | null
    proportionalRate: number | null
    baseAmount: number | null
    interest: number | null
    total: number | null
    verdictInterestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictInterestDetailsCountAggregateOutputType = {
    id: number
    period: number
    periodStart: number
    periodEnd: number
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    verdictInterestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerdictInterestDetailsAvgAggregateInputType = {
    days?: true
    annualRate?: true
    proportionalRate?: true
    baseAmount?: true
    interest?: true
    total?: true
  }

  export type VerdictInterestDetailsSumAggregateInputType = {
    days?: true
    annualRate?: true
    proportionalRate?: true
    baseAmount?: true
    interest?: true
    total?: true
  }

  export type VerdictInterestDetailsMinAggregateInputType = {
    id?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    days?: true
    annualRate?: true
    proportionalRate?: true
    baseAmount?: true
    interest?: true
    total?: true
    verdictInterestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictInterestDetailsMaxAggregateInputType = {
    id?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    days?: true
    annualRate?: true
    proportionalRate?: true
    baseAmount?: true
    interest?: true
    total?: true
    verdictInterestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictInterestDetailsCountAggregateInputType = {
    id?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    days?: true
    annualRate?: true
    proportionalRate?: true
    baseAmount?: true
    interest?: true
    total?: true
    verdictInterestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerdictInterestDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterestDetails to aggregate.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictInterestDetails
    **/
    _count?: true | VerdictInterestDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictInterestDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictInterestDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictInterestDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictInterestDetailsMaxAggregateInputType
  }

  export type GetVerdictInterestDetailsAggregateType<T extends VerdictInterestDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictInterestDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictInterestDetails[P]>
      : GetScalarType<T[P], AggregateVerdictInterestDetails[P]>
  }




  export type VerdictInterestDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestDetailsWhereInput
    orderBy?: VerdictInterestDetailsOrderByWithAggregationInput | VerdictInterestDetailsOrderByWithAggregationInput[]
    by: VerdictInterestDetailsScalarFieldEnum[] | VerdictInterestDetailsScalarFieldEnum
    having?: VerdictInterestDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictInterestDetailsCountAggregateInputType | true
    _avg?: VerdictInterestDetailsAvgAggregateInputType
    _sum?: VerdictInterestDetailsSumAggregateInputType
    _min?: VerdictInterestDetailsMinAggregateInputType
    _max?: VerdictInterestDetailsMaxAggregateInputType
  }

  export type VerdictInterestDetailsGroupByOutputType = {
    id: string
    period: string
    periodStart: Date
    periodEnd: Date
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    verdictInterestId: string
    createdAt: Date
    updatedAt: Date
    _count: VerdictInterestDetailsCountAggregateOutputType | null
    _avg: VerdictInterestDetailsAvgAggregateOutputType | null
    _sum: VerdictInterestDetailsSumAggregateOutputType | null
    _min: VerdictInterestDetailsMinAggregateOutputType | null
    _max: VerdictInterestDetailsMaxAggregateOutputType | null
  }

  type GetVerdictInterestDetailsGroupByPayload<T extends VerdictInterestDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictInterestDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictInterestDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictInterestDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictInterestDetailsGroupByOutputType[P]>
        }
      >
    >


  export type VerdictInterestDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    days?: boolean
    annualRate?: boolean
    proportionalRate?: boolean
    baseAmount?: boolean
    interest?: boolean
    total?: boolean
    verdictInterestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterestDetails"]>

  export type VerdictInterestDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    days?: boolean
    annualRate?: boolean
    proportionalRate?: boolean
    baseAmount?: boolean
    interest?: boolean
    total?: boolean
    verdictInterestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterestDetails"]>

  export type VerdictInterestDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    days?: boolean
    annualRate?: boolean
    proportionalRate?: boolean
    baseAmount?: boolean
    interest?: boolean
    total?: boolean
    verdictInterestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterestDetails"]>

  export type VerdictInterestDetailsSelectScalar = {
    id?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    days?: boolean
    annualRate?: boolean
    proportionalRate?: boolean
    baseAmount?: boolean
    interest?: boolean
    total?: boolean
    verdictInterestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerdictInterestDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "period" | "periodStart" | "periodEnd" | "days" | "annualRate" | "proportionalRate" | "baseAmount" | "interest" | "total" | "verdictInterestId" | "createdAt" | "updatedAt", ExtArgs["result"]["verdictInterestDetails"]>
  export type VerdictInterestDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }
  export type VerdictInterestDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }
  export type VerdictInterestDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }

  export type $VerdictInterestDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictInterestDetails"
    objects: {
      verdictInterest: Prisma.$VerdictInterestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      period: string
      periodStart: Date
      periodEnd: Date
      days: number
      annualRate: number
      proportionalRate: number
      baseAmount: number
      interest: number
      total: number
      verdictInterestId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verdictInterestDetails"]>
    composites: {}
  }

  type VerdictInterestDetailsGetPayload<S extends boolean | null | undefined | VerdictInterestDetailsDefaultArgs> = $Result.GetResult<Prisma.$VerdictInterestDetailsPayload, S>

  type VerdictInterestDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictInterestDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictInterestDetailsCountAggregateInputType | true
    }

  export interface VerdictInterestDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictInterestDetails'], meta: { name: 'VerdictInterestDetails' } }
    /**
     * Find zero or one VerdictInterestDetails that matches the filter.
     * @param {VerdictInterestDetailsFindUniqueArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictInterestDetailsFindUniqueArgs>(args: SelectSubset<T, VerdictInterestDetailsFindUniqueArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictInterestDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictInterestDetailsFindUniqueOrThrowArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictInterestDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictInterestDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterestDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsFindFirstArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictInterestDetailsFindFirstArgs>(args?: SelectSubset<T, VerdictInterestDetailsFindFirstArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterestDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsFindFirstOrThrowArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictInterestDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictInterestDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictInterestDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findMany()
     * 
     * // Get first 10 VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictInterestDetailsWithIdOnly = await prisma.verdictInterestDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictInterestDetailsFindManyArgs>(args?: SelectSubset<T, VerdictInterestDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictInterestDetails.
     * @param {VerdictInterestDetailsCreateArgs} args - Arguments to create a VerdictInterestDetails.
     * @example
     * // Create one VerdictInterestDetails
     * const VerdictInterestDetails = await prisma.verdictInterestDetails.create({
     *   data: {
     *     // ... data to create a VerdictInterestDetails
     *   }
     * })
     * 
     */
    create<T extends VerdictInterestDetailsCreateArgs>(args: SelectSubset<T, VerdictInterestDetailsCreateArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictInterestDetails.
     * @param {VerdictInterestDetailsCreateManyArgs} args - Arguments to create many VerdictInterestDetails.
     * @example
     * // Create many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictInterestDetailsCreateManyArgs>(args?: SelectSubset<T, VerdictInterestDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictInterestDetails and returns the data saved in the database.
     * @param {VerdictInterestDetailsCreateManyAndReturnArgs} args - Arguments to create many VerdictInterestDetails.
     * @example
     * // Create many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictInterestDetails and only return the `id`
     * const verdictInterestDetailsWithIdOnly = await prisma.verdictInterestDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictInterestDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictInterestDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictInterestDetails.
     * @param {VerdictInterestDetailsDeleteArgs} args - Arguments to delete one VerdictInterestDetails.
     * @example
     * // Delete one VerdictInterestDetails
     * const VerdictInterestDetails = await prisma.verdictInterestDetails.delete({
     *   where: {
     *     // ... filter to delete one VerdictInterestDetails
     *   }
     * })
     * 
     */
    delete<T extends VerdictInterestDetailsDeleteArgs>(args: SelectSubset<T, VerdictInterestDetailsDeleteArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictInterestDetails.
     * @param {VerdictInterestDetailsUpdateArgs} args - Arguments to update one VerdictInterestDetails.
     * @example
     * // Update one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictInterestDetailsUpdateArgs>(args: SelectSubset<T, VerdictInterestDetailsUpdateArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictInterestDetails.
     * @param {VerdictInterestDetailsDeleteManyArgs} args - Arguments to filter VerdictInterestDetails to delete.
     * @example
     * // Delete a few VerdictInterestDetails
     * const { count } = await prisma.verdictInterestDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictInterestDetailsDeleteManyArgs>(args?: SelectSubset<T, VerdictInterestDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictInterestDetailsUpdateManyArgs>(args: SelectSubset<T, VerdictInterestDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterestDetails and returns the data updated in the database.
     * @param {VerdictInterestDetailsUpdateManyAndReturnArgs} args - Arguments to update many VerdictInterestDetails.
     * @example
     * // Update many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictInterestDetails and only return the `id`
     * const verdictInterestDetailsWithIdOnly = await prisma.verdictInterestDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictInterestDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictInterestDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictInterestDetails.
     * @param {VerdictInterestDetailsUpsertArgs} args - Arguments to update or create a VerdictInterestDetails.
     * @example
     * // Update or create a VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.upsert({
     *   create: {
     *     // ... data to create a VerdictInterestDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictInterestDetails we want to update
     *   }
     * })
     */
    upsert<T extends VerdictInterestDetailsUpsertArgs>(args: SelectSubset<T, VerdictInterestDetailsUpsertArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsCountArgs} args - Arguments to filter VerdictInterestDetails to count.
     * @example
     * // Count the number of VerdictInterestDetails
     * const count = await prisma.verdictInterestDetails.count({
     *   where: {
     *     // ... the filter for the VerdictInterestDetails we want to count
     *   }
     * })
    **/
    count<T extends VerdictInterestDetailsCountArgs>(
      args?: Subset<T, VerdictInterestDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictInterestDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictInterestDetailsAggregateArgs>(args: Subset<T, VerdictInterestDetailsAggregateArgs>): Prisma.PrismaPromise<GetVerdictInterestDetailsAggregateType<T>>

    /**
     * Group by VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictInterestDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictInterestDetailsGroupByArgs['orderBy'] }
        : { orderBy?: VerdictInterestDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictInterestDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictInterestDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictInterestDetails model
   */
  readonly fields: VerdictInterestDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictInterestDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictInterestDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdictInterest<T extends VerdictInterestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictInterestDefaultArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictInterestDetails model
   */
  interface VerdictInterestDetailsFieldRefs {
    readonly id: FieldRef<"VerdictInterestDetails", 'String'>
    readonly period: FieldRef<"VerdictInterestDetails", 'String'>
    readonly periodStart: FieldRef<"VerdictInterestDetails", 'DateTime'>
    readonly periodEnd: FieldRef<"VerdictInterestDetails", 'DateTime'>
    readonly days: FieldRef<"VerdictInterestDetails", 'Int'>
    readonly annualRate: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly proportionalRate: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly baseAmount: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly interest: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly total: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly verdictInterestId: FieldRef<"VerdictInterestDetails", 'String'>
    readonly createdAt: FieldRef<"VerdictInterestDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"VerdictInterestDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerdictInterestDetails findUnique
   */
  export type VerdictInterestDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails findUniqueOrThrow
   */
  export type VerdictInterestDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails findFirst
   */
  export type VerdictInterestDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterestDetails.
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterestDetails.
     */
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterestDetails findFirstOrThrow
   */
  export type VerdictInterestDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterestDetails.
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterestDetails.
     */
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterestDetails findMany
   */
  export type VerdictInterestDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictInterestDetails.
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterestDetails create
   */
  export type VerdictInterestDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsCreateInput, VerdictInterestDetailsUncheckedCreateInput>
  }

  /**
   * VerdictInterestDetails createMany
   */
  export type VerdictInterestDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictInterestDetails.
     */
    data: VerdictInterestDetailsCreateManyInput | VerdictInterestDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictInterestDetails createManyAndReturn
   */
  export type VerdictInterestDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictInterestDetails.
     */
    data: VerdictInterestDetailsCreateManyInput | VerdictInterestDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterestDetails update
   */
  export type VerdictInterestDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsUpdateInput, VerdictInterestDetailsUncheckedUpdateInput>
    /**
     * Choose, which VerdictInterestDetails to update.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails updateMany
   */
  export type VerdictInterestDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsUpdateManyMutationInput, VerdictInterestDetailsUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterestDetails to update
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * Limit how many VerdictInterestDetails to update.
     */
    limit?: number
  }

  /**
   * VerdictInterestDetails updateManyAndReturn
   */
  export type VerdictInterestDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * The data used to update VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsUpdateManyMutationInput, VerdictInterestDetailsUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterestDetails to update
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * Limit how many VerdictInterestDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterestDetails upsert
   */
  export type VerdictInterestDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictInterestDetails to update in case it exists.
     */
    where: VerdictInterestDetailsWhereUniqueInput
    /**
     * In case the VerdictInterestDetails found by the `where` argument doesn't exist, create a new VerdictInterestDetails with this data.
     */
    create: XOR<VerdictInterestDetailsCreateInput, VerdictInterestDetailsUncheckedCreateInput>
    /**
     * In case the VerdictInterestDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictInterestDetailsUpdateInput, VerdictInterestDetailsUncheckedUpdateInput>
  }

  /**
   * VerdictInterestDetails delete
   */
  export type VerdictInterestDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter which VerdictInterestDetails to delete.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails deleteMany
   */
  export type VerdictInterestDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterestDetails to delete
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * Limit how many VerdictInterestDetails to delete.
     */
    limit?: number
  }

  /**
   * VerdictInterestDetails without action
   */
  export type VerdictInterestDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
  }


  /**
   * Model VerdictEmbargo
   */

  export type AggregateVerdictEmbargo = {
    _count: VerdictEmbargoCountAggregateOutputType | null
    _avg: VerdictEmbargoAvgAggregateOutputType | null
    _sum: VerdictEmbargoSumAggregateOutputType | null
    _min: VerdictEmbargoMinAggregateOutputType | null
    _max: VerdictEmbargoMaxAggregateOutputType | null
  }

  export type VerdictEmbargoAvgAggregateOutputType = {
    embargoAmount: number | null
    totalAmount: number | null
  }

  export type VerdictEmbargoSumAggregateOutputType = {
    embargoAmount: number | null
    totalAmount: number | null
  }

  export type VerdictEmbargoMinAggregateOutputType = {
    id: string | null
    verdictId: string | null
    companyName: string | null
    companyPhone: string | null
    companyEmail: string | null
    companyAddress: string | null
    embargoType: string | null
    embargoDate: Date | null
    embargoAmount: number | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictEmbargoMaxAggregateOutputType = {
    id: string | null
    verdictId: string | null
    companyName: string | null
    companyPhone: string | null
    companyEmail: string | null
    companyAddress: string | null
    embargoType: string | null
    embargoDate: Date | null
    embargoAmount: number | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictEmbargoCountAggregateOutputType = {
    id: number
    verdictId: number
    companyName: number
    companyPhone: number
    companyEmail: number
    companyAddress: number
    embargoType: number
    embargoDate: number
    embargoAmount: number
    totalAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerdictEmbargoAvgAggregateInputType = {
    embargoAmount?: true
    totalAmount?: true
  }

  export type VerdictEmbargoSumAggregateInputType = {
    embargoAmount?: true
    totalAmount?: true
  }

  export type VerdictEmbargoMinAggregateInputType = {
    id?: true
    verdictId?: true
    companyName?: true
    companyPhone?: true
    companyEmail?: true
    companyAddress?: true
    embargoType?: true
    embargoDate?: true
    embargoAmount?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictEmbargoMaxAggregateInputType = {
    id?: true
    verdictId?: true
    companyName?: true
    companyPhone?: true
    companyEmail?: true
    companyAddress?: true
    embargoType?: true
    embargoDate?: true
    embargoAmount?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictEmbargoCountAggregateInputType = {
    id?: true
    verdictId?: true
    companyName?: true
    companyPhone?: true
    companyEmail?: true
    companyAddress?: true
    embargoType?: true
    embargoDate?: true
    embargoAmount?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerdictEmbargoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictEmbargo to aggregate.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictEmbargos
    **/
    _count?: true | VerdictEmbargoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictEmbargoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictEmbargoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictEmbargoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictEmbargoMaxAggregateInputType
  }

  export type GetVerdictEmbargoAggregateType<T extends VerdictEmbargoAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictEmbargo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictEmbargo[P]>
      : GetScalarType<T[P], AggregateVerdictEmbargo[P]>
  }




  export type VerdictEmbargoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictEmbargoWhereInput
    orderBy?: VerdictEmbargoOrderByWithAggregationInput | VerdictEmbargoOrderByWithAggregationInput[]
    by: VerdictEmbargoScalarFieldEnum[] | VerdictEmbargoScalarFieldEnum
    having?: VerdictEmbargoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictEmbargoCountAggregateInputType | true
    _avg?: VerdictEmbargoAvgAggregateInputType
    _sum?: VerdictEmbargoSumAggregateInputType
    _min?: VerdictEmbargoMinAggregateInputType
    _max?: VerdictEmbargoMaxAggregateInputType
  }

  export type VerdictEmbargoGroupByOutputType = {
    id: string
    verdictId: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date
    embargoAmount: number
    totalAmount: number
    createdAt: Date
    updatedAt: Date
    _count: VerdictEmbargoCountAggregateOutputType | null
    _avg: VerdictEmbargoAvgAggregateOutputType | null
    _sum: VerdictEmbargoSumAggregateOutputType | null
    _min: VerdictEmbargoMinAggregateOutputType | null
    _max: VerdictEmbargoMaxAggregateOutputType | null
  }

  type GetVerdictEmbargoGroupByPayload<T extends VerdictEmbargoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictEmbargoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictEmbargoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictEmbargoGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictEmbargoGroupByOutputType[P]>
        }
      >
    >


  export type VerdictEmbargoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    companyName?: boolean
    companyPhone?: boolean
    companyEmail?: boolean
    companyAddress?: boolean
    embargoType?: boolean
    embargoDate?: boolean
    embargoAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictEmbargo"]>

  export type VerdictEmbargoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    companyName?: boolean
    companyPhone?: boolean
    companyEmail?: boolean
    companyAddress?: boolean
    embargoType?: boolean
    embargoDate?: boolean
    embargoAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictEmbargo"]>

  export type VerdictEmbargoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    companyName?: boolean
    companyPhone?: boolean
    companyEmail?: boolean
    companyAddress?: boolean
    embargoType?: boolean
    embargoDate?: boolean
    embargoAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictEmbargo"]>

  export type VerdictEmbargoSelectScalar = {
    id?: boolean
    verdictId?: boolean
    companyName?: boolean
    companyPhone?: boolean
    companyEmail?: boolean
    companyAddress?: boolean
    embargoType?: boolean
    embargoDate?: boolean
    embargoAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerdictEmbargoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "verdictId" | "companyName" | "companyPhone" | "companyEmail" | "companyAddress" | "embargoType" | "embargoDate" | "embargoAmount" | "totalAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["verdictEmbargo"]>
  export type VerdictEmbargoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictEmbargoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictEmbargoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }

  export type $VerdictEmbargoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictEmbargo"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      verdictId: string
      companyName: string
      companyPhone: string
      companyEmail: string
      companyAddress: string
      embargoType: string
      embargoDate: Date
      embargoAmount: number
      totalAmount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verdictEmbargo"]>
    composites: {}
  }

  type VerdictEmbargoGetPayload<S extends boolean | null | undefined | VerdictEmbargoDefaultArgs> = $Result.GetResult<Prisma.$VerdictEmbargoPayload, S>

  type VerdictEmbargoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictEmbargoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictEmbargoCountAggregateInputType | true
    }

  export interface VerdictEmbargoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictEmbargo'], meta: { name: 'VerdictEmbargo' } }
    /**
     * Find zero or one VerdictEmbargo that matches the filter.
     * @param {VerdictEmbargoFindUniqueArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictEmbargoFindUniqueArgs>(args: SelectSubset<T, VerdictEmbargoFindUniqueArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictEmbargo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictEmbargoFindUniqueOrThrowArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictEmbargoFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictEmbargoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictEmbargo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoFindFirstArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictEmbargoFindFirstArgs>(args?: SelectSubset<T, VerdictEmbargoFindFirstArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictEmbargo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoFindFirstOrThrowArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictEmbargoFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictEmbargoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictEmbargos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictEmbargos
     * const verdictEmbargos = await prisma.verdictEmbargo.findMany()
     * 
     * // Get first 10 VerdictEmbargos
     * const verdictEmbargos = await prisma.verdictEmbargo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictEmbargoWithIdOnly = await prisma.verdictEmbargo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictEmbargoFindManyArgs>(args?: SelectSubset<T, VerdictEmbargoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictEmbargo.
     * @param {VerdictEmbargoCreateArgs} args - Arguments to create a VerdictEmbargo.
     * @example
     * // Create one VerdictEmbargo
     * const VerdictEmbargo = await prisma.verdictEmbargo.create({
     *   data: {
     *     // ... data to create a VerdictEmbargo
     *   }
     * })
     * 
     */
    create<T extends VerdictEmbargoCreateArgs>(args: SelectSubset<T, VerdictEmbargoCreateArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictEmbargos.
     * @param {VerdictEmbargoCreateManyArgs} args - Arguments to create many VerdictEmbargos.
     * @example
     * // Create many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictEmbargoCreateManyArgs>(args?: SelectSubset<T, VerdictEmbargoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictEmbargos and returns the data saved in the database.
     * @param {VerdictEmbargoCreateManyAndReturnArgs} args - Arguments to create many VerdictEmbargos.
     * @example
     * // Create many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictEmbargos and only return the `id`
     * const verdictEmbargoWithIdOnly = await prisma.verdictEmbargo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictEmbargoCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictEmbargoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictEmbargo.
     * @param {VerdictEmbargoDeleteArgs} args - Arguments to delete one VerdictEmbargo.
     * @example
     * // Delete one VerdictEmbargo
     * const VerdictEmbargo = await prisma.verdictEmbargo.delete({
     *   where: {
     *     // ... filter to delete one VerdictEmbargo
     *   }
     * })
     * 
     */
    delete<T extends VerdictEmbargoDeleteArgs>(args: SelectSubset<T, VerdictEmbargoDeleteArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictEmbargo.
     * @param {VerdictEmbargoUpdateArgs} args - Arguments to update one VerdictEmbargo.
     * @example
     * // Update one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictEmbargoUpdateArgs>(args: SelectSubset<T, VerdictEmbargoUpdateArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictEmbargos.
     * @param {VerdictEmbargoDeleteManyArgs} args - Arguments to filter VerdictEmbargos to delete.
     * @example
     * // Delete a few VerdictEmbargos
     * const { count } = await prisma.verdictEmbargo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictEmbargoDeleteManyArgs>(args?: SelectSubset<T, VerdictEmbargoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictEmbargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictEmbargoUpdateManyArgs>(args: SelectSubset<T, VerdictEmbargoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictEmbargos and returns the data updated in the database.
     * @param {VerdictEmbargoUpdateManyAndReturnArgs} args - Arguments to update many VerdictEmbargos.
     * @example
     * // Update many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictEmbargos and only return the `id`
     * const verdictEmbargoWithIdOnly = await prisma.verdictEmbargo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictEmbargoUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictEmbargoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictEmbargo.
     * @param {VerdictEmbargoUpsertArgs} args - Arguments to update or create a VerdictEmbargo.
     * @example
     * // Update or create a VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.upsert({
     *   create: {
     *     // ... data to create a VerdictEmbargo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictEmbargo we want to update
     *   }
     * })
     */
    upsert<T extends VerdictEmbargoUpsertArgs>(args: SelectSubset<T, VerdictEmbargoUpsertArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictEmbargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoCountArgs} args - Arguments to filter VerdictEmbargos to count.
     * @example
     * // Count the number of VerdictEmbargos
     * const count = await prisma.verdictEmbargo.count({
     *   where: {
     *     // ... the filter for the VerdictEmbargos we want to count
     *   }
     * })
    **/
    count<T extends VerdictEmbargoCountArgs>(
      args?: Subset<T, VerdictEmbargoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictEmbargoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictEmbargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictEmbargoAggregateArgs>(args: Subset<T, VerdictEmbargoAggregateArgs>): Prisma.PrismaPromise<GetVerdictEmbargoAggregateType<T>>

    /**
     * Group by VerdictEmbargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictEmbargoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictEmbargoGroupByArgs['orderBy'] }
        : { orderBy?: VerdictEmbargoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictEmbargoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictEmbargoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictEmbargo model
   */
  readonly fields: VerdictEmbargoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictEmbargo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictEmbargoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictDefaultArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictEmbargo model
   */
  interface VerdictEmbargoFieldRefs {
    readonly id: FieldRef<"VerdictEmbargo", 'String'>
    readonly verdictId: FieldRef<"VerdictEmbargo", 'String'>
    readonly companyName: FieldRef<"VerdictEmbargo", 'String'>
    readonly companyPhone: FieldRef<"VerdictEmbargo", 'String'>
    readonly companyEmail: FieldRef<"VerdictEmbargo", 'String'>
    readonly companyAddress: FieldRef<"VerdictEmbargo", 'String'>
    readonly embargoType: FieldRef<"VerdictEmbargo", 'String'>
    readonly embargoDate: FieldRef<"VerdictEmbargo", 'DateTime'>
    readonly embargoAmount: FieldRef<"VerdictEmbargo", 'Float'>
    readonly totalAmount: FieldRef<"VerdictEmbargo", 'Float'>
    readonly createdAt: FieldRef<"VerdictEmbargo", 'DateTime'>
    readonly updatedAt: FieldRef<"VerdictEmbargo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerdictEmbargo findUnique
   */
  export type VerdictEmbargoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo findUniqueOrThrow
   */
  export type VerdictEmbargoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo findFirst
   */
  export type VerdictEmbargoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictEmbargos.
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictEmbargos.
     */
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * VerdictEmbargo findFirstOrThrow
   */
  export type VerdictEmbargoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictEmbargos.
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictEmbargos.
     */
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * VerdictEmbargo findMany
   */
  export type VerdictEmbargoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargos to fetch.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictEmbargos.
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * VerdictEmbargo create
   */
  export type VerdictEmbargoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictEmbargo.
     */
    data: XOR<VerdictEmbargoCreateInput, VerdictEmbargoUncheckedCreateInput>
  }

  /**
   * VerdictEmbargo createMany
   */
  export type VerdictEmbargoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictEmbargos.
     */
    data: VerdictEmbargoCreateManyInput | VerdictEmbargoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictEmbargo createManyAndReturn
   */
  export type VerdictEmbargoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictEmbargos.
     */
    data: VerdictEmbargoCreateManyInput | VerdictEmbargoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictEmbargo update
   */
  export type VerdictEmbargoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictEmbargo.
     */
    data: XOR<VerdictEmbargoUpdateInput, VerdictEmbargoUncheckedUpdateInput>
    /**
     * Choose, which VerdictEmbargo to update.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo updateMany
   */
  export type VerdictEmbargoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictEmbargos.
     */
    data: XOR<VerdictEmbargoUpdateManyMutationInput, VerdictEmbargoUncheckedUpdateManyInput>
    /**
     * Filter which VerdictEmbargos to update
     */
    where?: VerdictEmbargoWhereInput
    /**
     * Limit how many VerdictEmbargos to update.
     */
    limit?: number
  }

  /**
   * VerdictEmbargo updateManyAndReturn
   */
  export type VerdictEmbargoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * The data used to update VerdictEmbargos.
     */
    data: XOR<VerdictEmbargoUpdateManyMutationInput, VerdictEmbargoUncheckedUpdateManyInput>
    /**
     * Filter which VerdictEmbargos to update
     */
    where?: VerdictEmbargoWhereInput
    /**
     * Limit how many VerdictEmbargos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictEmbargo upsert
   */
  export type VerdictEmbargoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictEmbargo to update in case it exists.
     */
    where: VerdictEmbargoWhereUniqueInput
    /**
     * In case the VerdictEmbargo found by the `where` argument doesn't exist, create a new VerdictEmbargo with this data.
     */
    create: XOR<VerdictEmbargoCreateInput, VerdictEmbargoUncheckedCreateInput>
    /**
     * In case the VerdictEmbargo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictEmbargoUpdateInput, VerdictEmbargoUncheckedUpdateInput>
  }

  /**
   * VerdictEmbargo delete
   */
  export type VerdictEmbargoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter which VerdictEmbargo to delete.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo deleteMany
   */
  export type VerdictEmbargoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictEmbargos to delete
     */
    where?: VerdictEmbargoWhereInput
    /**
     * Limit how many VerdictEmbargos to delete.
     */
    limit?: number
  }

  /**
   * VerdictEmbargo without action
   */
  export type VerdictEmbargoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
  }


  /**
   * Model VerdictBailiffServices
   */

  export type AggregateVerdictBailiffServices = {
    _count: VerdictBailiffServicesCountAggregateOutputType | null
    _avg: VerdictBailiffServicesAvgAggregateOutputType | null
    _sum: VerdictBailiffServicesSumAggregateOutputType | null
    _min: VerdictBailiffServicesMinAggregateOutputType | null
    _max: VerdictBailiffServicesMaxAggregateOutputType | null
  }

  export type VerdictBailiffServicesAvgAggregateOutputType = {
    serviceCost: number | null
  }

  export type VerdictBailiffServicesSumAggregateOutputType = {
    serviceCost: number | null
  }

  export type VerdictBailiffServicesMinAggregateOutputType = {
    id: string | null
    verdictId: string | null
    serviceType: string | null
    serviceCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictBailiffServicesMaxAggregateOutputType = {
    id: string | null
    verdictId: string | null
    serviceType: string | null
    serviceCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictBailiffServicesCountAggregateOutputType = {
    id: number
    verdictId: number
    serviceType: number
    serviceCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerdictBailiffServicesAvgAggregateInputType = {
    serviceCost?: true
  }

  export type VerdictBailiffServicesSumAggregateInputType = {
    serviceCost?: true
  }

  export type VerdictBailiffServicesMinAggregateInputType = {
    id?: true
    verdictId?: true
    serviceType?: true
    serviceCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictBailiffServicesMaxAggregateInputType = {
    id?: true
    verdictId?: true
    serviceType?: true
    serviceCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictBailiffServicesCountAggregateInputType = {
    id?: true
    verdictId?: true
    serviceType?: true
    serviceCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerdictBailiffServicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictBailiffServices to aggregate.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictBailiffServices
    **/
    _count?: true | VerdictBailiffServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictBailiffServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictBailiffServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictBailiffServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictBailiffServicesMaxAggregateInputType
  }

  export type GetVerdictBailiffServicesAggregateType<T extends VerdictBailiffServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictBailiffServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictBailiffServices[P]>
      : GetScalarType<T[P], AggregateVerdictBailiffServices[P]>
  }




  export type VerdictBailiffServicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictBailiffServicesWhereInput
    orderBy?: VerdictBailiffServicesOrderByWithAggregationInput | VerdictBailiffServicesOrderByWithAggregationInput[]
    by: VerdictBailiffServicesScalarFieldEnum[] | VerdictBailiffServicesScalarFieldEnum
    having?: VerdictBailiffServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictBailiffServicesCountAggregateInputType | true
    _avg?: VerdictBailiffServicesAvgAggregateInputType
    _sum?: VerdictBailiffServicesSumAggregateInputType
    _min?: VerdictBailiffServicesMinAggregateInputType
    _max?: VerdictBailiffServicesMaxAggregateInputType
  }

  export type VerdictBailiffServicesGroupByOutputType = {
    id: string
    verdictId: string
    serviceType: string
    serviceCost: number
    createdAt: Date
    updatedAt: Date
    _count: VerdictBailiffServicesCountAggregateOutputType | null
    _avg: VerdictBailiffServicesAvgAggregateOutputType | null
    _sum: VerdictBailiffServicesSumAggregateOutputType | null
    _min: VerdictBailiffServicesMinAggregateOutputType | null
    _max: VerdictBailiffServicesMaxAggregateOutputType | null
  }

  type GetVerdictBailiffServicesGroupByPayload<T extends VerdictBailiffServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictBailiffServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictBailiffServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictBailiffServicesGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictBailiffServicesGroupByOutputType[P]>
        }
      >
    >


  export type VerdictBailiffServicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    serviceType?: boolean
    serviceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictBailiffServices"]>

  export type VerdictBailiffServicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    serviceType?: boolean
    serviceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictBailiffServices"]>

  export type VerdictBailiffServicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    serviceType?: boolean
    serviceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictBailiffServices"]>

  export type VerdictBailiffServicesSelectScalar = {
    id?: boolean
    verdictId?: boolean
    serviceType?: boolean
    serviceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerdictBailiffServicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "verdictId" | "serviceType" | "serviceCost" | "createdAt" | "updatedAt", ExtArgs["result"]["verdictBailiffServices"]>
  export type VerdictBailiffServicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictBailiffServicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictBailiffServicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }

  export type $VerdictBailiffServicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictBailiffServices"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      verdictId: string
      serviceType: string
      serviceCost: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verdictBailiffServices"]>
    composites: {}
  }

  type VerdictBailiffServicesGetPayload<S extends boolean | null | undefined | VerdictBailiffServicesDefaultArgs> = $Result.GetResult<Prisma.$VerdictBailiffServicesPayload, S>

  type VerdictBailiffServicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictBailiffServicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictBailiffServicesCountAggregateInputType | true
    }

  export interface VerdictBailiffServicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictBailiffServices'], meta: { name: 'VerdictBailiffServices' } }
    /**
     * Find zero or one VerdictBailiffServices that matches the filter.
     * @param {VerdictBailiffServicesFindUniqueArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictBailiffServicesFindUniqueArgs>(args: SelectSubset<T, VerdictBailiffServicesFindUniqueArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictBailiffServices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictBailiffServicesFindUniqueOrThrowArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictBailiffServicesFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictBailiffServicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictBailiffServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesFindFirstArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictBailiffServicesFindFirstArgs>(args?: SelectSubset<T, VerdictBailiffServicesFindFirstArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictBailiffServices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesFindFirstOrThrowArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictBailiffServicesFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictBailiffServicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictBailiffServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findMany()
     * 
     * // Get first 10 VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictBailiffServicesWithIdOnly = await prisma.verdictBailiffServices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictBailiffServicesFindManyArgs>(args?: SelectSubset<T, VerdictBailiffServicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictBailiffServices.
     * @param {VerdictBailiffServicesCreateArgs} args - Arguments to create a VerdictBailiffServices.
     * @example
     * // Create one VerdictBailiffServices
     * const VerdictBailiffServices = await prisma.verdictBailiffServices.create({
     *   data: {
     *     // ... data to create a VerdictBailiffServices
     *   }
     * })
     * 
     */
    create<T extends VerdictBailiffServicesCreateArgs>(args: SelectSubset<T, VerdictBailiffServicesCreateArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictBailiffServices.
     * @param {VerdictBailiffServicesCreateManyArgs} args - Arguments to create many VerdictBailiffServices.
     * @example
     * // Create many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictBailiffServicesCreateManyArgs>(args?: SelectSubset<T, VerdictBailiffServicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictBailiffServices and returns the data saved in the database.
     * @param {VerdictBailiffServicesCreateManyAndReturnArgs} args - Arguments to create many VerdictBailiffServices.
     * @example
     * // Create many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictBailiffServices and only return the `id`
     * const verdictBailiffServicesWithIdOnly = await prisma.verdictBailiffServices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictBailiffServicesCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictBailiffServicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictBailiffServices.
     * @param {VerdictBailiffServicesDeleteArgs} args - Arguments to delete one VerdictBailiffServices.
     * @example
     * // Delete one VerdictBailiffServices
     * const VerdictBailiffServices = await prisma.verdictBailiffServices.delete({
     *   where: {
     *     // ... filter to delete one VerdictBailiffServices
     *   }
     * })
     * 
     */
    delete<T extends VerdictBailiffServicesDeleteArgs>(args: SelectSubset<T, VerdictBailiffServicesDeleteArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictBailiffServices.
     * @param {VerdictBailiffServicesUpdateArgs} args - Arguments to update one VerdictBailiffServices.
     * @example
     * // Update one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictBailiffServicesUpdateArgs>(args: SelectSubset<T, VerdictBailiffServicesUpdateArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictBailiffServices.
     * @param {VerdictBailiffServicesDeleteManyArgs} args - Arguments to filter VerdictBailiffServices to delete.
     * @example
     * // Delete a few VerdictBailiffServices
     * const { count } = await prisma.verdictBailiffServices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictBailiffServicesDeleteManyArgs>(args?: SelectSubset<T, VerdictBailiffServicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictBailiffServicesUpdateManyArgs>(args: SelectSubset<T, VerdictBailiffServicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictBailiffServices and returns the data updated in the database.
     * @param {VerdictBailiffServicesUpdateManyAndReturnArgs} args - Arguments to update many VerdictBailiffServices.
     * @example
     * // Update many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictBailiffServices and only return the `id`
     * const verdictBailiffServicesWithIdOnly = await prisma.verdictBailiffServices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictBailiffServicesUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictBailiffServicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictBailiffServices.
     * @param {VerdictBailiffServicesUpsertArgs} args - Arguments to update or create a VerdictBailiffServices.
     * @example
     * // Update or create a VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.upsert({
     *   create: {
     *     // ... data to create a VerdictBailiffServices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictBailiffServices we want to update
     *   }
     * })
     */
    upsert<T extends VerdictBailiffServicesUpsertArgs>(args: SelectSubset<T, VerdictBailiffServicesUpsertArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesCountArgs} args - Arguments to filter VerdictBailiffServices to count.
     * @example
     * // Count the number of VerdictBailiffServices
     * const count = await prisma.verdictBailiffServices.count({
     *   where: {
     *     // ... the filter for the VerdictBailiffServices we want to count
     *   }
     * })
    **/
    count<T extends VerdictBailiffServicesCountArgs>(
      args?: Subset<T, VerdictBailiffServicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictBailiffServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictBailiffServicesAggregateArgs>(args: Subset<T, VerdictBailiffServicesAggregateArgs>): Prisma.PrismaPromise<GetVerdictBailiffServicesAggregateType<T>>

    /**
     * Group by VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictBailiffServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictBailiffServicesGroupByArgs['orderBy'] }
        : { orderBy?: VerdictBailiffServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictBailiffServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictBailiffServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictBailiffServices model
   */
  readonly fields: VerdictBailiffServicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictBailiffServices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictBailiffServicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictDefaultArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictBailiffServices model
   */
  interface VerdictBailiffServicesFieldRefs {
    readonly id: FieldRef<"VerdictBailiffServices", 'String'>
    readonly verdictId: FieldRef<"VerdictBailiffServices", 'String'>
    readonly serviceType: FieldRef<"VerdictBailiffServices", 'String'>
    readonly serviceCost: FieldRef<"VerdictBailiffServices", 'Float'>
    readonly createdAt: FieldRef<"VerdictBailiffServices", 'DateTime'>
    readonly updatedAt: FieldRef<"VerdictBailiffServices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerdictBailiffServices findUnique
   */
  export type VerdictBailiffServicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices findUniqueOrThrow
   */
  export type VerdictBailiffServicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices findFirst
   */
  export type VerdictBailiffServicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictBailiffServices.
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictBailiffServices.
     */
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * VerdictBailiffServices findFirstOrThrow
   */
  export type VerdictBailiffServicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictBailiffServices.
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictBailiffServices.
     */
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * VerdictBailiffServices findMany
   */
  export type VerdictBailiffServicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictBailiffServices.
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * VerdictBailiffServices create
   */
  export type VerdictBailiffServicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesCreateInput, VerdictBailiffServicesUncheckedCreateInput>
  }

  /**
   * VerdictBailiffServices createMany
   */
  export type VerdictBailiffServicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictBailiffServices.
     */
    data: VerdictBailiffServicesCreateManyInput | VerdictBailiffServicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictBailiffServices createManyAndReturn
   */
  export type VerdictBailiffServicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictBailiffServices.
     */
    data: VerdictBailiffServicesCreateManyInput | VerdictBailiffServicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictBailiffServices update
   */
  export type VerdictBailiffServicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesUpdateInput, VerdictBailiffServicesUncheckedUpdateInput>
    /**
     * Choose, which VerdictBailiffServices to update.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices updateMany
   */
  export type VerdictBailiffServicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesUpdateManyMutationInput, VerdictBailiffServicesUncheckedUpdateManyInput>
    /**
     * Filter which VerdictBailiffServices to update
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * Limit how many VerdictBailiffServices to update.
     */
    limit?: number
  }

  /**
   * VerdictBailiffServices updateManyAndReturn
   */
  export type VerdictBailiffServicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * The data used to update VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesUpdateManyMutationInput, VerdictBailiffServicesUncheckedUpdateManyInput>
    /**
     * Filter which VerdictBailiffServices to update
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * Limit how many VerdictBailiffServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictBailiffServices upsert
   */
  export type VerdictBailiffServicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictBailiffServices to update in case it exists.
     */
    where: VerdictBailiffServicesWhereUniqueInput
    /**
     * In case the VerdictBailiffServices found by the `where` argument doesn't exist, create a new VerdictBailiffServices with this data.
     */
    create: XOR<VerdictBailiffServicesCreateInput, VerdictBailiffServicesUncheckedCreateInput>
    /**
     * In case the VerdictBailiffServices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictBailiffServicesUpdateInput, VerdictBailiffServicesUncheckedUpdateInput>
  }

  /**
   * VerdictBailiffServices delete
   */
  export type VerdictBailiffServicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter which VerdictBailiffServices to delete.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices deleteMany
   */
  export type VerdictBailiffServicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictBailiffServices to delete
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * Limit how many VerdictBailiffServices to delete.
     */
    limit?: number
  }

  /**
   * VerdictBailiffServices without action
   */
  export type VerdictBailiffServicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
  }


  /**
   * Model VerdictAttachment
   */

  export type AggregateVerdictAttachment = {
    _count: VerdictAttachmentCountAggregateOutputType | null
    _avg: VerdictAttachmentAvgAggregateOutputType | null
    _sum: VerdictAttachmentSumAggregateOutputType | null
    _min: VerdictAttachmentMinAggregateOutputType | null
    _max: VerdictAttachmentMaxAggregateOutputType | null
  }

  export type VerdictAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type VerdictAttachmentSumAggregateOutputType = {
    fileSize: bigint | null
  }

  export type VerdictAttachmentMinAggregateOutputType = {
    id: string | null
    verdictId: string | null
    filePath: string | null
    fileSize: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    fileName: string | null
  }

  export type VerdictAttachmentMaxAggregateOutputType = {
    id: string | null
    verdictId: string | null
    filePath: string | null
    fileSize: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    fileName: string | null
  }

  export type VerdictAttachmentCountAggregateOutputType = {
    id: number
    verdictId: number
    filePath: number
    fileSize: number
    createdAt: number
    updatedAt: number
    fileName: number
    _all: number
  }


  export type VerdictAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type VerdictAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type VerdictAttachmentMinAggregateInputType = {
    id?: true
    verdictId?: true
    filePath?: true
    fileSize?: true
    createdAt?: true
    updatedAt?: true
    fileName?: true
  }

  export type VerdictAttachmentMaxAggregateInputType = {
    id?: true
    verdictId?: true
    filePath?: true
    fileSize?: true
    createdAt?: true
    updatedAt?: true
    fileName?: true
  }

  export type VerdictAttachmentCountAggregateInputType = {
    id?: true
    verdictId?: true
    filePath?: true
    fileSize?: true
    createdAt?: true
    updatedAt?: true
    fileName?: true
    _all?: true
  }

  export type VerdictAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictAttachment to aggregate.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictAttachments
    **/
    _count?: true | VerdictAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictAttachmentMaxAggregateInputType
  }

  export type GetVerdictAttachmentAggregateType<T extends VerdictAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictAttachment[P]>
      : GetScalarType<T[P], AggregateVerdictAttachment[P]>
  }




  export type VerdictAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictAttachmentWhereInput
    orderBy?: VerdictAttachmentOrderByWithAggregationInput | VerdictAttachmentOrderByWithAggregationInput[]
    by: VerdictAttachmentScalarFieldEnum[] | VerdictAttachmentScalarFieldEnum
    having?: VerdictAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictAttachmentCountAggregateInputType | true
    _avg?: VerdictAttachmentAvgAggregateInputType
    _sum?: VerdictAttachmentSumAggregateInputType
    _min?: VerdictAttachmentMinAggregateInputType
    _max?: VerdictAttachmentMaxAggregateInputType
  }

  export type VerdictAttachmentGroupByOutputType = {
    id: string
    verdictId: string
    filePath: string
    fileSize: bigint
    createdAt: Date
    updatedAt: Date
    fileName: string
    _count: VerdictAttachmentCountAggregateOutputType | null
    _avg: VerdictAttachmentAvgAggregateOutputType | null
    _sum: VerdictAttachmentSumAggregateOutputType | null
    _min: VerdictAttachmentMinAggregateOutputType | null
    _max: VerdictAttachmentMaxAggregateOutputType | null
  }

  type GetVerdictAttachmentGroupByPayload<T extends VerdictAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type VerdictAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    filePath?: boolean
    fileSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictAttachment"]>

  export type VerdictAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    filePath?: boolean
    fileSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictAttachment"]>

  export type VerdictAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    filePath?: boolean
    fileSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictAttachment"]>

  export type VerdictAttachmentSelectScalar = {
    id?: boolean
    verdictId?: boolean
    filePath?: boolean
    fileSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
  }

  export type VerdictAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "verdictId" | "filePath" | "fileSize" | "createdAt" | "updatedAt" | "fileName", ExtArgs["result"]["verdictAttachment"]>
  export type VerdictAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }

  export type $VerdictAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictAttachment"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      verdictId: string
      filePath: string
      fileSize: bigint
      createdAt: Date
      updatedAt: Date
      fileName: string
    }, ExtArgs["result"]["verdictAttachment"]>
    composites: {}
  }

  type VerdictAttachmentGetPayload<S extends boolean | null | undefined | VerdictAttachmentDefaultArgs> = $Result.GetResult<Prisma.$VerdictAttachmentPayload, S>

  type VerdictAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictAttachmentCountAggregateInputType | true
    }

  export interface VerdictAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictAttachment'], meta: { name: 'VerdictAttachment' } }
    /**
     * Find zero or one VerdictAttachment that matches the filter.
     * @param {VerdictAttachmentFindUniqueArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictAttachmentFindUniqueArgs>(args: SelectSubset<T, VerdictAttachmentFindUniqueArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictAttachmentFindUniqueOrThrowArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentFindFirstArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictAttachmentFindFirstArgs>(args?: SelectSubset<T, VerdictAttachmentFindFirstArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentFindFirstOrThrowArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictAttachments
     * const verdictAttachments = await prisma.verdictAttachment.findMany()
     * 
     * // Get first 10 VerdictAttachments
     * const verdictAttachments = await prisma.verdictAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictAttachmentWithIdOnly = await prisma.verdictAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictAttachmentFindManyArgs>(args?: SelectSubset<T, VerdictAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictAttachment.
     * @param {VerdictAttachmentCreateArgs} args - Arguments to create a VerdictAttachment.
     * @example
     * // Create one VerdictAttachment
     * const VerdictAttachment = await prisma.verdictAttachment.create({
     *   data: {
     *     // ... data to create a VerdictAttachment
     *   }
     * })
     * 
     */
    create<T extends VerdictAttachmentCreateArgs>(args: SelectSubset<T, VerdictAttachmentCreateArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictAttachments.
     * @param {VerdictAttachmentCreateManyArgs} args - Arguments to create many VerdictAttachments.
     * @example
     * // Create many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictAttachmentCreateManyArgs>(args?: SelectSubset<T, VerdictAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictAttachments and returns the data saved in the database.
     * @param {VerdictAttachmentCreateManyAndReturnArgs} args - Arguments to create many VerdictAttachments.
     * @example
     * // Create many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictAttachments and only return the `id`
     * const verdictAttachmentWithIdOnly = await prisma.verdictAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictAttachment.
     * @param {VerdictAttachmentDeleteArgs} args - Arguments to delete one VerdictAttachment.
     * @example
     * // Delete one VerdictAttachment
     * const VerdictAttachment = await prisma.verdictAttachment.delete({
     *   where: {
     *     // ... filter to delete one VerdictAttachment
     *   }
     * })
     * 
     */
    delete<T extends VerdictAttachmentDeleteArgs>(args: SelectSubset<T, VerdictAttachmentDeleteArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictAttachment.
     * @param {VerdictAttachmentUpdateArgs} args - Arguments to update one VerdictAttachment.
     * @example
     * // Update one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictAttachmentUpdateArgs>(args: SelectSubset<T, VerdictAttachmentUpdateArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictAttachments.
     * @param {VerdictAttachmentDeleteManyArgs} args - Arguments to filter VerdictAttachments to delete.
     * @example
     * // Delete a few VerdictAttachments
     * const { count } = await prisma.verdictAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictAttachmentDeleteManyArgs>(args?: SelectSubset<T, VerdictAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictAttachmentUpdateManyArgs>(args: SelectSubset<T, VerdictAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictAttachments and returns the data updated in the database.
     * @param {VerdictAttachmentUpdateManyAndReturnArgs} args - Arguments to update many VerdictAttachments.
     * @example
     * // Update many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictAttachments and only return the `id`
     * const verdictAttachmentWithIdOnly = await prisma.verdictAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictAttachment.
     * @param {VerdictAttachmentUpsertArgs} args - Arguments to update or create a VerdictAttachment.
     * @example
     * // Update or create a VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.upsert({
     *   create: {
     *     // ... data to create a VerdictAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictAttachment we want to update
     *   }
     * })
     */
    upsert<T extends VerdictAttachmentUpsertArgs>(args: SelectSubset<T, VerdictAttachmentUpsertArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentCountArgs} args - Arguments to filter VerdictAttachments to count.
     * @example
     * // Count the number of VerdictAttachments
     * const count = await prisma.verdictAttachment.count({
     *   where: {
     *     // ... the filter for the VerdictAttachments we want to count
     *   }
     * })
    **/
    count<T extends VerdictAttachmentCountArgs>(
      args?: Subset<T, VerdictAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictAttachmentAggregateArgs>(args: Subset<T, VerdictAttachmentAggregateArgs>): Prisma.PrismaPromise<GetVerdictAttachmentAggregateType<T>>

    /**
     * Group by VerdictAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: VerdictAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictAttachment model
   */
  readonly fields: VerdictAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictDefaultArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictAttachment model
   */
  interface VerdictAttachmentFieldRefs {
    readonly id: FieldRef<"VerdictAttachment", 'String'>
    readonly verdictId: FieldRef<"VerdictAttachment", 'String'>
    readonly filePath: FieldRef<"VerdictAttachment", 'String'>
    readonly fileSize: FieldRef<"VerdictAttachment", 'BigInt'>
    readonly createdAt: FieldRef<"VerdictAttachment", 'DateTime'>
    readonly updatedAt: FieldRef<"VerdictAttachment", 'DateTime'>
    readonly fileName: FieldRef<"VerdictAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VerdictAttachment findUnique
   */
  export type VerdictAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment findUniqueOrThrow
   */
  export type VerdictAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment findFirst
   */
  export type VerdictAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictAttachments.
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictAttachments.
     */
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * VerdictAttachment findFirstOrThrow
   */
  export type VerdictAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictAttachments.
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictAttachments.
     */
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * VerdictAttachment findMany
   */
  export type VerdictAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachments to fetch.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictAttachments.
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * VerdictAttachment create
   */
  export type VerdictAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictAttachment.
     */
    data: XOR<VerdictAttachmentCreateInput, VerdictAttachmentUncheckedCreateInput>
  }

  /**
   * VerdictAttachment createMany
   */
  export type VerdictAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictAttachments.
     */
    data: VerdictAttachmentCreateManyInput | VerdictAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictAttachment createManyAndReturn
   */
  export type VerdictAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictAttachments.
     */
    data: VerdictAttachmentCreateManyInput | VerdictAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictAttachment update
   */
  export type VerdictAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictAttachment.
     */
    data: XOR<VerdictAttachmentUpdateInput, VerdictAttachmentUncheckedUpdateInput>
    /**
     * Choose, which VerdictAttachment to update.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment updateMany
   */
  export type VerdictAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictAttachments.
     */
    data: XOR<VerdictAttachmentUpdateManyMutationInput, VerdictAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which VerdictAttachments to update
     */
    where?: VerdictAttachmentWhereInput
    /**
     * Limit how many VerdictAttachments to update.
     */
    limit?: number
  }

  /**
   * VerdictAttachment updateManyAndReturn
   */
  export type VerdictAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update VerdictAttachments.
     */
    data: XOR<VerdictAttachmentUpdateManyMutationInput, VerdictAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which VerdictAttachments to update
     */
    where?: VerdictAttachmentWhereInput
    /**
     * Limit how many VerdictAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictAttachment upsert
   */
  export type VerdictAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictAttachment to update in case it exists.
     */
    where: VerdictAttachmentWhereUniqueInput
    /**
     * In case the VerdictAttachment found by the `where` argument doesn't exist, create a new VerdictAttachment with this data.
     */
    create: XOR<VerdictAttachmentCreateInput, VerdictAttachmentUncheckedCreateInput>
    /**
     * In case the VerdictAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictAttachmentUpdateInput, VerdictAttachmentUncheckedUpdateInput>
  }

  /**
   * VerdictAttachment delete
   */
  export type VerdictAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter which VerdictAttachment to delete.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment deleteMany
   */
  export type VerdictAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictAttachments to delete
     */
    where?: VerdictAttachmentWhereInput
    /**
     * Limit how many VerdictAttachments to delete.
     */
    limit?: number
  }

  /**
   * VerdictAttachment without action
   */
  export type VerdictAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model InterestType
   */

  export type AggregateInterestType = {
    _count: InterestTypeCountAggregateOutputType | null
    _avg: InterestTypeAvgAggregateOutputType | null
    _sum: InterestTypeSumAggregateOutputType | null
    _min: InterestTypeMinAggregateOutputType | null
    _max: InterestTypeMaxAggregateOutputType | null
  }

  export type InterestTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type InterestTypeSumAggregateOutputType = {
    id: number | null
  }

  export type InterestTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    calculationType: $Enums.CalculationTypeEnum | null
  }

  export type InterestTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    calculationType: $Enums.CalculationTypeEnum | null
  }

  export type InterestTypeCountAggregateOutputType = {
    id: number
    name: number
    calculationType: number
    _all: number
  }


  export type InterestTypeAvgAggregateInputType = {
    id?: true
  }

  export type InterestTypeSumAggregateInputType = {
    id?: true
  }

  export type InterestTypeMinAggregateInputType = {
    id?: true
    name?: true
    calculationType?: true
  }

  export type InterestTypeMaxAggregateInputType = {
    id?: true
    name?: true
    calculationType?: true
  }

  export type InterestTypeCountAggregateInputType = {
    id?: true
    name?: true
    calculationType?: true
    _all?: true
  }

  export type InterestTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestType to aggregate.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterestTypes
    **/
    _count?: true | InterestTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterestTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterestTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestTypeMaxAggregateInputType
  }

  export type GetInterestTypeAggregateType<T extends InterestTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateInterestType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterestType[P]>
      : GetScalarType<T[P], AggregateInterestType[P]>
  }




  export type InterestTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestTypeWhereInput
    orderBy?: InterestTypeOrderByWithAggregationInput | InterestTypeOrderByWithAggregationInput[]
    by: InterestTypeScalarFieldEnum[] | InterestTypeScalarFieldEnum
    having?: InterestTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestTypeCountAggregateInputType | true
    _avg?: InterestTypeAvgAggregateInputType
    _sum?: InterestTypeSumAggregateInputType
    _min?: InterestTypeMinAggregateInputType
    _max?: InterestTypeMaxAggregateInputType
  }

  export type InterestTypeGroupByOutputType = {
    id: number
    name: string
    calculationType: $Enums.CalculationTypeEnum
    _count: InterestTypeCountAggregateOutputType | null
    _avg: InterestTypeAvgAggregateOutputType | null
    _sum: InterestTypeSumAggregateOutputType | null
    _min: InterestTypeMinAggregateOutputType | null
    _max: InterestTypeMaxAggregateOutputType | null
  }

  type GetInterestTypeGroupByPayload<T extends InterestTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestTypeGroupByOutputType[P]>
            : GetScalarType<T[P], InterestTypeGroupByOutputType[P]>
        }
      >
    >


  export type InterestTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calculationType?: boolean
    details?: boolean | InterestType$detailsArgs<ExtArgs>
    _count?: boolean | InterestTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestType"]>

  export type InterestTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calculationType?: boolean
  }, ExtArgs["result"]["interestType"]>

  export type InterestTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calculationType?: boolean
  }, ExtArgs["result"]["interestType"]>

  export type InterestTypeSelectScalar = {
    id?: boolean
    name?: boolean
    calculationType?: boolean
  }

  export type InterestTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "calculationType", ExtArgs["result"]["interestType"]>
  export type InterestTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | InterestType$detailsArgs<ExtArgs>
    _count?: boolean | InterestTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InterestTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InterestTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InterestTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterestType"
    objects: {
      details: Prisma.$InterestDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      calculationType: $Enums.CalculationTypeEnum
    }, ExtArgs["result"]["interestType"]>
    composites: {}
  }

  type InterestTypeGetPayload<S extends boolean | null | undefined | InterestTypeDefaultArgs> = $Result.GetResult<Prisma.$InterestTypePayload, S>

  type InterestTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterestTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterestTypeCountAggregateInputType | true
    }

  export interface InterestTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterestType'], meta: { name: 'InterestType' } }
    /**
     * Find zero or one InterestType that matches the filter.
     * @param {InterestTypeFindUniqueArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestTypeFindUniqueArgs>(args: SelectSubset<T, InterestTypeFindUniqueArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterestType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterestTypeFindUniqueOrThrowArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeFindFirstArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestTypeFindFirstArgs>(args?: SelectSubset<T, InterestTypeFindFirstArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeFindFirstOrThrowArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterestTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterestTypes
     * const interestTypes = await prisma.interestType.findMany()
     * 
     * // Get first 10 InterestTypes
     * const interestTypes = await prisma.interestType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestTypeWithIdOnly = await prisma.interestType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestTypeFindManyArgs>(args?: SelectSubset<T, InterestTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterestType.
     * @param {InterestTypeCreateArgs} args - Arguments to create a InterestType.
     * @example
     * // Create one InterestType
     * const InterestType = await prisma.interestType.create({
     *   data: {
     *     // ... data to create a InterestType
     *   }
     * })
     * 
     */
    create<T extends InterestTypeCreateArgs>(args: SelectSubset<T, InterestTypeCreateArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterestTypes.
     * @param {InterestTypeCreateManyArgs} args - Arguments to create many InterestTypes.
     * @example
     * // Create many InterestTypes
     * const interestType = await prisma.interestType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestTypeCreateManyArgs>(args?: SelectSubset<T, InterestTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterestTypes and returns the data saved in the database.
     * @param {InterestTypeCreateManyAndReturnArgs} args - Arguments to create many InterestTypes.
     * @example
     * // Create many InterestTypes
     * const interestType = await prisma.interestType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterestTypes and only return the `id`
     * const interestTypeWithIdOnly = await prisma.interestType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterestType.
     * @param {InterestTypeDeleteArgs} args - Arguments to delete one InterestType.
     * @example
     * // Delete one InterestType
     * const InterestType = await prisma.interestType.delete({
     *   where: {
     *     // ... filter to delete one InterestType
     *   }
     * })
     * 
     */
    delete<T extends InterestTypeDeleteArgs>(args: SelectSubset<T, InterestTypeDeleteArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterestType.
     * @param {InterestTypeUpdateArgs} args - Arguments to update one InterestType.
     * @example
     * // Update one InterestType
     * const interestType = await prisma.interestType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestTypeUpdateArgs>(args: SelectSubset<T, InterestTypeUpdateArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterestTypes.
     * @param {InterestTypeDeleteManyArgs} args - Arguments to filter InterestTypes to delete.
     * @example
     * // Delete a few InterestTypes
     * const { count } = await prisma.interestType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestTypeDeleteManyArgs>(args?: SelectSubset<T, InterestTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterestTypes
     * const interestType = await prisma.interestType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestTypeUpdateManyArgs>(args: SelectSubset<T, InterestTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestTypes and returns the data updated in the database.
     * @param {InterestTypeUpdateManyAndReturnArgs} args - Arguments to update many InterestTypes.
     * @example
     * // Update many InterestTypes
     * const interestType = await prisma.interestType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterestTypes and only return the `id`
     * const interestTypeWithIdOnly = await prisma.interestType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterestTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, InterestTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterestType.
     * @param {InterestTypeUpsertArgs} args - Arguments to update or create a InterestType.
     * @example
     * // Update or create a InterestType
     * const interestType = await prisma.interestType.upsert({
     *   create: {
     *     // ... data to create a InterestType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterestType we want to update
     *   }
     * })
     */
    upsert<T extends InterestTypeUpsertArgs>(args: SelectSubset<T, InterestTypeUpsertArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterestTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeCountArgs} args - Arguments to filter InterestTypes to count.
     * @example
     * // Count the number of InterestTypes
     * const count = await prisma.interestType.count({
     *   where: {
     *     // ... the filter for the InterestTypes we want to count
     *   }
     * })
    **/
    count<T extends InterestTypeCountArgs>(
      args?: Subset<T, InterestTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterestType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestTypeAggregateArgs>(args: Subset<T, InterestTypeAggregateArgs>): Prisma.PrismaPromise<GetInterestTypeAggregateType<T>>

    /**
     * Group by InterestType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestTypeGroupByArgs['orderBy'] }
        : { orderBy?: InterestTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterestType model
   */
  readonly fields: InterestTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterestType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    details<T extends InterestType$detailsArgs<ExtArgs> = {}>(args?: Subset<T, InterestType$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterestType model
   */
  interface InterestTypeFieldRefs {
    readonly id: FieldRef<"InterestType", 'Int'>
    readonly name: FieldRef<"InterestType", 'String'>
    readonly calculationType: FieldRef<"InterestType", 'CalculationTypeEnum'>
  }
    

  // Custom InputTypes
  /**
   * InterestType findUnique
   */
  export type InterestTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType findUniqueOrThrow
   */
  export type InterestTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType findFirst
   */
  export type InterestTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestTypes.
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestTypes.
     */
    distinct?: InterestTypeScalarFieldEnum | InterestTypeScalarFieldEnum[]
  }

  /**
   * InterestType findFirstOrThrow
   */
  export type InterestTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestTypes.
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestTypes.
     */
    distinct?: InterestTypeScalarFieldEnum | InterestTypeScalarFieldEnum[]
  }

  /**
   * InterestType findMany
   */
  export type InterestTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestTypes to fetch.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterestTypes.
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    distinct?: InterestTypeScalarFieldEnum | InterestTypeScalarFieldEnum[]
  }

  /**
   * InterestType create
   */
  export type InterestTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a InterestType.
     */
    data: XOR<InterestTypeCreateInput, InterestTypeUncheckedCreateInput>
  }

  /**
   * InterestType createMany
   */
  export type InterestTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterestTypes.
     */
    data: InterestTypeCreateManyInput | InterestTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterestType createManyAndReturn
   */
  export type InterestTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * The data used to create many InterestTypes.
     */
    data: InterestTypeCreateManyInput | InterestTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterestType update
   */
  export type InterestTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a InterestType.
     */
    data: XOR<InterestTypeUpdateInput, InterestTypeUncheckedUpdateInput>
    /**
     * Choose, which InterestType to update.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType updateMany
   */
  export type InterestTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterestTypes.
     */
    data: XOR<InterestTypeUpdateManyMutationInput, InterestTypeUncheckedUpdateManyInput>
    /**
     * Filter which InterestTypes to update
     */
    where?: InterestTypeWhereInput
    /**
     * Limit how many InterestTypes to update.
     */
    limit?: number
  }

  /**
   * InterestType updateManyAndReturn
   */
  export type InterestTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * The data used to update InterestTypes.
     */
    data: XOR<InterestTypeUpdateManyMutationInput, InterestTypeUncheckedUpdateManyInput>
    /**
     * Filter which InterestTypes to update
     */
    where?: InterestTypeWhereInput
    /**
     * Limit how many InterestTypes to update.
     */
    limit?: number
  }

  /**
   * InterestType upsert
   */
  export type InterestTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the InterestType to update in case it exists.
     */
    where: InterestTypeWhereUniqueInput
    /**
     * In case the InterestType found by the `where` argument doesn't exist, create a new InterestType with this data.
     */
    create: XOR<InterestTypeCreateInput, InterestTypeUncheckedCreateInput>
    /**
     * In case the InterestType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestTypeUpdateInput, InterestTypeUncheckedUpdateInput>
  }

  /**
   * InterestType delete
   */
  export type InterestTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter which InterestType to delete.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType deleteMany
   */
  export type InterestTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestTypes to delete
     */
    where?: InterestTypeWhereInput
    /**
     * Limit how many InterestTypes to delete.
     */
    limit?: number
  }

  /**
   * InterestType.details
   */
  export type InterestType$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    where?: InterestDetailWhereInput
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    cursor?: InterestDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestType without action
   */
  export type InterestTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
  }


  /**
   * Model InterestDetail
   */

  export type AggregateInterestDetail = {
    _count: InterestDetailCountAggregateOutputType | null
    _avg: InterestDetailAvgAggregateOutputType | null
    _sum: InterestDetailSumAggregateOutputType | null
    _min: InterestDetailMinAggregateOutputType | null
    _max: InterestDetailMaxAggregateOutputType | null
  }

  export type InterestDetailAvgAggregateOutputType = {
    id: number | null
    rate: number | null
    interestTypeId: number | null
  }

  export type InterestDetailSumAggregateOutputType = {
    id: number | null
    rate: number | null
    interestTypeId: number | null
  }

  export type InterestDetailMinAggregateOutputType = {
    id: number | null
    date: string | null
    rate: number | null
    interestTypeId: number | null
  }

  export type InterestDetailMaxAggregateOutputType = {
    id: number | null
    date: string | null
    rate: number | null
    interestTypeId: number | null
  }

  export type InterestDetailCountAggregateOutputType = {
    id: number
    date: number
    rate: number
    interestTypeId: number
    _all: number
  }


  export type InterestDetailAvgAggregateInputType = {
    id?: true
    rate?: true
    interestTypeId?: true
  }

  export type InterestDetailSumAggregateInputType = {
    id?: true
    rate?: true
    interestTypeId?: true
  }

  export type InterestDetailMinAggregateInputType = {
    id?: true
    date?: true
    rate?: true
    interestTypeId?: true
  }

  export type InterestDetailMaxAggregateInputType = {
    id?: true
    date?: true
    rate?: true
    interestTypeId?: true
  }

  export type InterestDetailCountAggregateInputType = {
    id?: true
    date?: true
    rate?: true
    interestTypeId?: true
    _all?: true
  }

  export type InterestDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestDetail to aggregate.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterestDetails
    **/
    _count?: true | InterestDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterestDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterestDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestDetailMaxAggregateInputType
  }

  export type GetInterestDetailAggregateType<T extends InterestDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateInterestDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterestDetail[P]>
      : GetScalarType<T[P], AggregateInterestDetail[P]>
  }




  export type InterestDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestDetailWhereInput
    orderBy?: InterestDetailOrderByWithAggregationInput | InterestDetailOrderByWithAggregationInput[]
    by: InterestDetailScalarFieldEnum[] | InterestDetailScalarFieldEnum
    having?: InterestDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestDetailCountAggregateInputType | true
    _avg?: InterestDetailAvgAggregateInputType
    _sum?: InterestDetailSumAggregateInputType
    _min?: InterestDetailMinAggregateInputType
    _max?: InterestDetailMaxAggregateInputType
  }

  export type InterestDetailGroupByOutputType = {
    id: number
    date: string
    rate: number
    interestTypeId: number
    _count: InterestDetailCountAggregateOutputType | null
    _avg: InterestDetailAvgAggregateOutputType | null
    _sum: InterestDetailSumAggregateOutputType | null
    _min: InterestDetailMinAggregateOutputType | null
    _max: InterestDetailMaxAggregateOutputType | null
  }

  type GetInterestDetailGroupByPayload<T extends InterestDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestDetailGroupByOutputType[P]>
            : GetScalarType<T[P], InterestDetailGroupByOutputType[P]>
        }
      >
    >


  export type InterestDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    rate?: boolean
    interestTypeId?: boolean
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestDetail"]>

  export type InterestDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    rate?: boolean
    interestTypeId?: boolean
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestDetail"]>

  export type InterestDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    rate?: boolean
    interestTypeId?: boolean
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestDetail"]>

  export type InterestDetailSelectScalar = {
    id?: boolean
    date?: boolean
    rate?: boolean
    interestTypeId?: boolean
  }

  export type InterestDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "rate" | "interestTypeId", ExtArgs["result"]["interestDetail"]>
  export type InterestDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }
  export type InterestDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }
  export type InterestDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }

  export type $InterestDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterestDetail"
    objects: {
      interestType: Prisma.$InterestTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: string
      rate: number
      interestTypeId: number
    }, ExtArgs["result"]["interestDetail"]>
    composites: {}
  }

  type InterestDetailGetPayload<S extends boolean | null | undefined | InterestDetailDefaultArgs> = $Result.GetResult<Prisma.$InterestDetailPayload, S>

  type InterestDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterestDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterestDetailCountAggregateInputType | true
    }

  export interface InterestDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterestDetail'], meta: { name: 'InterestDetail' } }
    /**
     * Find zero or one InterestDetail that matches the filter.
     * @param {InterestDetailFindUniqueArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestDetailFindUniqueArgs>(args: SelectSubset<T, InterestDetailFindUniqueArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterestDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterestDetailFindUniqueOrThrowArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailFindFirstArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestDetailFindFirstArgs>(args?: SelectSubset<T, InterestDetailFindFirstArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailFindFirstOrThrowArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterestDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterestDetails
     * const interestDetails = await prisma.interestDetail.findMany()
     * 
     * // Get first 10 InterestDetails
     * const interestDetails = await prisma.interestDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestDetailWithIdOnly = await prisma.interestDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestDetailFindManyArgs>(args?: SelectSubset<T, InterestDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterestDetail.
     * @param {InterestDetailCreateArgs} args - Arguments to create a InterestDetail.
     * @example
     * // Create one InterestDetail
     * const InterestDetail = await prisma.interestDetail.create({
     *   data: {
     *     // ... data to create a InterestDetail
     *   }
     * })
     * 
     */
    create<T extends InterestDetailCreateArgs>(args: SelectSubset<T, InterestDetailCreateArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterestDetails.
     * @param {InterestDetailCreateManyArgs} args - Arguments to create many InterestDetails.
     * @example
     * // Create many InterestDetails
     * const interestDetail = await prisma.interestDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestDetailCreateManyArgs>(args?: SelectSubset<T, InterestDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterestDetails and returns the data saved in the database.
     * @param {InterestDetailCreateManyAndReturnArgs} args - Arguments to create many InterestDetails.
     * @example
     * // Create many InterestDetails
     * const interestDetail = await prisma.interestDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterestDetails and only return the `id`
     * const interestDetailWithIdOnly = await prisma.interestDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterestDetail.
     * @param {InterestDetailDeleteArgs} args - Arguments to delete one InterestDetail.
     * @example
     * // Delete one InterestDetail
     * const InterestDetail = await prisma.interestDetail.delete({
     *   where: {
     *     // ... filter to delete one InterestDetail
     *   }
     * })
     * 
     */
    delete<T extends InterestDetailDeleteArgs>(args: SelectSubset<T, InterestDetailDeleteArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterestDetail.
     * @param {InterestDetailUpdateArgs} args - Arguments to update one InterestDetail.
     * @example
     * // Update one InterestDetail
     * const interestDetail = await prisma.interestDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestDetailUpdateArgs>(args: SelectSubset<T, InterestDetailUpdateArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterestDetails.
     * @param {InterestDetailDeleteManyArgs} args - Arguments to filter InterestDetails to delete.
     * @example
     * // Delete a few InterestDetails
     * const { count } = await prisma.interestDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestDetailDeleteManyArgs>(args?: SelectSubset<T, InterestDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterestDetails
     * const interestDetail = await prisma.interestDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestDetailUpdateManyArgs>(args: SelectSubset<T, InterestDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestDetails and returns the data updated in the database.
     * @param {InterestDetailUpdateManyAndReturnArgs} args - Arguments to update many InterestDetails.
     * @example
     * // Update many InterestDetails
     * const interestDetail = await prisma.interestDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterestDetails and only return the `id`
     * const interestDetailWithIdOnly = await prisma.interestDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterestDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, InterestDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterestDetail.
     * @param {InterestDetailUpsertArgs} args - Arguments to update or create a InterestDetail.
     * @example
     * // Update or create a InterestDetail
     * const interestDetail = await prisma.interestDetail.upsert({
     *   create: {
     *     // ... data to create a InterestDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterestDetail we want to update
     *   }
     * })
     */
    upsert<T extends InterestDetailUpsertArgs>(args: SelectSubset<T, InterestDetailUpsertArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailCountArgs} args - Arguments to filter InterestDetails to count.
     * @example
     * // Count the number of InterestDetails
     * const count = await prisma.interestDetail.count({
     *   where: {
     *     // ... the filter for the InterestDetails we want to count
     *   }
     * })
    **/
    count<T extends InterestDetailCountArgs>(
      args?: Subset<T, InterestDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterestDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestDetailAggregateArgs>(args: Subset<T, InterestDetailAggregateArgs>): Prisma.PrismaPromise<GetInterestDetailAggregateType<T>>

    /**
     * Group by InterestDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestDetailGroupByArgs['orderBy'] }
        : { orderBy?: InterestDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterestDetail model
   */
  readonly fields: InterestDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterestDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interestType<T extends InterestTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterestTypeDefaultArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterestDetail model
   */
  interface InterestDetailFieldRefs {
    readonly id: FieldRef<"InterestDetail", 'Int'>
    readonly date: FieldRef<"InterestDetail", 'String'>
    readonly rate: FieldRef<"InterestDetail", 'Float'>
    readonly interestTypeId: FieldRef<"InterestDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InterestDetail findUnique
   */
  export type InterestDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail findUniqueOrThrow
   */
  export type InterestDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail findFirst
   */
  export type InterestDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestDetails.
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestDetails.
     */
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestDetail findFirstOrThrow
   */
  export type InterestDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestDetails.
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestDetails.
     */
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestDetail findMany
   */
  export type InterestDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetails to fetch.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterestDetails.
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestDetail create
   */
  export type InterestDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a InterestDetail.
     */
    data: XOR<InterestDetailCreateInput, InterestDetailUncheckedCreateInput>
  }

  /**
   * InterestDetail createMany
   */
  export type InterestDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterestDetails.
     */
    data: InterestDetailCreateManyInput | InterestDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterestDetail createManyAndReturn
   */
  export type InterestDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * The data used to create many InterestDetails.
     */
    data: InterestDetailCreateManyInput | InterestDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterestDetail update
   */
  export type InterestDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a InterestDetail.
     */
    data: XOR<InterestDetailUpdateInput, InterestDetailUncheckedUpdateInput>
    /**
     * Choose, which InterestDetail to update.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail updateMany
   */
  export type InterestDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterestDetails.
     */
    data: XOR<InterestDetailUpdateManyMutationInput, InterestDetailUncheckedUpdateManyInput>
    /**
     * Filter which InterestDetails to update
     */
    where?: InterestDetailWhereInput
    /**
     * Limit how many InterestDetails to update.
     */
    limit?: number
  }

  /**
   * InterestDetail updateManyAndReturn
   */
  export type InterestDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * The data used to update InterestDetails.
     */
    data: XOR<InterestDetailUpdateManyMutationInput, InterestDetailUncheckedUpdateManyInput>
    /**
     * Filter which InterestDetails to update
     */
    where?: InterestDetailWhereInput
    /**
     * Limit how many InterestDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterestDetail upsert
   */
  export type InterestDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the InterestDetail to update in case it exists.
     */
    where: InterestDetailWhereUniqueInput
    /**
     * In case the InterestDetail found by the `where` argument doesn't exist, create a new InterestDetail with this data.
     */
    create: XOR<InterestDetailCreateInput, InterestDetailUncheckedCreateInput>
    /**
     * In case the InterestDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestDetailUpdateInput, InterestDetailUncheckedUpdateInput>
  }

  /**
   * InterestDetail delete
   */
  export type InterestDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter which InterestDetail to delete.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail deleteMany
   */
  export type InterestDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestDetails to delete
     */
    where?: InterestDetailWhereInput
    /**
     * Limit how many InterestDetails to delete.
     */
    limit?: number
  }

  /**
   * InterestDetail without action
   */
  export type InterestDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
  }


  /**
   * Model BillingInvoice
   */

  export type AggregateBillingInvoice = {
    _count: BillingInvoiceCountAggregateOutputType | null
    _avg: BillingInvoiceAvgAggregateOutputType | null
    _sum: BillingInvoiceSumAggregateOutputType | null
    _min: BillingInvoiceMinAggregateOutputType | null
    _max: BillingInvoiceMaxAggregateOutputType | null
  }

  export type BillingInvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillingInvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type BillingInvoiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceNumber: string | null
    amount: number | null
    currency: string | null
    issueDate: Date | null
    dueDate: Date | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingInvoiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceNumber: string | null
    amount: number | null
    currency: string | null
    issueDate: Date | null
    dueDate: Date | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingInvoiceCountAggregateOutputType = {
    id: number
    tenantId: number
    invoiceNumber: number
    amount: number
    currency: number
    issueDate: number
    dueDate: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillingInvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type BillingInvoiceSumAggregateInputType = {
    amount?: true
  }

  export type BillingInvoiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    issueDate?: true
    dueDate?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingInvoiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    issueDate?: true
    dueDate?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingInvoiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    issueDate?: true
    dueDate?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillingInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoice to aggregate.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingInvoices
    **/
    _count?: true | BillingInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingInvoiceMaxAggregateInputType
  }

  export type GetBillingInvoiceAggregateType<T extends BillingInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingInvoice[P]>
      : GetScalarType<T[P], AggregateBillingInvoice[P]>
  }




  export type BillingInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceWhereInput
    orderBy?: BillingInvoiceOrderByWithAggregationInput | BillingInvoiceOrderByWithAggregationInput[]
    by: BillingInvoiceScalarFieldEnum[] | BillingInvoiceScalarFieldEnum
    having?: BillingInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingInvoiceCountAggregateInputType | true
    _avg?: BillingInvoiceAvgAggregateInputType
    _sum?: BillingInvoiceSumAggregateInputType
    _min?: BillingInvoiceMinAggregateInputType
    _max?: BillingInvoiceMaxAggregateInputType
  }

  export type BillingInvoiceGroupByOutputType = {
    id: string
    tenantId: string
    invoiceNumber: string
    amount: number
    currency: string
    issueDate: Date
    dueDate: Date
    description: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: BillingInvoiceCountAggregateOutputType | null
    _avg: BillingInvoiceAvgAggregateOutputType | null
    _sum: BillingInvoiceSumAggregateOutputType | null
    _min: BillingInvoiceMinAggregateOutputType | null
    _max: BillingInvoiceMaxAggregateOutputType | null
  }

  type GetBillingInvoiceGroupByPayload<T extends BillingInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], BillingInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type BillingInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    issueDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    details?: boolean | BillingInvoice$detailsArgs<ExtArgs>
    payments?: boolean | BillingInvoice$paymentsArgs<ExtArgs>
    subscription?: boolean | BillingInvoice$subscriptionArgs<ExtArgs>
    _count?: boolean | BillingInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoice"]>

  export type BillingInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    issueDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoice"]>

  export type BillingInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    issueDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoice"]>

  export type BillingInvoiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    issueDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillingInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "invoiceNumber" | "amount" | "currency" | "issueDate" | "dueDate" | "description" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["billingInvoice"]>
  export type BillingInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    details?: boolean | BillingInvoice$detailsArgs<ExtArgs>
    payments?: boolean | BillingInvoice$paymentsArgs<ExtArgs>
    subscription?: boolean | BillingInvoice$subscriptionArgs<ExtArgs>
    _count?: boolean | BillingInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillingInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type BillingInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $BillingInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingInvoice"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      details: Prisma.$BillingInvoiceDetailPayload<ExtArgs>[]
      payments: Prisma.$BillingPaymentPayload<ExtArgs>[]
      subscription: Prisma.$BillingSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      invoiceNumber: string
      amount: number
      currency: string
      issueDate: Date
      dueDate: Date
      description: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billingInvoice"]>
    composites: {}
  }

  type BillingInvoiceGetPayload<S extends boolean | null | undefined | BillingInvoiceDefaultArgs> = $Result.GetResult<Prisma.$BillingInvoicePayload, S>

  type BillingInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingInvoiceCountAggregateInputType | true
    }

  export interface BillingInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingInvoice'], meta: { name: 'BillingInvoice' } }
    /**
     * Find zero or one BillingInvoice that matches the filter.
     * @param {BillingInvoiceFindUniqueArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingInvoiceFindUniqueArgs>(args: SelectSubset<T, BillingInvoiceFindUniqueArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingInvoiceFindUniqueOrThrowArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceFindFirstArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingInvoiceFindFirstArgs>(args?: SelectSubset<T, BillingInvoiceFindFirstArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceFindFirstOrThrowArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingInvoices
     * const billingInvoices = await prisma.billingInvoice.findMany()
     * 
     * // Get first 10 BillingInvoices
     * const billingInvoices = await prisma.billingInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingInvoiceWithIdOnly = await prisma.billingInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingInvoiceFindManyArgs>(args?: SelectSubset<T, BillingInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingInvoice.
     * @param {BillingInvoiceCreateArgs} args - Arguments to create a BillingInvoice.
     * @example
     * // Create one BillingInvoice
     * const BillingInvoice = await prisma.billingInvoice.create({
     *   data: {
     *     // ... data to create a BillingInvoice
     *   }
     * })
     * 
     */
    create<T extends BillingInvoiceCreateArgs>(args: SelectSubset<T, BillingInvoiceCreateArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingInvoices.
     * @param {BillingInvoiceCreateManyArgs} args - Arguments to create many BillingInvoices.
     * @example
     * // Create many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingInvoiceCreateManyArgs>(args?: SelectSubset<T, BillingInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingInvoices and returns the data saved in the database.
     * @param {BillingInvoiceCreateManyAndReturnArgs} args - Arguments to create many BillingInvoices.
     * @example
     * // Create many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingInvoices and only return the `id`
     * const billingInvoiceWithIdOnly = await prisma.billingInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingInvoice.
     * @param {BillingInvoiceDeleteArgs} args - Arguments to delete one BillingInvoice.
     * @example
     * // Delete one BillingInvoice
     * const BillingInvoice = await prisma.billingInvoice.delete({
     *   where: {
     *     // ... filter to delete one BillingInvoice
     *   }
     * })
     * 
     */
    delete<T extends BillingInvoiceDeleteArgs>(args: SelectSubset<T, BillingInvoiceDeleteArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingInvoice.
     * @param {BillingInvoiceUpdateArgs} args - Arguments to update one BillingInvoice.
     * @example
     * // Update one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingInvoiceUpdateArgs>(args: SelectSubset<T, BillingInvoiceUpdateArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingInvoices.
     * @param {BillingInvoiceDeleteManyArgs} args - Arguments to filter BillingInvoices to delete.
     * @example
     * // Delete a few BillingInvoices
     * const { count } = await prisma.billingInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingInvoiceDeleteManyArgs>(args?: SelectSubset<T, BillingInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingInvoiceUpdateManyArgs>(args: SelectSubset<T, BillingInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoices and returns the data updated in the database.
     * @param {BillingInvoiceUpdateManyAndReturnArgs} args - Arguments to update many BillingInvoices.
     * @example
     * // Update many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingInvoices and only return the `id`
     * const billingInvoiceWithIdOnly = await prisma.billingInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingInvoice.
     * @param {BillingInvoiceUpsertArgs} args - Arguments to update or create a BillingInvoice.
     * @example
     * // Update or create a BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.upsert({
     *   create: {
     *     // ... data to create a BillingInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingInvoice we want to update
     *   }
     * })
     */
    upsert<T extends BillingInvoiceUpsertArgs>(args: SelectSubset<T, BillingInvoiceUpsertArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceCountArgs} args - Arguments to filter BillingInvoices to count.
     * @example
     * // Count the number of BillingInvoices
     * const count = await prisma.billingInvoice.count({
     *   where: {
     *     // ... the filter for the BillingInvoices we want to count
     *   }
     * })
    **/
    count<T extends BillingInvoiceCountArgs>(
      args?: Subset<T, BillingInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingInvoiceAggregateArgs>(args: Subset<T, BillingInvoiceAggregateArgs>): Prisma.PrismaPromise<GetBillingInvoiceAggregateType<T>>

    /**
     * Group by BillingInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: BillingInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingInvoice model
   */
  readonly fields: BillingInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    details<T extends BillingInvoice$detailsArgs<ExtArgs> = {}>(args?: Subset<T, BillingInvoice$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends BillingInvoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, BillingInvoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends BillingInvoice$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, BillingInvoice$subscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingInvoice model
   */
  interface BillingInvoiceFieldRefs {
    readonly id: FieldRef<"BillingInvoice", 'String'>
    readonly tenantId: FieldRef<"BillingInvoice", 'String'>
    readonly invoiceNumber: FieldRef<"BillingInvoice", 'String'>
    readonly amount: FieldRef<"BillingInvoice", 'Float'>
    readonly currency: FieldRef<"BillingInvoice", 'String'>
    readonly issueDate: FieldRef<"BillingInvoice", 'DateTime'>
    readonly dueDate: FieldRef<"BillingInvoice", 'DateTime'>
    readonly description: FieldRef<"BillingInvoice", 'String'>
    readonly status: FieldRef<"BillingInvoice", 'String'>
    readonly createdAt: FieldRef<"BillingInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingInvoice findUnique
   */
  export type BillingInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice findUniqueOrThrow
   */
  export type BillingInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice findFirst
   */
  export type BillingInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoices.
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoices.
     */
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * BillingInvoice findFirstOrThrow
   */
  export type BillingInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoices.
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoices.
     */
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * BillingInvoice findMany
   */
  export type BillingInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoices to fetch.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingInvoices.
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * BillingInvoice create
   */
  export type BillingInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingInvoice.
     */
    data: XOR<BillingInvoiceCreateInput, BillingInvoiceUncheckedCreateInput>
  }

  /**
   * BillingInvoice createMany
   */
  export type BillingInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingInvoices.
     */
    data: BillingInvoiceCreateManyInput | BillingInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingInvoice createManyAndReturn
   */
  export type BillingInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many BillingInvoices.
     */
    data: BillingInvoiceCreateManyInput | BillingInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoice update
   */
  export type BillingInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingInvoice.
     */
    data: XOR<BillingInvoiceUpdateInput, BillingInvoiceUncheckedUpdateInput>
    /**
     * Choose, which BillingInvoice to update.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice updateMany
   */
  export type BillingInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingInvoices.
     */
    data: XOR<BillingInvoiceUpdateManyMutationInput, BillingInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoices to update
     */
    where?: BillingInvoiceWhereInput
    /**
     * Limit how many BillingInvoices to update.
     */
    limit?: number
  }

  /**
   * BillingInvoice updateManyAndReturn
   */
  export type BillingInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update BillingInvoices.
     */
    data: XOR<BillingInvoiceUpdateManyMutationInput, BillingInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoices to update
     */
    where?: BillingInvoiceWhereInput
    /**
     * Limit how many BillingInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoice upsert
   */
  export type BillingInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingInvoice to update in case it exists.
     */
    where: BillingInvoiceWhereUniqueInput
    /**
     * In case the BillingInvoice found by the `where` argument doesn't exist, create a new BillingInvoice with this data.
     */
    create: XOR<BillingInvoiceCreateInput, BillingInvoiceUncheckedCreateInput>
    /**
     * In case the BillingInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingInvoiceUpdateInput, BillingInvoiceUncheckedUpdateInput>
  }

  /**
   * BillingInvoice delete
   */
  export type BillingInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter which BillingInvoice to delete.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice deleteMany
   */
  export type BillingInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoices to delete
     */
    where?: BillingInvoiceWhereInput
    /**
     * Limit how many BillingInvoices to delete.
     */
    limit?: number
  }

  /**
   * BillingInvoice.details
   */
  export type BillingInvoice$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    where?: BillingInvoiceDetailWhereInput
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    cursor?: BillingInvoiceDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoice.payments
   */
  export type BillingInvoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    where?: BillingPaymentWhereInput
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    cursor?: BillingPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingInvoice.subscription
   */
  export type BillingInvoice$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    where?: BillingSubscriptionWhereInput
    orderBy?: BillingSubscriptionOrderByWithRelationInput | BillingSubscriptionOrderByWithRelationInput[]
    cursor?: BillingSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingSubscriptionScalarFieldEnum | BillingSubscriptionScalarFieldEnum[]
  }

  /**
   * BillingInvoice without action
   */
  export type BillingInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model BillingInvoiceDetail
   */

  export type AggregateBillingInvoiceDetail = {
    _count: BillingInvoiceDetailCountAggregateOutputType | null
    _avg: BillingInvoiceDetailAvgAggregateOutputType | null
    _sum: BillingInvoiceDetailSumAggregateOutputType | null
    _min: BillingInvoiceDetailMinAggregateOutputType | null
    _max: BillingInvoiceDetailMaxAggregateOutputType | null
  }

  export type BillingInvoiceDetailAvgAggregateOutputType = {
    itemQuantity: number | null
    itemUnitPrice: number | null
    itemTotalPrice: number | null
    itemTaxRate: number | null
    itemTaxAmount: number | null
    itemTotalWithTax: number | null
  }

  export type BillingInvoiceDetailSumAggregateOutputType = {
    itemQuantity: number | null
    itemUnitPrice: number | null
    itemTotalPrice: number | null
    itemTaxRate: number | null
    itemTaxAmount: number | null
    itemTotalWithTax: number | null
  }

  export type BillingInvoiceDetailMinAggregateOutputType = {
    id: string | null
    itemDescription: string | null
    itemQuantity: number | null
    itemUnitPrice: number | null
    itemTotalPrice: number | null
    itemTaxRate: number | null
    itemTaxAmount: number | null
    itemTotalWithTax: number | null
    createdAt: Date | null
    updatedAt: Date | null
    billingInvoiceId: string | null
  }

  export type BillingInvoiceDetailMaxAggregateOutputType = {
    id: string | null
    itemDescription: string | null
    itemQuantity: number | null
    itemUnitPrice: number | null
    itemTotalPrice: number | null
    itemTaxRate: number | null
    itemTaxAmount: number | null
    itemTotalWithTax: number | null
    createdAt: Date | null
    updatedAt: Date | null
    billingInvoiceId: string | null
  }

  export type BillingInvoiceDetailCountAggregateOutputType = {
    id: number
    itemDescription: number
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt: number
    updatedAt: number
    billingInvoiceId: number
    _all: number
  }


  export type BillingInvoiceDetailAvgAggregateInputType = {
    itemQuantity?: true
    itemUnitPrice?: true
    itemTotalPrice?: true
    itemTaxRate?: true
    itemTaxAmount?: true
    itemTotalWithTax?: true
  }

  export type BillingInvoiceDetailSumAggregateInputType = {
    itemQuantity?: true
    itemUnitPrice?: true
    itemTotalPrice?: true
    itemTaxRate?: true
    itemTaxAmount?: true
    itemTotalWithTax?: true
  }

  export type BillingInvoiceDetailMinAggregateInputType = {
    id?: true
    itemDescription?: true
    itemQuantity?: true
    itemUnitPrice?: true
    itemTotalPrice?: true
    itemTaxRate?: true
    itemTaxAmount?: true
    itemTotalWithTax?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
  }

  export type BillingInvoiceDetailMaxAggregateInputType = {
    id?: true
    itemDescription?: true
    itemQuantity?: true
    itemUnitPrice?: true
    itemTotalPrice?: true
    itemTaxRate?: true
    itemTaxAmount?: true
    itemTotalWithTax?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
  }

  export type BillingInvoiceDetailCountAggregateInputType = {
    id?: true
    itemDescription?: true
    itemQuantity?: true
    itemUnitPrice?: true
    itemTotalPrice?: true
    itemTaxRate?: true
    itemTaxAmount?: true
    itemTotalWithTax?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
    _all?: true
  }

  export type BillingInvoiceDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoiceDetail to aggregate.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingInvoiceDetails
    **/
    _count?: true | BillingInvoiceDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingInvoiceDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingInvoiceDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingInvoiceDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingInvoiceDetailMaxAggregateInputType
  }

  export type GetBillingInvoiceDetailAggregateType<T extends BillingInvoiceDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingInvoiceDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingInvoiceDetail[P]>
      : GetScalarType<T[P], AggregateBillingInvoiceDetail[P]>
  }




  export type BillingInvoiceDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceDetailWhereInput
    orderBy?: BillingInvoiceDetailOrderByWithAggregationInput | BillingInvoiceDetailOrderByWithAggregationInput[]
    by: BillingInvoiceDetailScalarFieldEnum[] | BillingInvoiceDetailScalarFieldEnum
    having?: BillingInvoiceDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingInvoiceDetailCountAggregateInputType | true
    _avg?: BillingInvoiceDetailAvgAggregateInputType
    _sum?: BillingInvoiceDetailSumAggregateInputType
    _min?: BillingInvoiceDetailMinAggregateInputType
    _max?: BillingInvoiceDetailMaxAggregateInputType
  }

  export type BillingInvoiceDetailGroupByOutputType = {
    id: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt: Date
    updatedAt: Date
    billingInvoiceId: string | null
    _count: BillingInvoiceDetailCountAggregateOutputType | null
    _avg: BillingInvoiceDetailAvgAggregateOutputType | null
    _sum: BillingInvoiceDetailSumAggregateOutputType | null
    _min: BillingInvoiceDetailMinAggregateOutputType | null
    _max: BillingInvoiceDetailMaxAggregateOutputType | null
  }

  type GetBillingInvoiceDetailGroupByPayload<T extends BillingInvoiceDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingInvoiceDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingInvoiceDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingInvoiceDetailGroupByOutputType[P]>
            : GetScalarType<T[P], BillingInvoiceDetailGroupByOutputType[P]>
        }
      >
    >


  export type BillingInvoiceDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemDescription?: boolean
    itemQuantity?: boolean
    itemUnitPrice?: boolean
    itemTotalPrice?: boolean
    itemTaxRate?: boolean
    itemTaxAmount?: boolean
    itemTotalWithTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoiceDetail"]>

  export type BillingInvoiceDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemDescription?: boolean
    itemQuantity?: boolean
    itemUnitPrice?: boolean
    itemTotalPrice?: boolean
    itemTaxRate?: boolean
    itemTaxAmount?: boolean
    itemTotalWithTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoiceDetail"]>

  export type BillingInvoiceDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemDescription?: boolean
    itemQuantity?: boolean
    itemUnitPrice?: boolean
    itemTotalPrice?: boolean
    itemTaxRate?: boolean
    itemTaxAmount?: boolean
    itemTotalWithTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoiceDetail"]>

  export type BillingInvoiceDetailSelectScalar = {
    id?: boolean
    itemDescription?: boolean
    itemQuantity?: boolean
    itemUnitPrice?: boolean
    itemTotalPrice?: boolean
    itemTaxRate?: boolean
    itemTaxAmount?: boolean
    itemTotalWithTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
  }

  export type BillingInvoiceDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemDescription" | "itemQuantity" | "itemUnitPrice" | "itemTotalPrice" | "itemTaxRate" | "itemTaxAmount" | "itemTotalWithTax" | "createdAt" | "updatedAt" | "billingInvoiceId", ExtArgs["result"]["billingInvoiceDetail"]>
  export type BillingInvoiceDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }
  export type BillingInvoiceDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }
  export type BillingInvoiceDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }

  export type $BillingInvoiceDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingInvoiceDetail"
    objects: {
      billingInvoice: Prisma.$BillingInvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemDescription: string
      itemQuantity: number
      itemUnitPrice: number
      itemTotalPrice: number
      itemTaxRate: number
      itemTaxAmount: number
      itemTotalWithTax: number
      createdAt: Date
      updatedAt: Date
      billingInvoiceId: string | null
    }, ExtArgs["result"]["billingInvoiceDetail"]>
    composites: {}
  }

  type BillingInvoiceDetailGetPayload<S extends boolean | null | undefined | BillingInvoiceDetailDefaultArgs> = $Result.GetResult<Prisma.$BillingInvoiceDetailPayload, S>

  type BillingInvoiceDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingInvoiceDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingInvoiceDetailCountAggregateInputType | true
    }

  export interface BillingInvoiceDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingInvoiceDetail'], meta: { name: 'BillingInvoiceDetail' } }
    /**
     * Find zero or one BillingInvoiceDetail that matches the filter.
     * @param {BillingInvoiceDetailFindUniqueArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingInvoiceDetailFindUniqueArgs>(args: SelectSubset<T, BillingInvoiceDetailFindUniqueArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingInvoiceDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingInvoiceDetailFindUniqueOrThrowArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingInvoiceDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingInvoiceDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoiceDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailFindFirstArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingInvoiceDetailFindFirstArgs>(args?: SelectSubset<T, BillingInvoiceDetailFindFirstArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoiceDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailFindFirstOrThrowArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingInvoiceDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingInvoiceDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingInvoiceDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingInvoiceDetails
     * const billingInvoiceDetails = await prisma.billingInvoiceDetail.findMany()
     * 
     * // Get first 10 BillingInvoiceDetails
     * const billingInvoiceDetails = await prisma.billingInvoiceDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingInvoiceDetailWithIdOnly = await prisma.billingInvoiceDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingInvoiceDetailFindManyArgs>(args?: SelectSubset<T, BillingInvoiceDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingInvoiceDetail.
     * @param {BillingInvoiceDetailCreateArgs} args - Arguments to create a BillingInvoiceDetail.
     * @example
     * // Create one BillingInvoiceDetail
     * const BillingInvoiceDetail = await prisma.billingInvoiceDetail.create({
     *   data: {
     *     // ... data to create a BillingInvoiceDetail
     *   }
     * })
     * 
     */
    create<T extends BillingInvoiceDetailCreateArgs>(args: SelectSubset<T, BillingInvoiceDetailCreateArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingInvoiceDetails.
     * @param {BillingInvoiceDetailCreateManyArgs} args - Arguments to create many BillingInvoiceDetails.
     * @example
     * // Create many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingInvoiceDetailCreateManyArgs>(args?: SelectSubset<T, BillingInvoiceDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingInvoiceDetails and returns the data saved in the database.
     * @param {BillingInvoiceDetailCreateManyAndReturnArgs} args - Arguments to create many BillingInvoiceDetails.
     * @example
     * // Create many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingInvoiceDetails and only return the `id`
     * const billingInvoiceDetailWithIdOnly = await prisma.billingInvoiceDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingInvoiceDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingInvoiceDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingInvoiceDetail.
     * @param {BillingInvoiceDetailDeleteArgs} args - Arguments to delete one BillingInvoiceDetail.
     * @example
     * // Delete one BillingInvoiceDetail
     * const BillingInvoiceDetail = await prisma.billingInvoiceDetail.delete({
     *   where: {
     *     // ... filter to delete one BillingInvoiceDetail
     *   }
     * })
     * 
     */
    delete<T extends BillingInvoiceDetailDeleteArgs>(args: SelectSubset<T, BillingInvoiceDetailDeleteArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingInvoiceDetail.
     * @param {BillingInvoiceDetailUpdateArgs} args - Arguments to update one BillingInvoiceDetail.
     * @example
     * // Update one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingInvoiceDetailUpdateArgs>(args: SelectSubset<T, BillingInvoiceDetailUpdateArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingInvoiceDetails.
     * @param {BillingInvoiceDetailDeleteManyArgs} args - Arguments to filter BillingInvoiceDetails to delete.
     * @example
     * // Delete a few BillingInvoiceDetails
     * const { count } = await prisma.billingInvoiceDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingInvoiceDetailDeleteManyArgs>(args?: SelectSubset<T, BillingInvoiceDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoiceDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingInvoiceDetailUpdateManyArgs>(args: SelectSubset<T, BillingInvoiceDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoiceDetails and returns the data updated in the database.
     * @param {BillingInvoiceDetailUpdateManyAndReturnArgs} args - Arguments to update many BillingInvoiceDetails.
     * @example
     * // Update many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingInvoiceDetails and only return the `id`
     * const billingInvoiceDetailWithIdOnly = await prisma.billingInvoiceDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingInvoiceDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingInvoiceDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingInvoiceDetail.
     * @param {BillingInvoiceDetailUpsertArgs} args - Arguments to update or create a BillingInvoiceDetail.
     * @example
     * // Update or create a BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.upsert({
     *   create: {
     *     // ... data to create a BillingInvoiceDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingInvoiceDetail we want to update
     *   }
     * })
     */
    upsert<T extends BillingInvoiceDetailUpsertArgs>(args: SelectSubset<T, BillingInvoiceDetailUpsertArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingInvoiceDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailCountArgs} args - Arguments to filter BillingInvoiceDetails to count.
     * @example
     * // Count the number of BillingInvoiceDetails
     * const count = await prisma.billingInvoiceDetail.count({
     *   where: {
     *     // ... the filter for the BillingInvoiceDetails we want to count
     *   }
     * })
    **/
    count<T extends BillingInvoiceDetailCountArgs>(
      args?: Subset<T, BillingInvoiceDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingInvoiceDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingInvoiceDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingInvoiceDetailAggregateArgs>(args: Subset<T, BillingInvoiceDetailAggregateArgs>): Prisma.PrismaPromise<GetBillingInvoiceDetailAggregateType<T>>

    /**
     * Group by BillingInvoiceDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingInvoiceDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingInvoiceDetailGroupByArgs['orderBy'] }
        : { orderBy?: BillingInvoiceDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingInvoiceDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingInvoiceDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingInvoiceDetail model
   */
  readonly fields: BillingInvoiceDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingInvoiceDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingInvoiceDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billingInvoice<T extends BillingInvoiceDetail$billingInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingInvoiceDetail model
   */
  interface BillingInvoiceDetailFieldRefs {
    readonly id: FieldRef<"BillingInvoiceDetail", 'String'>
    readonly itemDescription: FieldRef<"BillingInvoiceDetail", 'String'>
    readonly itemQuantity: FieldRef<"BillingInvoiceDetail", 'Int'>
    readonly itemUnitPrice: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly itemTotalPrice: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly itemTaxRate: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly itemTaxAmount: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly itemTotalWithTax: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly createdAt: FieldRef<"BillingInvoiceDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingInvoiceDetail", 'DateTime'>
    readonly billingInvoiceId: FieldRef<"BillingInvoiceDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BillingInvoiceDetail findUnique
   */
  export type BillingInvoiceDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail findUniqueOrThrow
   */
  export type BillingInvoiceDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail findFirst
   */
  export type BillingInvoiceDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoiceDetails.
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoiceDetails.
     */
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoiceDetail findFirstOrThrow
   */
  export type BillingInvoiceDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoiceDetails.
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoiceDetails.
     */
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoiceDetail findMany
   */
  export type BillingInvoiceDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetails to fetch.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingInvoiceDetails.
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoiceDetail create
   */
  export type BillingInvoiceDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingInvoiceDetail.
     */
    data: XOR<BillingInvoiceDetailCreateInput, BillingInvoiceDetailUncheckedCreateInput>
  }

  /**
   * BillingInvoiceDetail createMany
   */
  export type BillingInvoiceDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingInvoiceDetails.
     */
    data: BillingInvoiceDetailCreateManyInput | BillingInvoiceDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingInvoiceDetail createManyAndReturn
   */
  export type BillingInvoiceDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * The data used to create many BillingInvoiceDetails.
     */
    data: BillingInvoiceDetailCreateManyInput | BillingInvoiceDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoiceDetail update
   */
  export type BillingInvoiceDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingInvoiceDetail.
     */
    data: XOR<BillingInvoiceDetailUpdateInput, BillingInvoiceDetailUncheckedUpdateInput>
    /**
     * Choose, which BillingInvoiceDetail to update.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail updateMany
   */
  export type BillingInvoiceDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingInvoiceDetails.
     */
    data: XOR<BillingInvoiceDetailUpdateManyMutationInput, BillingInvoiceDetailUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoiceDetails to update
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * Limit how many BillingInvoiceDetails to update.
     */
    limit?: number
  }

  /**
   * BillingInvoiceDetail updateManyAndReturn
   */
  export type BillingInvoiceDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * The data used to update BillingInvoiceDetails.
     */
    data: XOR<BillingInvoiceDetailUpdateManyMutationInput, BillingInvoiceDetailUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoiceDetails to update
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * Limit how many BillingInvoiceDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoiceDetail upsert
   */
  export type BillingInvoiceDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingInvoiceDetail to update in case it exists.
     */
    where: BillingInvoiceDetailWhereUniqueInput
    /**
     * In case the BillingInvoiceDetail found by the `where` argument doesn't exist, create a new BillingInvoiceDetail with this data.
     */
    create: XOR<BillingInvoiceDetailCreateInput, BillingInvoiceDetailUncheckedCreateInput>
    /**
     * In case the BillingInvoiceDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingInvoiceDetailUpdateInput, BillingInvoiceDetailUncheckedUpdateInput>
  }

  /**
   * BillingInvoiceDetail delete
   */
  export type BillingInvoiceDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter which BillingInvoiceDetail to delete.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail deleteMany
   */
  export type BillingInvoiceDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoiceDetails to delete
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * Limit how many BillingInvoiceDetails to delete.
     */
    limit?: number
  }

  /**
   * BillingInvoiceDetail.billingInvoice
   */
  export type BillingInvoiceDetail$billingInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    where?: BillingInvoiceWhereInput
  }

  /**
   * BillingInvoiceDetail without action
   */
  export type BillingInvoiceDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
  }


  /**
   * Model BillingPlan
   */

  export type AggregateBillingPlan = {
    _count: BillingPlanCountAggregateOutputType | null
    _avg: BillingPlanAvgAggregateOutputType | null
    _sum: BillingPlanSumAggregateOutputType | null
    _min: BillingPlanMinAggregateOutputType | null
    _max: BillingPlanMaxAggregateOutputType | null
  }

  export type BillingPlanAvgAggregateOutputType = {
    price: number | null
  }

  export type BillingPlanSumAggregateOutputType = {
    price: number | null
  }

  export type BillingPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    currency: string | null
    billingCycle: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    currency: string | null
    billingCycle: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingPlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    currency: number
    billingCycle: number
    features: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillingPlanAvgAggregateInputType = {
    price?: true
  }

  export type BillingPlanSumAggregateInputType = {
    price?: true
  }

  export type BillingPlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    billingCycle?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingPlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    billingCycle?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingPlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    billingCycle?: true
    features?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillingPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPlan to aggregate.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingPlans
    **/
    _count?: true | BillingPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingPlanMaxAggregateInputType
  }

  export type GetBillingPlanAggregateType<T extends BillingPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingPlan[P]>
      : GetScalarType<T[P], AggregateBillingPlan[P]>
  }




  export type BillingPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingPlanWhereInput
    orderBy?: BillingPlanOrderByWithAggregationInput | BillingPlanOrderByWithAggregationInput[]
    by: BillingPlanScalarFieldEnum[] | BillingPlanScalarFieldEnum
    having?: BillingPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingPlanCountAggregateInputType | true
    _avg?: BillingPlanAvgAggregateInputType
    _sum?: BillingPlanSumAggregateInputType
    _min?: BillingPlanMinAggregateInputType
    _max?: BillingPlanMaxAggregateInputType
  }

  export type BillingPlanGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    currency: string
    billingCycle: string
    features: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BillingPlanCountAggregateOutputType | null
    _avg: BillingPlanAvgAggregateOutputType | null
    _sum: BillingPlanSumAggregateOutputType | null
    _min: BillingPlanMinAggregateOutputType | null
    _max: BillingPlanMaxAggregateOutputType | null
  }

  type GetBillingPlanGroupByPayload<T extends BillingPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingPlanGroupByOutputType[P]>
            : GetScalarType<T[P], BillingPlanGroupByOutputType[P]>
        }
      >
    >


  export type BillingPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    billingCycle?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscriptions?: boolean | BillingPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | BillingPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingPlan"]>

  export type BillingPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    billingCycle?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingPlan"]>

  export type BillingPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    billingCycle?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billingPlan"]>

  export type BillingPlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    billingCycle?: boolean
    features?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillingPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "currency" | "billingCycle" | "features" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["billingPlan"]>
  export type BillingPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | BillingPlan$subscriptionsArgs<ExtArgs>
    _count?: boolean | BillingPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillingPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BillingPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BillingPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingPlan"
    objects: {
      subscriptions: Prisma.$BillingSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number
      currency: string
      billingCycle: string
      features: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billingPlan"]>
    composites: {}
  }

  type BillingPlanGetPayload<S extends boolean | null | undefined | BillingPlanDefaultArgs> = $Result.GetResult<Prisma.$BillingPlanPayload, S>

  type BillingPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingPlanCountAggregateInputType | true
    }

  export interface BillingPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingPlan'], meta: { name: 'BillingPlan' } }
    /**
     * Find zero or one BillingPlan that matches the filter.
     * @param {BillingPlanFindUniqueArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingPlanFindUniqueArgs>(args: SelectSubset<T, BillingPlanFindUniqueArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingPlanFindUniqueOrThrowArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanFindFirstArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingPlanFindFirstArgs>(args?: SelectSubset<T, BillingPlanFindFirstArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanFindFirstOrThrowArgs} args - Arguments to find a BillingPlan
     * @example
     * // Get one BillingPlan
     * const billingPlan = await prisma.billingPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingPlans
     * const billingPlans = await prisma.billingPlan.findMany()
     * 
     * // Get first 10 BillingPlans
     * const billingPlans = await prisma.billingPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingPlanWithIdOnly = await prisma.billingPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingPlanFindManyArgs>(args?: SelectSubset<T, BillingPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingPlan.
     * @param {BillingPlanCreateArgs} args - Arguments to create a BillingPlan.
     * @example
     * // Create one BillingPlan
     * const BillingPlan = await prisma.billingPlan.create({
     *   data: {
     *     // ... data to create a BillingPlan
     *   }
     * })
     * 
     */
    create<T extends BillingPlanCreateArgs>(args: SelectSubset<T, BillingPlanCreateArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingPlans.
     * @param {BillingPlanCreateManyArgs} args - Arguments to create many BillingPlans.
     * @example
     * // Create many BillingPlans
     * const billingPlan = await prisma.billingPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingPlanCreateManyArgs>(args?: SelectSubset<T, BillingPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingPlans and returns the data saved in the database.
     * @param {BillingPlanCreateManyAndReturnArgs} args - Arguments to create many BillingPlans.
     * @example
     * // Create many BillingPlans
     * const billingPlan = await prisma.billingPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingPlans and only return the `id`
     * const billingPlanWithIdOnly = await prisma.billingPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingPlan.
     * @param {BillingPlanDeleteArgs} args - Arguments to delete one BillingPlan.
     * @example
     * // Delete one BillingPlan
     * const BillingPlan = await prisma.billingPlan.delete({
     *   where: {
     *     // ... filter to delete one BillingPlan
     *   }
     * })
     * 
     */
    delete<T extends BillingPlanDeleteArgs>(args: SelectSubset<T, BillingPlanDeleteArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingPlan.
     * @param {BillingPlanUpdateArgs} args - Arguments to update one BillingPlan.
     * @example
     * // Update one BillingPlan
     * const billingPlan = await prisma.billingPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingPlanUpdateArgs>(args: SelectSubset<T, BillingPlanUpdateArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingPlans.
     * @param {BillingPlanDeleteManyArgs} args - Arguments to filter BillingPlans to delete.
     * @example
     * // Delete a few BillingPlans
     * const { count } = await prisma.billingPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingPlanDeleteManyArgs>(args?: SelectSubset<T, BillingPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingPlans
     * const billingPlan = await prisma.billingPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingPlanUpdateManyArgs>(args: SelectSubset<T, BillingPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingPlans and returns the data updated in the database.
     * @param {BillingPlanUpdateManyAndReturnArgs} args - Arguments to update many BillingPlans.
     * @example
     * // Update many BillingPlans
     * const billingPlan = await prisma.billingPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingPlans and only return the `id`
     * const billingPlanWithIdOnly = await prisma.billingPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingPlan.
     * @param {BillingPlanUpsertArgs} args - Arguments to update or create a BillingPlan.
     * @example
     * // Update or create a BillingPlan
     * const billingPlan = await prisma.billingPlan.upsert({
     *   create: {
     *     // ... data to create a BillingPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingPlan we want to update
     *   }
     * })
     */
    upsert<T extends BillingPlanUpsertArgs>(args: SelectSubset<T, BillingPlanUpsertArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanCountArgs} args - Arguments to filter BillingPlans to count.
     * @example
     * // Count the number of BillingPlans
     * const count = await prisma.billingPlan.count({
     *   where: {
     *     // ... the filter for the BillingPlans we want to count
     *   }
     * })
    **/
    count<T extends BillingPlanCountArgs>(
      args?: Subset<T, BillingPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingPlanAggregateArgs>(args: Subset<T, BillingPlanAggregateArgs>): Prisma.PrismaPromise<GetBillingPlanAggregateType<T>>

    /**
     * Group by BillingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingPlanGroupByArgs['orderBy'] }
        : { orderBy?: BillingPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingPlan model
   */
  readonly fields: BillingPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends BillingPlan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, BillingPlan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingPlan model
   */
  interface BillingPlanFieldRefs {
    readonly id: FieldRef<"BillingPlan", 'String'>
    readonly name: FieldRef<"BillingPlan", 'String'>
    readonly description: FieldRef<"BillingPlan", 'String'>
    readonly price: FieldRef<"BillingPlan", 'Float'>
    readonly currency: FieldRef<"BillingPlan", 'String'>
    readonly billingCycle: FieldRef<"BillingPlan", 'String'>
    readonly features: FieldRef<"BillingPlan", 'Json'>
    readonly isActive: FieldRef<"BillingPlan", 'Boolean'>
    readonly createdAt: FieldRef<"BillingPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingPlan findUnique
   */
  export type BillingPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPlanInclude<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan findUniqueOrThrow
   */
  export type BillingPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPlanInclude<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan findFirst
   */
  export type BillingPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPlanInclude<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPlans.
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPlans.
     */
    distinct?: BillingPlanScalarFieldEnum | BillingPlanScalarFieldEnum[]
  }

  /**
   * BillingPlan findFirstOrThrow
   */
  export type BillingPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPlanInclude<ExtArgs> | null
    /**
     * Filter, which BillingPlan to fetch.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPlans.
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPlans.
     */
    distinct?: BillingPlanScalarFieldEnum | BillingPlanScalarFieldEnum[]
  }

  /**
   * BillingPlan findMany
   */
  export type BillingPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPlanInclude<ExtArgs> | null
    /**
     * Filter, which BillingPlans to fetch.
     */
    where?: BillingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPlans to fetch.
     */
    orderBy?: BillingPlanOrderByWithRelationInput | BillingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingPlans.
     */
    cursor?: BillingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPlans.
     */
    skip?: number
    distinct?: BillingPlanScalarFieldEnum | BillingPlanScalarFieldEnum[]
  }

  /**
   * BillingPlan create
   */
  export type BillingPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingPlan.
     */
    data: XOR<BillingPlanCreateInput, BillingPlanUncheckedCreateInput>
  }

  /**
   * BillingPlan createMany
   */
  export type BillingPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingPlans.
     */
    data: BillingPlanCreateManyInput | BillingPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingPlan createManyAndReturn
   */
  export type BillingPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * The data used to create many BillingPlans.
     */
    data: BillingPlanCreateManyInput | BillingPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingPlan update
   */
  export type BillingPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingPlan.
     */
    data: XOR<BillingPlanUpdateInput, BillingPlanUncheckedUpdateInput>
    /**
     * Choose, which BillingPlan to update.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan updateMany
   */
  export type BillingPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingPlans.
     */
    data: XOR<BillingPlanUpdateManyMutationInput, BillingPlanUncheckedUpdateManyInput>
    /**
     * Filter which BillingPlans to update
     */
    where?: BillingPlanWhereInput
    /**
     * Limit how many BillingPlans to update.
     */
    limit?: number
  }

  /**
   * BillingPlan updateManyAndReturn
   */
  export type BillingPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * The data used to update BillingPlans.
     */
    data: XOR<BillingPlanUpdateManyMutationInput, BillingPlanUncheckedUpdateManyInput>
    /**
     * Filter which BillingPlans to update
     */
    where?: BillingPlanWhereInput
    /**
     * Limit how many BillingPlans to update.
     */
    limit?: number
  }

  /**
   * BillingPlan upsert
   */
  export type BillingPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingPlan to update in case it exists.
     */
    where: BillingPlanWhereUniqueInput
    /**
     * In case the BillingPlan found by the `where` argument doesn't exist, create a new BillingPlan with this data.
     */
    create: XOR<BillingPlanCreateInput, BillingPlanUncheckedCreateInput>
    /**
     * In case the BillingPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingPlanUpdateInput, BillingPlanUncheckedUpdateInput>
  }

  /**
   * BillingPlan delete
   */
  export type BillingPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPlanInclude<ExtArgs> | null
    /**
     * Filter which BillingPlan to delete.
     */
    where: BillingPlanWhereUniqueInput
  }

  /**
   * BillingPlan deleteMany
   */
  export type BillingPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPlans to delete
     */
    where?: BillingPlanWhereInput
    /**
     * Limit how many BillingPlans to delete.
     */
    limit?: number
  }

  /**
   * BillingPlan.subscriptions
   */
  export type BillingPlan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    where?: BillingSubscriptionWhereInput
    orderBy?: BillingSubscriptionOrderByWithRelationInput | BillingSubscriptionOrderByWithRelationInput[]
    cursor?: BillingSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingSubscriptionScalarFieldEnum | BillingSubscriptionScalarFieldEnum[]
  }

  /**
   * BillingPlan without action
   */
  export type BillingPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPlan
     */
    select?: BillingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPlan
     */
    omit?: BillingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPlanInclude<ExtArgs> | null
  }


  /**
   * Model BillingSubscription
   */

  export type AggregateBillingSubscription = {
    _count: BillingSubscriptionCountAggregateOutputType | null
    _avg: BillingSubscriptionAvgAggregateOutputType | null
    _sum: BillingSubscriptionSumAggregateOutputType | null
    _min: BillingSubscriptionMinAggregateOutputType | null
    _max: BillingSubscriptionMaxAggregateOutputType | null
  }

  export type BillingSubscriptionAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillingSubscriptionSumAggregateOutputType = {
    amount: number | null
  }

  export type BillingSubscriptionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
    nextBillingDate: Date | null
    billingCycle: string | null
    amount: number | null
    currency: string | null
    lastInvoiceId: string | null
    trialEndsAt: Date | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.BillingSubscriptionStatus | null
  }

  export type BillingSubscriptionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
    nextBillingDate: Date | null
    billingCycle: string | null
    amount: number | null
    currency: string | null
    lastInvoiceId: string | null
    trialEndsAt: Date | null
    canceledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.BillingSubscriptionStatus | null
  }

  export type BillingSubscriptionCountAggregateOutputType = {
    id: number
    tenantId: number
    planId: number
    startDate: number
    endDate: number
    nextBillingDate: number
    billingCycle: number
    amount: number
    currency: number
    lastInvoiceId: number
    trialEndsAt: number
    canceledAt: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type BillingSubscriptionAvgAggregateInputType = {
    amount?: true
  }

  export type BillingSubscriptionSumAggregateInputType = {
    amount?: true
  }

  export type BillingSubscriptionMinAggregateInputType = {
    id?: true
    tenantId?: true
    planId?: true
    startDate?: true
    endDate?: true
    nextBillingDate?: true
    billingCycle?: true
    amount?: true
    currency?: true
    lastInvoiceId?: true
    trialEndsAt?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type BillingSubscriptionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    planId?: true
    startDate?: true
    endDate?: true
    nextBillingDate?: true
    billingCycle?: true
    amount?: true
    currency?: true
    lastInvoiceId?: true
    trialEndsAt?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type BillingSubscriptionCountAggregateInputType = {
    id?: true
    tenantId?: true
    planId?: true
    startDate?: true
    endDate?: true
    nextBillingDate?: true
    billingCycle?: true
    amount?: true
    currency?: true
    lastInvoiceId?: true
    trialEndsAt?: true
    canceledAt?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type BillingSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingSubscription to aggregate.
     */
    where?: BillingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingSubscriptions to fetch.
     */
    orderBy?: BillingSubscriptionOrderByWithRelationInput | BillingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingSubscriptions
    **/
    _count?: true | BillingSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingSubscriptionMaxAggregateInputType
  }

  export type GetBillingSubscriptionAggregateType<T extends BillingSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingSubscription[P]>
      : GetScalarType<T[P], AggregateBillingSubscription[P]>
  }




  export type BillingSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingSubscriptionWhereInput
    orderBy?: BillingSubscriptionOrderByWithAggregationInput | BillingSubscriptionOrderByWithAggregationInput[]
    by: BillingSubscriptionScalarFieldEnum[] | BillingSubscriptionScalarFieldEnum
    having?: BillingSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingSubscriptionCountAggregateInputType | true
    _avg?: BillingSubscriptionAvgAggregateInputType
    _sum?: BillingSubscriptionSumAggregateInputType
    _min?: BillingSubscriptionMinAggregateInputType
    _max?: BillingSubscriptionMaxAggregateInputType
  }

  export type BillingSubscriptionGroupByOutputType = {
    id: string
    tenantId: string
    planId: string
    startDate: Date
    endDate: Date | null
    nextBillingDate: Date | null
    billingCycle: string
    amount: number
    currency: string
    lastInvoiceId: string | null
    trialEndsAt: Date | null
    canceledAt: Date | null
    createdAt: Date
    updatedAt: Date
    status: $Enums.BillingSubscriptionStatus
    _count: BillingSubscriptionCountAggregateOutputType | null
    _avg: BillingSubscriptionAvgAggregateOutputType | null
    _sum: BillingSubscriptionSumAggregateOutputType | null
    _min: BillingSubscriptionMinAggregateOutputType | null
    _max: BillingSubscriptionMaxAggregateOutputType | null
  }

  type GetBillingSubscriptionGroupByPayload<T extends BillingSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], BillingSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type BillingSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    nextBillingDate?: boolean
    billingCycle?: boolean
    amount?: boolean
    currency?: boolean
    lastInvoiceId?: boolean
    trialEndsAt?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    lastInvoice?: boolean | BillingSubscription$lastInvoiceArgs<ExtArgs>
    plan?: boolean | BillingPlanDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingSubscription"]>

  export type BillingSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    nextBillingDate?: boolean
    billingCycle?: boolean
    amount?: boolean
    currency?: boolean
    lastInvoiceId?: boolean
    trialEndsAt?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    lastInvoice?: boolean | BillingSubscription$lastInvoiceArgs<ExtArgs>
    plan?: boolean | BillingPlanDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingSubscription"]>

  export type BillingSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    nextBillingDate?: boolean
    billingCycle?: boolean
    amount?: boolean
    currency?: boolean
    lastInvoiceId?: boolean
    trialEndsAt?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    lastInvoice?: boolean | BillingSubscription$lastInvoiceArgs<ExtArgs>
    plan?: boolean | BillingPlanDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingSubscription"]>

  export type BillingSubscriptionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    nextBillingDate?: boolean
    billingCycle?: boolean
    amount?: boolean
    currency?: boolean
    lastInvoiceId?: boolean
    trialEndsAt?: boolean
    canceledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type BillingSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "planId" | "startDate" | "endDate" | "nextBillingDate" | "billingCycle" | "amount" | "currency" | "lastInvoiceId" | "trialEndsAt" | "canceledAt" | "createdAt" | "updatedAt" | "status", ExtArgs["result"]["billingSubscription"]>
  export type BillingSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastInvoice?: boolean | BillingSubscription$lastInvoiceArgs<ExtArgs>
    plan?: boolean | BillingPlanDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type BillingSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastInvoice?: boolean | BillingSubscription$lastInvoiceArgs<ExtArgs>
    plan?: boolean | BillingPlanDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type BillingSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastInvoice?: boolean | BillingSubscription$lastInvoiceArgs<ExtArgs>
    plan?: boolean | BillingPlanDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $BillingSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingSubscription"
    objects: {
      lastInvoice: Prisma.$BillingInvoicePayload<ExtArgs> | null
      plan: Prisma.$BillingPlanPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      planId: string
      startDate: Date
      endDate: Date | null
      nextBillingDate: Date | null
      billingCycle: string
      amount: number
      currency: string
      lastInvoiceId: string | null
      trialEndsAt: Date | null
      canceledAt: Date | null
      createdAt: Date
      updatedAt: Date
      status: $Enums.BillingSubscriptionStatus
    }, ExtArgs["result"]["billingSubscription"]>
    composites: {}
  }

  type BillingSubscriptionGetPayload<S extends boolean | null | undefined | BillingSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$BillingSubscriptionPayload, S>

  type BillingSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingSubscriptionCountAggregateInputType | true
    }

  export interface BillingSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingSubscription'], meta: { name: 'BillingSubscription' } }
    /**
     * Find zero or one BillingSubscription that matches the filter.
     * @param {BillingSubscriptionFindUniqueArgs} args - Arguments to find a BillingSubscription
     * @example
     * // Get one BillingSubscription
     * const billingSubscription = await prisma.billingSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingSubscriptionFindUniqueArgs>(args: SelectSubset<T, BillingSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__BillingSubscriptionClient<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a BillingSubscription
     * @example
     * // Get one BillingSubscription
     * const billingSubscription = await prisma.billingSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingSubscriptionClient<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSubscriptionFindFirstArgs} args - Arguments to find a BillingSubscription
     * @example
     * // Get one BillingSubscription
     * const billingSubscription = await prisma.billingSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingSubscriptionFindFirstArgs>(args?: SelectSubset<T, BillingSubscriptionFindFirstArgs<ExtArgs>>): Prisma__BillingSubscriptionClient<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSubscriptionFindFirstOrThrowArgs} args - Arguments to find a BillingSubscription
     * @example
     * // Get one BillingSubscription
     * const billingSubscription = await prisma.billingSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingSubscriptionClient<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingSubscriptions
     * const billingSubscriptions = await prisma.billingSubscription.findMany()
     * 
     * // Get first 10 BillingSubscriptions
     * const billingSubscriptions = await prisma.billingSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingSubscriptionWithIdOnly = await prisma.billingSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingSubscriptionFindManyArgs>(args?: SelectSubset<T, BillingSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingSubscription.
     * @param {BillingSubscriptionCreateArgs} args - Arguments to create a BillingSubscription.
     * @example
     * // Create one BillingSubscription
     * const BillingSubscription = await prisma.billingSubscription.create({
     *   data: {
     *     // ... data to create a BillingSubscription
     *   }
     * })
     * 
     */
    create<T extends BillingSubscriptionCreateArgs>(args: SelectSubset<T, BillingSubscriptionCreateArgs<ExtArgs>>): Prisma__BillingSubscriptionClient<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingSubscriptions.
     * @param {BillingSubscriptionCreateManyArgs} args - Arguments to create many BillingSubscriptions.
     * @example
     * // Create many BillingSubscriptions
     * const billingSubscription = await prisma.billingSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingSubscriptionCreateManyArgs>(args?: SelectSubset<T, BillingSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingSubscriptions and returns the data saved in the database.
     * @param {BillingSubscriptionCreateManyAndReturnArgs} args - Arguments to create many BillingSubscriptions.
     * @example
     * // Create many BillingSubscriptions
     * const billingSubscription = await prisma.billingSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingSubscriptions and only return the `id`
     * const billingSubscriptionWithIdOnly = await prisma.billingSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingSubscription.
     * @param {BillingSubscriptionDeleteArgs} args - Arguments to delete one BillingSubscription.
     * @example
     * // Delete one BillingSubscription
     * const BillingSubscription = await prisma.billingSubscription.delete({
     *   where: {
     *     // ... filter to delete one BillingSubscription
     *   }
     * })
     * 
     */
    delete<T extends BillingSubscriptionDeleteArgs>(args: SelectSubset<T, BillingSubscriptionDeleteArgs<ExtArgs>>): Prisma__BillingSubscriptionClient<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingSubscription.
     * @param {BillingSubscriptionUpdateArgs} args - Arguments to update one BillingSubscription.
     * @example
     * // Update one BillingSubscription
     * const billingSubscription = await prisma.billingSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingSubscriptionUpdateArgs>(args: SelectSubset<T, BillingSubscriptionUpdateArgs<ExtArgs>>): Prisma__BillingSubscriptionClient<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingSubscriptions.
     * @param {BillingSubscriptionDeleteManyArgs} args - Arguments to filter BillingSubscriptions to delete.
     * @example
     * // Delete a few BillingSubscriptions
     * const { count } = await prisma.billingSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingSubscriptionDeleteManyArgs>(args?: SelectSubset<T, BillingSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingSubscriptions
     * const billingSubscription = await prisma.billingSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingSubscriptionUpdateManyArgs>(args: SelectSubset<T, BillingSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingSubscriptions and returns the data updated in the database.
     * @param {BillingSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many BillingSubscriptions.
     * @example
     * // Update many BillingSubscriptions
     * const billingSubscription = await prisma.billingSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingSubscriptions and only return the `id`
     * const billingSubscriptionWithIdOnly = await prisma.billingSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingSubscription.
     * @param {BillingSubscriptionUpsertArgs} args - Arguments to update or create a BillingSubscription.
     * @example
     * // Update or create a BillingSubscription
     * const billingSubscription = await prisma.billingSubscription.upsert({
     *   create: {
     *     // ... data to create a BillingSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingSubscription we want to update
     *   }
     * })
     */
    upsert<T extends BillingSubscriptionUpsertArgs>(args: SelectSubset<T, BillingSubscriptionUpsertArgs<ExtArgs>>): Prisma__BillingSubscriptionClient<$Result.GetResult<Prisma.$BillingSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSubscriptionCountArgs} args - Arguments to filter BillingSubscriptions to count.
     * @example
     * // Count the number of BillingSubscriptions
     * const count = await prisma.billingSubscription.count({
     *   where: {
     *     // ... the filter for the BillingSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends BillingSubscriptionCountArgs>(
      args?: Subset<T, BillingSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingSubscriptionAggregateArgs>(args: Subset<T, BillingSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetBillingSubscriptionAggregateType<T>>

    /**
     * Group by BillingSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: BillingSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingSubscription model
   */
  readonly fields: BillingSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lastInvoice<T extends BillingSubscription$lastInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, BillingSubscription$lastInvoiceArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    plan<T extends BillingPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillingPlanDefaultArgs<ExtArgs>>): Prisma__BillingPlanClient<$Result.GetResult<Prisma.$BillingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingSubscription model
   */
  interface BillingSubscriptionFieldRefs {
    readonly id: FieldRef<"BillingSubscription", 'String'>
    readonly tenantId: FieldRef<"BillingSubscription", 'String'>
    readonly planId: FieldRef<"BillingSubscription", 'String'>
    readonly startDate: FieldRef<"BillingSubscription", 'DateTime'>
    readonly endDate: FieldRef<"BillingSubscription", 'DateTime'>
    readonly nextBillingDate: FieldRef<"BillingSubscription", 'DateTime'>
    readonly billingCycle: FieldRef<"BillingSubscription", 'String'>
    readonly amount: FieldRef<"BillingSubscription", 'Float'>
    readonly currency: FieldRef<"BillingSubscription", 'String'>
    readonly lastInvoiceId: FieldRef<"BillingSubscription", 'String'>
    readonly trialEndsAt: FieldRef<"BillingSubscription", 'DateTime'>
    readonly canceledAt: FieldRef<"BillingSubscription", 'DateTime'>
    readonly createdAt: FieldRef<"BillingSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingSubscription", 'DateTime'>
    readonly status: FieldRef<"BillingSubscription", 'BillingSubscriptionStatus'>
  }
    

  // Custom InputTypes
  /**
   * BillingSubscription findUnique
   */
  export type BillingSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which BillingSubscription to fetch.
     */
    where: BillingSubscriptionWhereUniqueInput
  }

  /**
   * BillingSubscription findUniqueOrThrow
   */
  export type BillingSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which BillingSubscription to fetch.
     */
    where: BillingSubscriptionWhereUniqueInput
  }

  /**
   * BillingSubscription findFirst
   */
  export type BillingSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which BillingSubscription to fetch.
     */
    where?: BillingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingSubscriptions to fetch.
     */
    orderBy?: BillingSubscriptionOrderByWithRelationInput | BillingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingSubscriptions.
     */
    cursor?: BillingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingSubscriptions.
     */
    distinct?: BillingSubscriptionScalarFieldEnum | BillingSubscriptionScalarFieldEnum[]
  }

  /**
   * BillingSubscription findFirstOrThrow
   */
  export type BillingSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which BillingSubscription to fetch.
     */
    where?: BillingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingSubscriptions to fetch.
     */
    orderBy?: BillingSubscriptionOrderByWithRelationInput | BillingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingSubscriptions.
     */
    cursor?: BillingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingSubscriptions.
     */
    distinct?: BillingSubscriptionScalarFieldEnum | BillingSubscriptionScalarFieldEnum[]
  }

  /**
   * BillingSubscription findMany
   */
  export type BillingSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which BillingSubscriptions to fetch.
     */
    where?: BillingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingSubscriptions to fetch.
     */
    orderBy?: BillingSubscriptionOrderByWithRelationInput | BillingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingSubscriptions.
     */
    cursor?: BillingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingSubscriptions.
     */
    skip?: number
    distinct?: BillingSubscriptionScalarFieldEnum | BillingSubscriptionScalarFieldEnum[]
  }

  /**
   * BillingSubscription create
   */
  export type BillingSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingSubscription.
     */
    data: XOR<BillingSubscriptionCreateInput, BillingSubscriptionUncheckedCreateInput>
  }

  /**
   * BillingSubscription createMany
   */
  export type BillingSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingSubscriptions.
     */
    data: BillingSubscriptionCreateManyInput | BillingSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingSubscription createManyAndReturn
   */
  export type BillingSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many BillingSubscriptions.
     */
    data: BillingSubscriptionCreateManyInput | BillingSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingSubscription update
   */
  export type BillingSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingSubscription.
     */
    data: XOR<BillingSubscriptionUpdateInput, BillingSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which BillingSubscription to update.
     */
    where: BillingSubscriptionWhereUniqueInput
  }

  /**
   * BillingSubscription updateMany
   */
  export type BillingSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingSubscriptions.
     */
    data: XOR<BillingSubscriptionUpdateManyMutationInput, BillingSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which BillingSubscriptions to update
     */
    where?: BillingSubscriptionWhereInput
    /**
     * Limit how many BillingSubscriptions to update.
     */
    limit?: number
  }

  /**
   * BillingSubscription updateManyAndReturn
   */
  export type BillingSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update BillingSubscriptions.
     */
    data: XOR<BillingSubscriptionUpdateManyMutationInput, BillingSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which BillingSubscriptions to update
     */
    where?: BillingSubscriptionWhereInput
    /**
     * Limit how many BillingSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingSubscription upsert
   */
  export type BillingSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingSubscription to update in case it exists.
     */
    where: BillingSubscriptionWhereUniqueInput
    /**
     * In case the BillingSubscription found by the `where` argument doesn't exist, create a new BillingSubscription with this data.
     */
    create: XOR<BillingSubscriptionCreateInput, BillingSubscriptionUncheckedCreateInput>
    /**
     * In case the BillingSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingSubscriptionUpdateInput, BillingSubscriptionUncheckedUpdateInput>
  }

  /**
   * BillingSubscription delete
   */
  export type BillingSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which BillingSubscription to delete.
     */
    where: BillingSubscriptionWhereUniqueInput
  }

  /**
   * BillingSubscription deleteMany
   */
  export type BillingSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingSubscriptions to delete
     */
    where?: BillingSubscriptionWhereInput
    /**
     * Limit how many BillingSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * BillingSubscription.lastInvoice
   */
  export type BillingSubscription$lastInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    where?: BillingInvoiceWhereInput
  }

  /**
   * BillingSubscription without action
   */
  export type BillingSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingSubscription
     */
    select?: BillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingSubscription
     */
    omit?: BillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model BillingPayment
   */

  export type AggregateBillingPayment = {
    _count: BillingPaymentCountAggregateOutputType | null
    _avg: BillingPaymentAvgAggregateOutputType | null
    _sum: BillingPaymentSumAggregateOutputType | null
    _min: BillingPaymentMinAggregateOutputType | null
    _max: BillingPaymentMaxAggregateOutputType | null
  }

  export type BillingPaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillingPaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type BillingPaymentMinAggregateOutputType = {
    id: string | null
    paymentDate: Date | null
    amount: number | null
    paymentMethod: string | null
    transactionId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    billingInvoiceId: string | null
  }

  export type BillingPaymentMaxAggregateOutputType = {
    id: string | null
    paymentDate: Date | null
    amount: number | null
    paymentMethod: string | null
    transactionId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    billingInvoiceId: string | null
  }

  export type BillingPaymentCountAggregateOutputType = {
    id: number
    paymentDate: number
    amount: number
    paymentMethod: number
    transactionId: number
    status: number
    createdAt: number
    updatedAt: number
    billingInvoiceId: number
    _all: number
  }


  export type BillingPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type BillingPaymentSumAggregateInputType = {
    amount?: true
  }

  export type BillingPaymentMinAggregateInputType = {
    id?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    transactionId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
  }

  export type BillingPaymentMaxAggregateInputType = {
    id?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    transactionId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
  }

  export type BillingPaymentCountAggregateInputType = {
    id?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    transactionId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
    _all?: true
  }

  export type BillingPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPayment to aggregate.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingPayments
    **/
    _count?: true | BillingPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingPaymentMaxAggregateInputType
  }

  export type GetBillingPaymentAggregateType<T extends BillingPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingPayment[P]>
      : GetScalarType<T[P], AggregateBillingPayment[P]>
  }




  export type BillingPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingPaymentWhereInput
    orderBy?: BillingPaymentOrderByWithAggregationInput | BillingPaymentOrderByWithAggregationInput[]
    by: BillingPaymentScalarFieldEnum[] | BillingPaymentScalarFieldEnum
    having?: BillingPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingPaymentCountAggregateInputType | true
    _avg?: BillingPaymentAvgAggregateInputType
    _sum?: BillingPaymentSumAggregateInputType
    _min?: BillingPaymentMinAggregateInputType
    _max?: BillingPaymentMaxAggregateInputType
  }

  export type BillingPaymentGroupByOutputType = {
    id: string
    paymentDate: Date
    amount: number
    paymentMethod: string
    transactionId: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    billingInvoiceId: string | null
    _count: BillingPaymentCountAggregateOutputType | null
    _avg: BillingPaymentAvgAggregateOutputType | null
    _sum: BillingPaymentSumAggregateOutputType | null
    _min: BillingPaymentMinAggregateOutputType | null
    _max: BillingPaymentMaxAggregateOutputType | null
  }

  type GetBillingPaymentGroupByPayload<T extends BillingPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], BillingPaymentGroupByOutputType[P]>
        }
      >
    >


  export type BillingPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingPayment"]>

  export type BillingPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingPayment"]>

  export type BillingPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingPayment"]>

  export type BillingPaymentSelectScalar = {
    id?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
  }

  export type BillingPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentDate" | "amount" | "paymentMethod" | "transactionId" | "status" | "createdAt" | "updatedAt" | "billingInvoiceId", ExtArgs["result"]["billingPayment"]>
  export type BillingPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }
  export type BillingPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }
  export type BillingPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }

  export type $BillingPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingPayment"
    objects: {
      BillingInvoice: Prisma.$BillingInvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentDate: Date
      amount: number
      paymentMethod: string
      transactionId: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      billingInvoiceId: string | null
    }, ExtArgs["result"]["billingPayment"]>
    composites: {}
  }

  type BillingPaymentGetPayload<S extends boolean | null | undefined | BillingPaymentDefaultArgs> = $Result.GetResult<Prisma.$BillingPaymentPayload, S>

  type BillingPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingPaymentCountAggregateInputType | true
    }

  export interface BillingPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingPayment'], meta: { name: 'BillingPayment' } }
    /**
     * Find zero or one BillingPayment that matches the filter.
     * @param {BillingPaymentFindUniqueArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingPaymentFindUniqueArgs>(args: SelectSubset<T, BillingPaymentFindUniqueArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingPaymentFindUniqueOrThrowArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentFindFirstArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingPaymentFindFirstArgs>(args?: SelectSubset<T, BillingPaymentFindFirstArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentFindFirstOrThrowArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingPayments
     * const billingPayments = await prisma.billingPayment.findMany()
     * 
     * // Get first 10 BillingPayments
     * const billingPayments = await prisma.billingPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingPaymentWithIdOnly = await prisma.billingPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingPaymentFindManyArgs>(args?: SelectSubset<T, BillingPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingPayment.
     * @param {BillingPaymentCreateArgs} args - Arguments to create a BillingPayment.
     * @example
     * // Create one BillingPayment
     * const BillingPayment = await prisma.billingPayment.create({
     *   data: {
     *     // ... data to create a BillingPayment
     *   }
     * })
     * 
     */
    create<T extends BillingPaymentCreateArgs>(args: SelectSubset<T, BillingPaymentCreateArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingPayments.
     * @param {BillingPaymentCreateManyArgs} args - Arguments to create many BillingPayments.
     * @example
     * // Create many BillingPayments
     * const billingPayment = await prisma.billingPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingPaymentCreateManyArgs>(args?: SelectSubset<T, BillingPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingPayments and returns the data saved in the database.
     * @param {BillingPaymentCreateManyAndReturnArgs} args - Arguments to create many BillingPayments.
     * @example
     * // Create many BillingPayments
     * const billingPayment = await prisma.billingPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingPayments and only return the `id`
     * const billingPaymentWithIdOnly = await prisma.billingPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingPayment.
     * @param {BillingPaymentDeleteArgs} args - Arguments to delete one BillingPayment.
     * @example
     * // Delete one BillingPayment
     * const BillingPayment = await prisma.billingPayment.delete({
     *   where: {
     *     // ... filter to delete one BillingPayment
     *   }
     * })
     * 
     */
    delete<T extends BillingPaymentDeleteArgs>(args: SelectSubset<T, BillingPaymentDeleteArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingPayment.
     * @param {BillingPaymentUpdateArgs} args - Arguments to update one BillingPayment.
     * @example
     * // Update one BillingPayment
     * const billingPayment = await prisma.billingPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingPaymentUpdateArgs>(args: SelectSubset<T, BillingPaymentUpdateArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingPayments.
     * @param {BillingPaymentDeleteManyArgs} args - Arguments to filter BillingPayments to delete.
     * @example
     * // Delete a few BillingPayments
     * const { count } = await prisma.billingPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingPaymentDeleteManyArgs>(args?: SelectSubset<T, BillingPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingPayments
     * const billingPayment = await prisma.billingPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingPaymentUpdateManyArgs>(args: SelectSubset<T, BillingPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingPayments and returns the data updated in the database.
     * @param {BillingPaymentUpdateManyAndReturnArgs} args - Arguments to update many BillingPayments.
     * @example
     * // Update many BillingPayments
     * const billingPayment = await prisma.billingPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingPayments and only return the `id`
     * const billingPaymentWithIdOnly = await prisma.billingPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingPayment.
     * @param {BillingPaymentUpsertArgs} args - Arguments to update or create a BillingPayment.
     * @example
     * // Update or create a BillingPayment
     * const billingPayment = await prisma.billingPayment.upsert({
     *   create: {
     *     // ... data to create a BillingPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingPayment we want to update
     *   }
     * })
     */
    upsert<T extends BillingPaymentUpsertArgs>(args: SelectSubset<T, BillingPaymentUpsertArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentCountArgs} args - Arguments to filter BillingPayments to count.
     * @example
     * // Count the number of BillingPayments
     * const count = await prisma.billingPayment.count({
     *   where: {
     *     // ... the filter for the BillingPayments we want to count
     *   }
     * })
    **/
    count<T extends BillingPaymentCountArgs>(
      args?: Subset<T, BillingPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingPaymentAggregateArgs>(args: Subset<T, BillingPaymentAggregateArgs>): Prisma.PrismaPromise<GetBillingPaymentAggregateType<T>>

    /**
     * Group by BillingPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingPaymentGroupByArgs['orderBy'] }
        : { orderBy?: BillingPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingPayment model
   */
  readonly fields: BillingPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BillingInvoice<T extends BillingPayment$BillingInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, BillingPayment$BillingInvoiceArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingPayment model
   */
  interface BillingPaymentFieldRefs {
    readonly id: FieldRef<"BillingPayment", 'String'>
    readonly paymentDate: FieldRef<"BillingPayment", 'DateTime'>
    readonly amount: FieldRef<"BillingPayment", 'Float'>
    readonly paymentMethod: FieldRef<"BillingPayment", 'String'>
    readonly transactionId: FieldRef<"BillingPayment", 'String'>
    readonly status: FieldRef<"BillingPayment", 'String'>
    readonly createdAt: FieldRef<"BillingPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingPayment", 'DateTime'>
    readonly billingInvoiceId: FieldRef<"BillingPayment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BillingPayment findUnique
   */
  export type BillingPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment findUniqueOrThrow
   */
  export type BillingPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment findFirst
   */
  export type BillingPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPayments.
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPayments.
     */
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingPayment findFirstOrThrow
   */
  export type BillingPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPayments.
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPayments.
     */
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingPayment findMany
   */
  export type BillingPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayments to fetch.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingPayments.
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingPayment create
   */
  export type BillingPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingPayment.
     */
    data: XOR<BillingPaymentCreateInput, BillingPaymentUncheckedCreateInput>
  }

  /**
   * BillingPayment createMany
   */
  export type BillingPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingPayments.
     */
    data: BillingPaymentCreateManyInput | BillingPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingPayment createManyAndReturn
   */
  export type BillingPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many BillingPayments.
     */
    data: BillingPaymentCreateManyInput | BillingPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingPayment update
   */
  export type BillingPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingPayment.
     */
    data: XOR<BillingPaymentUpdateInput, BillingPaymentUncheckedUpdateInput>
    /**
     * Choose, which BillingPayment to update.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment updateMany
   */
  export type BillingPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingPayments.
     */
    data: XOR<BillingPaymentUpdateManyMutationInput, BillingPaymentUncheckedUpdateManyInput>
    /**
     * Filter which BillingPayments to update
     */
    where?: BillingPaymentWhereInput
    /**
     * Limit how many BillingPayments to update.
     */
    limit?: number
  }

  /**
   * BillingPayment updateManyAndReturn
   */
  export type BillingPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * The data used to update BillingPayments.
     */
    data: XOR<BillingPaymentUpdateManyMutationInput, BillingPaymentUncheckedUpdateManyInput>
    /**
     * Filter which BillingPayments to update
     */
    where?: BillingPaymentWhereInput
    /**
     * Limit how many BillingPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingPayment upsert
   */
  export type BillingPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingPayment to update in case it exists.
     */
    where: BillingPaymentWhereUniqueInput
    /**
     * In case the BillingPayment found by the `where` argument doesn't exist, create a new BillingPayment with this data.
     */
    create: XOR<BillingPaymentCreateInput, BillingPaymentUncheckedCreateInput>
    /**
     * In case the BillingPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingPaymentUpdateInput, BillingPaymentUncheckedUpdateInput>
  }

  /**
   * BillingPayment delete
   */
  export type BillingPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter which BillingPayment to delete.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment deleteMany
   */
  export type BillingPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPayments to delete
     */
    where?: BillingPaymentWhereInput
    /**
     * Limit how many BillingPayments to delete.
     */
    limit?: number
  }

  /**
   * BillingPayment.BillingInvoice
   */
  export type BillingPayment$BillingInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    where?: BillingInvoiceWhereInput
  }

  /**
   * BillingPayment without action
   */
  export type BillingPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
  }


  /**
   * Model CollectionCase
   */

  export type AggregateCollectionCase = {
    _count: CollectionCaseCountAggregateOutputType | null
    _avg: CollectionCaseAvgAggregateOutputType | null
    _sum: CollectionCaseSumAggregateOutputType | null
    _min: CollectionCaseMinAggregateOutputType | null
    _max: CollectionCaseMaxAggregateOutputType | null
  }

  export type CollectionCaseAvgAggregateOutputType = {
    amountOriginal: Decimal | null
    amountDue: Decimal | null
    amountToReceive: Decimal | null
  }

  export type CollectionCaseSumAggregateOutputType = {
    amountOriginal: Decimal | null
    amountDue: Decimal | null
    amountToReceive: Decimal | null
  }

  export type CollectionCaseMinAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    issueDate: Date | null
    dueDate: Date | null
    tenantId: string | null
    debtorId: string | null
    amountOriginal: Decimal | null
    amountDue: Decimal | null
    amountToReceive: Decimal | null
    status: $Enums.CollectionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionCaseMaxAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    issueDate: Date | null
    dueDate: Date | null
    tenantId: string | null
    debtorId: string | null
    amountOriginal: Decimal | null
    amountDue: Decimal | null
    amountToReceive: Decimal | null
    status: $Enums.CollectionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionCaseCountAggregateOutputType = {
    id: number
    referenceNumber: number
    issueDate: number
    dueDate: number
    tenantId: number
    debtorId: number
    amountOriginal: number
    amountDue: number
    amountToReceive: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollectionCaseAvgAggregateInputType = {
    amountOriginal?: true
    amountDue?: true
    amountToReceive?: true
  }

  export type CollectionCaseSumAggregateInputType = {
    amountOriginal?: true
    amountDue?: true
    amountToReceive?: true
  }

  export type CollectionCaseMinAggregateInputType = {
    id?: true
    referenceNumber?: true
    issueDate?: true
    dueDate?: true
    tenantId?: true
    debtorId?: true
    amountOriginal?: true
    amountDue?: true
    amountToReceive?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionCaseMaxAggregateInputType = {
    id?: true
    referenceNumber?: true
    issueDate?: true
    dueDate?: true
    tenantId?: true
    debtorId?: true
    amountOriginal?: true
    amountDue?: true
    amountToReceive?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionCaseCountAggregateInputType = {
    id?: true
    referenceNumber?: true
    issueDate?: true
    dueDate?: true
    tenantId?: true
    debtorId?: true
    amountOriginal?: true
    amountDue?: true
    amountToReceive?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollectionCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCase to aggregate.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionCases
    **/
    _count?: true | CollectionCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionCaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionCaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionCaseMaxAggregateInputType
  }

  export type GetCollectionCaseAggregateType<T extends CollectionCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionCase[P]>
      : GetScalarType<T[P], AggregateCollectionCase[P]>
  }




  export type CollectionCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseWhereInput
    orderBy?: CollectionCaseOrderByWithAggregationInput | CollectionCaseOrderByWithAggregationInput[]
    by: CollectionCaseScalarFieldEnum[] | CollectionCaseScalarFieldEnum
    having?: CollectionCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCaseCountAggregateInputType | true
    _avg?: CollectionCaseAvgAggregateInputType
    _sum?: CollectionCaseSumAggregateInputType
    _min?: CollectionCaseMinAggregateInputType
    _max?: CollectionCaseMaxAggregateInputType
  }

  export type CollectionCaseGroupByOutputType = {
    id: string
    referenceNumber: string | null
    issueDate: Date | null
    dueDate: Date | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal
    amountDue: Decimal
    amountToReceive: Decimal
    status: $Enums.CollectionStatus
    createdAt: Date
    updatedAt: Date
    _count: CollectionCaseCountAggregateOutputType | null
    _avg: CollectionCaseAvgAggregateOutputType | null
    _sum: CollectionCaseSumAggregateOutputType | null
    _min: CollectionCaseMinAggregateOutputType | null
    _max: CollectionCaseMaxAggregateOutputType | null
  }

  type GetCollectionCaseGroupByPayload<T extends CollectionCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionCaseGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionCaseGroupByOutputType[P]>
        }
      >
    >


  export type CollectionCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    issueDate?: boolean
    dueDate?: boolean
    tenantId?: boolean
    debtorId?: boolean
    amountOriginal?: boolean
    amountDue?: boolean
    amountToReceive?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    notifications?: boolean | CollectionCase$notificationsArgs<ExtArgs>
    payments?: boolean | CollectionCase$paymentsArgs<ExtArgs>
    agreements?: boolean | CollectionCase$agreementsArgs<ExtArgs>
    penalties?: boolean | CollectionCase$penaltiesArgs<ExtArgs>
    _count?: boolean | CollectionCaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCase"]>

  export type CollectionCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    issueDate?: boolean
    dueDate?: boolean
    tenantId?: boolean
    debtorId?: boolean
    amountOriginal?: boolean
    amountDue?: boolean
    amountToReceive?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCase"]>

  export type CollectionCaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    issueDate?: boolean
    dueDate?: boolean
    tenantId?: boolean
    debtorId?: boolean
    amountOriginal?: boolean
    amountDue?: boolean
    amountToReceive?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCase"]>

  export type CollectionCaseSelectScalar = {
    id?: boolean
    referenceNumber?: boolean
    issueDate?: boolean
    dueDate?: boolean
    tenantId?: boolean
    debtorId?: boolean
    amountOriginal?: boolean
    amountDue?: boolean
    amountToReceive?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CollectionCaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referenceNumber" | "issueDate" | "dueDate" | "tenantId" | "debtorId" | "amountOriginal" | "amountDue" | "amountToReceive" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["collectionCase"]>
  export type CollectionCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    notifications?: boolean | CollectionCase$notificationsArgs<ExtArgs>
    payments?: boolean | CollectionCase$paymentsArgs<ExtArgs>
    agreements?: boolean | CollectionCase$agreementsArgs<ExtArgs>
    penalties?: boolean | CollectionCase$penaltiesArgs<ExtArgs>
    _count?: boolean | CollectionCaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollectionCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CollectionCaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CollectionCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionCase"
    objects: {
      debtor: Prisma.$DebtorPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      agreements: Prisma.$PaymentAgreementPayload<ExtArgs>[]
      penalties: Prisma.$PenaltyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referenceNumber: string | null
      issueDate: Date | null
      dueDate: Date | null
      tenantId: string
      debtorId: string
      amountOriginal: Prisma.Decimal
      amountDue: Prisma.Decimal
      amountToReceive: Prisma.Decimal
      status: $Enums.CollectionStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["collectionCase"]>
    composites: {}
  }

  type CollectionCaseGetPayload<S extends boolean | null | undefined | CollectionCaseDefaultArgs> = $Result.GetResult<Prisma.$CollectionCasePayload, S>

  type CollectionCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionCaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCaseCountAggregateInputType | true
    }

  export interface CollectionCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionCase'], meta: { name: 'CollectionCase' } }
    /**
     * Find zero or one CollectionCase that matches the filter.
     * @param {CollectionCaseFindUniqueArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionCaseFindUniqueArgs>(args: SelectSubset<T, CollectionCaseFindUniqueArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionCase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionCaseFindUniqueOrThrowArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseFindFirstArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionCaseFindFirstArgs>(args?: SelectSubset<T, CollectionCaseFindFirstArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseFindFirstOrThrowArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionCases
     * const collectionCases = await prisma.collectionCase.findMany()
     * 
     * // Get first 10 CollectionCases
     * const collectionCases = await prisma.collectionCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionCaseWithIdOnly = await prisma.collectionCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionCaseFindManyArgs>(args?: SelectSubset<T, CollectionCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionCase.
     * @param {CollectionCaseCreateArgs} args - Arguments to create a CollectionCase.
     * @example
     * // Create one CollectionCase
     * const CollectionCase = await prisma.collectionCase.create({
     *   data: {
     *     // ... data to create a CollectionCase
     *   }
     * })
     * 
     */
    create<T extends CollectionCaseCreateArgs>(args: SelectSubset<T, CollectionCaseCreateArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionCases.
     * @param {CollectionCaseCreateManyArgs} args - Arguments to create many CollectionCases.
     * @example
     * // Create many CollectionCases
     * const collectionCase = await prisma.collectionCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCaseCreateManyArgs>(args?: SelectSubset<T, CollectionCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionCases and returns the data saved in the database.
     * @param {CollectionCaseCreateManyAndReturnArgs} args - Arguments to create many CollectionCases.
     * @example
     * // Create many CollectionCases
     * const collectionCase = await prisma.collectionCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionCases and only return the `id`
     * const collectionCaseWithIdOnly = await prisma.collectionCase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionCase.
     * @param {CollectionCaseDeleteArgs} args - Arguments to delete one CollectionCase.
     * @example
     * // Delete one CollectionCase
     * const CollectionCase = await prisma.collectionCase.delete({
     *   where: {
     *     // ... filter to delete one CollectionCase
     *   }
     * })
     * 
     */
    delete<T extends CollectionCaseDeleteArgs>(args: SelectSubset<T, CollectionCaseDeleteArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionCase.
     * @param {CollectionCaseUpdateArgs} args - Arguments to update one CollectionCase.
     * @example
     * // Update one CollectionCase
     * const collectionCase = await prisma.collectionCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionCaseUpdateArgs>(args: SelectSubset<T, CollectionCaseUpdateArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionCases.
     * @param {CollectionCaseDeleteManyArgs} args - Arguments to filter CollectionCases to delete.
     * @example
     * // Delete a few CollectionCases
     * const { count } = await prisma.collectionCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionCaseDeleteManyArgs>(args?: SelectSubset<T, CollectionCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionCases
     * const collectionCase = await prisma.collectionCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionCaseUpdateManyArgs>(args: SelectSubset<T, CollectionCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCases and returns the data updated in the database.
     * @param {CollectionCaseUpdateManyAndReturnArgs} args - Arguments to update many CollectionCases.
     * @example
     * // Update many CollectionCases
     * const collectionCase = await prisma.collectionCase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionCases and only return the `id`
     * const collectionCaseWithIdOnly = await prisma.collectionCase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionCaseUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionCaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionCase.
     * @param {CollectionCaseUpsertArgs} args - Arguments to update or create a CollectionCase.
     * @example
     * // Update or create a CollectionCase
     * const collectionCase = await prisma.collectionCase.upsert({
     *   create: {
     *     // ... data to create a CollectionCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionCase we want to update
     *   }
     * })
     */
    upsert<T extends CollectionCaseUpsertArgs>(args: SelectSubset<T, CollectionCaseUpsertArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseCountArgs} args - Arguments to filter CollectionCases to count.
     * @example
     * // Count the number of CollectionCases
     * const count = await prisma.collectionCase.count({
     *   where: {
     *     // ... the filter for the CollectionCases we want to count
     *   }
     * })
    **/
    count<T extends CollectionCaseCountArgs>(
      args?: Subset<T, CollectionCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionCaseAggregateArgs>(args: Subset<T, CollectionCaseAggregateArgs>): Prisma.PrismaPromise<GetCollectionCaseAggregateType<T>>

    /**
     * Group by CollectionCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionCaseGroupByArgs['orderBy'] }
        : { orderBy?: CollectionCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionCase model
   */
  readonly fields: CollectionCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    debtor<T extends DebtorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtorDefaultArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends CollectionCase$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends CollectionCase$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agreements<T extends CollectionCase$agreementsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$agreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    penalties<T extends CollectionCase$penaltiesArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$penaltiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionCase model
   */
  interface CollectionCaseFieldRefs {
    readonly id: FieldRef<"CollectionCase", 'String'>
    readonly referenceNumber: FieldRef<"CollectionCase", 'String'>
    readonly issueDate: FieldRef<"CollectionCase", 'DateTime'>
    readonly dueDate: FieldRef<"CollectionCase", 'DateTime'>
    readonly tenantId: FieldRef<"CollectionCase", 'String'>
    readonly debtorId: FieldRef<"CollectionCase", 'String'>
    readonly amountOriginal: FieldRef<"CollectionCase", 'Decimal'>
    readonly amountDue: FieldRef<"CollectionCase", 'Decimal'>
    readonly amountToReceive: FieldRef<"CollectionCase", 'Decimal'>
    readonly status: FieldRef<"CollectionCase", 'CollectionStatus'>
    readonly createdAt: FieldRef<"CollectionCase", 'DateTime'>
    readonly updatedAt: FieldRef<"CollectionCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionCase findUnique
   */
  export type CollectionCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase findUniqueOrThrow
   */
  export type CollectionCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase findFirst
   */
  export type CollectionCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCases.
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCases.
     */
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * CollectionCase findFirstOrThrow
   */
  export type CollectionCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCases.
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCases.
     */
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * CollectionCase findMany
   */
  export type CollectionCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCases to fetch.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionCases.
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * CollectionCase create
   */
  export type CollectionCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a CollectionCase.
     */
    data: XOR<CollectionCaseCreateInput, CollectionCaseUncheckedCreateInput>
  }

  /**
   * CollectionCase createMany
   */
  export type CollectionCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionCases.
     */
    data: CollectionCaseCreateManyInput | CollectionCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionCase createManyAndReturn
   */
  export type CollectionCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionCases.
     */
    data: CollectionCaseCreateManyInput | CollectionCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCase update
   */
  export type CollectionCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a CollectionCase.
     */
    data: XOR<CollectionCaseUpdateInput, CollectionCaseUncheckedUpdateInput>
    /**
     * Choose, which CollectionCase to update.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase updateMany
   */
  export type CollectionCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionCases.
     */
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCases to update
     */
    where?: CollectionCaseWhereInput
    /**
     * Limit how many CollectionCases to update.
     */
    limit?: number
  }

  /**
   * CollectionCase updateManyAndReturn
   */
  export type CollectionCaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * The data used to update CollectionCases.
     */
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCases to update
     */
    where?: CollectionCaseWhereInput
    /**
     * Limit how many CollectionCases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCase upsert
   */
  export type CollectionCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the CollectionCase to update in case it exists.
     */
    where: CollectionCaseWhereUniqueInput
    /**
     * In case the CollectionCase found by the `where` argument doesn't exist, create a new CollectionCase with this data.
     */
    create: XOR<CollectionCaseCreateInput, CollectionCaseUncheckedCreateInput>
    /**
     * In case the CollectionCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionCaseUpdateInput, CollectionCaseUncheckedUpdateInput>
  }

  /**
   * CollectionCase delete
   */
  export type CollectionCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter which CollectionCase to delete.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase deleteMany
   */
  export type CollectionCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCases to delete
     */
    where?: CollectionCaseWhereInput
    /**
     * Limit how many CollectionCases to delete.
     */
    limit?: number
  }

  /**
   * CollectionCase.notifications
   */
  export type CollectionCase$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * CollectionCase.payments
   */
  export type CollectionCase$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * CollectionCase.agreements
   */
  export type CollectionCase$agreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    where?: PaymentAgreementWhereInput
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    cursor?: PaymentAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentAgreementScalarFieldEnum | PaymentAgreementScalarFieldEnum[]
  }

  /**
   * CollectionCase.penalties
   */
  export type CollectionCase$penaltiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    where?: PenaltyWhereInput
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    cursor?: PenaltyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * CollectionCase without action
   */
  export type CollectionCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
  }


  /**
   * Model Penalty
   */

  export type AggregatePenalty = {
    _count: PenaltyCountAggregateOutputType | null
    _avg: PenaltyAvgAggregateOutputType | null
    _sum: PenaltySumAggregateOutputType | null
    _min: PenaltyMinAggregateOutputType | null
    _max: PenaltyMaxAggregateOutputType | null
  }

  export type PenaltyAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PenaltySumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PenaltyMinAggregateOutputType = {
    id: string | null
    collectionCaseId: string | null
    description: string | null
    amount: Decimal | null
    dateApplied: Date | null
    isPaid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PenaltyMaxAggregateOutputType = {
    id: string | null
    collectionCaseId: string | null
    description: string | null
    amount: Decimal | null
    dateApplied: Date | null
    isPaid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PenaltyCountAggregateOutputType = {
    id: number
    collectionCaseId: number
    description: number
    amount: number
    dateApplied: number
    isPaid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PenaltyAvgAggregateInputType = {
    amount?: true
  }

  export type PenaltySumAggregateInputType = {
    amount?: true
  }

  export type PenaltyMinAggregateInputType = {
    id?: true
    collectionCaseId?: true
    description?: true
    amount?: true
    dateApplied?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PenaltyMaxAggregateInputType = {
    id?: true
    collectionCaseId?: true
    description?: true
    amount?: true
    dateApplied?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PenaltyCountAggregateInputType = {
    id?: true
    collectionCaseId?: true
    description?: true
    amount?: true
    dateApplied?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PenaltyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Penalty to aggregate.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Penalties
    **/
    _count?: true | PenaltyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PenaltyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PenaltySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PenaltyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PenaltyMaxAggregateInputType
  }

  export type GetPenaltyAggregateType<T extends PenaltyAggregateArgs> = {
        [P in keyof T & keyof AggregatePenalty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePenalty[P]>
      : GetScalarType<T[P], AggregatePenalty[P]>
  }




  export type PenaltyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PenaltyWhereInput
    orderBy?: PenaltyOrderByWithAggregationInput | PenaltyOrderByWithAggregationInput[]
    by: PenaltyScalarFieldEnum[] | PenaltyScalarFieldEnum
    having?: PenaltyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PenaltyCountAggregateInputType | true
    _avg?: PenaltyAvgAggregateInputType
    _sum?: PenaltySumAggregateInputType
    _min?: PenaltyMinAggregateInputType
    _max?: PenaltyMaxAggregateInputType
  }

  export type PenaltyGroupByOutputType = {
    id: string
    collectionCaseId: string
    description: string | null
    amount: Decimal
    dateApplied: Date
    isPaid: boolean
    createdAt: Date
    updatedAt: Date
    _count: PenaltyCountAggregateOutputType | null
    _avg: PenaltyAvgAggregateOutputType | null
    _sum: PenaltySumAggregateOutputType | null
    _min: PenaltyMinAggregateOutputType | null
    _max: PenaltyMaxAggregateOutputType | null
  }

  type GetPenaltyGroupByPayload<T extends PenaltyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PenaltyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PenaltyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PenaltyGroupByOutputType[P]>
            : GetScalarType<T[P], PenaltyGroupByOutputType[P]>
        }
      >
    >


  export type PenaltySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    description?: boolean
    amount?: boolean
    dateApplied?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["penalty"]>

  export type PenaltySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    description?: boolean
    amount?: boolean
    dateApplied?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["penalty"]>

  export type PenaltySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    description?: boolean
    amount?: boolean
    dateApplied?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["penalty"]>

  export type PenaltySelectScalar = {
    id?: boolean
    collectionCaseId?: boolean
    description?: boolean
    amount?: boolean
    dateApplied?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PenaltyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collectionCaseId" | "description" | "amount" | "dateApplied" | "isPaid" | "createdAt" | "updatedAt", ExtArgs["result"]["penalty"]>
  export type PenaltyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type PenaltyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type PenaltyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }

  export type $PenaltyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Penalty"
    objects: {
      collectionCase: Prisma.$CollectionCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collectionCaseId: string
      description: string | null
      amount: Prisma.Decimal
      dateApplied: Date
      isPaid: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["penalty"]>
    composites: {}
  }

  type PenaltyGetPayload<S extends boolean | null | undefined | PenaltyDefaultArgs> = $Result.GetResult<Prisma.$PenaltyPayload, S>

  type PenaltyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PenaltyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PenaltyCountAggregateInputType | true
    }

  export interface PenaltyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Penalty'], meta: { name: 'Penalty' } }
    /**
     * Find zero or one Penalty that matches the filter.
     * @param {PenaltyFindUniqueArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PenaltyFindUniqueArgs>(args: SelectSubset<T, PenaltyFindUniqueArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Penalty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PenaltyFindUniqueOrThrowArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PenaltyFindUniqueOrThrowArgs>(args: SelectSubset<T, PenaltyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Penalty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindFirstArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PenaltyFindFirstArgs>(args?: SelectSubset<T, PenaltyFindFirstArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Penalty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindFirstOrThrowArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PenaltyFindFirstOrThrowArgs>(args?: SelectSubset<T, PenaltyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Penalties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Penalties
     * const penalties = await prisma.penalty.findMany()
     * 
     * // Get first 10 Penalties
     * const penalties = await prisma.penalty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const penaltyWithIdOnly = await prisma.penalty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PenaltyFindManyArgs>(args?: SelectSubset<T, PenaltyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Penalty.
     * @param {PenaltyCreateArgs} args - Arguments to create a Penalty.
     * @example
     * // Create one Penalty
     * const Penalty = await prisma.penalty.create({
     *   data: {
     *     // ... data to create a Penalty
     *   }
     * })
     * 
     */
    create<T extends PenaltyCreateArgs>(args: SelectSubset<T, PenaltyCreateArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Penalties.
     * @param {PenaltyCreateManyArgs} args - Arguments to create many Penalties.
     * @example
     * // Create many Penalties
     * const penalty = await prisma.penalty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PenaltyCreateManyArgs>(args?: SelectSubset<T, PenaltyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Penalties and returns the data saved in the database.
     * @param {PenaltyCreateManyAndReturnArgs} args - Arguments to create many Penalties.
     * @example
     * // Create many Penalties
     * const penalty = await prisma.penalty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Penalties and only return the `id`
     * const penaltyWithIdOnly = await prisma.penalty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PenaltyCreateManyAndReturnArgs>(args?: SelectSubset<T, PenaltyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Penalty.
     * @param {PenaltyDeleteArgs} args - Arguments to delete one Penalty.
     * @example
     * // Delete one Penalty
     * const Penalty = await prisma.penalty.delete({
     *   where: {
     *     // ... filter to delete one Penalty
     *   }
     * })
     * 
     */
    delete<T extends PenaltyDeleteArgs>(args: SelectSubset<T, PenaltyDeleteArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Penalty.
     * @param {PenaltyUpdateArgs} args - Arguments to update one Penalty.
     * @example
     * // Update one Penalty
     * const penalty = await prisma.penalty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PenaltyUpdateArgs>(args: SelectSubset<T, PenaltyUpdateArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Penalties.
     * @param {PenaltyDeleteManyArgs} args - Arguments to filter Penalties to delete.
     * @example
     * // Delete a few Penalties
     * const { count } = await prisma.penalty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PenaltyDeleteManyArgs>(args?: SelectSubset<T, PenaltyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Penalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Penalties
     * const penalty = await prisma.penalty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PenaltyUpdateManyArgs>(args: SelectSubset<T, PenaltyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Penalties and returns the data updated in the database.
     * @param {PenaltyUpdateManyAndReturnArgs} args - Arguments to update many Penalties.
     * @example
     * // Update many Penalties
     * const penalty = await prisma.penalty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Penalties and only return the `id`
     * const penaltyWithIdOnly = await prisma.penalty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PenaltyUpdateManyAndReturnArgs>(args: SelectSubset<T, PenaltyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Penalty.
     * @param {PenaltyUpsertArgs} args - Arguments to update or create a Penalty.
     * @example
     * // Update or create a Penalty
     * const penalty = await prisma.penalty.upsert({
     *   create: {
     *     // ... data to create a Penalty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Penalty we want to update
     *   }
     * })
     */
    upsert<T extends PenaltyUpsertArgs>(args: SelectSubset<T, PenaltyUpsertArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Penalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyCountArgs} args - Arguments to filter Penalties to count.
     * @example
     * // Count the number of Penalties
     * const count = await prisma.penalty.count({
     *   where: {
     *     // ... the filter for the Penalties we want to count
     *   }
     * })
    **/
    count<T extends PenaltyCountArgs>(
      args?: Subset<T, PenaltyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PenaltyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Penalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PenaltyAggregateArgs>(args: Subset<T, PenaltyAggregateArgs>): Prisma.PrismaPromise<GetPenaltyAggregateType<T>>

    /**
     * Group by Penalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PenaltyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PenaltyGroupByArgs['orderBy'] }
        : { orderBy?: PenaltyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PenaltyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPenaltyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Penalty model
   */
  readonly fields: PenaltyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Penalty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PenaltyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionCase<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Penalty model
   */
  interface PenaltyFieldRefs {
    readonly id: FieldRef<"Penalty", 'String'>
    readonly collectionCaseId: FieldRef<"Penalty", 'String'>
    readonly description: FieldRef<"Penalty", 'String'>
    readonly amount: FieldRef<"Penalty", 'Decimal'>
    readonly dateApplied: FieldRef<"Penalty", 'DateTime'>
    readonly isPaid: FieldRef<"Penalty", 'Boolean'>
    readonly createdAt: FieldRef<"Penalty", 'DateTime'>
    readonly updatedAt: FieldRef<"Penalty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Penalty findUnique
   */
  export type PenaltyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty findUniqueOrThrow
   */
  export type PenaltyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty findFirst
   */
  export type PenaltyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Penalties.
     */
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty findFirstOrThrow
   */
  export type PenaltyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Penalties.
     */
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty findMany
   */
  export type PenaltyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalties to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty create
   */
  export type PenaltyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The data needed to create a Penalty.
     */
    data: XOR<PenaltyCreateInput, PenaltyUncheckedCreateInput>
  }

  /**
   * Penalty createMany
   */
  export type PenaltyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Penalties.
     */
    data: PenaltyCreateManyInput | PenaltyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Penalty createManyAndReturn
   */
  export type PenaltyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * The data used to create many Penalties.
     */
    data: PenaltyCreateManyInput | PenaltyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Penalty update
   */
  export type PenaltyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The data needed to update a Penalty.
     */
    data: XOR<PenaltyUpdateInput, PenaltyUncheckedUpdateInput>
    /**
     * Choose, which Penalty to update.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty updateMany
   */
  export type PenaltyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Penalties.
     */
    data: XOR<PenaltyUpdateManyMutationInput, PenaltyUncheckedUpdateManyInput>
    /**
     * Filter which Penalties to update
     */
    where?: PenaltyWhereInput
    /**
     * Limit how many Penalties to update.
     */
    limit?: number
  }

  /**
   * Penalty updateManyAndReturn
   */
  export type PenaltyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * The data used to update Penalties.
     */
    data: XOR<PenaltyUpdateManyMutationInput, PenaltyUncheckedUpdateManyInput>
    /**
     * Filter which Penalties to update
     */
    where?: PenaltyWhereInput
    /**
     * Limit how many Penalties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Penalty upsert
   */
  export type PenaltyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The filter to search for the Penalty to update in case it exists.
     */
    where: PenaltyWhereUniqueInput
    /**
     * In case the Penalty found by the `where` argument doesn't exist, create a new Penalty with this data.
     */
    create: XOR<PenaltyCreateInput, PenaltyUncheckedCreateInput>
    /**
     * In case the Penalty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PenaltyUpdateInput, PenaltyUncheckedUpdateInput>
  }

  /**
   * Penalty delete
   */
  export type PenaltyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter which Penalty to delete.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty deleteMany
   */
  export type PenaltyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Penalties to delete
     */
    where?: PenaltyWhereInput
    /**
     * Limit how many Penalties to delete.
     */
    limit?: number
  }

  /**
   * Penalty without action
   */
  export type PenaltyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    collectionCaseId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    sentAt: Date | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    collectionCaseId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    sentAt: Date | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    collectionCaseId: number
    type: number
    title: number
    message: number
    sentAt: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    collectionCaseId?: true
    type?: true
    title?: true
    message?: true
    sentAt?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    collectionCaseId?: true
    type?: true
    title?: true
    message?: true
    sentAt?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    collectionCaseId?: true
    type?: true
    title?: true
    message?: true
    sentAt?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    collectionCaseId: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt: Date
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sentAt?: boolean
    read?: boolean
    createdAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sentAt?: boolean
    read?: boolean
    createdAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sentAt?: boolean
    read?: boolean
    createdAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    collectionCaseId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sentAt?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collectionCaseId" | "type" | "title" | "message" | "sentAt" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      collectionCase: Prisma.$CollectionCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collectionCaseId: string
      type: $Enums.NotificationType
      title: string
      message: string
      sentAt: Date
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionCase<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly collectionCaseId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    createdAt: Date | null
    collectionCaseId: string | null
    paymentDate: Date | null
    referenceNumber: string | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    createdAt: Date | null
    collectionCaseId: string | null
    paymentDate: Date | null
    referenceNumber: string | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    amount: number
    method: number
    createdAt: number
    collectionCaseId: number
    paymentDate: number
    referenceNumber: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    amount?: true
    method?: true
    createdAt?: true
    collectionCaseId?: true
    paymentDate?: true
    referenceNumber?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    amount?: true
    method?: true
    createdAt?: true
    collectionCaseId?: true
    paymentDate?: true
    referenceNumber?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    amount?: true
    method?: true
    createdAt?: true
    collectionCaseId?: true
    paymentDate?: true
    referenceNumber?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    amount: Decimal
    method: $Enums.PaymentMethod
    createdAt: Date
    collectionCaseId: string
    paymentDate: Date
    referenceNumber: string | null
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    method?: boolean
    createdAt?: boolean
    collectionCaseId?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    updatedAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    method?: boolean
    createdAt?: boolean
    collectionCaseId?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    updatedAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    method?: boolean
    createdAt?: boolean
    collectionCaseId?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    updatedAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    amount?: boolean
    method?: boolean
    createdAt?: boolean
    collectionCaseId?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "method" | "createdAt" | "collectionCaseId" | "paymentDate" | "referenceNumber" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      collectionCase: Prisma.$CollectionCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: Prisma.Decimal
      method: $Enums.PaymentMethod
      createdAt: Date
      collectionCaseId: string
      paymentDate: Date
      referenceNumber: string | null
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionCase<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly collectionCaseId: FieldRef<"Payment", 'String'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly referenceNumber: FieldRef<"Payment", 'String'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model PaymentAgreement
   */

  export type AggregatePaymentAgreement = {
    _count: PaymentAgreementCountAggregateOutputType | null
    _avg: PaymentAgreementAvgAggregateOutputType | null
    _sum: PaymentAgreementSumAggregateOutputType | null
    _min: PaymentAgreementMinAggregateOutputType | null
    _max: PaymentAgreementMaxAggregateOutputType | null
  }

  export type PaymentAgreementAvgAggregateOutputType = {
    installmentAmount: Decimal | null
    totalInstallments: number | null
  }

  export type PaymentAgreementSumAggregateOutputType = {
    installmentAmount: Decimal | null
    totalInstallments: number | null
  }

  export type PaymentAgreementMinAggregateOutputType = {
    id: string | null
    debtorId: string | null
    agreementDate: Date | null
    status: $Enums.AgreementStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    collectionCaseId: string | null
    installmentAmount: Decimal | null
    nextPaymentDate: Date | null
    notes: string | null
    totalInstallments: number | null
  }

  export type PaymentAgreementMaxAggregateOutputType = {
    id: string | null
    debtorId: string | null
    agreementDate: Date | null
    status: $Enums.AgreementStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    collectionCaseId: string | null
    installmentAmount: Decimal | null
    nextPaymentDate: Date | null
    notes: string | null
    totalInstallments: number | null
  }

  export type PaymentAgreementCountAggregateOutputType = {
    id: number
    debtorId: number
    agreementDate: number
    status: number
    createdAt: number
    updatedAt: number
    collectionCaseId: number
    installmentAmount: number
    nextPaymentDate: number
    notes: number
    totalInstallments: number
    _all: number
  }


  export type PaymentAgreementAvgAggregateInputType = {
    installmentAmount?: true
    totalInstallments?: true
  }

  export type PaymentAgreementSumAggregateInputType = {
    installmentAmount?: true
    totalInstallments?: true
  }

  export type PaymentAgreementMinAggregateInputType = {
    id?: true
    debtorId?: true
    agreementDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    collectionCaseId?: true
    installmentAmount?: true
    nextPaymentDate?: true
    notes?: true
    totalInstallments?: true
  }

  export type PaymentAgreementMaxAggregateInputType = {
    id?: true
    debtorId?: true
    agreementDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    collectionCaseId?: true
    installmentAmount?: true
    nextPaymentDate?: true
    notes?: true
    totalInstallments?: true
  }

  export type PaymentAgreementCountAggregateInputType = {
    id?: true
    debtorId?: true
    agreementDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    collectionCaseId?: true
    installmentAmount?: true
    nextPaymentDate?: true
    notes?: true
    totalInstallments?: true
    _all?: true
  }

  export type PaymentAgreementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAgreement to aggregate.
     */
    where?: PaymentAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAgreements to fetch.
     */
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentAgreements
    **/
    _count?: true | PaymentAgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAgreementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentAgreementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentAgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentAgreementMaxAggregateInputType
  }

  export type GetPaymentAgreementAggregateType<T extends PaymentAgreementAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentAgreement[P]>
      : GetScalarType<T[P], AggregatePaymentAgreement[P]>
  }




  export type PaymentAgreementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAgreementWhereInput
    orderBy?: PaymentAgreementOrderByWithAggregationInput | PaymentAgreementOrderByWithAggregationInput[]
    by: PaymentAgreementScalarFieldEnum[] | PaymentAgreementScalarFieldEnum
    having?: PaymentAgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentAgreementCountAggregateInputType | true
    _avg?: PaymentAgreementAvgAggregateInputType
    _sum?: PaymentAgreementSumAggregateInputType
    _min?: PaymentAgreementMinAggregateInputType
    _max?: PaymentAgreementMaxAggregateInputType
  }

  export type PaymentAgreementGroupByOutputType = {
    id: string
    debtorId: string | null
    agreementDate: Date
    status: $Enums.AgreementStatus
    createdAt: Date
    updatedAt: Date
    collectionCaseId: string
    installmentAmount: Decimal | null
    nextPaymentDate: Date | null
    notes: string | null
    totalInstallments: number | null
    _count: PaymentAgreementCountAggregateOutputType | null
    _avg: PaymentAgreementAvgAggregateOutputType | null
    _sum: PaymentAgreementSumAggregateOutputType | null
    _min: PaymentAgreementMinAggregateOutputType | null
    _max: PaymentAgreementMaxAggregateOutputType | null
  }

  type GetPaymentAgreementGroupByPayload<T extends PaymentAgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentAgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentAgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentAgreementGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentAgreementGroupByOutputType[P]>
        }
      >
    >


  export type PaymentAgreementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtorId?: boolean
    agreementDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCaseId?: boolean
    installmentAmount?: boolean
    nextPaymentDate?: boolean
    notes?: boolean
    totalInstallments?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAgreement"]>

  export type PaymentAgreementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtorId?: boolean
    agreementDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCaseId?: boolean
    installmentAmount?: boolean
    nextPaymentDate?: boolean
    notes?: boolean
    totalInstallments?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAgreement"]>

  export type PaymentAgreementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtorId?: boolean
    agreementDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCaseId?: boolean
    installmentAmount?: boolean
    nextPaymentDate?: boolean
    notes?: boolean
    totalInstallments?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAgreement"]>

  export type PaymentAgreementSelectScalar = {
    id?: boolean
    debtorId?: boolean
    agreementDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCaseId?: boolean
    installmentAmount?: boolean
    nextPaymentDate?: boolean
    notes?: boolean
    totalInstallments?: boolean
  }

  export type PaymentAgreementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "debtorId" | "agreementDate" | "status" | "createdAt" | "updatedAt" | "collectionCaseId" | "installmentAmount" | "nextPaymentDate" | "notes" | "totalInstallments", ExtArgs["result"]["paymentAgreement"]>
  export type PaymentAgreementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
  }
  export type PaymentAgreementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
  }
  export type PaymentAgreementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
  }

  export type $PaymentAgreementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentAgreement"
    objects: {
      collectionCase: Prisma.$CollectionCasePayload<ExtArgs>
      Debtor: Prisma.$DebtorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      debtorId: string | null
      agreementDate: Date
      status: $Enums.AgreementStatus
      createdAt: Date
      updatedAt: Date
      collectionCaseId: string
      installmentAmount: Prisma.Decimal | null
      nextPaymentDate: Date | null
      notes: string | null
      totalInstallments: number | null
    }, ExtArgs["result"]["paymentAgreement"]>
    composites: {}
  }

  type PaymentAgreementGetPayload<S extends boolean | null | undefined | PaymentAgreementDefaultArgs> = $Result.GetResult<Prisma.$PaymentAgreementPayload, S>

  type PaymentAgreementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentAgreementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentAgreementCountAggregateInputType | true
    }

  export interface PaymentAgreementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentAgreement'], meta: { name: 'PaymentAgreement' } }
    /**
     * Find zero or one PaymentAgreement that matches the filter.
     * @param {PaymentAgreementFindUniqueArgs} args - Arguments to find a PaymentAgreement
     * @example
     * // Get one PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentAgreementFindUniqueArgs>(args: SelectSubset<T, PaymentAgreementFindUniqueArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentAgreement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentAgreementFindUniqueOrThrowArgs} args - Arguments to find a PaymentAgreement
     * @example
     * // Get one PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentAgreementFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentAgreementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentAgreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementFindFirstArgs} args - Arguments to find a PaymentAgreement
     * @example
     * // Get one PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentAgreementFindFirstArgs>(args?: SelectSubset<T, PaymentAgreementFindFirstArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentAgreement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementFindFirstOrThrowArgs} args - Arguments to find a PaymentAgreement
     * @example
     * // Get one PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentAgreementFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentAgreementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentAgreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentAgreements
     * const paymentAgreements = await prisma.paymentAgreement.findMany()
     * 
     * // Get first 10 PaymentAgreements
     * const paymentAgreements = await prisma.paymentAgreement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentAgreementWithIdOnly = await prisma.paymentAgreement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentAgreementFindManyArgs>(args?: SelectSubset<T, PaymentAgreementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentAgreement.
     * @param {PaymentAgreementCreateArgs} args - Arguments to create a PaymentAgreement.
     * @example
     * // Create one PaymentAgreement
     * const PaymentAgreement = await prisma.paymentAgreement.create({
     *   data: {
     *     // ... data to create a PaymentAgreement
     *   }
     * })
     * 
     */
    create<T extends PaymentAgreementCreateArgs>(args: SelectSubset<T, PaymentAgreementCreateArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentAgreements.
     * @param {PaymentAgreementCreateManyArgs} args - Arguments to create many PaymentAgreements.
     * @example
     * // Create many PaymentAgreements
     * const paymentAgreement = await prisma.paymentAgreement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentAgreementCreateManyArgs>(args?: SelectSubset<T, PaymentAgreementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentAgreements and returns the data saved in the database.
     * @param {PaymentAgreementCreateManyAndReturnArgs} args - Arguments to create many PaymentAgreements.
     * @example
     * // Create many PaymentAgreements
     * const paymentAgreement = await prisma.paymentAgreement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentAgreements and only return the `id`
     * const paymentAgreementWithIdOnly = await prisma.paymentAgreement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentAgreementCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentAgreementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentAgreement.
     * @param {PaymentAgreementDeleteArgs} args - Arguments to delete one PaymentAgreement.
     * @example
     * // Delete one PaymentAgreement
     * const PaymentAgreement = await prisma.paymentAgreement.delete({
     *   where: {
     *     // ... filter to delete one PaymentAgreement
     *   }
     * })
     * 
     */
    delete<T extends PaymentAgreementDeleteArgs>(args: SelectSubset<T, PaymentAgreementDeleteArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentAgreement.
     * @param {PaymentAgreementUpdateArgs} args - Arguments to update one PaymentAgreement.
     * @example
     * // Update one PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentAgreementUpdateArgs>(args: SelectSubset<T, PaymentAgreementUpdateArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentAgreements.
     * @param {PaymentAgreementDeleteManyArgs} args - Arguments to filter PaymentAgreements to delete.
     * @example
     * // Delete a few PaymentAgreements
     * const { count } = await prisma.paymentAgreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentAgreementDeleteManyArgs>(args?: SelectSubset<T, PaymentAgreementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentAgreements
     * const paymentAgreement = await prisma.paymentAgreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentAgreementUpdateManyArgs>(args: SelectSubset<T, PaymentAgreementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAgreements and returns the data updated in the database.
     * @param {PaymentAgreementUpdateManyAndReturnArgs} args - Arguments to update many PaymentAgreements.
     * @example
     * // Update many PaymentAgreements
     * const paymentAgreement = await prisma.paymentAgreement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentAgreements and only return the `id`
     * const paymentAgreementWithIdOnly = await prisma.paymentAgreement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentAgreementUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentAgreementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentAgreement.
     * @param {PaymentAgreementUpsertArgs} args - Arguments to update or create a PaymentAgreement.
     * @example
     * // Update or create a PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.upsert({
     *   create: {
     *     // ... data to create a PaymentAgreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentAgreement we want to update
     *   }
     * })
     */
    upsert<T extends PaymentAgreementUpsertArgs>(args: SelectSubset<T, PaymentAgreementUpsertArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementCountArgs} args - Arguments to filter PaymentAgreements to count.
     * @example
     * // Count the number of PaymentAgreements
     * const count = await prisma.paymentAgreement.count({
     *   where: {
     *     // ... the filter for the PaymentAgreements we want to count
     *   }
     * })
    **/
    count<T extends PaymentAgreementCountArgs>(
      args?: Subset<T, PaymentAgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentAgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAgreementAggregateArgs>(args: Subset<T, PaymentAgreementAggregateArgs>): Prisma.PrismaPromise<GetPaymentAgreementAggregateType<T>>

    /**
     * Group by PaymentAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentAgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentAgreementGroupByArgs['orderBy'] }
        : { orderBy?: PaymentAgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentAgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentAgreement model
   */
  readonly fields: PaymentAgreementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentAgreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentAgreementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionCase<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Debtor<T extends PaymentAgreement$DebtorArgs<ExtArgs> = {}>(args?: Subset<T, PaymentAgreement$DebtorArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentAgreement model
   */
  interface PaymentAgreementFieldRefs {
    readonly id: FieldRef<"PaymentAgreement", 'String'>
    readonly debtorId: FieldRef<"PaymentAgreement", 'String'>
    readonly agreementDate: FieldRef<"PaymentAgreement", 'DateTime'>
    readonly status: FieldRef<"PaymentAgreement", 'AgreementStatus'>
    readonly createdAt: FieldRef<"PaymentAgreement", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentAgreement", 'DateTime'>
    readonly collectionCaseId: FieldRef<"PaymentAgreement", 'String'>
    readonly installmentAmount: FieldRef<"PaymentAgreement", 'Decimal'>
    readonly nextPaymentDate: FieldRef<"PaymentAgreement", 'DateTime'>
    readonly notes: FieldRef<"PaymentAgreement", 'String'>
    readonly totalInstallments: FieldRef<"PaymentAgreement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PaymentAgreement findUnique
   */
  export type PaymentAgreementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAgreement to fetch.
     */
    where: PaymentAgreementWhereUniqueInput
  }

  /**
   * PaymentAgreement findUniqueOrThrow
   */
  export type PaymentAgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAgreement to fetch.
     */
    where: PaymentAgreementWhereUniqueInput
  }

  /**
   * PaymentAgreement findFirst
   */
  export type PaymentAgreementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAgreement to fetch.
     */
    where?: PaymentAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAgreements to fetch.
     */
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAgreements.
     */
    cursor?: PaymentAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAgreements.
     */
    distinct?: PaymentAgreementScalarFieldEnum | PaymentAgreementScalarFieldEnum[]
  }

  /**
   * PaymentAgreement findFirstOrThrow
   */
  export type PaymentAgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAgreement to fetch.
     */
    where?: PaymentAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAgreements to fetch.
     */
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAgreements.
     */
    cursor?: PaymentAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAgreements.
     */
    distinct?: PaymentAgreementScalarFieldEnum | PaymentAgreementScalarFieldEnum[]
  }

  /**
   * PaymentAgreement findMany
   */
  export type PaymentAgreementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAgreements to fetch.
     */
    where?: PaymentAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAgreements to fetch.
     */
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentAgreements.
     */
    cursor?: PaymentAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAgreements.
     */
    skip?: number
    distinct?: PaymentAgreementScalarFieldEnum | PaymentAgreementScalarFieldEnum[]
  }

  /**
   * PaymentAgreement create
   */
  export type PaymentAgreementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentAgreement.
     */
    data: XOR<PaymentAgreementCreateInput, PaymentAgreementUncheckedCreateInput>
  }

  /**
   * PaymentAgreement createMany
   */
  export type PaymentAgreementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentAgreements.
     */
    data: PaymentAgreementCreateManyInput | PaymentAgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentAgreement createManyAndReturn
   */
  export type PaymentAgreementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentAgreements.
     */
    data: PaymentAgreementCreateManyInput | PaymentAgreementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentAgreement update
   */
  export type PaymentAgreementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentAgreement.
     */
    data: XOR<PaymentAgreementUpdateInput, PaymentAgreementUncheckedUpdateInput>
    /**
     * Choose, which PaymentAgreement to update.
     */
    where: PaymentAgreementWhereUniqueInput
  }

  /**
   * PaymentAgreement updateMany
   */
  export type PaymentAgreementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentAgreements.
     */
    data: XOR<PaymentAgreementUpdateManyMutationInput, PaymentAgreementUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAgreements to update
     */
    where?: PaymentAgreementWhereInput
    /**
     * Limit how many PaymentAgreements to update.
     */
    limit?: number
  }

  /**
   * PaymentAgreement updateManyAndReturn
   */
  export type PaymentAgreementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * The data used to update PaymentAgreements.
     */
    data: XOR<PaymentAgreementUpdateManyMutationInput, PaymentAgreementUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAgreements to update
     */
    where?: PaymentAgreementWhereInput
    /**
     * Limit how many PaymentAgreements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentAgreement upsert
   */
  export type PaymentAgreementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentAgreement to update in case it exists.
     */
    where: PaymentAgreementWhereUniqueInput
    /**
     * In case the PaymentAgreement found by the `where` argument doesn't exist, create a new PaymentAgreement with this data.
     */
    create: XOR<PaymentAgreementCreateInput, PaymentAgreementUncheckedCreateInput>
    /**
     * In case the PaymentAgreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentAgreementUpdateInput, PaymentAgreementUncheckedUpdateInput>
  }

  /**
   * PaymentAgreement delete
   */
  export type PaymentAgreementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter which PaymentAgreement to delete.
     */
    where: PaymentAgreementWhereUniqueInput
  }

  /**
   * PaymentAgreement deleteMany
   */
  export type PaymentAgreementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAgreements to delete
     */
    where?: PaymentAgreementWhereInput
    /**
     * Limit how many PaymentAgreements to delete.
     */
    limit?: number
  }

  /**
   * PaymentAgreement.Debtor
   */
  export type PaymentAgreement$DebtorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    where?: DebtorWhereInput
  }

  /**
   * PaymentAgreement without action
   */
  export type PaymentAgreementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
  }


  /**
   * Model Debtor
   */

  export type AggregateDebtor = {
    _count: DebtorCountAggregateOutputType | null
    _avg: DebtorAvgAggregateOutputType | null
    _sum: DebtorSumAggregateOutputType | null
    _min: DebtorMinAggregateOutputType | null
    _max: DebtorMaxAggregateOutputType | null
  }

  export type DebtorAvgAggregateOutputType = {
    totalIncome: number | null
  }

  export type DebtorSumAggregateOutputType = {
    totalIncome: number | null
  }

  export type DebtorMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    fullname: string | null
    email: string | null
    phone: string | null
    address: string | null
    personType: string | null
    identificationType: $Enums.IdentificationType | null
    identification: string | null
    totalIncome: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtorMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    fullname: string | null
    email: string | null
    phone: string | null
    address: string | null
    personType: string | null
    identificationType: $Enums.IdentificationType | null
    identification: string | null
    totalIncome: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtorCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    fullname: number
    email: number
    phone: number
    address: number
    personType: number
    identificationType: number
    identification: number
    totalIncome: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DebtorAvgAggregateInputType = {
    totalIncome?: true
  }

  export type DebtorSumAggregateInputType = {
    totalIncome?: true
  }

  export type DebtorMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    fullname?: true
    email?: true
    phone?: true
    address?: true
    personType?: true
    identificationType?: true
    identification?: true
    totalIncome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtorMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    fullname?: true
    email?: true
    phone?: true
    address?: true
    personType?: true
    identificationType?: true
    identification?: true
    totalIncome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtorCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    fullname?: true
    email?: true
    phone?: true
    address?: true
    personType?: true
    identificationType?: true
    identification?: true
    totalIncome?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DebtorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debtor to aggregate.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Debtors
    **/
    _count?: true | DebtorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtorMaxAggregateInputType
  }

  export type GetDebtorAggregateType<T extends DebtorAggregateArgs> = {
        [P in keyof T & keyof AggregateDebtor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebtor[P]>
      : GetScalarType<T[P], AggregateDebtor[P]>
  }




  export type DebtorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorWhereInput
    orderBy?: DebtorOrderByWithAggregationInput | DebtorOrderByWithAggregationInput[]
    by: DebtorScalarFieldEnum[] | DebtorScalarFieldEnum
    having?: DebtorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtorCountAggregateInputType | true
    _avg?: DebtorAvgAggregateInputType
    _sum?: DebtorSumAggregateInputType
    _min?: DebtorMinAggregateInputType
    _max?: DebtorMaxAggregateInputType
  }

  export type DebtorGroupByOutputType = {
    id: string
    tenantId: string
    userId: string | null
    fullname: string
    email: string
    phone: string | null
    address: string | null
    personType: string | null
    identificationType: $Enums.IdentificationType | null
    identification: string | null
    totalIncome: number | null
    createdAt: Date
    updatedAt: Date
    _count: DebtorCountAggregateOutputType | null
    _avg: DebtorAvgAggregateOutputType | null
    _sum: DebtorSumAggregateOutputType | null
    _min: DebtorMinAggregateOutputType | null
    _max: DebtorMaxAggregateOutputType | null
  }

  type GetDebtorGroupByPayload<T extends DebtorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtorGroupByOutputType[P]>
            : GetScalarType<T[P], DebtorGroupByOutputType[P]>
        }
      >
    >


  export type DebtorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    personType?: boolean
    identificationType?: boolean
    identification?: boolean
    totalIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCases?: boolean | Debtor$collectionCasesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
    incomes?: boolean | Debtor$incomesArgs<ExtArgs>
    paymentAgreements?: boolean | Debtor$paymentAgreementsArgs<ExtArgs>
    verdicts?: boolean | Debtor$verdictsArgs<ExtArgs>
    _count?: boolean | DebtorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtor"]>

  export type DebtorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    personType?: boolean
    identificationType?: boolean
    identification?: boolean
    totalIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }, ExtArgs["result"]["debtor"]>

  export type DebtorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    personType?: boolean
    identificationType?: boolean
    identification?: boolean
    totalIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }, ExtArgs["result"]["debtor"]>

  export type DebtorSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    personType?: boolean
    identificationType?: boolean
    identification?: boolean
    totalIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DebtorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "fullname" | "email" | "phone" | "address" | "personType" | "identificationType" | "identification" | "totalIncome" | "createdAt" | "updatedAt", ExtArgs["result"]["debtor"]>
  export type DebtorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCases?: boolean | Debtor$collectionCasesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
    incomes?: boolean | Debtor$incomesArgs<ExtArgs>
    paymentAgreements?: boolean | Debtor$paymentAgreementsArgs<ExtArgs>
    verdicts?: boolean | Debtor$verdictsArgs<ExtArgs>
    _count?: boolean | DebtorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DebtorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }
  export type DebtorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }

  export type $DebtorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Debtor"
    objects: {
      collectionCases: Prisma.$CollectionCasePayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      incomes: Prisma.$DebtorIncomePayload<ExtArgs>[]
      paymentAgreements: Prisma.$PaymentAgreementPayload<ExtArgs>[]
      verdicts: Prisma.$VerdictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string | null
      fullname: string
      email: string
      phone: string | null
      address: string | null
      personType: string | null
      identificationType: $Enums.IdentificationType | null
      identification: string | null
      totalIncome: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["debtor"]>
    composites: {}
  }

  type DebtorGetPayload<S extends boolean | null | undefined | DebtorDefaultArgs> = $Result.GetResult<Prisma.$DebtorPayload, S>

  type DebtorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DebtorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DebtorCountAggregateInputType | true
    }

  export interface DebtorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Debtor'], meta: { name: 'Debtor' } }
    /**
     * Find zero or one Debtor that matches the filter.
     * @param {DebtorFindUniqueArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtorFindUniqueArgs>(args: SelectSubset<T, DebtorFindUniqueArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Debtor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DebtorFindUniqueOrThrowArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtorFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debtor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorFindFirstArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtorFindFirstArgs>(args?: SelectSubset<T, DebtorFindFirstArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debtor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorFindFirstOrThrowArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtorFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Debtors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Debtors
     * const debtors = await prisma.debtor.findMany()
     * 
     * // Get first 10 Debtors
     * const debtors = await prisma.debtor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtorWithIdOnly = await prisma.debtor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtorFindManyArgs>(args?: SelectSubset<T, DebtorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Debtor.
     * @param {DebtorCreateArgs} args - Arguments to create a Debtor.
     * @example
     * // Create one Debtor
     * const Debtor = await prisma.debtor.create({
     *   data: {
     *     // ... data to create a Debtor
     *   }
     * })
     * 
     */
    create<T extends DebtorCreateArgs>(args: SelectSubset<T, DebtorCreateArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Debtors.
     * @param {DebtorCreateManyArgs} args - Arguments to create many Debtors.
     * @example
     * // Create many Debtors
     * const debtor = await prisma.debtor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtorCreateManyArgs>(args?: SelectSubset<T, DebtorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Debtors and returns the data saved in the database.
     * @param {DebtorCreateManyAndReturnArgs} args - Arguments to create many Debtors.
     * @example
     * // Create many Debtors
     * const debtor = await prisma.debtor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Debtors and only return the `id`
     * const debtorWithIdOnly = await prisma.debtor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DebtorCreateManyAndReturnArgs>(args?: SelectSubset<T, DebtorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Debtor.
     * @param {DebtorDeleteArgs} args - Arguments to delete one Debtor.
     * @example
     * // Delete one Debtor
     * const Debtor = await prisma.debtor.delete({
     *   where: {
     *     // ... filter to delete one Debtor
     *   }
     * })
     * 
     */
    delete<T extends DebtorDeleteArgs>(args: SelectSubset<T, DebtorDeleteArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Debtor.
     * @param {DebtorUpdateArgs} args - Arguments to update one Debtor.
     * @example
     * // Update one Debtor
     * const debtor = await prisma.debtor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtorUpdateArgs>(args: SelectSubset<T, DebtorUpdateArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Debtors.
     * @param {DebtorDeleteManyArgs} args - Arguments to filter Debtors to delete.
     * @example
     * // Delete a few Debtors
     * const { count } = await prisma.debtor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtorDeleteManyArgs>(args?: SelectSubset<T, DebtorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debtors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Debtors
     * const debtor = await prisma.debtor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtorUpdateManyArgs>(args: SelectSubset<T, DebtorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debtors and returns the data updated in the database.
     * @param {DebtorUpdateManyAndReturnArgs} args - Arguments to update many Debtors.
     * @example
     * // Update many Debtors
     * const debtor = await prisma.debtor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Debtors and only return the `id`
     * const debtorWithIdOnly = await prisma.debtor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DebtorUpdateManyAndReturnArgs>(args: SelectSubset<T, DebtorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Debtor.
     * @param {DebtorUpsertArgs} args - Arguments to update or create a Debtor.
     * @example
     * // Update or create a Debtor
     * const debtor = await prisma.debtor.upsert({
     *   create: {
     *     // ... data to create a Debtor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Debtor we want to update
     *   }
     * })
     */
    upsert<T extends DebtorUpsertArgs>(args: SelectSubset<T, DebtorUpsertArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Debtors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorCountArgs} args - Arguments to filter Debtors to count.
     * @example
     * // Count the number of Debtors
     * const count = await prisma.debtor.count({
     *   where: {
     *     // ... the filter for the Debtors we want to count
     *   }
     * })
    **/
    count<T extends DebtorCountArgs>(
      args?: Subset<T, DebtorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Debtor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtorAggregateArgs>(args: Subset<T, DebtorAggregateArgs>): Prisma.PrismaPromise<GetDebtorAggregateType<T>>

    /**
     * Group by Debtor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtorGroupByArgs['orderBy'] }
        : { orderBy?: DebtorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Debtor model
   */
  readonly fields: DebtorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Debtor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionCases<T extends Debtor$collectionCasesArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$collectionCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Debtor$userArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    incomes<T extends Debtor$incomesArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$incomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentAgreements<T extends Debtor$paymentAgreementsArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$paymentAgreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdicts<T extends Debtor$verdictsArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$verdictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Debtor model
   */
  interface DebtorFieldRefs {
    readonly id: FieldRef<"Debtor", 'String'>
    readonly tenantId: FieldRef<"Debtor", 'String'>
    readonly userId: FieldRef<"Debtor", 'String'>
    readonly fullname: FieldRef<"Debtor", 'String'>
    readonly email: FieldRef<"Debtor", 'String'>
    readonly phone: FieldRef<"Debtor", 'String'>
    readonly address: FieldRef<"Debtor", 'String'>
    readonly personType: FieldRef<"Debtor", 'String'>
    readonly identificationType: FieldRef<"Debtor", 'IdentificationType'>
    readonly identification: FieldRef<"Debtor", 'String'>
    readonly totalIncome: FieldRef<"Debtor", 'Float'>
    readonly createdAt: FieldRef<"Debtor", 'DateTime'>
    readonly updatedAt: FieldRef<"Debtor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Debtor findUnique
   */
  export type DebtorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor findUniqueOrThrow
   */
  export type DebtorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor findFirst
   */
  export type DebtorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debtors.
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debtors.
     */
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Debtor findFirstOrThrow
   */
  export type DebtorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debtors.
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debtors.
     */
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Debtor findMany
   */
  export type DebtorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtors to fetch.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Debtors.
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Debtor create
   */
  export type DebtorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * The data needed to create a Debtor.
     */
    data: XOR<DebtorCreateInput, DebtorUncheckedCreateInput>
  }

  /**
   * Debtor createMany
   */
  export type DebtorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Debtors.
     */
    data: DebtorCreateManyInput | DebtorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Debtor createManyAndReturn
   */
  export type DebtorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * The data used to create many Debtors.
     */
    data: DebtorCreateManyInput | DebtorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Debtor update
   */
  export type DebtorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * The data needed to update a Debtor.
     */
    data: XOR<DebtorUpdateInput, DebtorUncheckedUpdateInput>
    /**
     * Choose, which Debtor to update.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor updateMany
   */
  export type DebtorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Debtors.
     */
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyInput>
    /**
     * Filter which Debtors to update
     */
    where?: DebtorWhereInput
    /**
     * Limit how many Debtors to update.
     */
    limit?: number
  }

  /**
   * Debtor updateManyAndReturn
   */
  export type DebtorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * The data used to update Debtors.
     */
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyInput>
    /**
     * Filter which Debtors to update
     */
    where?: DebtorWhereInput
    /**
     * Limit how many Debtors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Debtor upsert
   */
  export type DebtorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * The filter to search for the Debtor to update in case it exists.
     */
    where: DebtorWhereUniqueInput
    /**
     * In case the Debtor found by the `where` argument doesn't exist, create a new Debtor with this data.
     */
    create: XOR<DebtorCreateInput, DebtorUncheckedCreateInput>
    /**
     * In case the Debtor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtorUpdateInput, DebtorUncheckedUpdateInput>
  }

  /**
   * Debtor delete
   */
  export type DebtorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter which Debtor to delete.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor deleteMany
   */
  export type DebtorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debtors to delete
     */
    where?: DebtorWhereInput
    /**
     * Limit how many Debtors to delete.
     */
    limit?: number
  }

  /**
   * Debtor.collectionCases
   */
  export type Debtor$collectionCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    where?: CollectionCaseWhereInput
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    cursor?: CollectionCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * Debtor.user
   */
  export type Debtor$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Debtor.incomes
   */
  export type Debtor$incomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    where?: DebtorIncomeWhereInput
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    cursor?: DebtorIncomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * Debtor.paymentAgreements
   */
  export type Debtor$paymentAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    where?: PaymentAgreementWhereInput
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    cursor?: PaymentAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentAgreementScalarFieldEnum | PaymentAgreementScalarFieldEnum[]
  }

  /**
   * Debtor.verdicts
   */
  export type Debtor$verdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    cursor?: VerdictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Debtor without action
   */
  export type DebtorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
  }


  /**
   * Model DebtorIncome
   */

  export type AggregateDebtorIncome = {
    _count: DebtorIncomeCountAggregateOutputType | null
    _avg: DebtorIncomeAvgAggregateOutputType | null
    _sum: DebtorIncomeSumAggregateOutputType | null
    _min: DebtorIncomeMinAggregateOutputType | null
    _max: DebtorIncomeMaxAggregateOutputType | null
  }

  export type DebtorIncomeAvgAggregateOutputType = {
    amount: number | null
  }

  export type DebtorIncomeSumAggregateOutputType = {
    amount: number | null
  }

  export type DebtorIncomeMinAggregateOutputType = {
    id: string | null
    debtorId: string | null
    amount: number | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtorIncomeMaxAggregateOutputType = {
    id: string | null
    debtorId: string | null
    amount: number | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtorIncomeCountAggregateOutputType = {
    id: number
    debtorId: number
    amount: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DebtorIncomeAvgAggregateInputType = {
    amount?: true
  }

  export type DebtorIncomeSumAggregateInputType = {
    amount?: true
  }

  export type DebtorIncomeMinAggregateInputType = {
    id?: true
    debtorId?: true
    amount?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtorIncomeMaxAggregateInputType = {
    id?: true
    debtorId?: true
    amount?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtorIncomeCountAggregateInputType = {
    id?: true
    debtorId?: true
    amount?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DebtorIncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtorIncome to aggregate.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DebtorIncomes
    **/
    _count?: true | DebtorIncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtorIncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtorIncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtorIncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtorIncomeMaxAggregateInputType
  }

  export type GetDebtorIncomeAggregateType<T extends DebtorIncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateDebtorIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebtorIncome[P]>
      : GetScalarType<T[P], AggregateDebtorIncome[P]>
  }




  export type DebtorIncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorIncomeWhereInput
    orderBy?: DebtorIncomeOrderByWithAggregationInput | DebtorIncomeOrderByWithAggregationInput[]
    by: DebtorIncomeScalarFieldEnum[] | DebtorIncomeScalarFieldEnum
    having?: DebtorIncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtorIncomeCountAggregateInputType | true
    _avg?: DebtorIncomeAvgAggregateInputType
    _sum?: DebtorIncomeSumAggregateInputType
    _min?: DebtorIncomeMinAggregateInputType
    _max?: DebtorIncomeMaxAggregateInputType
  }

  export type DebtorIncomeGroupByOutputType = {
    id: string
    debtorId: string
    amount: number
    source: string
    createdAt: Date
    updatedAt: Date
    _count: DebtorIncomeCountAggregateOutputType | null
    _avg: DebtorIncomeAvgAggregateOutputType | null
    _sum: DebtorIncomeSumAggregateOutputType | null
    _min: DebtorIncomeMinAggregateOutputType | null
    _max: DebtorIncomeMaxAggregateOutputType | null
  }

  type GetDebtorIncomeGroupByPayload<T extends DebtorIncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtorIncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtorIncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtorIncomeGroupByOutputType[P]>
            : GetScalarType<T[P], DebtorIncomeGroupByOutputType[P]>
        }
      >
    >


  export type DebtorIncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtorId?: boolean
    amount?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtorIncome"]>

  export type DebtorIncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtorId?: boolean
    amount?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtorIncome"]>

  export type DebtorIncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtorId?: boolean
    amount?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtorIncome"]>

  export type DebtorIncomeSelectScalar = {
    id?: boolean
    debtorId?: boolean
    amount?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DebtorIncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "debtorId" | "amount" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["debtorIncome"]>
  export type DebtorIncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }
  export type DebtorIncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }
  export type DebtorIncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }

  export type $DebtorIncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DebtorIncome"
    objects: {
      debtor: Prisma.$DebtorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      debtorId: string
      amount: number
      source: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["debtorIncome"]>
    composites: {}
  }

  type DebtorIncomeGetPayload<S extends boolean | null | undefined | DebtorIncomeDefaultArgs> = $Result.GetResult<Prisma.$DebtorIncomePayload, S>

  type DebtorIncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DebtorIncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DebtorIncomeCountAggregateInputType | true
    }

  export interface DebtorIncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DebtorIncome'], meta: { name: 'DebtorIncome' } }
    /**
     * Find zero or one DebtorIncome that matches the filter.
     * @param {DebtorIncomeFindUniqueArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtorIncomeFindUniqueArgs>(args: SelectSubset<T, DebtorIncomeFindUniqueArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DebtorIncome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DebtorIncomeFindUniqueOrThrowArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtorIncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtorIncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DebtorIncome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeFindFirstArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtorIncomeFindFirstArgs>(args?: SelectSubset<T, DebtorIncomeFindFirstArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DebtorIncome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeFindFirstOrThrowArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtorIncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtorIncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DebtorIncomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DebtorIncomes
     * const debtorIncomes = await prisma.debtorIncome.findMany()
     * 
     * // Get first 10 DebtorIncomes
     * const debtorIncomes = await prisma.debtorIncome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtorIncomeWithIdOnly = await prisma.debtorIncome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtorIncomeFindManyArgs>(args?: SelectSubset<T, DebtorIncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DebtorIncome.
     * @param {DebtorIncomeCreateArgs} args - Arguments to create a DebtorIncome.
     * @example
     * // Create one DebtorIncome
     * const DebtorIncome = await prisma.debtorIncome.create({
     *   data: {
     *     // ... data to create a DebtorIncome
     *   }
     * })
     * 
     */
    create<T extends DebtorIncomeCreateArgs>(args: SelectSubset<T, DebtorIncomeCreateArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DebtorIncomes.
     * @param {DebtorIncomeCreateManyArgs} args - Arguments to create many DebtorIncomes.
     * @example
     * // Create many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtorIncomeCreateManyArgs>(args?: SelectSubset<T, DebtorIncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DebtorIncomes and returns the data saved in the database.
     * @param {DebtorIncomeCreateManyAndReturnArgs} args - Arguments to create many DebtorIncomes.
     * @example
     * // Create many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DebtorIncomes and only return the `id`
     * const debtorIncomeWithIdOnly = await prisma.debtorIncome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DebtorIncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, DebtorIncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DebtorIncome.
     * @param {DebtorIncomeDeleteArgs} args - Arguments to delete one DebtorIncome.
     * @example
     * // Delete one DebtorIncome
     * const DebtorIncome = await prisma.debtorIncome.delete({
     *   where: {
     *     // ... filter to delete one DebtorIncome
     *   }
     * })
     * 
     */
    delete<T extends DebtorIncomeDeleteArgs>(args: SelectSubset<T, DebtorIncomeDeleteArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DebtorIncome.
     * @param {DebtorIncomeUpdateArgs} args - Arguments to update one DebtorIncome.
     * @example
     * // Update one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtorIncomeUpdateArgs>(args: SelectSubset<T, DebtorIncomeUpdateArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DebtorIncomes.
     * @param {DebtorIncomeDeleteManyArgs} args - Arguments to filter DebtorIncomes to delete.
     * @example
     * // Delete a few DebtorIncomes
     * const { count } = await prisma.debtorIncome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtorIncomeDeleteManyArgs>(args?: SelectSubset<T, DebtorIncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DebtorIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtorIncomeUpdateManyArgs>(args: SelectSubset<T, DebtorIncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DebtorIncomes and returns the data updated in the database.
     * @param {DebtorIncomeUpdateManyAndReturnArgs} args - Arguments to update many DebtorIncomes.
     * @example
     * // Update many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DebtorIncomes and only return the `id`
     * const debtorIncomeWithIdOnly = await prisma.debtorIncome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DebtorIncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, DebtorIncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DebtorIncome.
     * @param {DebtorIncomeUpsertArgs} args - Arguments to update or create a DebtorIncome.
     * @example
     * // Update or create a DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.upsert({
     *   create: {
     *     // ... data to create a DebtorIncome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DebtorIncome we want to update
     *   }
     * })
     */
    upsert<T extends DebtorIncomeUpsertArgs>(args: SelectSubset<T, DebtorIncomeUpsertArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DebtorIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeCountArgs} args - Arguments to filter DebtorIncomes to count.
     * @example
     * // Count the number of DebtorIncomes
     * const count = await prisma.debtorIncome.count({
     *   where: {
     *     // ... the filter for the DebtorIncomes we want to count
     *   }
     * })
    **/
    count<T extends DebtorIncomeCountArgs>(
      args?: Subset<T, DebtorIncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtorIncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DebtorIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtorIncomeAggregateArgs>(args: Subset<T, DebtorIncomeAggregateArgs>): Prisma.PrismaPromise<GetDebtorIncomeAggregateType<T>>

    /**
     * Group by DebtorIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtorIncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtorIncomeGroupByArgs['orderBy'] }
        : { orderBy?: DebtorIncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtorIncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtorIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DebtorIncome model
   */
  readonly fields: DebtorIncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DebtorIncome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtorIncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    debtor<T extends DebtorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtorDefaultArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DebtorIncome model
   */
  interface DebtorIncomeFieldRefs {
    readonly id: FieldRef<"DebtorIncome", 'String'>
    readonly debtorId: FieldRef<"DebtorIncome", 'String'>
    readonly amount: FieldRef<"DebtorIncome", 'Float'>
    readonly source: FieldRef<"DebtorIncome", 'String'>
    readonly createdAt: FieldRef<"DebtorIncome", 'DateTime'>
    readonly updatedAt: FieldRef<"DebtorIncome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DebtorIncome findUnique
   */
  export type DebtorIncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome findUniqueOrThrow
   */
  export type DebtorIncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome findFirst
   */
  export type DebtorIncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtorIncomes.
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtorIncomes.
     */
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * DebtorIncome findFirstOrThrow
   */
  export type DebtorIncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtorIncomes.
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtorIncomes.
     */
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * DebtorIncome findMany
   */
  export type DebtorIncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncomes to fetch.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DebtorIncomes.
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * DebtorIncome create
   */
  export type DebtorIncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a DebtorIncome.
     */
    data: XOR<DebtorIncomeCreateInput, DebtorIncomeUncheckedCreateInput>
  }

  /**
   * DebtorIncome createMany
   */
  export type DebtorIncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DebtorIncomes.
     */
    data: DebtorIncomeCreateManyInput | DebtorIncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DebtorIncome createManyAndReturn
   */
  export type DebtorIncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * The data used to create many DebtorIncomes.
     */
    data: DebtorIncomeCreateManyInput | DebtorIncomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DebtorIncome update
   */
  export type DebtorIncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a DebtorIncome.
     */
    data: XOR<DebtorIncomeUpdateInput, DebtorIncomeUncheckedUpdateInput>
    /**
     * Choose, which DebtorIncome to update.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome updateMany
   */
  export type DebtorIncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DebtorIncomes.
     */
    data: XOR<DebtorIncomeUpdateManyMutationInput, DebtorIncomeUncheckedUpdateManyInput>
    /**
     * Filter which DebtorIncomes to update
     */
    where?: DebtorIncomeWhereInput
    /**
     * Limit how many DebtorIncomes to update.
     */
    limit?: number
  }

  /**
   * DebtorIncome updateManyAndReturn
   */
  export type DebtorIncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * The data used to update DebtorIncomes.
     */
    data: XOR<DebtorIncomeUpdateManyMutationInput, DebtorIncomeUncheckedUpdateManyInput>
    /**
     * Filter which DebtorIncomes to update
     */
    where?: DebtorIncomeWhereInput
    /**
     * Limit how many DebtorIncomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DebtorIncome upsert
   */
  export type DebtorIncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the DebtorIncome to update in case it exists.
     */
    where: DebtorIncomeWhereUniqueInput
    /**
     * In case the DebtorIncome found by the `where` argument doesn't exist, create a new DebtorIncome with this data.
     */
    create: XOR<DebtorIncomeCreateInput, DebtorIncomeUncheckedCreateInput>
    /**
     * In case the DebtorIncome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtorIncomeUpdateInput, DebtorIncomeUncheckedUpdateInput>
  }

  /**
   * DebtorIncome delete
   */
  export type DebtorIncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter which DebtorIncome to delete.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome deleteMany
   */
  export type DebtorIncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtorIncomes to delete
     */
    where?: DebtorIncomeWhereInput
    /**
     * Limit how many DebtorIncomes to delete.
     */
    limit?: number
  }

  /**
   * DebtorIncome without action
   */
  export type DebtorIncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    subdomain: 'subdomain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    contactEmail: 'contactEmail',
    countryCode: 'countryCode',
    name: 'name',
    planStatus: 'planStatus',
    termsAccepted: 'termsAccepted',
    address: 'address',
    city: 'city',
    logoUrl: 'logoUrl',
    numberOfEmployees: 'numberOfEmployees',
    phone: 'phone',
    website: 'website',
    isActive: 'isActive'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const TenantRegistryScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    kvk: 'kvk',
    crib: 'crib',
    taxId: 'taxId',
    vatNumber: 'vatNumber',
    legalName: 'legalName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantRegistryScalarFieldEnum = (typeof TenantRegistryScalarFieldEnum)[keyof typeof TenantRegistryScalarFieldEnum]


  export const TenantInvitationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    status: 'status',
    invitedBy: 'invitedBy',
    createdAt: 'createdAt',
    userId: 'userId',
    role: 'role'
  };

  export type TenantInvitationScalarFieldEnum = (typeof TenantInvitationScalarFieldEnum)[keyof typeof TenantInvitationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    fullname: 'fullname',
    phone: 'phone',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MembershipScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenantId: 'tenantId',
    status: 'status',
    joinedAt: 'joinedAt',
    role: 'role'
  };

  export type MembershipScalarFieldEnum = (typeof MembershipScalarFieldEnum)[keyof typeof MembershipScalarFieldEnum]


  export const GlobalParameterScalarFieldEnum: {
    id: 'id',
    porcCobranza: 'porcCobranza',
    porcAbb: 'porcAbb',
    diasPlazoEmpresaAanmaning: 'diasPlazoEmpresaAanmaning',
    diasPlazoConsumidorAanmaning: 'diasPlazoConsumidorAanmaning',
    diasPlazoEmpresaSommatie: 'diasPlazoEmpresaSommatie',
    diasPlazoConsumidorSommatie: 'diasPlazoConsumidorSommatie',
    precioEmpresaPequena: 'precioEmpresaPequena',
    contribucionEmpresaPequenaPfc: 'contribucionEmpresaPequenaPfc',
    precioEmpresaGrande: 'precioEmpresaGrande',
    contribucionEmpresaGrandePfc: 'contribucionEmpresaGrandePfc',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    multaAanmaningEmpresa: 'multaAanmaningEmpresa',
    multaAanmaningNatural: 'multaAanmaningNatural',
    multaSommatieEmpresa: 'multaSommatieEmpresa',
    multaSommatieNatural: 'multaSommatieNatural',
    limiteDiasReaccionEmpresa: 'limiteDiasReaccionEmpresa',
    multaNoReaccionEmpresa: 'multaNoReaccionEmpresa',
    multaNoReaccionNatural: 'multaNoReaccionNatural',
    multaAcuerdoPagoEmpresa: 'multaAcuerdoPagoEmpresa',
    multaAcuerdoPagoNatural: 'multaAcuerdoPagoNatural',
    invoiceNumberLength: 'invoiceNumberLength',
    invoicePrefix: 'invoicePrefix',
    invoiceSecuence: 'invoiceSecuence',
    bankAccount: 'bankAccount',
    bankName: 'bankName'
  };

  export type GlobalParameterScalarFieldEnum = (typeof GlobalParameterScalarFieldEnum)[keyof typeof GlobalParameterScalarFieldEnum]


  export const VerdictScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    creditorName: 'creditorName',
    debtorId: 'debtorId',
    registrationNumber: 'registrationNumber',
    sentenceAmount: 'sentenceAmount',
    sentenceDate: 'sentenceDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    procesalCost: 'procesalCost',
    tenantId: 'tenantId',
    notes: 'notes',
    bailiffId: 'bailiffId'
  };

  export type VerdictScalarFieldEnum = (typeof VerdictScalarFieldEnum)[keyof typeof VerdictScalarFieldEnum]


  export const VerdictInterestScalarFieldEnum: {
    id: 'id',
    interestType: 'interestType',
    baseAmount: 'baseAmount',
    calculatedInterest: 'calculatedInterest',
    calculationStart: 'calculationStart',
    calculationEnd: 'calculationEnd',
    totalInterest: 'totalInterest',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    verdictId: 'verdictId'
  };

  export type VerdictInterestScalarFieldEnum = (typeof VerdictInterestScalarFieldEnum)[keyof typeof VerdictInterestScalarFieldEnum]


  export const VerdictInterestDetailsScalarFieldEnum: {
    id: 'id',
    period: 'period',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    days: 'days',
    annualRate: 'annualRate',
    proportionalRate: 'proportionalRate',
    baseAmount: 'baseAmount',
    interest: 'interest',
    total: 'total',
    verdictInterestId: 'verdictInterestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerdictInterestDetailsScalarFieldEnum = (typeof VerdictInterestDetailsScalarFieldEnum)[keyof typeof VerdictInterestDetailsScalarFieldEnum]


  export const VerdictEmbargoScalarFieldEnum: {
    id: 'id',
    verdictId: 'verdictId',
    companyName: 'companyName',
    companyPhone: 'companyPhone',
    companyEmail: 'companyEmail',
    companyAddress: 'companyAddress',
    embargoType: 'embargoType',
    embargoDate: 'embargoDate',
    embargoAmount: 'embargoAmount',
    totalAmount: 'totalAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerdictEmbargoScalarFieldEnum = (typeof VerdictEmbargoScalarFieldEnum)[keyof typeof VerdictEmbargoScalarFieldEnum]


  export const VerdictBailiffServicesScalarFieldEnum: {
    id: 'id',
    verdictId: 'verdictId',
    serviceType: 'serviceType',
    serviceCost: 'serviceCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerdictBailiffServicesScalarFieldEnum = (typeof VerdictBailiffServicesScalarFieldEnum)[keyof typeof VerdictBailiffServicesScalarFieldEnum]


  export const VerdictAttachmentScalarFieldEnum: {
    id: 'id',
    verdictId: 'verdictId',
    filePath: 'filePath',
    fileSize: 'fileSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fileName: 'fileName'
  };

  export type VerdictAttachmentScalarFieldEnum = (typeof VerdictAttachmentScalarFieldEnum)[keyof typeof VerdictAttachmentScalarFieldEnum]


  export const InterestTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    calculationType: 'calculationType'
  };

  export type InterestTypeScalarFieldEnum = (typeof InterestTypeScalarFieldEnum)[keyof typeof InterestTypeScalarFieldEnum]


  export const InterestDetailScalarFieldEnum: {
    id: 'id',
    date: 'date',
    rate: 'rate',
    interestTypeId: 'interestTypeId'
  };

  export type InterestDetailScalarFieldEnum = (typeof InterestDetailScalarFieldEnum)[keyof typeof InterestDetailScalarFieldEnum]


  export const BillingInvoiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    invoiceNumber: 'invoiceNumber',
    amount: 'amount',
    currency: 'currency',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillingInvoiceScalarFieldEnum = (typeof BillingInvoiceScalarFieldEnum)[keyof typeof BillingInvoiceScalarFieldEnum]


  export const BillingInvoiceDetailScalarFieldEnum: {
    id: 'id',
    itemDescription: 'itemDescription',
    itemQuantity: 'itemQuantity',
    itemUnitPrice: 'itemUnitPrice',
    itemTotalPrice: 'itemTotalPrice',
    itemTaxRate: 'itemTaxRate',
    itemTaxAmount: 'itemTaxAmount',
    itemTotalWithTax: 'itemTotalWithTax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    billingInvoiceId: 'billingInvoiceId'
  };

  export type BillingInvoiceDetailScalarFieldEnum = (typeof BillingInvoiceDetailScalarFieldEnum)[keyof typeof BillingInvoiceDetailScalarFieldEnum]


  export const BillingPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    currency: 'currency',
    billingCycle: 'billingCycle',
    features: 'features',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillingPlanScalarFieldEnum = (typeof BillingPlanScalarFieldEnum)[keyof typeof BillingPlanScalarFieldEnum]


  export const BillingSubscriptionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    planId: 'planId',
    startDate: 'startDate',
    endDate: 'endDate',
    nextBillingDate: 'nextBillingDate',
    billingCycle: 'billingCycle',
    amount: 'amount',
    currency: 'currency',
    lastInvoiceId: 'lastInvoiceId',
    trialEndsAt: 'trialEndsAt',
    canceledAt: 'canceledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type BillingSubscriptionScalarFieldEnum = (typeof BillingSubscriptionScalarFieldEnum)[keyof typeof BillingSubscriptionScalarFieldEnum]


  export const BillingPaymentScalarFieldEnum: {
    id: 'id',
    paymentDate: 'paymentDate',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    billingInvoiceId: 'billingInvoiceId'
  };

  export type BillingPaymentScalarFieldEnum = (typeof BillingPaymentScalarFieldEnum)[keyof typeof BillingPaymentScalarFieldEnum]


  export const CollectionCaseScalarFieldEnum: {
    id: 'id',
    referenceNumber: 'referenceNumber',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    tenantId: 'tenantId',
    debtorId: 'debtorId',
    amountOriginal: 'amountOriginal',
    amountDue: 'amountDue',
    amountToReceive: 'amountToReceive',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollectionCaseScalarFieldEnum = (typeof CollectionCaseScalarFieldEnum)[keyof typeof CollectionCaseScalarFieldEnum]


  export const PenaltyScalarFieldEnum: {
    id: 'id',
    collectionCaseId: 'collectionCaseId',
    description: 'description',
    amount: 'amount',
    dateApplied: 'dateApplied',
    isPaid: 'isPaid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PenaltyScalarFieldEnum = (typeof PenaltyScalarFieldEnum)[keyof typeof PenaltyScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    collectionCaseId: 'collectionCaseId',
    type: 'type',
    title: 'title',
    message: 'message',
    sentAt: 'sentAt',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    method: 'method',
    createdAt: 'createdAt',
    collectionCaseId: 'collectionCaseId',
    paymentDate: 'paymentDate',
    referenceNumber: 'referenceNumber',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PaymentAgreementScalarFieldEnum: {
    id: 'id',
    debtorId: 'debtorId',
    agreementDate: 'agreementDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    collectionCaseId: 'collectionCaseId',
    installmentAmount: 'installmentAmount',
    nextPaymentDate: 'nextPaymentDate',
    notes: 'notes',
    totalInstallments: 'totalInstallments'
  };

  export type PaymentAgreementScalarFieldEnum = (typeof PaymentAgreementScalarFieldEnum)[keyof typeof PaymentAgreementScalarFieldEnum]


  export const DebtorScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    fullname: 'fullname',
    email: 'email',
    phone: 'phone',
    address: 'address',
    personType: 'personType',
    identificationType: 'identificationType',
    identification: 'identification',
    totalIncome: 'totalIncome',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DebtorScalarFieldEnum = (typeof DebtorScalarFieldEnum)[keyof typeof DebtorScalarFieldEnum]


  export const DebtorIncomeScalarFieldEnum: {
    id: 'id',
    debtorId: 'debtorId',
    amount: 'amount',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DebtorIncomeScalarFieldEnum = (typeof DebtorIncomeScalarFieldEnum)[keyof typeof DebtorIncomeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'roleEnum'
   */
  export type EnumroleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'roleEnum'>
    


  /**
   * Reference to a field of type 'roleEnum[]'
   */
  export type ListEnumroleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'roleEnum[]'>
    


  /**
   * Reference to a field of type 'MembershipStatus'
   */
  export type EnumMembershipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MembershipStatus'>
    


  /**
   * Reference to a field of type 'MembershipStatus[]'
   */
  export type ListEnumMembershipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MembershipStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'VerdictStatus'
   */
  export type EnumVerdictStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerdictStatus'>
    


  /**
   * Reference to a field of type 'VerdictStatus[]'
   */
  export type ListEnumVerdictStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerdictStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'CalculationTypeEnum'
   */
  export type EnumCalculationTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalculationTypeEnum'>
    


  /**
   * Reference to a field of type 'CalculationTypeEnum[]'
   */
  export type ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalculationTypeEnum[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'BillingSubscriptionStatus'
   */
  export type EnumBillingSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingSubscriptionStatus'>
    


  /**
   * Reference to a field of type 'BillingSubscriptionStatus[]'
   */
  export type ListEnumBillingSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingSubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'CollectionStatus'
   */
  export type EnumCollectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CollectionStatus'>
    


  /**
   * Reference to a field of type 'CollectionStatus[]'
   */
  export type ListEnumCollectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CollectionStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'AgreementStatus'
   */
  export type EnumAgreementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgreementStatus'>
    


  /**
   * Reference to a field of type 'AgreementStatus[]'
   */
  export type ListEnumAgreementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgreementStatus[]'>
    


  /**
   * Reference to a field of type 'IdentificationType'
   */
  export type EnumIdentificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentificationType'>
    


  /**
   * Reference to a field of type 'IdentificationType[]'
   */
  export type ListEnumIdentificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentificationType[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    subdomain?: StringFilter<"Tenant"> | string
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    contactEmail?: StringFilter<"Tenant"> | string
    countryCode?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    planStatus?: StringFilter<"Tenant"> | string
    termsAccepted?: BoolFilter<"Tenant"> | boolean
    address?: StringNullableFilter<"Tenant"> | string | null
    city?: StringNullableFilter<"Tenant"> | string | null
    logoUrl?: StringNullableFilter<"Tenant"> | string | null
    numberOfEmployees?: IntNullableFilter<"Tenant"> | number | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    website?: StringNullableFilter<"Tenant"> | string | null
    isActive?: BoolFilter<"Tenant"> | boolean
    billingInvoice?: BillingInvoiceListRelationFilter
    subscription?: BillingSubscriptionListRelationFilter
    collectionCases?: CollectionCaseListRelationFilter
    debtors?: DebtorListRelationFilter
    memberships?: MembershipListRelationFilter
    tenantInvitations?: TenantInvitationListRelationFilter
    registry?: XOR<TenantRegistryNullableScalarRelationFilter, TenantRegistryWhereInput> | null
    verdicts?: VerdictListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactEmail?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    planStatus?: SortOrder
    termsAccepted?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    numberOfEmployees?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isActive?: SortOrder
    billingInvoice?: BillingInvoiceOrderByRelationAggregateInput
    subscription?: BillingSubscriptionOrderByRelationAggregateInput
    collectionCases?: CollectionCaseOrderByRelationAggregateInput
    debtors?: DebtorOrderByRelationAggregateInput
    memberships?: MembershipOrderByRelationAggregateInput
    tenantInvitations?: TenantInvitationOrderByRelationAggregateInput
    registry?: TenantRegistryOrderByWithRelationInput
    verdicts?: VerdictOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subdomain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    contactEmail?: StringFilter<"Tenant"> | string
    countryCode?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    planStatus?: StringFilter<"Tenant"> | string
    termsAccepted?: BoolFilter<"Tenant"> | boolean
    address?: StringNullableFilter<"Tenant"> | string | null
    city?: StringNullableFilter<"Tenant"> | string | null
    logoUrl?: StringNullableFilter<"Tenant"> | string | null
    numberOfEmployees?: IntNullableFilter<"Tenant"> | number | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    website?: StringNullableFilter<"Tenant"> | string | null
    isActive?: BoolFilter<"Tenant"> | boolean
    billingInvoice?: BillingInvoiceListRelationFilter
    subscription?: BillingSubscriptionListRelationFilter
    collectionCases?: CollectionCaseListRelationFilter
    debtors?: DebtorListRelationFilter
    memberships?: MembershipListRelationFilter
    tenantInvitations?: TenantInvitationListRelationFilter
    registry?: XOR<TenantRegistryNullableScalarRelationFilter, TenantRegistryWhereInput> | null
    verdicts?: VerdictListRelationFilter
  }, "id" | "subdomain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactEmail?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    planStatus?: SortOrder
    termsAccepted?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    numberOfEmployees?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    subdomain?: StringWithAggregatesFilter<"Tenant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    contactEmail?: StringWithAggregatesFilter<"Tenant"> | string
    countryCode?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    planStatus?: StringWithAggregatesFilter<"Tenant"> | string
    termsAccepted?: BoolWithAggregatesFilter<"Tenant"> | boolean
    address?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    city?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    numberOfEmployees?: IntNullableWithAggregatesFilter<"Tenant"> | number | null
    phone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    website?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    isActive?: BoolWithAggregatesFilter<"Tenant"> | boolean
  }

  export type TenantRegistryWhereInput = {
    AND?: TenantRegistryWhereInput | TenantRegistryWhereInput[]
    OR?: TenantRegistryWhereInput[]
    NOT?: TenantRegistryWhereInput | TenantRegistryWhereInput[]
    id?: StringFilter<"TenantRegistry"> | string
    tenantId?: StringFilter<"TenantRegistry"> | string
    kvk?: StringNullableFilter<"TenantRegistry"> | string | null
    crib?: StringNullableFilter<"TenantRegistry"> | string | null
    taxId?: StringNullableFilter<"TenantRegistry"> | string | null
    vatNumber?: StringNullableFilter<"TenantRegistry"> | string | null
    legalName?: StringNullableFilter<"TenantRegistry"> | string | null
    createdAt?: DateTimeFilter<"TenantRegistry"> | Date | string
    updatedAt?: DateTimeFilter<"TenantRegistry"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantRegistryOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kvk?: SortOrderInput | SortOrder
    crib?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    legalName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantRegistryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: TenantRegistryWhereInput | TenantRegistryWhereInput[]
    OR?: TenantRegistryWhereInput[]
    NOT?: TenantRegistryWhereInput | TenantRegistryWhereInput[]
    kvk?: StringNullableFilter<"TenantRegistry"> | string | null
    crib?: StringNullableFilter<"TenantRegistry"> | string | null
    taxId?: StringNullableFilter<"TenantRegistry"> | string | null
    vatNumber?: StringNullableFilter<"TenantRegistry"> | string | null
    legalName?: StringNullableFilter<"TenantRegistry"> | string | null
    createdAt?: DateTimeFilter<"TenantRegistry"> | Date | string
    updatedAt?: DateTimeFilter<"TenantRegistry"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type TenantRegistryOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kvk?: SortOrderInput | SortOrder
    crib?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    legalName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantRegistryCountOrderByAggregateInput
    _max?: TenantRegistryMaxOrderByAggregateInput
    _min?: TenantRegistryMinOrderByAggregateInput
  }

  export type TenantRegistryScalarWhereWithAggregatesInput = {
    AND?: TenantRegistryScalarWhereWithAggregatesInput | TenantRegistryScalarWhereWithAggregatesInput[]
    OR?: TenantRegistryScalarWhereWithAggregatesInput[]
    NOT?: TenantRegistryScalarWhereWithAggregatesInput | TenantRegistryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantRegistry"> | string
    tenantId?: StringWithAggregatesFilter<"TenantRegistry"> | string
    kvk?: StringNullableWithAggregatesFilter<"TenantRegistry"> | string | null
    crib?: StringNullableWithAggregatesFilter<"TenantRegistry"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"TenantRegistry"> | string | null
    vatNumber?: StringNullableWithAggregatesFilter<"TenantRegistry"> | string | null
    legalName?: StringNullableWithAggregatesFilter<"TenantRegistry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantRegistry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantRegistry"> | Date | string
  }

  export type TenantInvitationWhereInput = {
    AND?: TenantInvitationWhereInput | TenantInvitationWhereInput[]
    OR?: TenantInvitationWhereInput[]
    NOT?: TenantInvitationWhereInput | TenantInvitationWhereInput[]
    id?: StringFilter<"TenantInvitation"> | string
    tenantId?: StringFilter<"TenantInvitation"> | string
    email?: StringFilter<"TenantInvitation"> | string
    status?: StringFilter<"TenantInvitation"> | string
    invitedBy?: StringFilter<"TenantInvitation"> | string
    createdAt?: DateTimeFilter<"TenantInvitation"> | Date | string
    userId?: StringNullableFilter<"TenantInvitation"> | string | null
    role?: EnumroleEnumFilter<"TenantInvitation"> | $Enums.roleEnum
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TenantInvitationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    status?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    role?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type TenantInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantInvitationWhereInput | TenantInvitationWhereInput[]
    OR?: TenantInvitationWhereInput[]
    NOT?: TenantInvitationWhereInput | TenantInvitationWhereInput[]
    tenantId?: StringFilter<"TenantInvitation"> | string
    email?: StringFilter<"TenantInvitation"> | string
    status?: StringFilter<"TenantInvitation"> | string
    invitedBy?: StringFilter<"TenantInvitation"> | string
    createdAt?: DateTimeFilter<"TenantInvitation"> | Date | string
    userId?: StringNullableFilter<"TenantInvitation"> | string | null
    role?: EnumroleEnumFilter<"TenantInvitation"> | $Enums.roleEnum
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TenantInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    status?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    role?: SortOrder
    _count?: TenantInvitationCountOrderByAggregateInput
    _max?: TenantInvitationMaxOrderByAggregateInput
    _min?: TenantInvitationMinOrderByAggregateInput
  }

  export type TenantInvitationScalarWhereWithAggregatesInput = {
    AND?: TenantInvitationScalarWhereWithAggregatesInput | TenantInvitationScalarWhereWithAggregatesInput[]
    OR?: TenantInvitationScalarWhereWithAggregatesInput[]
    NOT?: TenantInvitationScalarWhereWithAggregatesInput | TenantInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantInvitation"> | string
    tenantId?: StringWithAggregatesFilter<"TenantInvitation"> | string
    email?: StringWithAggregatesFilter<"TenantInvitation"> | string
    status?: StringWithAggregatesFilter<"TenantInvitation"> | string
    invitedBy?: StringWithAggregatesFilter<"TenantInvitation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TenantInvitation"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"TenantInvitation"> | string | null
    role?: EnumroleEnumWithAggregatesFilter<"TenantInvitation"> | $Enums.roleEnum
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    fullname?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    debtors?: DebtorListRelationFilter
    memberships?: MembershipListRelationFilter
    tenantInvitations?: TenantInvitationListRelationFilter
    verdictBailiffs?: VerdictListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    debtors?: DebtorOrderByRelationAggregateInput
    memberships?: MembershipOrderByRelationAggregateInput
    tenantInvitations?: TenantInvitationOrderByRelationAggregateInput
    verdictBailiffs?: VerdictOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    fullname?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    debtors?: DebtorListRelationFilter
    memberships?: MembershipListRelationFilter
    tenantInvitations?: TenantInvitationListRelationFilter
    verdictBailiffs?: VerdictListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullname?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type MembershipWhereInput = {
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    id?: StringFilter<"Membership"> | string
    userId?: StringFilter<"Membership"> | string
    tenantId?: StringFilter<"Membership"> | string
    status?: EnumMembershipStatusFilter<"Membership"> | $Enums.MembershipStatus
    joinedAt?: DateTimeFilter<"Membership"> | Date | string
    role?: EnumroleEnumFilter<"Membership"> | $Enums.roleEnum
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MembershipOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    role?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tenantId?: MembershipUserIdTenantIdCompoundUniqueInput
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    userId?: StringFilter<"Membership"> | string
    tenantId?: StringFilter<"Membership"> | string
    status?: EnumMembershipStatusFilter<"Membership"> | $Enums.MembershipStatus
    joinedAt?: DateTimeFilter<"Membership"> | Date | string
    role?: EnumroleEnumFilter<"Membership"> | $Enums.roleEnum
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_tenantId">

  export type MembershipOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    role?: SortOrder
    _count?: MembershipCountOrderByAggregateInput
    _max?: MembershipMaxOrderByAggregateInput
    _min?: MembershipMinOrderByAggregateInput
  }

  export type MembershipScalarWhereWithAggregatesInput = {
    AND?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    OR?: MembershipScalarWhereWithAggregatesInput[]
    NOT?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Membership"> | string
    userId?: StringWithAggregatesFilter<"Membership"> | string
    tenantId?: StringWithAggregatesFilter<"Membership"> | string
    status?: EnumMembershipStatusWithAggregatesFilter<"Membership"> | $Enums.MembershipStatus
    joinedAt?: DateTimeWithAggregatesFilter<"Membership"> | Date | string
    role?: EnumroleEnumWithAggregatesFilter<"Membership"> | $Enums.roleEnum
  }

  export type GlobalParameterWhereInput = {
    AND?: GlobalParameterWhereInput | GlobalParameterWhereInput[]
    OR?: GlobalParameterWhereInput[]
    NOT?: GlobalParameterWhereInput | GlobalParameterWhereInput[]
    id?: StringFilter<"GlobalParameter"> | string
    porcCobranza?: FloatFilter<"GlobalParameter"> | number
    porcAbb?: FloatFilter<"GlobalParameter"> | number
    diasPlazoEmpresaAanmaning?: IntFilter<"GlobalParameter"> | number
    diasPlazoConsumidorAanmaning?: IntFilter<"GlobalParameter"> | number
    diasPlazoEmpresaSommatie?: IntFilter<"GlobalParameter"> | number
    diasPlazoConsumidorSommatie?: IntFilter<"GlobalParameter"> | number
    precioEmpresaPequena?: FloatFilter<"GlobalParameter"> | number
    contribucionEmpresaPequenaPfc?: FloatFilter<"GlobalParameter"> | number
    precioEmpresaGrande?: FloatFilter<"GlobalParameter"> | number
    contribucionEmpresaGrandePfc?: FloatFilter<"GlobalParameter"> | number
    createdAt?: DateTimeFilter<"GlobalParameter"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalParameter"> | Date | string
    multaAanmaningEmpresa?: FloatFilter<"GlobalParameter"> | number
    multaAanmaningNatural?: FloatFilter<"GlobalParameter"> | number
    multaSommatieEmpresa?: FloatFilter<"GlobalParameter"> | number
    multaSommatieNatural?: FloatFilter<"GlobalParameter"> | number
    limiteDiasReaccionEmpresa?: IntFilter<"GlobalParameter"> | number
    multaNoReaccionEmpresa?: FloatFilter<"GlobalParameter"> | number
    multaNoReaccionNatural?: FloatFilter<"GlobalParameter"> | number
    multaAcuerdoPagoEmpresa?: FloatFilter<"GlobalParameter"> | number
    multaAcuerdoPagoNatural?: FloatFilter<"GlobalParameter"> | number
    invoiceNumberLength?: IntFilter<"GlobalParameter"> | number
    invoicePrefix?: StringFilter<"GlobalParameter"> | string
    invoiceSecuence?: IntFilter<"GlobalParameter"> | number
    bankAccount?: StringFilter<"GlobalParameter"> | string
    bankName?: StringFilter<"GlobalParameter"> | string
  }

  export type GlobalParameterOrderByWithRelationInput = {
    id?: SortOrder
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoicePrefix?: SortOrder
    invoiceSecuence?: SortOrder
    bankAccount?: SortOrder
    bankName?: SortOrder
  }

  export type GlobalParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GlobalParameterWhereInput | GlobalParameterWhereInput[]
    OR?: GlobalParameterWhereInput[]
    NOT?: GlobalParameterWhereInput | GlobalParameterWhereInput[]
    porcCobranza?: FloatFilter<"GlobalParameter"> | number
    porcAbb?: FloatFilter<"GlobalParameter"> | number
    diasPlazoEmpresaAanmaning?: IntFilter<"GlobalParameter"> | number
    diasPlazoConsumidorAanmaning?: IntFilter<"GlobalParameter"> | number
    diasPlazoEmpresaSommatie?: IntFilter<"GlobalParameter"> | number
    diasPlazoConsumidorSommatie?: IntFilter<"GlobalParameter"> | number
    precioEmpresaPequena?: FloatFilter<"GlobalParameter"> | number
    contribucionEmpresaPequenaPfc?: FloatFilter<"GlobalParameter"> | number
    precioEmpresaGrande?: FloatFilter<"GlobalParameter"> | number
    contribucionEmpresaGrandePfc?: FloatFilter<"GlobalParameter"> | number
    createdAt?: DateTimeFilter<"GlobalParameter"> | Date | string
    updatedAt?: DateTimeFilter<"GlobalParameter"> | Date | string
    multaAanmaningEmpresa?: FloatFilter<"GlobalParameter"> | number
    multaAanmaningNatural?: FloatFilter<"GlobalParameter"> | number
    multaSommatieEmpresa?: FloatFilter<"GlobalParameter"> | number
    multaSommatieNatural?: FloatFilter<"GlobalParameter"> | number
    limiteDiasReaccionEmpresa?: IntFilter<"GlobalParameter"> | number
    multaNoReaccionEmpresa?: FloatFilter<"GlobalParameter"> | number
    multaNoReaccionNatural?: FloatFilter<"GlobalParameter"> | number
    multaAcuerdoPagoEmpresa?: FloatFilter<"GlobalParameter"> | number
    multaAcuerdoPagoNatural?: FloatFilter<"GlobalParameter"> | number
    invoiceNumberLength?: IntFilter<"GlobalParameter"> | number
    invoicePrefix?: StringFilter<"GlobalParameter"> | string
    invoiceSecuence?: IntFilter<"GlobalParameter"> | number
    bankAccount?: StringFilter<"GlobalParameter"> | string
    bankName?: StringFilter<"GlobalParameter"> | string
  }, "id">

  export type GlobalParameterOrderByWithAggregationInput = {
    id?: SortOrder
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoicePrefix?: SortOrder
    invoiceSecuence?: SortOrder
    bankAccount?: SortOrder
    bankName?: SortOrder
    _count?: GlobalParameterCountOrderByAggregateInput
    _avg?: GlobalParameterAvgOrderByAggregateInput
    _max?: GlobalParameterMaxOrderByAggregateInput
    _min?: GlobalParameterMinOrderByAggregateInput
    _sum?: GlobalParameterSumOrderByAggregateInput
  }

  export type GlobalParameterScalarWhereWithAggregatesInput = {
    AND?: GlobalParameterScalarWhereWithAggregatesInput | GlobalParameterScalarWhereWithAggregatesInput[]
    OR?: GlobalParameterScalarWhereWithAggregatesInput[]
    NOT?: GlobalParameterScalarWhereWithAggregatesInput | GlobalParameterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GlobalParameter"> | string
    porcCobranza?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    porcAbb?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    diasPlazoEmpresaAanmaning?: IntWithAggregatesFilter<"GlobalParameter"> | number
    diasPlazoConsumidorAanmaning?: IntWithAggregatesFilter<"GlobalParameter"> | number
    diasPlazoEmpresaSommatie?: IntWithAggregatesFilter<"GlobalParameter"> | number
    diasPlazoConsumidorSommatie?: IntWithAggregatesFilter<"GlobalParameter"> | number
    precioEmpresaPequena?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    contribucionEmpresaPequenaPfc?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    precioEmpresaGrande?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    contribucionEmpresaGrandePfc?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GlobalParameter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GlobalParameter"> | Date | string
    multaAanmaningEmpresa?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    multaAanmaningNatural?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    multaSommatieEmpresa?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    multaSommatieNatural?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    limiteDiasReaccionEmpresa?: IntWithAggregatesFilter<"GlobalParameter"> | number
    multaNoReaccionEmpresa?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    multaNoReaccionNatural?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    multaAcuerdoPagoEmpresa?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    multaAcuerdoPagoNatural?: FloatWithAggregatesFilter<"GlobalParameter"> | number
    invoiceNumberLength?: IntWithAggregatesFilter<"GlobalParameter"> | number
    invoicePrefix?: StringWithAggregatesFilter<"GlobalParameter"> | string
    invoiceSecuence?: IntWithAggregatesFilter<"GlobalParameter"> | number
    bankAccount?: StringWithAggregatesFilter<"GlobalParameter"> | string
    bankName?: StringWithAggregatesFilter<"GlobalParameter"> | string
  }

  export type VerdictWhereInput = {
    AND?: VerdictWhereInput | VerdictWhereInput[]
    OR?: VerdictWhereInput[]
    NOT?: VerdictWhereInput | VerdictWhereInput[]
    id?: StringFilter<"Verdict"> | string
    invoiceNumber?: StringFilter<"Verdict"> | string
    creditorName?: StringFilter<"Verdict"> | string
    debtorId?: StringFilter<"Verdict"> | string
    registrationNumber?: StringFilter<"Verdict"> | string
    sentenceAmount?: FloatFilter<"Verdict"> | number
    sentenceDate?: DateTimeFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusFilter<"Verdict"> | $Enums.VerdictStatus
    createdAt?: DateTimeFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeFilter<"Verdict"> | Date | string
    procesalCost?: FloatNullableFilter<"Verdict"> | number | null
    tenantId?: StringFilter<"Verdict"> | string
    notes?: StringNullableFilter<"Verdict"> | string | null
    bailiffId?: StringNullableFilter<"Verdict"> | string | null
    bailiff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    attachments?: VerdictAttachmentListRelationFilter
    bailiffServices?: VerdictBailiffServicesListRelationFilter
    verdictEmbargo?: VerdictEmbargoListRelationFilter
    verdictInterest?: VerdictInterestListRelationFilter
  }

  export type VerdictOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    creditorName?: SortOrder
    debtorId?: SortOrder
    registrationNumber?: SortOrder
    sentenceAmount?: SortOrder
    sentenceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procesalCost?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    notes?: SortOrderInput | SortOrder
    bailiffId?: SortOrderInput | SortOrder
    bailiff?: UserOrderByWithRelationInput
    debtor?: DebtorOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    attachments?: VerdictAttachmentOrderByRelationAggregateInput
    bailiffServices?: VerdictBailiffServicesOrderByRelationAggregateInput
    verdictEmbargo?: VerdictEmbargoOrderByRelationAggregateInput
    verdictInterest?: VerdictInterestOrderByRelationAggregateInput
  }

  export type VerdictWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictWhereInput | VerdictWhereInput[]
    OR?: VerdictWhereInput[]
    NOT?: VerdictWhereInput | VerdictWhereInput[]
    invoiceNumber?: StringFilter<"Verdict"> | string
    creditorName?: StringFilter<"Verdict"> | string
    debtorId?: StringFilter<"Verdict"> | string
    registrationNumber?: StringFilter<"Verdict"> | string
    sentenceAmount?: FloatFilter<"Verdict"> | number
    sentenceDate?: DateTimeFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusFilter<"Verdict"> | $Enums.VerdictStatus
    createdAt?: DateTimeFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeFilter<"Verdict"> | Date | string
    procesalCost?: FloatNullableFilter<"Verdict"> | number | null
    tenantId?: StringFilter<"Verdict"> | string
    notes?: StringNullableFilter<"Verdict"> | string | null
    bailiffId?: StringNullableFilter<"Verdict"> | string | null
    bailiff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    attachments?: VerdictAttachmentListRelationFilter
    bailiffServices?: VerdictBailiffServicesListRelationFilter
    verdictEmbargo?: VerdictEmbargoListRelationFilter
    verdictInterest?: VerdictInterestListRelationFilter
  }, "id">

  export type VerdictOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    creditorName?: SortOrder
    debtorId?: SortOrder
    registrationNumber?: SortOrder
    sentenceAmount?: SortOrder
    sentenceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procesalCost?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    notes?: SortOrderInput | SortOrder
    bailiffId?: SortOrderInput | SortOrder
    _count?: VerdictCountOrderByAggregateInput
    _avg?: VerdictAvgOrderByAggregateInput
    _max?: VerdictMaxOrderByAggregateInput
    _min?: VerdictMinOrderByAggregateInput
    _sum?: VerdictSumOrderByAggregateInput
  }

  export type VerdictScalarWhereWithAggregatesInput = {
    AND?: VerdictScalarWhereWithAggregatesInput | VerdictScalarWhereWithAggregatesInput[]
    OR?: VerdictScalarWhereWithAggregatesInput[]
    NOT?: VerdictScalarWhereWithAggregatesInput | VerdictScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verdict"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Verdict"> | string
    creditorName?: StringWithAggregatesFilter<"Verdict"> | string
    debtorId?: StringWithAggregatesFilter<"Verdict"> | string
    registrationNumber?: StringWithAggregatesFilter<"Verdict"> | string
    sentenceAmount?: FloatWithAggregatesFilter<"Verdict"> | number
    sentenceDate?: DateTimeWithAggregatesFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusWithAggregatesFilter<"Verdict"> | $Enums.VerdictStatus
    createdAt?: DateTimeWithAggregatesFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verdict"> | Date | string
    procesalCost?: FloatNullableWithAggregatesFilter<"Verdict"> | number | null
    tenantId?: StringWithAggregatesFilter<"Verdict"> | string
    notes?: StringNullableWithAggregatesFilter<"Verdict"> | string | null
    bailiffId?: StringNullableWithAggregatesFilter<"Verdict"> | string | null
  }

  export type VerdictInterestWhereInput = {
    AND?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    OR?: VerdictInterestWhereInput[]
    NOT?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    id?: StringFilter<"VerdictInterest"> | string
    interestType?: IntFilter<"VerdictInterest"> | number
    baseAmount?: FloatFilter<"VerdictInterest"> | number
    calculatedInterest?: FloatNullableFilter<"VerdictInterest"> | number | null
    calculationStart?: DateTimeFilter<"VerdictInterest"> | Date | string
    calculationEnd?: DateTimeFilter<"VerdictInterest"> | Date | string
    totalInterest?: FloatFilter<"VerdictInterest"> | number
    createdAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    verdictId?: StringNullableFilter<"VerdictInterest"> | string | null
    verdict?: XOR<VerdictNullableScalarRelationFilter, VerdictWhereInput> | null
    details?: VerdictInterestDetailsListRelationFilter
  }

  export type VerdictInterestOrderByWithRelationInput = {
    id?: SortOrder
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrderInput | SortOrder
    calculationStart?: SortOrder
    calculationEnd?: SortOrder
    totalInterest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictId?: SortOrderInput | SortOrder
    verdict?: VerdictOrderByWithRelationInput
    details?: VerdictInterestDetailsOrderByRelationAggregateInput
  }

  export type VerdictInterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    OR?: VerdictInterestWhereInput[]
    NOT?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    interestType?: IntFilter<"VerdictInterest"> | number
    baseAmount?: FloatFilter<"VerdictInterest"> | number
    calculatedInterest?: FloatNullableFilter<"VerdictInterest"> | number | null
    calculationStart?: DateTimeFilter<"VerdictInterest"> | Date | string
    calculationEnd?: DateTimeFilter<"VerdictInterest"> | Date | string
    totalInterest?: FloatFilter<"VerdictInterest"> | number
    createdAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    verdictId?: StringNullableFilter<"VerdictInterest"> | string | null
    verdict?: XOR<VerdictNullableScalarRelationFilter, VerdictWhereInput> | null
    details?: VerdictInterestDetailsListRelationFilter
  }, "id">

  export type VerdictInterestOrderByWithAggregationInput = {
    id?: SortOrder
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrderInput | SortOrder
    calculationStart?: SortOrder
    calculationEnd?: SortOrder
    totalInterest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictId?: SortOrderInput | SortOrder
    _count?: VerdictInterestCountOrderByAggregateInput
    _avg?: VerdictInterestAvgOrderByAggregateInput
    _max?: VerdictInterestMaxOrderByAggregateInput
    _min?: VerdictInterestMinOrderByAggregateInput
    _sum?: VerdictInterestSumOrderByAggregateInput
  }

  export type VerdictInterestScalarWhereWithAggregatesInput = {
    AND?: VerdictInterestScalarWhereWithAggregatesInput | VerdictInterestScalarWhereWithAggregatesInput[]
    OR?: VerdictInterestScalarWhereWithAggregatesInput[]
    NOT?: VerdictInterestScalarWhereWithAggregatesInput | VerdictInterestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictInterest"> | string
    interestType?: IntWithAggregatesFilter<"VerdictInterest"> | number
    baseAmount?: FloatWithAggregatesFilter<"VerdictInterest"> | number
    calculatedInterest?: FloatNullableWithAggregatesFilter<"VerdictInterest"> | number | null
    calculationStart?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    calculationEnd?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    totalInterest?: FloatWithAggregatesFilter<"VerdictInterest"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    verdictId?: StringNullableWithAggregatesFilter<"VerdictInterest"> | string | null
  }

  export type VerdictInterestDetailsWhereInput = {
    AND?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    OR?: VerdictInterestDetailsWhereInput[]
    NOT?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    id?: StringFilter<"VerdictInterestDetails"> | string
    period?: StringFilter<"VerdictInterestDetails"> | string
    periodStart?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    periodEnd?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    days?: IntFilter<"VerdictInterestDetails"> | number
    annualRate?: FloatFilter<"VerdictInterestDetails"> | number
    proportionalRate?: FloatFilter<"VerdictInterestDetails"> | number
    baseAmount?: FloatFilter<"VerdictInterestDetails"> | number
    interest?: FloatFilter<"VerdictInterestDetails"> | number
    total?: FloatFilter<"VerdictInterestDetails"> | number
    verdictInterestId?: StringFilter<"VerdictInterestDetails"> | string
    createdAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    verdictInterest?: XOR<VerdictInterestScalarRelationFilter, VerdictInterestWhereInput>
  }

  export type VerdictInterestDetailsOrderByWithRelationInput = {
    id?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdictInterestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictInterest?: VerdictInterestOrderByWithRelationInput
  }

  export type VerdictInterestDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    OR?: VerdictInterestDetailsWhereInput[]
    NOT?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    period?: StringFilter<"VerdictInterestDetails"> | string
    periodStart?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    periodEnd?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    days?: IntFilter<"VerdictInterestDetails"> | number
    annualRate?: FloatFilter<"VerdictInterestDetails"> | number
    proportionalRate?: FloatFilter<"VerdictInterestDetails"> | number
    baseAmount?: FloatFilter<"VerdictInterestDetails"> | number
    interest?: FloatFilter<"VerdictInterestDetails"> | number
    total?: FloatFilter<"VerdictInterestDetails"> | number
    verdictInterestId?: StringFilter<"VerdictInterestDetails"> | string
    createdAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    verdictInterest?: XOR<VerdictInterestScalarRelationFilter, VerdictInterestWhereInput>
  }, "id">

  export type VerdictInterestDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdictInterestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerdictInterestDetailsCountOrderByAggregateInput
    _avg?: VerdictInterestDetailsAvgOrderByAggregateInput
    _max?: VerdictInterestDetailsMaxOrderByAggregateInput
    _min?: VerdictInterestDetailsMinOrderByAggregateInput
    _sum?: VerdictInterestDetailsSumOrderByAggregateInput
  }

  export type VerdictInterestDetailsScalarWhereWithAggregatesInput = {
    AND?: VerdictInterestDetailsScalarWhereWithAggregatesInput | VerdictInterestDetailsScalarWhereWithAggregatesInput[]
    OR?: VerdictInterestDetailsScalarWhereWithAggregatesInput[]
    NOT?: VerdictInterestDetailsScalarWhereWithAggregatesInput | VerdictInterestDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictInterestDetails"> | string
    period?: StringWithAggregatesFilter<"VerdictInterestDetails"> | string
    periodStart?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
    days?: IntWithAggregatesFilter<"VerdictInterestDetails"> | number
    annualRate?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    proportionalRate?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    baseAmount?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    interest?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    total?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    verdictInterestId?: StringWithAggregatesFilter<"VerdictInterestDetails"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
  }

  export type VerdictEmbargoWhereInput = {
    AND?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    OR?: VerdictEmbargoWhereInput[]
    NOT?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    id?: StringFilter<"VerdictEmbargo"> | string
    verdictId?: StringFilter<"VerdictEmbargo"> | string
    companyName?: StringFilter<"VerdictEmbargo"> | string
    companyPhone?: StringFilter<"VerdictEmbargo"> | string
    companyEmail?: StringFilter<"VerdictEmbargo"> | string
    companyAddress?: StringFilter<"VerdictEmbargo"> | string
    embargoType?: StringFilter<"VerdictEmbargo"> | string
    embargoDate?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    embargoAmount?: FloatFilter<"VerdictEmbargo"> | number
    totalAmount?: FloatFilter<"VerdictEmbargo"> | number
    createdAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }

  export type VerdictEmbargoOrderByWithRelationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    companyName?: SortOrder
    companyPhone?: SortOrder
    companyEmail?: SortOrder
    companyAddress?: SortOrder
    embargoType?: SortOrder
    embargoDate?: SortOrder
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdict?: VerdictOrderByWithRelationInput
  }

  export type VerdictEmbargoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    OR?: VerdictEmbargoWhereInput[]
    NOT?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    verdictId?: StringFilter<"VerdictEmbargo"> | string
    companyName?: StringFilter<"VerdictEmbargo"> | string
    companyPhone?: StringFilter<"VerdictEmbargo"> | string
    companyEmail?: StringFilter<"VerdictEmbargo"> | string
    companyAddress?: StringFilter<"VerdictEmbargo"> | string
    embargoType?: StringFilter<"VerdictEmbargo"> | string
    embargoDate?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    embargoAmount?: FloatFilter<"VerdictEmbargo"> | number
    totalAmount?: FloatFilter<"VerdictEmbargo"> | number
    createdAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }, "id">

  export type VerdictEmbargoOrderByWithAggregationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    companyName?: SortOrder
    companyPhone?: SortOrder
    companyEmail?: SortOrder
    companyAddress?: SortOrder
    embargoType?: SortOrder
    embargoDate?: SortOrder
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerdictEmbargoCountOrderByAggregateInput
    _avg?: VerdictEmbargoAvgOrderByAggregateInput
    _max?: VerdictEmbargoMaxOrderByAggregateInput
    _min?: VerdictEmbargoMinOrderByAggregateInput
    _sum?: VerdictEmbargoSumOrderByAggregateInput
  }

  export type VerdictEmbargoScalarWhereWithAggregatesInput = {
    AND?: VerdictEmbargoScalarWhereWithAggregatesInput | VerdictEmbargoScalarWhereWithAggregatesInput[]
    OR?: VerdictEmbargoScalarWhereWithAggregatesInput[]
    NOT?: VerdictEmbargoScalarWhereWithAggregatesInput | VerdictEmbargoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    verdictId?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    companyName?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    companyPhone?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    companyEmail?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    companyAddress?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    embargoType?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    embargoDate?: DateTimeWithAggregatesFilter<"VerdictEmbargo"> | Date | string
    embargoAmount?: FloatWithAggregatesFilter<"VerdictEmbargo"> | number
    totalAmount?: FloatWithAggregatesFilter<"VerdictEmbargo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VerdictEmbargo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerdictEmbargo"> | Date | string
  }

  export type VerdictBailiffServicesWhereInput = {
    AND?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    OR?: VerdictBailiffServicesWhereInput[]
    NOT?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    id?: StringFilter<"VerdictBailiffServices"> | string
    verdictId?: StringFilter<"VerdictBailiffServices"> | string
    serviceType?: StringFilter<"VerdictBailiffServices"> | string
    serviceCost?: FloatFilter<"VerdictBailiffServices"> | number
    createdAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }

  export type VerdictBailiffServicesOrderByWithRelationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    serviceType?: SortOrder
    serviceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdict?: VerdictOrderByWithRelationInput
  }

  export type VerdictBailiffServicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    OR?: VerdictBailiffServicesWhereInput[]
    NOT?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    verdictId?: StringFilter<"VerdictBailiffServices"> | string
    serviceType?: StringFilter<"VerdictBailiffServices"> | string
    serviceCost?: FloatFilter<"VerdictBailiffServices"> | number
    createdAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }, "id">

  export type VerdictBailiffServicesOrderByWithAggregationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    serviceType?: SortOrder
    serviceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerdictBailiffServicesCountOrderByAggregateInput
    _avg?: VerdictBailiffServicesAvgOrderByAggregateInput
    _max?: VerdictBailiffServicesMaxOrderByAggregateInput
    _min?: VerdictBailiffServicesMinOrderByAggregateInput
    _sum?: VerdictBailiffServicesSumOrderByAggregateInput
  }

  export type VerdictBailiffServicesScalarWhereWithAggregatesInput = {
    AND?: VerdictBailiffServicesScalarWhereWithAggregatesInput | VerdictBailiffServicesScalarWhereWithAggregatesInput[]
    OR?: VerdictBailiffServicesScalarWhereWithAggregatesInput[]
    NOT?: VerdictBailiffServicesScalarWhereWithAggregatesInput | VerdictBailiffServicesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictBailiffServices"> | string
    verdictId?: StringWithAggregatesFilter<"VerdictBailiffServices"> | string
    serviceType?: StringWithAggregatesFilter<"VerdictBailiffServices"> | string
    serviceCost?: FloatWithAggregatesFilter<"VerdictBailiffServices"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VerdictBailiffServices"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerdictBailiffServices"> | Date | string
  }

  export type VerdictAttachmentWhereInput = {
    AND?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    OR?: VerdictAttachmentWhereInput[]
    NOT?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    id?: StringFilter<"VerdictAttachment"> | string
    verdictId?: StringFilter<"VerdictAttachment"> | string
    filePath?: StringFilter<"VerdictAttachment"> | string
    fileSize?: BigIntFilter<"VerdictAttachment"> | bigint | number
    createdAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    fileName?: StringFilter<"VerdictAttachment"> | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }

  export type VerdictAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
    verdict?: VerdictOrderByWithRelationInput
  }

  export type VerdictAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    OR?: VerdictAttachmentWhereInput[]
    NOT?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    verdictId?: StringFilter<"VerdictAttachment"> | string
    filePath?: StringFilter<"VerdictAttachment"> | string
    fileSize?: BigIntFilter<"VerdictAttachment"> | bigint | number
    createdAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    fileName?: StringFilter<"VerdictAttachment"> | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }, "id">

  export type VerdictAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
    _count?: VerdictAttachmentCountOrderByAggregateInput
    _avg?: VerdictAttachmentAvgOrderByAggregateInput
    _max?: VerdictAttachmentMaxOrderByAggregateInput
    _min?: VerdictAttachmentMinOrderByAggregateInput
    _sum?: VerdictAttachmentSumOrderByAggregateInput
  }

  export type VerdictAttachmentScalarWhereWithAggregatesInput = {
    AND?: VerdictAttachmentScalarWhereWithAggregatesInput | VerdictAttachmentScalarWhereWithAggregatesInput[]
    OR?: VerdictAttachmentScalarWhereWithAggregatesInput[]
    NOT?: VerdictAttachmentScalarWhereWithAggregatesInput | VerdictAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictAttachment"> | string
    verdictId?: StringWithAggregatesFilter<"VerdictAttachment"> | string
    filePath?: StringWithAggregatesFilter<"VerdictAttachment"> | string
    fileSize?: BigIntWithAggregatesFilter<"VerdictAttachment"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"VerdictAttachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerdictAttachment"> | Date | string
    fileName?: StringWithAggregatesFilter<"VerdictAttachment"> | string
  }

  export type InterestTypeWhereInput = {
    AND?: InterestTypeWhereInput | InterestTypeWhereInput[]
    OR?: InterestTypeWhereInput[]
    NOT?: InterestTypeWhereInput | InterestTypeWhereInput[]
    id?: IntFilter<"InterestType"> | number
    name?: StringFilter<"InterestType"> | string
    calculationType?: EnumCalculationTypeEnumFilter<"InterestType"> | $Enums.CalculationTypeEnum
    details?: InterestDetailListRelationFilter
  }

  export type InterestTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    calculationType?: SortOrder
    details?: InterestDetailOrderByRelationAggregateInput
  }

  export type InterestTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InterestTypeWhereInput | InterestTypeWhereInput[]
    OR?: InterestTypeWhereInput[]
    NOT?: InterestTypeWhereInput | InterestTypeWhereInput[]
    name?: StringFilter<"InterestType"> | string
    calculationType?: EnumCalculationTypeEnumFilter<"InterestType"> | $Enums.CalculationTypeEnum
    details?: InterestDetailListRelationFilter
  }, "id">

  export type InterestTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    calculationType?: SortOrder
    _count?: InterestTypeCountOrderByAggregateInput
    _avg?: InterestTypeAvgOrderByAggregateInput
    _max?: InterestTypeMaxOrderByAggregateInput
    _min?: InterestTypeMinOrderByAggregateInput
    _sum?: InterestTypeSumOrderByAggregateInput
  }

  export type InterestTypeScalarWhereWithAggregatesInput = {
    AND?: InterestTypeScalarWhereWithAggregatesInput | InterestTypeScalarWhereWithAggregatesInput[]
    OR?: InterestTypeScalarWhereWithAggregatesInput[]
    NOT?: InterestTypeScalarWhereWithAggregatesInput | InterestTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InterestType"> | number
    name?: StringWithAggregatesFilter<"InterestType"> | string
    calculationType?: EnumCalculationTypeEnumWithAggregatesFilter<"InterestType"> | $Enums.CalculationTypeEnum
  }

  export type InterestDetailWhereInput = {
    AND?: InterestDetailWhereInput | InterestDetailWhereInput[]
    OR?: InterestDetailWhereInput[]
    NOT?: InterestDetailWhereInput | InterestDetailWhereInput[]
    id?: IntFilter<"InterestDetail"> | number
    date?: StringFilter<"InterestDetail"> | string
    rate?: FloatFilter<"InterestDetail"> | number
    interestTypeId?: IntFilter<"InterestDetail"> | number
    interestType?: XOR<InterestTypeScalarRelationFilter, InterestTypeWhereInput>
  }

  export type InterestDetailOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
    interestType?: InterestTypeOrderByWithRelationInput
  }

  export type InterestDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InterestDetailWhereInput | InterestDetailWhereInput[]
    OR?: InterestDetailWhereInput[]
    NOT?: InterestDetailWhereInput | InterestDetailWhereInput[]
    date?: StringFilter<"InterestDetail"> | string
    rate?: FloatFilter<"InterestDetail"> | number
    interestTypeId?: IntFilter<"InterestDetail"> | number
    interestType?: XOR<InterestTypeScalarRelationFilter, InterestTypeWhereInput>
  }, "id">

  export type InterestDetailOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
    _count?: InterestDetailCountOrderByAggregateInput
    _avg?: InterestDetailAvgOrderByAggregateInput
    _max?: InterestDetailMaxOrderByAggregateInput
    _min?: InterestDetailMinOrderByAggregateInput
    _sum?: InterestDetailSumOrderByAggregateInput
  }

  export type InterestDetailScalarWhereWithAggregatesInput = {
    AND?: InterestDetailScalarWhereWithAggregatesInput | InterestDetailScalarWhereWithAggregatesInput[]
    OR?: InterestDetailScalarWhereWithAggregatesInput[]
    NOT?: InterestDetailScalarWhereWithAggregatesInput | InterestDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InterestDetail"> | number
    date?: StringWithAggregatesFilter<"InterestDetail"> | string
    rate?: FloatWithAggregatesFilter<"InterestDetail"> | number
    interestTypeId?: IntWithAggregatesFilter<"InterestDetail"> | number
  }

  export type BillingInvoiceWhereInput = {
    AND?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    OR?: BillingInvoiceWhereInput[]
    NOT?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    id?: StringFilter<"BillingInvoice"> | string
    tenantId?: StringFilter<"BillingInvoice"> | string
    invoiceNumber?: StringFilter<"BillingInvoice"> | string
    amount?: FloatFilter<"BillingInvoice"> | number
    currency?: StringFilter<"BillingInvoice"> | string
    issueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    dueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    description?: StringNullableFilter<"BillingInvoice"> | string | null
    status?: StringFilter<"BillingInvoice"> | string
    createdAt?: DateTimeFilter<"BillingInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoice"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    details?: BillingInvoiceDetailListRelationFilter
    payments?: BillingPaymentListRelationFilter
    subscription?: BillingSubscriptionListRelationFilter
  }

  export type BillingInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    details?: BillingInvoiceDetailOrderByRelationAggregateInput
    payments?: BillingPaymentOrderByRelationAggregateInput
    subscription?: BillingSubscriptionOrderByRelationAggregateInput
  }

  export type BillingInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    OR?: BillingInvoiceWhereInput[]
    NOT?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    tenantId?: StringFilter<"BillingInvoice"> | string
    amount?: FloatFilter<"BillingInvoice"> | number
    currency?: StringFilter<"BillingInvoice"> | string
    issueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    dueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    description?: StringNullableFilter<"BillingInvoice"> | string | null
    status?: StringFilter<"BillingInvoice"> | string
    createdAt?: DateTimeFilter<"BillingInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoice"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    details?: BillingInvoiceDetailListRelationFilter
    payments?: BillingPaymentListRelationFilter
    subscription?: BillingSubscriptionListRelationFilter
  }, "id" | "invoiceNumber">

  export type BillingInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillingInvoiceCountOrderByAggregateInput
    _avg?: BillingInvoiceAvgOrderByAggregateInput
    _max?: BillingInvoiceMaxOrderByAggregateInput
    _min?: BillingInvoiceMinOrderByAggregateInput
    _sum?: BillingInvoiceSumOrderByAggregateInput
  }

  export type BillingInvoiceScalarWhereWithAggregatesInput = {
    AND?: BillingInvoiceScalarWhereWithAggregatesInput | BillingInvoiceScalarWhereWithAggregatesInput[]
    OR?: BillingInvoiceScalarWhereWithAggregatesInput[]
    NOT?: BillingInvoiceScalarWhereWithAggregatesInput | BillingInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingInvoice"> | string
    tenantId?: StringWithAggregatesFilter<"BillingInvoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"BillingInvoice"> | string
    amount?: FloatWithAggregatesFilter<"BillingInvoice"> | number
    currency?: StringWithAggregatesFilter<"BillingInvoice"> | string
    issueDate?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
    description?: StringNullableWithAggregatesFilter<"BillingInvoice"> | string | null
    status?: StringWithAggregatesFilter<"BillingInvoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
  }

  export type BillingInvoiceDetailWhereInput = {
    AND?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    OR?: BillingInvoiceDetailWhereInput[]
    NOT?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    id?: StringFilter<"BillingInvoiceDetail"> | string
    itemDescription?: StringFilter<"BillingInvoiceDetail"> | string
    itemQuantity?: IntFilter<"BillingInvoiceDetail"> | number
    itemUnitPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxRate?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxAmount?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalWithTax?: FloatFilter<"BillingInvoiceDetail"> | number
    createdAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingInvoiceDetail"> | string | null
    billingInvoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }

  export type BillingInvoiceDetailOrderByWithRelationInput = {
    id?: SortOrder
    itemDescription?: SortOrder
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrderInput | SortOrder
    billingInvoice?: BillingInvoiceOrderByWithRelationInput
  }

  export type BillingInvoiceDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    OR?: BillingInvoiceDetailWhereInput[]
    NOT?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    itemDescription?: StringFilter<"BillingInvoiceDetail"> | string
    itemQuantity?: IntFilter<"BillingInvoiceDetail"> | number
    itemUnitPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxRate?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxAmount?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalWithTax?: FloatFilter<"BillingInvoiceDetail"> | number
    createdAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingInvoiceDetail"> | string | null
    billingInvoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }, "id">

  export type BillingInvoiceDetailOrderByWithAggregationInput = {
    id?: SortOrder
    itemDescription?: SortOrder
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrderInput | SortOrder
    _count?: BillingInvoiceDetailCountOrderByAggregateInput
    _avg?: BillingInvoiceDetailAvgOrderByAggregateInput
    _max?: BillingInvoiceDetailMaxOrderByAggregateInput
    _min?: BillingInvoiceDetailMinOrderByAggregateInput
    _sum?: BillingInvoiceDetailSumOrderByAggregateInput
  }

  export type BillingInvoiceDetailScalarWhereWithAggregatesInput = {
    AND?: BillingInvoiceDetailScalarWhereWithAggregatesInput | BillingInvoiceDetailScalarWhereWithAggregatesInput[]
    OR?: BillingInvoiceDetailScalarWhereWithAggregatesInput[]
    NOT?: BillingInvoiceDetailScalarWhereWithAggregatesInput | BillingInvoiceDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingInvoiceDetail"> | string
    itemDescription?: StringWithAggregatesFilter<"BillingInvoiceDetail"> | string
    itemQuantity?: IntWithAggregatesFilter<"BillingInvoiceDetail"> | number
    itemUnitPrice?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    itemTotalPrice?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    itemTaxRate?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    itemTaxAmount?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    itemTotalWithTax?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BillingInvoiceDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingInvoiceDetail"> | Date | string
    billingInvoiceId?: StringNullableWithAggregatesFilter<"BillingInvoiceDetail"> | string | null
  }

  export type BillingPlanWhereInput = {
    AND?: BillingPlanWhereInput | BillingPlanWhereInput[]
    OR?: BillingPlanWhereInput[]
    NOT?: BillingPlanWhereInput | BillingPlanWhereInput[]
    id?: StringFilter<"BillingPlan"> | string
    name?: StringFilter<"BillingPlan"> | string
    description?: StringNullableFilter<"BillingPlan"> | string | null
    price?: FloatFilter<"BillingPlan"> | number
    currency?: StringFilter<"BillingPlan"> | string
    billingCycle?: StringFilter<"BillingPlan"> | string
    features?: JsonNullableFilter<"BillingPlan">
    isActive?: BoolFilter<"BillingPlan"> | boolean
    createdAt?: DateTimeFilter<"BillingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPlan"> | Date | string
    subscriptions?: BillingSubscriptionListRelationFilter
  }

  export type BillingPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingCycle?: SortOrder
    features?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscriptions?: BillingSubscriptionOrderByRelationAggregateInput
  }

  export type BillingPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingPlanWhereInput | BillingPlanWhereInput[]
    OR?: BillingPlanWhereInput[]
    NOT?: BillingPlanWhereInput | BillingPlanWhereInput[]
    name?: StringFilter<"BillingPlan"> | string
    description?: StringNullableFilter<"BillingPlan"> | string | null
    price?: FloatFilter<"BillingPlan"> | number
    currency?: StringFilter<"BillingPlan"> | string
    billingCycle?: StringFilter<"BillingPlan"> | string
    features?: JsonNullableFilter<"BillingPlan">
    isActive?: BoolFilter<"BillingPlan"> | boolean
    createdAt?: DateTimeFilter<"BillingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPlan"> | Date | string
    subscriptions?: BillingSubscriptionListRelationFilter
  }, "id">

  export type BillingPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingCycle?: SortOrder
    features?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillingPlanCountOrderByAggregateInput
    _avg?: BillingPlanAvgOrderByAggregateInput
    _max?: BillingPlanMaxOrderByAggregateInput
    _min?: BillingPlanMinOrderByAggregateInput
    _sum?: BillingPlanSumOrderByAggregateInput
  }

  export type BillingPlanScalarWhereWithAggregatesInput = {
    AND?: BillingPlanScalarWhereWithAggregatesInput | BillingPlanScalarWhereWithAggregatesInput[]
    OR?: BillingPlanScalarWhereWithAggregatesInput[]
    NOT?: BillingPlanScalarWhereWithAggregatesInput | BillingPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingPlan"> | string
    name?: StringWithAggregatesFilter<"BillingPlan"> | string
    description?: StringNullableWithAggregatesFilter<"BillingPlan"> | string | null
    price?: FloatWithAggregatesFilter<"BillingPlan"> | number
    currency?: StringWithAggregatesFilter<"BillingPlan"> | string
    billingCycle?: StringWithAggregatesFilter<"BillingPlan"> | string
    features?: JsonNullableWithAggregatesFilter<"BillingPlan">
    isActive?: BoolWithAggregatesFilter<"BillingPlan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BillingPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingPlan"> | Date | string
  }

  export type BillingSubscriptionWhereInput = {
    AND?: BillingSubscriptionWhereInput | BillingSubscriptionWhereInput[]
    OR?: BillingSubscriptionWhereInput[]
    NOT?: BillingSubscriptionWhereInput | BillingSubscriptionWhereInput[]
    id?: StringFilter<"BillingSubscription"> | string
    tenantId?: StringFilter<"BillingSubscription"> | string
    planId?: StringFilter<"BillingSubscription"> | string
    startDate?: DateTimeFilter<"BillingSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    billingCycle?: StringFilter<"BillingSubscription"> | string
    amount?: FloatFilter<"BillingSubscription"> | number
    currency?: StringFilter<"BillingSubscription"> | string
    lastInvoiceId?: StringNullableFilter<"BillingSubscription"> | string | null
    trialEndsAt?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"BillingSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"BillingSubscription"> | Date | string
    status?: EnumBillingSubscriptionStatusFilter<"BillingSubscription"> | $Enums.BillingSubscriptionStatus
    lastInvoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
    plan?: XOR<BillingPlanScalarRelationFilter, BillingPlanWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type BillingSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    billingCycle?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    lastInvoiceId?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    lastInvoice?: BillingInvoiceOrderByWithRelationInput
    plan?: BillingPlanOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type BillingSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingSubscriptionWhereInput | BillingSubscriptionWhereInput[]
    OR?: BillingSubscriptionWhereInput[]
    NOT?: BillingSubscriptionWhereInput | BillingSubscriptionWhereInput[]
    tenantId?: StringFilter<"BillingSubscription"> | string
    planId?: StringFilter<"BillingSubscription"> | string
    startDate?: DateTimeFilter<"BillingSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    billingCycle?: StringFilter<"BillingSubscription"> | string
    amount?: FloatFilter<"BillingSubscription"> | number
    currency?: StringFilter<"BillingSubscription"> | string
    lastInvoiceId?: StringNullableFilter<"BillingSubscription"> | string | null
    trialEndsAt?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"BillingSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"BillingSubscription"> | Date | string
    status?: EnumBillingSubscriptionStatusFilter<"BillingSubscription"> | $Enums.BillingSubscriptionStatus
    lastInvoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
    plan?: XOR<BillingPlanScalarRelationFilter, BillingPlanWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type BillingSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nextBillingDate?: SortOrderInput | SortOrder
    billingCycle?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    lastInvoiceId?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: BillingSubscriptionCountOrderByAggregateInput
    _avg?: BillingSubscriptionAvgOrderByAggregateInput
    _max?: BillingSubscriptionMaxOrderByAggregateInput
    _min?: BillingSubscriptionMinOrderByAggregateInput
    _sum?: BillingSubscriptionSumOrderByAggregateInput
  }

  export type BillingSubscriptionScalarWhereWithAggregatesInput = {
    AND?: BillingSubscriptionScalarWhereWithAggregatesInput | BillingSubscriptionScalarWhereWithAggregatesInput[]
    OR?: BillingSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: BillingSubscriptionScalarWhereWithAggregatesInput | BillingSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingSubscription"> | string
    tenantId?: StringWithAggregatesFilter<"BillingSubscription"> | string
    planId?: StringWithAggregatesFilter<"BillingSubscription"> | string
    startDate?: DateTimeWithAggregatesFilter<"BillingSubscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"BillingSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableWithAggregatesFilter<"BillingSubscription"> | Date | string | null
    billingCycle?: StringWithAggregatesFilter<"BillingSubscription"> | string
    amount?: FloatWithAggregatesFilter<"BillingSubscription"> | number
    currency?: StringWithAggregatesFilter<"BillingSubscription"> | string
    lastInvoiceId?: StringNullableWithAggregatesFilter<"BillingSubscription"> | string | null
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"BillingSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"BillingSubscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BillingSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingSubscription"> | Date | string
    status?: EnumBillingSubscriptionStatusWithAggregatesFilter<"BillingSubscription"> | $Enums.BillingSubscriptionStatus
  }

  export type BillingPaymentWhereInput = {
    AND?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    OR?: BillingPaymentWhereInput[]
    NOT?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    id?: StringFilter<"BillingPayment"> | string
    paymentDate?: DateTimeFilter<"BillingPayment"> | Date | string
    amount?: FloatFilter<"BillingPayment"> | number
    paymentMethod?: StringFilter<"BillingPayment"> | string
    transactionId?: StringNullableFilter<"BillingPayment"> | string | null
    status?: StringFilter<"BillingPayment"> | string
    createdAt?: DateTimeFilter<"BillingPayment"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPayment"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingPayment"> | string | null
    BillingInvoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }

  export type BillingPaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrderInput | SortOrder
    BillingInvoice?: BillingInvoiceOrderByWithRelationInput
  }

  export type BillingPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    OR?: BillingPaymentWhereInput[]
    NOT?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    paymentDate?: DateTimeFilter<"BillingPayment"> | Date | string
    amount?: FloatFilter<"BillingPayment"> | number
    paymentMethod?: StringFilter<"BillingPayment"> | string
    transactionId?: StringNullableFilter<"BillingPayment"> | string | null
    status?: StringFilter<"BillingPayment"> | string
    createdAt?: DateTimeFilter<"BillingPayment"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPayment"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingPayment"> | string | null
    BillingInvoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }, "id">

  export type BillingPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrderInput | SortOrder
    _count?: BillingPaymentCountOrderByAggregateInput
    _avg?: BillingPaymentAvgOrderByAggregateInput
    _max?: BillingPaymentMaxOrderByAggregateInput
    _min?: BillingPaymentMinOrderByAggregateInput
    _sum?: BillingPaymentSumOrderByAggregateInput
  }

  export type BillingPaymentScalarWhereWithAggregatesInput = {
    AND?: BillingPaymentScalarWhereWithAggregatesInput | BillingPaymentScalarWhereWithAggregatesInput[]
    OR?: BillingPaymentScalarWhereWithAggregatesInput[]
    NOT?: BillingPaymentScalarWhereWithAggregatesInput | BillingPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingPayment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"BillingPayment"> | Date | string
    amount?: FloatWithAggregatesFilter<"BillingPayment"> | number
    paymentMethod?: StringWithAggregatesFilter<"BillingPayment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"BillingPayment"> | string | null
    status?: StringWithAggregatesFilter<"BillingPayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BillingPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingPayment"> | Date | string
    billingInvoiceId?: StringNullableWithAggregatesFilter<"BillingPayment"> | string | null
  }

  export type CollectionCaseWhereInput = {
    AND?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    OR?: CollectionCaseWhereInput[]
    NOT?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    id?: StringFilter<"CollectionCase"> | string
    referenceNumber?: StringNullableFilter<"CollectionCase"> | string | null
    issueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    tenantId?: StringFilter<"CollectionCase"> | string
    debtorId?: StringFilter<"CollectionCase"> | string
    amountOriginal?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFilter<"CollectionCase"> | $Enums.CollectionStatus
    createdAt?: DateTimeFilter<"CollectionCase"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionCase"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    agreements?: PaymentAgreementListRelationFilter
    penalties?: PenaltyListRelationFilter
  }

  export type CollectionCaseOrderByWithRelationInput = {
    id?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    debtorId?: SortOrder
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    debtor?: DebtorOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    agreements?: PaymentAgreementOrderByRelationAggregateInput
    penalties?: PenaltyOrderByRelationAggregateInput
  }

  export type CollectionCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    OR?: CollectionCaseWhereInput[]
    NOT?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    referenceNumber?: StringNullableFilter<"CollectionCase"> | string | null
    issueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    tenantId?: StringFilter<"CollectionCase"> | string
    debtorId?: StringFilter<"CollectionCase"> | string
    amountOriginal?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFilter<"CollectionCase"> | $Enums.CollectionStatus
    createdAt?: DateTimeFilter<"CollectionCase"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionCase"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    agreements?: PaymentAgreementListRelationFilter
    penalties?: PenaltyListRelationFilter
  }, "id">

  export type CollectionCaseOrderByWithAggregationInput = {
    id?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    debtorId?: SortOrder
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CollectionCaseCountOrderByAggregateInput
    _avg?: CollectionCaseAvgOrderByAggregateInput
    _max?: CollectionCaseMaxOrderByAggregateInput
    _min?: CollectionCaseMinOrderByAggregateInput
    _sum?: CollectionCaseSumOrderByAggregateInput
  }

  export type CollectionCaseScalarWhereWithAggregatesInput = {
    AND?: CollectionCaseScalarWhereWithAggregatesInput | CollectionCaseScalarWhereWithAggregatesInput[]
    OR?: CollectionCaseScalarWhereWithAggregatesInput[]
    NOT?: CollectionCaseScalarWhereWithAggregatesInput | CollectionCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionCase"> | string
    referenceNumber?: StringNullableWithAggregatesFilter<"CollectionCase"> | string | null
    issueDate?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    tenantId?: StringWithAggregatesFilter<"CollectionCase"> | string
    debtorId?: StringWithAggregatesFilter<"CollectionCase"> | string
    amountOriginal?: DecimalWithAggregatesFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalWithAggregatesFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalWithAggregatesFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusWithAggregatesFilter<"CollectionCase"> | $Enums.CollectionStatus
    createdAt?: DateTimeWithAggregatesFilter<"CollectionCase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CollectionCase"> | Date | string
  }

  export type PenaltyWhereInput = {
    AND?: PenaltyWhereInput | PenaltyWhereInput[]
    OR?: PenaltyWhereInput[]
    NOT?: PenaltyWhereInput | PenaltyWhereInput[]
    id?: StringFilter<"Penalty"> | string
    collectionCaseId?: StringFilter<"Penalty"> | string
    description?: StringNullableFilter<"Penalty"> | string | null
    amount?: DecimalFilter<"Penalty"> | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFilter<"Penalty"> | Date | string
    isPaid?: BoolFilter<"Penalty"> | boolean
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
    updatedAt?: DateTimeFilter<"Penalty"> | Date | string
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }

  export type PenaltyOrderByWithRelationInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    dateApplied?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collectionCase?: CollectionCaseOrderByWithRelationInput
  }

  export type PenaltyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PenaltyWhereInput | PenaltyWhereInput[]
    OR?: PenaltyWhereInput[]
    NOT?: PenaltyWhereInput | PenaltyWhereInput[]
    collectionCaseId?: StringFilter<"Penalty"> | string
    description?: StringNullableFilter<"Penalty"> | string | null
    amount?: DecimalFilter<"Penalty"> | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFilter<"Penalty"> | Date | string
    isPaid?: BoolFilter<"Penalty"> | boolean
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
    updatedAt?: DateTimeFilter<"Penalty"> | Date | string
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }, "id">

  export type PenaltyOrderByWithAggregationInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    dateApplied?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PenaltyCountOrderByAggregateInput
    _avg?: PenaltyAvgOrderByAggregateInput
    _max?: PenaltyMaxOrderByAggregateInput
    _min?: PenaltyMinOrderByAggregateInput
    _sum?: PenaltySumOrderByAggregateInput
  }

  export type PenaltyScalarWhereWithAggregatesInput = {
    AND?: PenaltyScalarWhereWithAggregatesInput | PenaltyScalarWhereWithAggregatesInput[]
    OR?: PenaltyScalarWhereWithAggregatesInput[]
    NOT?: PenaltyScalarWhereWithAggregatesInput | PenaltyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Penalty"> | string
    collectionCaseId?: StringWithAggregatesFilter<"Penalty"> | string
    description?: StringNullableWithAggregatesFilter<"Penalty"> | string | null
    amount?: DecimalWithAggregatesFilter<"Penalty"> | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeWithAggregatesFilter<"Penalty"> | Date | string
    isPaid?: BoolWithAggregatesFilter<"Penalty"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Penalty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Penalty"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    collectionCaseId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    sentAt?: DateTimeFilter<"Notification"> | Date | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    collectionCase?: CollectionCaseOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    collectionCaseId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    sentAt?: DateTimeFilter<"Notification"> | Date | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    collectionCaseId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    sentAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    collectionCaseId?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    collectionCaseId?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    collectionCase?: CollectionCaseOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    collectionCaseId?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    collectionCaseId?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    collectionCaseId?: StringWithAggregatesFilter<"Payment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PaymentAgreementWhereInput = {
    AND?: PaymentAgreementWhereInput | PaymentAgreementWhereInput[]
    OR?: PaymentAgreementWhereInput[]
    NOT?: PaymentAgreementWhereInput | PaymentAgreementWhereInput[]
    id?: StringFilter<"PaymentAgreement"> | string
    debtorId?: StringNullableFilter<"PaymentAgreement"> | string | null
    agreementDate?: DateTimeFilter<"PaymentAgreement"> | Date | string
    status?: EnumAgreementStatusFilter<"PaymentAgreement"> | $Enums.AgreementStatus
    createdAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    collectionCaseId?: StringFilter<"PaymentAgreement"> | string
    installmentAmount?: DecimalNullableFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: DateTimeNullableFilter<"PaymentAgreement"> | Date | string | null
    notes?: StringNullableFilter<"PaymentAgreement"> | string | null
    totalInstallments?: IntNullableFilter<"PaymentAgreement"> | number | null
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    Debtor?: XOR<DebtorNullableScalarRelationFilter, DebtorWhereInput> | null
  }

  export type PaymentAgreementOrderByWithRelationInput = {
    id?: SortOrder
    debtorId?: SortOrderInput | SortOrder
    agreementDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collectionCaseId?: SortOrder
    installmentAmount?: SortOrderInput | SortOrder
    nextPaymentDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    totalInstallments?: SortOrderInput | SortOrder
    collectionCase?: CollectionCaseOrderByWithRelationInput
    Debtor?: DebtorOrderByWithRelationInput
  }

  export type PaymentAgreementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentAgreementWhereInput | PaymentAgreementWhereInput[]
    OR?: PaymentAgreementWhereInput[]
    NOT?: PaymentAgreementWhereInput | PaymentAgreementWhereInput[]
    debtorId?: StringNullableFilter<"PaymentAgreement"> | string | null
    agreementDate?: DateTimeFilter<"PaymentAgreement"> | Date | string
    status?: EnumAgreementStatusFilter<"PaymentAgreement"> | $Enums.AgreementStatus
    createdAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    collectionCaseId?: StringFilter<"PaymentAgreement"> | string
    installmentAmount?: DecimalNullableFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: DateTimeNullableFilter<"PaymentAgreement"> | Date | string | null
    notes?: StringNullableFilter<"PaymentAgreement"> | string | null
    totalInstallments?: IntNullableFilter<"PaymentAgreement"> | number | null
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    Debtor?: XOR<DebtorNullableScalarRelationFilter, DebtorWhereInput> | null
  }, "id">

  export type PaymentAgreementOrderByWithAggregationInput = {
    id?: SortOrder
    debtorId?: SortOrderInput | SortOrder
    agreementDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collectionCaseId?: SortOrder
    installmentAmount?: SortOrderInput | SortOrder
    nextPaymentDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    totalInstallments?: SortOrderInput | SortOrder
    _count?: PaymentAgreementCountOrderByAggregateInput
    _avg?: PaymentAgreementAvgOrderByAggregateInput
    _max?: PaymentAgreementMaxOrderByAggregateInput
    _min?: PaymentAgreementMinOrderByAggregateInput
    _sum?: PaymentAgreementSumOrderByAggregateInput
  }

  export type PaymentAgreementScalarWhereWithAggregatesInput = {
    AND?: PaymentAgreementScalarWhereWithAggregatesInput | PaymentAgreementScalarWhereWithAggregatesInput[]
    OR?: PaymentAgreementScalarWhereWithAggregatesInput[]
    NOT?: PaymentAgreementScalarWhereWithAggregatesInput | PaymentAgreementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentAgreement"> | string
    debtorId?: StringNullableWithAggregatesFilter<"PaymentAgreement"> | string | null
    agreementDate?: DateTimeWithAggregatesFilter<"PaymentAgreement"> | Date | string
    status?: EnumAgreementStatusWithAggregatesFilter<"PaymentAgreement"> | $Enums.AgreementStatus
    createdAt?: DateTimeWithAggregatesFilter<"PaymentAgreement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentAgreement"> | Date | string
    collectionCaseId?: StringWithAggregatesFilter<"PaymentAgreement"> | string
    installmentAmount?: DecimalNullableWithAggregatesFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: DateTimeNullableWithAggregatesFilter<"PaymentAgreement"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"PaymentAgreement"> | string | null
    totalInstallments?: IntNullableWithAggregatesFilter<"PaymentAgreement"> | number | null
  }

  export type DebtorWhereInput = {
    AND?: DebtorWhereInput | DebtorWhereInput[]
    OR?: DebtorWhereInput[]
    NOT?: DebtorWhereInput | DebtorWhereInput[]
    id?: StringFilter<"Debtor"> | string
    tenantId?: StringFilter<"Debtor"> | string
    userId?: StringNullableFilter<"Debtor"> | string | null
    fullname?: StringFilter<"Debtor"> | string
    email?: StringFilter<"Debtor"> | string
    phone?: StringNullableFilter<"Debtor"> | string | null
    address?: StringNullableFilter<"Debtor"> | string | null
    personType?: StringNullableFilter<"Debtor"> | string | null
    identificationType?: EnumIdentificationTypeNullableFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableFilter<"Debtor"> | string | null
    totalIncome?: FloatNullableFilter<"Debtor"> | number | null
    createdAt?: DateTimeFilter<"Debtor"> | Date | string
    updatedAt?: DateTimeFilter<"Debtor"> | Date | string
    collectionCases?: CollectionCaseListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    incomes?: DebtorIncomeListRelationFilter
    paymentAgreements?: PaymentAgreementListRelationFilter
    verdicts?: VerdictListRelationFilter
  }

  export type DebtorOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    personType?: SortOrderInput | SortOrder
    identificationType?: SortOrderInput | SortOrder
    identification?: SortOrderInput | SortOrder
    totalIncome?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collectionCases?: CollectionCaseOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    incomes?: DebtorIncomeOrderByRelationAggregateInput
    paymentAgreements?: PaymentAgreementOrderByRelationAggregateInput
    verdicts?: VerdictOrderByRelationAggregateInput
  }

  export type DebtorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_email?: DebtorTenantIdEmailCompoundUniqueInput
    tenantId_identification?: DebtorTenantIdIdentificationCompoundUniqueInput
    AND?: DebtorWhereInput | DebtorWhereInput[]
    OR?: DebtorWhereInput[]
    NOT?: DebtorWhereInput | DebtorWhereInput[]
    tenantId?: StringFilter<"Debtor"> | string
    userId?: StringNullableFilter<"Debtor"> | string | null
    fullname?: StringFilter<"Debtor"> | string
    email?: StringFilter<"Debtor"> | string
    phone?: StringNullableFilter<"Debtor"> | string | null
    address?: StringNullableFilter<"Debtor"> | string | null
    personType?: StringNullableFilter<"Debtor"> | string | null
    identificationType?: EnumIdentificationTypeNullableFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableFilter<"Debtor"> | string | null
    totalIncome?: FloatNullableFilter<"Debtor"> | number | null
    createdAt?: DateTimeFilter<"Debtor"> | Date | string
    updatedAt?: DateTimeFilter<"Debtor"> | Date | string
    collectionCases?: CollectionCaseListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    incomes?: DebtorIncomeListRelationFilter
    paymentAgreements?: PaymentAgreementListRelationFilter
    verdicts?: VerdictListRelationFilter
  }, "id" | "tenantId_email" | "tenantId_identification">

  export type DebtorOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    personType?: SortOrderInput | SortOrder
    identificationType?: SortOrderInput | SortOrder
    identification?: SortOrderInput | SortOrder
    totalIncome?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DebtorCountOrderByAggregateInput
    _avg?: DebtorAvgOrderByAggregateInput
    _max?: DebtorMaxOrderByAggregateInput
    _min?: DebtorMinOrderByAggregateInput
    _sum?: DebtorSumOrderByAggregateInput
  }

  export type DebtorScalarWhereWithAggregatesInput = {
    AND?: DebtorScalarWhereWithAggregatesInput | DebtorScalarWhereWithAggregatesInput[]
    OR?: DebtorScalarWhereWithAggregatesInput[]
    NOT?: DebtorScalarWhereWithAggregatesInput | DebtorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Debtor"> | string
    tenantId?: StringWithAggregatesFilter<"Debtor"> | string
    userId?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    fullname?: StringWithAggregatesFilter<"Debtor"> | string
    email?: StringWithAggregatesFilter<"Debtor"> | string
    phone?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    address?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    personType?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    identificationType?: EnumIdentificationTypeNullableWithAggregatesFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    totalIncome?: FloatNullableWithAggregatesFilter<"Debtor"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Debtor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Debtor"> | Date | string
  }

  export type DebtorIncomeWhereInput = {
    AND?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    OR?: DebtorIncomeWhereInput[]
    NOT?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    id?: StringFilter<"DebtorIncome"> | string
    debtorId?: StringFilter<"DebtorIncome"> | string
    amount?: FloatFilter<"DebtorIncome"> | number
    source?: StringFilter<"DebtorIncome"> | string
    createdAt?: DateTimeFilter<"DebtorIncome"> | Date | string
    updatedAt?: DateTimeFilter<"DebtorIncome"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
  }

  export type DebtorIncomeOrderByWithRelationInput = {
    id?: SortOrder
    debtorId?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    debtor?: DebtorOrderByWithRelationInput
  }

  export type DebtorIncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    OR?: DebtorIncomeWhereInput[]
    NOT?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    debtorId?: StringFilter<"DebtorIncome"> | string
    amount?: FloatFilter<"DebtorIncome"> | number
    source?: StringFilter<"DebtorIncome"> | string
    createdAt?: DateTimeFilter<"DebtorIncome"> | Date | string
    updatedAt?: DateTimeFilter<"DebtorIncome"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
  }, "id">

  export type DebtorIncomeOrderByWithAggregationInput = {
    id?: SortOrder
    debtorId?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DebtorIncomeCountOrderByAggregateInput
    _avg?: DebtorIncomeAvgOrderByAggregateInput
    _max?: DebtorIncomeMaxOrderByAggregateInput
    _min?: DebtorIncomeMinOrderByAggregateInput
    _sum?: DebtorIncomeSumOrderByAggregateInput
  }

  export type DebtorIncomeScalarWhereWithAggregatesInput = {
    AND?: DebtorIncomeScalarWhereWithAggregatesInput | DebtorIncomeScalarWhereWithAggregatesInput[]
    OR?: DebtorIncomeScalarWhereWithAggregatesInput[]
    NOT?: DebtorIncomeScalarWhereWithAggregatesInput | DebtorIncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DebtorIncome"> | string
    debtorId?: StringWithAggregatesFilter<"DebtorIncome"> | string
    amount?: FloatWithAggregatesFilter<"DebtorIncome"> | number
    source?: StringWithAggregatesFilter<"DebtorIncome"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DebtorIncome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DebtorIncome"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TenantRegistryCreateInput = {
    id?: string
    kvk?: string | null
    crib?: string | null
    taxId?: string | null
    vatNumber?: string | null
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutRegistryInput
  }

  export type TenantRegistryUncheckedCreateInput = {
    id?: string
    tenantId: string
    kvk?: string | null
    crib?: string | null
    taxId?: string | null
    vatNumber?: string | null
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantRegistryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutRegistryNestedInput
  }

  export type TenantRegistryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantRegistryCreateManyInput = {
    id?: string
    tenantId: string
    kvk?: string | null
    crib?: string | null
    taxId?: string | null
    vatNumber?: string | null
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantRegistryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantRegistryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantInvitationCreateInput = {
    id?: string
    email: string
    status?: string
    invitedBy: string
    createdAt?: Date | string
    role?: $Enums.roleEnum
    tenant: TenantCreateNestedOneWithoutTenantInvitationsInput
    User?: UserCreateNestedOneWithoutTenantInvitationsInput
  }

  export type TenantInvitationUncheckedCreateInput = {
    id?: string
    tenantId: string
    email: string
    status?: string
    invitedBy: string
    createdAt?: Date | string
    userId?: string | null
    role?: $Enums.roleEnum
  }

  export type TenantInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    tenant?: TenantUpdateOneRequiredWithoutTenantInvitationsNestedInput
    User?: UserUpdateOneWithoutTenantInvitationsNestedInput
  }

  export type TenantInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type TenantInvitationCreateManyInput = {
    id?: string
    tenantId: string
    email: string
    status?: string
    invitedBy: string
    createdAt?: Date | string
    userId?: string | null
    role?: $Enums.roleEnum
  }

  export type TenantInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type TenantInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictCreateNestedManyWithoutBailiffInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateInput = {
    id?: string
    status?: $Enums.MembershipStatus
    joinedAt?: Date | string
    role?: $Enums.roleEnum
    tenant: TenantCreateNestedOneWithoutMembershipsInput
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type MembershipUncheckedCreateInput = {
    id?: string
    userId: string
    tenantId: string
    status?: $Enums.MembershipStatus
    joinedAt?: Date | string
    role?: $Enums.roleEnum
  }

  export type MembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMembershipStatusFieldUpdateOperationsInput | $Enums.MembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    tenant?: TenantUpdateOneRequiredWithoutMembershipsNestedInput
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type MembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumMembershipStatusFieldUpdateOperationsInput | $Enums.MembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type MembershipCreateManyInput = {
    id?: string
    userId: string
    tenantId: string
    status?: $Enums.MembershipStatus
    joinedAt?: Date | string
    role?: $Enums.roleEnum
  }

  export type MembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMembershipStatusFieldUpdateOperationsInput | $Enums.MembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type MembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumMembershipStatusFieldUpdateOperationsInput | $Enums.MembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type GlobalParameterCreateInput = {
    id?: string
    porcCobranza?: number
    porcAbb?: number
    diasPlazoEmpresaAanmaning?: number
    diasPlazoConsumidorAanmaning?: number
    diasPlazoEmpresaSommatie?: number
    diasPlazoConsumidorSommatie?: number
    precioEmpresaPequena?: number
    contribucionEmpresaPequenaPfc?: number
    precioEmpresaGrande?: number
    contribucionEmpresaGrandePfc?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    multaAanmaningEmpresa?: number
    multaAanmaningNatural?: number
    multaSommatieEmpresa?: number
    multaSommatieNatural?: number
    limiteDiasReaccionEmpresa?: number
    multaNoReaccionEmpresa?: number
    multaNoReaccionNatural?: number
    multaAcuerdoPagoEmpresa?: number
    multaAcuerdoPagoNatural?: number
    invoiceNumberLength?: number
    invoicePrefix?: string
    invoiceSecuence?: number
    bankAccount?: string
    bankName?: string
  }

  export type GlobalParameterUncheckedCreateInput = {
    id?: string
    porcCobranza?: number
    porcAbb?: number
    diasPlazoEmpresaAanmaning?: number
    diasPlazoConsumidorAanmaning?: number
    diasPlazoEmpresaSommatie?: number
    diasPlazoConsumidorSommatie?: number
    precioEmpresaPequena?: number
    contribucionEmpresaPequenaPfc?: number
    precioEmpresaGrande?: number
    contribucionEmpresaGrandePfc?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    multaAanmaningEmpresa?: number
    multaAanmaningNatural?: number
    multaSommatieEmpresa?: number
    multaSommatieNatural?: number
    limiteDiasReaccionEmpresa?: number
    multaNoReaccionEmpresa?: number
    multaNoReaccionNatural?: number
    multaAcuerdoPagoEmpresa?: number
    multaAcuerdoPagoNatural?: number
    invoiceNumberLength?: number
    invoicePrefix?: string
    invoiceSecuence?: number
    bankAccount?: string
    bankName?: string
  }

  export type GlobalParameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    porcCobranza?: FloatFieldUpdateOperationsInput | number
    porcAbb?: FloatFieldUpdateOperationsInput | number
    diasPlazoEmpresaAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoEmpresaSommatie?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorSommatie?: IntFieldUpdateOperationsInput | number
    precioEmpresaPequena?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaPequenaPfc?: FloatFieldUpdateOperationsInput | number
    precioEmpresaGrande?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaGrandePfc?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multaAanmaningEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAanmaningNatural?: FloatFieldUpdateOperationsInput | number
    multaSommatieEmpresa?: FloatFieldUpdateOperationsInput | number
    multaSommatieNatural?: FloatFieldUpdateOperationsInput | number
    limiteDiasReaccionEmpresa?: IntFieldUpdateOperationsInput | number
    multaNoReaccionEmpresa?: FloatFieldUpdateOperationsInput | number
    multaNoReaccionNatural?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoNatural?: FloatFieldUpdateOperationsInput | number
    invoiceNumberLength?: IntFieldUpdateOperationsInput | number
    invoicePrefix?: StringFieldUpdateOperationsInput | string
    invoiceSecuence?: IntFieldUpdateOperationsInput | number
    bankAccount?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type GlobalParameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    porcCobranza?: FloatFieldUpdateOperationsInput | number
    porcAbb?: FloatFieldUpdateOperationsInput | number
    diasPlazoEmpresaAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoEmpresaSommatie?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorSommatie?: IntFieldUpdateOperationsInput | number
    precioEmpresaPequena?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaPequenaPfc?: FloatFieldUpdateOperationsInput | number
    precioEmpresaGrande?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaGrandePfc?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multaAanmaningEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAanmaningNatural?: FloatFieldUpdateOperationsInput | number
    multaSommatieEmpresa?: FloatFieldUpdateOperationsInput | number
    multaSommatieNatural?: FloatFieldUpdateOperationsInput | number
    limiteDiasReaccionEmpresa?: IntFieldUpdateOperationsInput | number
    multaNoReaccionEmpresa?: FloatFieldUpdateOperationsInput | number
    multaNoReaccionNatural?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoNatural?: FloatFieldUpdateOperationsInput | number
    invoiceNumberLength?: IntFieldUpdateOperationsInput | number
    invoicePrefix?: StringFieldUpdateOperationsInput | string
    invoiceSecuence?: IntFieldUpdateOperationsInput | number
    bankAccount?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type GlobalParameterCreateManyInput = {
    id?: string
    porcCobranza?: number
    porcAbb?: number
    diasPlazoEmpresaAanmaning?: number
    diasPlazoConsumidorAanmaning?: number
    diasPlazoEmpresaSommatie?: number
    diasPlazoConsumidorSommatie?: number
    precioEmpresaPequena?: number
    contribucionEmpresaPequenaPfc?: number
    precioEmpresaGrande?: number
    contribucionEmpresaGrandePfc?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    multaAanmaningEmpresa?: number
    multaAanmaningNatural?: number
    multaSommatieEmpresa?: number
    multaSommatieNatural?: number
    limiteDiasReaccionEmpresa?: number
    multaNoReaccionEmpresa?: number
    multaNoReaccionNatural?: number
    multaAcuerdoPagoEmpresa?: number
    multaAcuerdoPagoNatural?: number
    invoiceNumberLength?: number
    invoicePrefix?: string
    invoiceSecuence?: number
    bankAccount?: string
    bankName?: string
  }

  export type GlobalParameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    porcCobranza?: FloatFieldUpdateOperationsInput | number
    porcAbb?: FloatFieldUpdateOperationsInput | number
    diasPlazoEmpresaAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoEmpresaSommatie?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorSommatie?: IntFieldUpdateOperationsInput | number
    precioEmpresaPequena?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaPequenaPfc?: FloatFieldUpdateOperationsInput | number
    precioEmpresaGrande?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaGrandePfc?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multaAanmaningEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAanmaningNatural?: FloatFieldUpdateOperationsInput | number
    multaSommatieEmpresa?: FloatFieldUpdateOperationsInput | number
    multaSommatieNatural?: FloatFieldUpdateOperationsInput | number
    limiteDiasReaccionEmpresa?: IntFieldUpdateOperationsInput | number
    multaNoReaccionEmpresa?: FloatFieldUpdateOperationsInput | number
    multaNoReaccionNatural?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoNatural?: FloatFieldUpdateOperationsInput | number
    invoiceNumberLength?: IntFieldUpdateOperationsInput | number
    invoicePrefix?: StringFieldUpdateOperationsInput | string
    invoiceSecuence?: IntFieldUpdateOperationsInput | number
    bankAccount?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type GlobalParameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    porcCobranza?: FloatFieldUpdateOperationsInput | number
    porcAbb?: FloatFieldUpdateOperationsInput | number
    diasPlazoEmpresaAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoEmpresaSommatie?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorSommatie?: IntFieldUpdateOperationsInput | number
    precioEmpresaPequena?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaPequenaPfc?: FloatFieldUpdateOperationsInput | number
    precioEmpresaGrande?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaGrandePfc?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multaAanmaningEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAanmaningNatural?: FloatFieldUpdateOperationsInput | number
    multaSommatieEmpresa?: FloatFieldUpdateOperationsInput | number
    multaSommatieNatural?: FloatFieldUpdateOperationsInput | number
    limiteDiasReaccionEmpresa?: IntFieldUpdateOperationsInput | number
    multaNoReaccionEmpresa?: FloatFieldUpdateOperationsInput | number
    multaNoReaccionNatural?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoNatural?: FloatFieldUpdateOperationsInput | number
    invoiceNumberLength?: IntFieldUpdateOperationsInput | number
    invoicePrefix?: StringFieldUpdateOperationsInput | string
    invoiceSecuence?: IntFieldUpdateOperationsInput | number
    bankAccount?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictCreateInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictCreateManyInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
  }

  export type VerdictUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictInterestCreateInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdict?: VerdictCreateNestedOneWithoutVerdictInterestInput
    details?: VerdictInterestDetailsCreateNestedManyWithoutVerdictInterestInput
  }

  export type VerdictInterestUncheckedCreateInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdictId?: string | null
    details?: VerdictInterestDetailsUncheckedCreateNestedManyWithoutVerdictInterestInput
  }

  export type VerdictInterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneWithoutVerdictInterestNestedInput
    details?: VerdictInterestDetailsUpdateManyWithoutVerdictInterestNestedInput
  }

  export type VerdictInterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdictId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: VerdictInterestDetailsUncheckedUpdateManyWithoutVerdictInterestNestedInput
  }

  export type VerdictInterestCreateManyInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdictId?: string | null
  }

  export type VerdictInterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdictId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictInterestDetailsCreateInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdictInterest: VerdictInterestCreateNestedOneWithoutDetailsInput
  }

  export type VerdictInterestDetailsUncheckedCreateInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    verdictInterestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdictInterest?: VerdictInterestUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type VerdictInterestDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    verdictInterestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsCreateManyInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    verdictInterestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    verdictInterestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoCreateInput = {
    id?: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdict: VerdictCreateNestedOneWithoutVerdictEmbargoInput
  }

  export type VerdictEmbargoUncheckedCreateInput = {
    id?: string
    verdictId: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictEmbargoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneRequiredWithoutVerdictEmbargoNestedInput
  }

  export type VerdictEmbargoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoCreateManyInput = {
    id?: string
    verdictId: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictEmbargoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesCreateInput = {
    id?: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdict: VerdictCreateNestedOneWithoutBailiffServicesInput
  }

  export type VerdictBailiffServicesUncheckedCreateInput = {
    id?: string
    verdictId: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictBailiffServicesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneRequiredWithoutBailiffServicesNestedInput
  }

  export type VerdictBailiffServicesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesCreateManyInput = {
    id?: string
    verdictId: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictBailiffServicesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictAttachmentCreateInput = {
    id?: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
    verdict: VerdictCreateNestedOneWithoutAttachmentsInput
  }

  export type VerdictAttachmentUncheckedCreateInput = {
    id?: string
    verdictId: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
  }

  export type VerdictAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    verdict?: VerdictUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type VerdictAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentCreateManyInput = {
    id?: string
    verdictId: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
  }

  export type VerdictAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type InterestTypeCreateInput = {
    name: string
    calculationType: $Enums.CalculationTypeEnum
    details?: InterestDetailCreateNestedManyWithoutInterestTypeInput
  }

  export type InterestTypeUncheckedCreateInput = {
    id?: number
    name: string
    calculationType: $Enums.CalculationTypeEnum
    details?: InterestDetailUncheckedCreateNestedManyWithoutInterestTypeInput
  }

  export type InterestTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
    details?: InterestDetailUpdateManyWithoutInterestTypeNestedInput
  }

  export type InterestTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
    details?: InterestDetailUncheckedUpdateManyWithoutInterestTypeNestedInput
  }

  export type InterestTypeCreateManyInput = {
    id?: number
    name: string
    calculationType: $Enums.CalculationTypeEnum
  }

  export type InterestTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type InterestTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type InterestDetailCreateInput = {
    date: string
    rate: number
    interestType: InterestTypeCreateNestedOneWithoutDetailsInput
  }

  export type InterestDetailUncheckedCreateInput = {
    id?: number
    date: string
    rate: number
    interestTypeId: number
  }

  export type InterestDetailUpdateInput = {
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    interestType?: InterestTypeUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type InterestDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    interestTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type InterestDetailCreateManyInput = {
    id?: number
    date: string
    rate: number
    interestTypeId: number
  }

  export type InterestDetailUpdateManyMutationInput = {
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type InterestDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    interestTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type BillingInvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBillingInvoiceInput
    details?: BillingInvoiceDetailCreateNestedManyWithoutBillingInvoiceInput
    payments?: BillingPaymentCreateNestedManyWithoutBillingInvoiceInput
    subscription?: BillingSubscriptionCreateNestedManyWithoutLastInvoiceInput
  }

  export type BillingInvoiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BillingInvoiceDetailUncheckedCreateNestedManyWithoutBillingInvoiceInput
    payments?: BillingPaymentUncheckedCreateNestedManyWithoutBillingInvoiceInput
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutLastInvoiceInput
  }

  export type BillingInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBillingInvoiceNestedInput
    details?: BillingInvoiceDetailUpdateManyWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUpdateManyWithoutBillingInvoiceNestedInput
    subscription?: BillingSubscriptionUpdateManyWithoutLastInvoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceNestedInput
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutLastInvoiceNestedInput
  }

  export type BillingInvoiceCreateManyInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailCreateInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoice?: BillingInvoiceCreateNestedOneWithoutDetailsInput
  }

  export type BillingInvoiceDetailUncheckedCreateInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoiceId?: string | null
  }

  export type BillingInvoiceDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoice?: BillingInvoiceUpdateOneWithoutDetailsNestedInput
  }

  export type BillingInvoiceDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingInvoiceDetailCreateManyInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoiceId?: string | null
  }

  export type BillingInvoiceDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingPlanCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    billingCycle?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: BillingSubscriptionCreateNestedManyWithoutPlanInput
  }

  export type BillingPlanUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    billingCycle?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subscriptions?: BillingSubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type BillingPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: BillingSubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type BillingPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: BillingSubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type BillingPlanCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    billingCycle?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingSubscriptionCreateInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
    lastInvoice?: BillingInvoiceCreateNestedOneWithoutSubscriptionInput
    plan: BillingPlanCreateNestedOneWithoutSubscriptionsInput
    tenant: TenantCreateNestedOneWithoutSubscriptionInput
  }

  export type BillingSubscriptionUncheckedCreateInput = {
    id?: string
    tenantId: string
    planId: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    lastInvoiceId?: string | null
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
    lastInvoice?: BillingInvoiceUpdateOneWithoutSubscriptionNestedInput
    plan?: BillingPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type BillingSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionCreateManyInput = {
    id?: string
    tenantId: string
    planId: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    lastInvoiceId?: string | null
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
  }

  export type BillingPaymentCreateInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    BillingInvoice?: BillingInvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type BillingPaymentUncheckedCreateInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoiceId?: string | null
  }

  export type BillingPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BillingInvoice?: BillingInvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type BillingPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingPaymentCreateManyInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoiceId?: string | null
  }

  export type BillingPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CollectionCaseCreateInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseCreateManyInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyCreateInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutPenaltiesInput
  }

  export type PenaltyUncheckedCreateInput = {
    id?: string
    collectionCaseId: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PenaltyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutPenaltiesNestedInput
  }

  export type PenaltyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyCreateManyInput = {
    id?: string
    collectionCaseId: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PenaltyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    collectionCaseId: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    collectionCaseId: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    collectionCaseId: string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    collectionCaseId: string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAgreementCreateInput = {
    id?: string
    agreementDate: Date | string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    installmentAmount?: Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: Date | string | null
    notes?: string | null
    totalInstallments?: number | null
    collectionCase: CollectionCaseCreateNestedOneWithoutAgreementsInput
    Debtor?: DebtorCreateNestedOneWithoutPaymentAgreementsInput
  }

  export type PaymentAgreementUncheckedCreateInput = {
    id?: string
    debtorId?: string | null
    agreementDate: Date | string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCaseId: string
    installmentAmount?: Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: Date | string | null
    notes?: string | null
    totalInstallments?: number | null
  }

  export type PaymentAgreementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installmentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutAgreementsNestedInput
    Debtor?: DebtorUpdateOneWithoutPaymentAgreementsNestedInput
  }

  export type PaymentAgreementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    agreementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    installmentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstallments?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentAgreementCreateManyInput = {
    id?: string
    debtorId?: string | null
    agreementDate: Date | string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCaseId: string
    installmentAmount?: Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: Date | string | null
    notes?: string | null
    totalInstallments?: number | null
  }

  export type PaymentAgreementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installmentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstallments?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentAgreementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    agreementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    installmentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstallments?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DebtorCreateInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorCreateManyInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeCreateInput = {
    id?: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutIncomesInput
  }

  export type DebtorIncomeUncheckedCreateInput = {
    id?: string
    debtorId: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorIncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutIncomesNestedInput
  }

  export type DebtorIncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeCreateManyInput = {
    id?: string
    debtorId: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorIncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BillingInvoiceListRelationFilter = {
    every?: BillingInvoiceWhereInput
    some?: BillingInvoiceWhereInput
    none?: BillingInvoiceWhereInput
  }

  export type BillingSubscriptionListRelationFilter = {
    every?: BillingSubscriptionWhereInput
    some?: BillingSubscriptionWhereInput
    none?: BillingSubscriptionWhereInput
  }

  export type CollectionCaseListRelationFilter = {
    every?: CollectionCaseWhereInput
    some?: CollectionCaseWhereInput
    none?: CollectionCaseWhereInput
  }

  export type DebtorListRelationFilter = {
    every?: DebtorWhereInput
    some?: DebtorWhereInput
    none?: DebtorWhereInput
  }

  export type MembershipListRelationFilter = {
    every?: MembershipWhereInput
    some?: MembershipWhereInput
    none?: MembershipWhereInput
  }

  export type TenantInvitationListRelationFilter = {
    every?: TenantInvitationWhereInput
    some?: TenantInvitationWhereInput
    none?: TenantInvitationWhereInput
  }

  export type TenantRegistryNullableScalarRelationFilter = {
    is?: TenantRegistryWhereInput | null
    isNot?: TenantRegistryWhereInput | null
  }

  export type VerdictListRelationFilter = {
    every?: VerdictWhereInput
    some?: VerdictWhereInput
    none?: VerdictWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BillingInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactEmail?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    planStatus?: SortOrder
    termsAccepted?: SortOrder
    address?: SortOrder
    city?: SortOrder
    logoUrl?: SortOrder
    numberOfEmployees?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    numberOfEmployees?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactEmail?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    planStatus?: SortOrder
    termsAccepted?: SortOrder
    address?: SortOrder
    city?: SortOrder
    logoUrl?: SortOrder
    numberOfEmployees?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactEmail?: SortOrder
    countryCode?: SortOrder
    name?: SortOrder
    planStatus?: SortOrder
    termsAccepted?: SortOrder
    address?: SortOrder
    city?: SortOrder
    logoUrl?: SortOrder
    numberOfEmployees?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    isActive?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    numberOfEmployees?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type TenantRegistryCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kvk?: SortOrder
    crib?: SortOrder
    taxId?: SortOrder
    vatNumber?: SortOrder
    legalName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantRegistryMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kvk?: SortOrder
    crib?: SortOrder
    taxId?: SortOrder
    vatNumber?: SortOrder
    legalName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantRegistryMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kvk?: SortOrder
    crib?: SortOrder
    taxId?: SortOrder
    vatNumber?: SortOrder
    legalName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumroleEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumFilter<$PrismaModel> | $Enums.roleEnum
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TenantInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    status?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type TenantInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    status?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type TenantInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    status?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type EnumroleEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumWithAggregatesFilter<$PrismaModel> | $Enums.roleEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleEnumFilter<$PrismaModel>
    _max?: NestedEnumroleEnumFilter<$PrismaModel>
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullname?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullname?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullname?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMembershipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipStatus | EnumMembershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipStatus[] | ListEnumMembershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipStatus[] | ListEnumMembershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipStatusFilter<$PrismaModel> | $Enums.MembershipStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type MembershipUserIdTenantIdCompoundUniqueInput = {
    userId: string
    tenantId: string
  }

  export type MembershipCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    role?: SortOrder
  }

  export type MembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    role?: SortOrder
  }

  export type MembershipMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    role?: SortOrder
  }

  export type EnumMembershipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipStatus | EnumMembershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipStatus[] | ListEnumMembershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipStatus[] | ListEnumMembershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipStatusWithAggregatesFilter<$PrismaModel> | $Enums.MembershipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMembershipStatusFilter<$PrismaModel>
    _max?: NestedEnumMembershipStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type GlobalParameterCountOrderByAggregateInput = {
    id?: SortOrder
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoicePrefix?: SortOrder
    invoiceSecuence?: SortOrder
    bankAccount?: SortOrder
    bankName?: SortOrder
  }

  export type GlobalParameterAvgOrderByAggregateInput = {
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoiceSecuence?: SortOrder
  }

  export type GlobalParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoicePrefix?: SortOrder
    invoiceSecuence?: SortOrder
    bankAccount?: SortOrder
    bankName?: SortOrder
  }

  export type GlobalParameterMinOrderByAggregateInput = {
    id?: SortOrder
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoicePrefix?: SortOrder
    invoiceSecuence?: SortOrder
    bankAccount?: SortOrder
    bankName?: SortOrder
  }

  export type GlobalParameterSumOrderByAggregateInput = {
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoiceSecuence?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumVerdictStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusFilter<$PrismaModel> | $Enums.VerdictStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DebtorScalarRelationFilter = {
    is?: DebtorWhereInput
    isNot?: DebtorWhereInput
  }

  export type VerdictAttachmentListRelationFilter = {
    every?: VerdictAttachmentWhereInput
    some?: VerdictAttachmentWhereInput
    none?: VerdictAttachmentWhereInput
  }

  export type VerdictBailiffServicesListRelationFilter = {
    every?: VerdictBailiffServicesWhereInput
    some?: VerdictBailiffServicesWhereInput
    none?: VerdictBailiffServicesWhereInput
  }

  export type VerdictEmbargoListRelationFilter = {
    every?: VerdictEmbargoWhereInput
    some?: VerdictEmbargoWhereInput
    none?: VerdictEmbargoWhereInput
  }

  export type VerdictInterestListRelationFilter = {
    every?: VerdictInterestWhereInput
    some?: VerdictInterestWhereInput
    none?: VerdictInterestWhereInput
  }

  export type VerdictAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictBailiffServicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictEmbargoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    creditorName?: SortOrder
    debtorId?: SortOrder
    registrationNumber?: SortOrder
    sentenceAmount?: SortOrder
    sentenceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procesalCost?: SortOrder
    tenantId?: SortOrder
    notes?: SortOrder
    bailiffId?: SortOrder
  }

  export type VerdictAvgOrderByAggregateInput = {
    sentenceAmount?: SortOrder
    procesalCost?: SortOrder
  }

  export type VerdictMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    creditorName?: SortOrder
    debtorId?: SortOrder
    registrationNumber?: SortOrder
    sentenceAmount?: SortOrder
    sentenceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procesalCost?: SortOrder
    tenantId?: SortOrder
    notes?: SortOrder
    bailiffId?: SortOrder
  }

  export type VerdictMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    creditorName?: SortOrder
    debtorId?: SortOrder
    registrationNumber?: SortOrder
    sentenceAmount?: SortOrder
    sentenceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procesalCost?: SortOrder
    tenantId?: SortOrder
    notes?: SortOrder
    bailiffId?: SortOrder
  }

  export type VerdictSumOrderByAggregateInput = {
    sentenceAmount?: SortOrder
    procesalCost?: SortOrder
  }

  export type EnumVerdictStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerdictStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerdictStatusFilter<$PrismaModel>
    _max?: NestedEnumVerdictStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type VerdictNullableScalarRelationFilter = {
    is?: VerdictWhereInput | null
    isNot?: VerdictWhereInput | null
  }

  export type VerdictInterestDetailsListRelationFilter = {
    every?: VerdictInterestDetailsWhereInput
    some?: VerdictInterestDetailsWhereInput
    none?: VerdictInterestDetailsWhereInput
  }

  export type VerdictInterestDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictInterestCountOrderByAggregateInput = {
    id?: SortOrder
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrder
    calculationStart?: SortOrder
    calculationEnd?: SortOrder
    totalInterest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictId?: SortOrder
  }

  export type VerdictInterestAvgOrderByAggregateInput = {
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrder
    totalInterest?: SortOrder
  }

  export type VerdictInterestMaxOrderByAggregateInput = {
    id?: SortOrder
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrder
    calculationStart?: SortOrder
    calculationEnd?: SortOrder
    totalInterest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictId?: SortOrder
  }

  export type VerdictInterestMinOrderByAggregateInput = {
    id?: SortOrder
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrder
    calculationStart?: SortOrder
    calculationEnd?: SortOrder
    totalInterest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictId?: SortOrder
  }

  export type VerdictInterestSumOrderByAggregateInput = {
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrder
    totalInterest?: SortOrder
  }

  export type VerdictInterestScalarRelationFilter = {
    is?: VerdictInterestWhereInput
    isNot?: VerdictInterestWhereInput
  }

  export type VerdictInterestDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdictInterestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictInterestDetailsAvgOrderByAggregateInput = {
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
  }

  export type VerdictInterestDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdictInterestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictInterestDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdictInterestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictInterestDetailsSumOrderByAggregateInput = {
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
  }

  export type VerdictScalarRelationFilter = {
    is?: VerdictWhereInput
    isNot?: VerdictWhereInput
  }

  export type VerdictEmbargoCountOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    companyName?: SortOrder
    companyPhone?: SortOrder
    companyEmail?: SortOrder
    companyAddress?: SortOrder
    embargoType?: SortOrder
    embargoDate?: SortOrder
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictEmbargoAvgOrderByAggregateInput = {
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type VerdictEmbargoMaxOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    companyName?: SortOrder
    companyPhone?: SortOrder
    companyEmail?: SortOrder
    companyAddress?: SortOrder
    embargoType?: SortOrder
    embargoDate?: SortOrder
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictEmbargoMinOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    companyName?: SortOrder
    companyPhone?: SortOrder
    companyEmail?: SortOrder
    companyAddress?: SortOrder
    embargoType?: SortOrder
    embargoDate?: SortOrder
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictEmbargoSumOrderByAggregateInput = {
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type VerdictBailiffServicesCountOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    serviceType?: SortOrder
    serviceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictBailiffServicesAvgOrderByAggregateInput = {
    serviceCost?: SortOrder
  }

  export type VerdictBailiffServicesMaxOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    serviceType?: SortOrder
    serviceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictBailiffServicesMinOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    serviceType?: SortOrder
    serviceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictBailiffServicesSumOrderByAggregateInput = {
    serviceCost?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type VerdictAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
  }

  export type VerdictAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type VerdictAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
  }

  export type VerdictAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
  }

  export type VerdictAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumCalculationTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumFilter<$PrismaModel> | $Enums.CalculationTypeEnum
  }

  export type InterestDetailListRelationFilter = {
    every?: InterestDetailWhereInput
    some?: InterestDetailWhereInput
    none?: InterestDetailWhereInput
  }

  export type InterestDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterestTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calculationType?: SortOrder
  }

  export type InterestTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InterestTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calculationType?: SortOrder
  }

  export type InterestTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calculationType?: SortOrder
  }

  export type InterestTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.CalculationTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
  }

  export type InterestTypeScalarRelationFilter = {
    is?: InterestTypeWhereInput
    isNot?: InterestTypeWhereInput
  }

  export type InterestDetailCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
  }

  export type InterestDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
  }

  export type InterestDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
  }

  export type InterestDetailMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
  }

  export type InterestDetailSumOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
  }

  export type BillingInvoiceDetailListRelationFilter = {
    every?: BillingInvoiceDetailWhereInput
    some?: BillingInvoiceDetailWhereInput
    none?: BillingInvoiceDetailWhereInput
  }

  export type BillingPaymentListRelationFilter = {
    every?: BillingPaymentWhereInput
    some?: BillingPaymentWhereInput
    none?: BillingPaymentWhereInput
  }

  export type BillingInvoiceDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingInvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingInvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingInvoiceNullableScalarRelationFilter = {
    is?: BillingInvoiceWhereInput | null
    isNot?: BillingInvoiceWhereInput | null
  }

  export type BillingInvoiceDetailCountOrderByAggregateInput = {
    id?: SortOrder
    itemDescription?: SortOrder
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingInvoiceDetailAvgOrderByAggregateInput = {
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
  }

  export type BillingInvoiceDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    itemDescription?: SortOrder
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingInvoiceDetailMinOrderByAggregateInput = {
    id?: SortOrder
    itemDescription?: SortOrder
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingInvoiceDetailSumOrderByAggregateInput = {
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BillingPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingCycle?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingPlanAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type BillingPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingCycle?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    billingCycle?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingPlanSumOrderByAggregateInput = {
    price?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumBillingSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingSubscriptionStatus | EnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingSubscriptionStatus[] | ListEnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingSubscriptionStatus[] | ListEnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingSubscriptionStatusFilter<$PrismaModel> | $Enums.BillingSubscriptionStatus
  }

  export type BillingPlanScalarRelationFilter = {
    is?: BillingPlanWhereInput
    isNot?: BillingPlanWhereInput
  }

  export type BillingSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextBillingDate?: SortOrder
    billingCycle?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    lastInvoiceId?: SortOrder
    trialEndsAt?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type BillingSubscriptionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextBillingDate?: SortOrder
    billingCycle?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    lastInvoiceId?: SortOrder
    trialEndsAt?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type BillingSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nextBillingDate?: SortOrder
    billingCycle?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    lastInvoiceId?: SortOrder
    trialEndsAt?: SortOrder
    canceledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type BillingSubscriptionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumBillingSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingSubscriptionStatus | EnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingSubscriptionStatus[] | ListEnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingSubscriptionStatus[] | ListEnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillingSubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumBillingSubscriptionStatusFilter<$PrismaModel>
  }

  export type BillingPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumCollectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionStatus | EnumCollectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionStatusFilter<$PrismaModel> | $Enums.CollectionStatus
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentAgreementListRelationFilter = {
    every?: PaymentAgreementWhereInput
    some?: PaymentAgreementWhereInput
    none?: PaymentAgreementWhereInput
  }

  export type PenaltyListRelationFilter = {
    every?: PenaltyWhereInput
    some?: PenaltyWhereInput
    none?: PenaltyWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentAgreementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PenaltyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCaseCountOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    tenantId?: SortOrder
    debtorId?: SortOrder
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionCaseAvgOrderByAggregateInput = {
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
  }

  export type CollectionCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    tenantId?: SortOrder
    debtorId?: SortOrder
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionCaseMinOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    tenantId?: SortOrder
    debtorId?: SortOrder
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionCaseSumOrderByAggregateInput = {
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumCollectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionStatus | EnumCollectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CollectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCollectionStatusFilter<$PrismaModel>
    _max?: NestedEnumCollectionStatusFilter<$PrismaModel>
  }

  export type CollectionCaseScalarRelationFilter = {
    is?: CollectionCaseWhereInput
    isNot?: CollectionCaseWhereInput
  }

  export type PenaltyCountOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    dateApplied?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PenaltyAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PenaltyMaxOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    dateApplied?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PenaltyMinOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    dateApplied?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PenaltySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    collectionCaseId?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    collectionCaseId?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    collectionCaseId?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumAgreementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusFilter<$PrismaModel> | $Enums.AgreementStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DebtorNullableScalarRelationFilter = {
    is?: DebtorWhereInput | null
    isNot?: DebtorWhereInput | null
  }

  export type PaymentAgreementCountOrderByAggregateInput = {
    id?: SortOrder
    debtorId?: SortOrder
    agreementDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collectionCaseId?: SortOrder
    installmentAmount?: SortOrder
    nextPaymentDate?: SortOrder
    notes?: SortOrder
    totalInstallments?: SortOrder
  }

  export type PaymentAgreementAvgOrderByAggregateInput = {
    installmentAmount?: SortOrder
    totalInstallments?: SortOrder
  }

  export type PaymentAgreementMaxOrderByAggregateInput = {
    id?: SortOrder
    debtorId?: SortOrder
    agreementDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collectionCaseId?: SortOrder
    installmentAmount?: SortOrder
    nextPaymentDate?: SortOrder
    notes?: SortOrder
    totalInstallments?: SortOrder
  }

  export type PaymentAgreementMinOrderByAggregateInput = {
    id?: SortOrder
    debtorId?: SortOrder
    agreementDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collectionCaseId?: SortOrder
    installmentAmount?: SortOrder
    nextPaymentDate?: SortOrder
    notes?: SortOrder
    totalInstallments?: SortOrder
  }

  export type PaymentAgreementSumOrderByAggregateInput = {
    installmentAmount?: SortOrder
    totalInstallments?: SortOrder
  }

  export type EnumAgreementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgreementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgreementStatusFilter<$PrismaModel>
    _max?: NestedEnumAgreementStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumIdentificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel> | $Enums.IdentificationType | null
  }

  export type DebtorIncomeListRelationFilter = {
    every?: DebtorIncomeWhereInput
    some?: DebtorIncomeWhereInput
    none?: DebtorIncomeWhereInput
  }

  export type DebtorIncomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtorTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type DebtorTenantIdIdentificationCompoundUniqueInput = {
    tenantId: string
    identification: string
  }

  export type DebtorCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    personType?: SortOrder
    identificationType?: SortOrder
    identification?: SortOrder
    totalIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorAvgOrderByAggregateInput = {
    totalIncome?: SortOrder
  }

  export type DebtorMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    personType?: SortOrder
    identificationType?: SortOrder
    identification?: SortOrder
    totalIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    personType?: SortOrder
    identificationType?: SortOrder
    identification?: SortOrder
    totalIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorSumOrderByAggregateInput = {
    totalIncome?: SortOrder
  }

  export type EnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.IdentificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
  }

  export type DebtorIncomeCountOrderByAggregateInput = {
    id?: SortOrder
    debtorId?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorIncomeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DebtorIncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    debtorId?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorIncomeMinOrderByAggregateInput = {
    id?: SortOrder
    debtorId?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorIncomeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingInvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
  }

  export type BillingSubscriptionCreateNestedManyWithoutTenantInput = {
    create?: XOR<BillingSubscriptionCreateWithoutTenantInput, BillingSubscriptionUncheckedCreateWithoutTenantInput> | BillingSubscriptionCreateWithoutTenantInput[] | BillingSubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutTenantInput | BillingSubscriptionCreateOrConnectWithoutTenantInput[]
    createMany?: BillingSubscriptionCreateManyTenantInputEnvelope
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
  }

  export type CollectionCaseCreateNestedManyWithoutTenantInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type DebtorCreateNestedManyWithoutTenantInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type MembershipCreateNestedManyWithoutTenantInput = {
    create?: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput> | MembershipCreateWithoutTenantInput[] | MembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutTenantInput | MembershipCreateOrConnectWithoutTenantInput[]
    createMany?: MembershipCreateManyTenantInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type TenantInvitationCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantInvitationCreateWithoutTenantInput, TenantInvitationUncheckedCreateWithoutTenantInput> | TenantInvitationCreateWithoutTenantInput[] | TenantInvitationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantInvitationCreateOrConnectWithoutTenantInput | TenantInvitationCreateOrConnectWithoutTenantInput[]
    createMany?: TenantInvitationCreateManyTenantInputEnvelope
    connect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
  }

  export type TenantRegistryCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantRegistryCreateOrConnectWithoutTenantInput
    connect?: TenantRegistryWhereUniqueInput
  }

  export type VerdictCreateNestedManyWithoutTenantInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
  }

  export type BillingSubscriptionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BillingSubscriptionCreateWithoutTenantInput, BillingSubscriptionUncheckedCreateWithoutTenantInput> | BillingSubscriptionCreateWithoutTenantInput[] | BillingSubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutTenantInput | BillingSubscriptionCreateOrConnectWithoutTenantInput[]
    createMany?: BillingSubscriptionCreateManyTenantInputEnvelope
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
  }

  export type CollectionCaseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type DebtorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type MembershipUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput> | MembershipCreateWithoutTenantInput[] | MembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutTenantInput | MembershipCreateOrConnectWithoutTenantInput[]
    createMany?: MembershipCreateManyTenantInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type TenantInvitationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantInvitationCreateWithoutTenantInput, TenantInvitationUncheckedCreateWithoutTenantInput> | TenantInvitationCreateWithoutTenantInput[] | TenantInvitationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantInvitationCreateOrConnectWithoutTenantInput | TenantInvitationCreateOrConnectWithoutTenantInput[]
    createMany?: TenantInvitationCreateManyTenantInputEnvelope
    connect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
  }

  export type TenantRegistryUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantRegistryCreateOrConnectWithoutTenantInput
    connect?: TenantRegistryWhereUniqueInput
  }

  export type VerdictUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BillingInvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput | BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    set?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    disconnect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    delete?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    update?: BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput | BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BillingInvoiceUpdateManyWithWhereWithoutTenantInput | BillingInvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
  }

  export type BillingSubscriptionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BillingSubscriptionCreateWithoutTenantInput, BillingSubscriptionUncheckedCreateWithoutTenantInput> | BillingSubscriptionCreateWithoutTenantInput[] | BillingSubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutTenantInput | BillingSubscriptionCreateOrConnectWithoutTenantInput[]
    upsert?: BillingSubscriptionUpsertWithWhereUniqueWithoutTenantInput | BillingSubscriptionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BillingSubscriptionCreateManyTenantInputEnvelope
    set?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    disconnect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    delete?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    update?: BillingSubscriptionUpdateWithWhereUniqueWithoutTenantInput | BillingSubscriptionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BillingSubscriptionUpdateManyWithWhereWithoutTenantInput | BillingSubscriptionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BillingSubscriptionScalarWhereInput | BillingSubscriptionScalarWhereInput[]
  }

  export type CollectionCaseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutTenantInput | CollectionCaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutTenantInput | CollectionCaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutTenantInput | CollectionCaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type DebtorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutTenantInput | DebtorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutTenantInput | DebtorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutTenantInput | DebtorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type MembershipUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput> | MembershipCreateWithoutTenantInput[] | MembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutTenantInput | MembershipCreateOrConnectWithoutTenantInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutTenantInput | MembershipUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MembershipCreateManyTenantInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutTenantInput | MembershipUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutTenantInput | MembershipUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type TenantInvitationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantInvitationCreateWithoutTenantInput, TenantInvitationUncheckedCreateWithoutTenantInput> | TenantInvitationCreateWithoutTenantInput[] | TenantInvitationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantInvitationCreateOrConnectWithoutTenantInput | TenantInvitationCreateOrConnectWithoutTenantInput[]
    upsert?: TenantInvitationUpsertWithWhereUniqueWithoutTenantInput | TenantInvitationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantInvitationCreateManyTenantInputEnvelope
    set?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    disconnect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    delete?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    connect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    update?: TenantInvitationUpdateWithWhereUniqueWithoutTenantInput | TenantInvitationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantInvitationUpdateManyWithWhereWithoutTenantInput | TenantInvitationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantInvitationScalarWhereInput | TenantInvitationScalarWhereInput[]
  }

  export type TenantRegistryUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantRegistryCreateOrConnectWithoutTenantInput
    upsert?: TenantRegistryUpsertWithoutTenantInput
    disconnect?: TenantRegistryWhereInput | boolean
    delete?: TenantRegistryWhereInput | boolean
    connect?: TenantRegistryWhereUniqueInput
    update?: XOR<XOR<TenantRegistryUpdateToOneWithWhereWithoutTenantInput, TenantRegistryUpdateWithoutTenantInput>, TenantRegistryUncheckedUpdateWithoutTenantInput>
  }

  export type VerdictUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutTenantInput | VerdictUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutTenantInput | VerdictUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutTenantInput | VerdictUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput | BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    set?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    disconnect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    delete?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    update?: BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput | BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BillingInvoiceUpdateManyWithWhereWithoutTenantInput | BillingInvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
  }

  export type BillingSubscriptionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BillingSubscriptionCreateWithoutTenantInput, BillingSubscriptionUncheckedCreateWithoutTenantInput> | BillingSubscriptionCreateWithoutTenantInput[] | BillingSubscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutTenantInput | BillingSubscriptionCreateOrConnectWithoutTenantInput[]
    upsert?: BillingSubscriptionUpsertWithWhereUniqueWithoutTenantInput | BillingSubscriptionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BillingSubscriptionCreateManyTenantInputEnvelope
    set?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    disconnect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    delete?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    update?: BillingSubscriptionUpdateWithWhereUniqueWithoutTenantInput | BillingSubscriptionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BillingSubscriptionUpdateManyWithWhereWithoutTenantInput | BillingSubscriptionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BillingSubscriptionScalarWhereInput | BillingSubscriptionScalarWhereInput[]
  }

  export type CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutTenantInput | CollectionCaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutTenantInput | CollectionCaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutTenantInput | CollectionCaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type DebtorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutTenantInput | DebtorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutTenantInput | DebtorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutTenantInput | DebtorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type MembershipUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput> | MembershipCreateWithoutTenantInput[] | MembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutTenantInput | MembershipCreateOrConnectWithoutTenantInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutTenantInput | MembershipUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MembershipCreateManyTenantInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutTenantInput | MembershipUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutTenantInput | MembershipUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type TenantInvitationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantInvitationCreateWithoutTenantInput, TenantInvitationUncheckedCreateWithoutTenantInput> | TenantInvitationCreateWithoutTenantInput[] | TenantInvitationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantInvitationCreateOrConnectWithoutTenantInput | TenantInvitationCreateOrConnectWithoutTenantInput[]
    upsert?: TenantInvitationUpsertWithWhereUniqueWithoutTenantInput | TenantInvitationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantInvitationCreateManyTenantInputEnvelope
    set?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    disconnect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    delete?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    connect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    update?: TenantInvitationUpdateWithWhereUniqueWithoutTenantInput | TenantInvitationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantInvitationUpdateManyWithWhereWithoutTenantInput | TenantInvitationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantInvitationScalarWhereInput | TenantInvitationScalarWhereInput[]
  }

  export type TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantRegistryCreateOrConnectWithoutTenantInput
    upsert?: TenantRegistryUpsertWithoutTenantInput
    disconnect?: TenantRegistryWhereInput | boolean
    delete?: TenantRegistryWhereInput | boolean
    connect?: TenantRegistryWhereUniqueInput
    update?: XOR<XOR<TenantRegistryUpdateToOneWithWhereWithoutTenantInput, TenantRegistryUpdateWithoutTenantInput>, TenantRegistryUncheckedUpdateWithoutTenantInput>
  }

  export type VerdictUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutTenantInput | VerdictUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutTenantInput | VerdictUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutTenantInput | VerdictUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutRegistryInput = {
    create?: XOR<TenantCreateWithoutRegistryInput, TenantUncheckedCreateWithoutRegistryInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRegistryInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutRegistryNestedInput = {
    create?: XOR<TenantCreateWithoutRegistryInput, TenantUncheckedCreateWithoutRegistryInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRegistryInput
    upsert?: TenantUpsertWithoutRegistryInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRegistryInput, TenantUpdateWithoutRegistryInput>, TenantUncheckedUpdateWithoutRegistryInput>
  }

  export type TenantCreateNestedOneWithoutTenantInvitationsInput = {
    create?: XOR<TenantCreateWithoutTenantInvitationsInput, TenantUncheckedCreateWithoutTenantInvitationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantInvitationsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTenantInvitationsInput = {
    create?: XOR<UserCreateWithoutTenantInvitationsInput, UserUncheckedCreateWithoutTenantInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumroleEnumFieldUpdateOperationsInput = {
    set?: $Enums.roleEnum
  }

  export type TenantUpdateOneRequiredWithoutTenantInvitationsNestedInput = {
    create?: XOR<TenantCreateWithoutTenantInvitationsInput, TenantUncheckedCreateWithoutTenantInvitationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTenantInvitationsInput
    upsert?: TenantUpsertWithoutTenantInvitationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTenantInvitationsInput, TenantUpdateWithoutTenantInvitationsInput>, TenantUncheckedUpdateWithoutTenantInvitationsInput>
  }

  export type UserUpdateOneWithoutTenantInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutTenantInvitationsInput, UserUncheckedCreateWithoutTenantInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantInvitationsInput
    upsert?: UserUpsertWithoutTenantInvitationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTenantInvitationsInput, UserUpdateWithoutTenantInvitationsInput>, UserUncheckedUpdateWithoutTenantInvitationsInput>
  }

  export type DebtorCreateNestedManyWithoutUserInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type MembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type TenantInvitationCreateNestedManyWithoutUserInput = {
    create?: XOR<TenantInvitationCreateWithoutUserInput, TenantInvitationUncheckedCreateWithoutUserInput> | TenantInvitationCreateWithoutUserInput[] | TenantInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantInvitationCreateOrConnectWithoutUserInput | TenantInvitationCreateOrConnectWithoutUserInput[]
    createMany?: TenantInvitationCreateManyUserInputEnvelope
    connect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
  }

  export type VerdictCreateNestedManyWithoutBailiffInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type DebtorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type MembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type TenantInvitationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TenantInvitationCreateWithoutUserInput, TenantInvitationUncheckedCreateWithoutUserInput> | TenantInvitationCreateWithoutUserInput[] | TenantInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantInvitationCreateOrConnectWithoutUserInput | TenantInvitationCreateOrConnectWithoutUserInput[]
    createMany?: TenantInvitationCreateManyUserInputEnvelope
    connect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
  }

  export type VerdictUncheckedCreateNestedManyWithoutBailiffInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type DebtorUpdateManyWithoutUserNestedInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutUserInput | DebtorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutUserInput | DebtorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutUserInput | DebtorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type MembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutUserInput | MembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutUserInput | MembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutUserInput | MembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type TenantInvitationUpdateManyWithoutUserNestedInput = {
    create?: XOR<TenantInvitationCreateWithoutUserInput, TenantInvitationUncheckedCreateWithoutUserInput> | TenantInvitationCreateWithoutUserInput[] | TenantInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantInvitationCreateOrConnectWithoutUserInput | TenantInvitationCreateOrConnectWithoutUserInput[]
    upsert?: TenantInvitationUpsertWithWhereUniqueWithoutUserInput | TenantInvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TenantInvitationCreateManyUserInputEnvelope
    set?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    disconnect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    delete?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    connect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    update?: TenantInvitationUpdateWithWhereUniqueWithoutUserInput | TenantInvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TenantInvitationUpdateManyWithWhereWithoutUserInput | TenantInvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TenantInvitationScalarWhereInput | TenantInvitationScalarWhereInput[]
  }

  export type VerdictUpdateManyWithoutBailiffNestedInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutBailiffInput | VerdictUpsertWithWhereUniqueWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutBailiffInput | VerdictUpdateWithWhereUniqueWithoutBailiffInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutBailiffInput | VerdictUpdateManyWithWhereWithoutBailiffInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type DebtorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutUserInput | DebtorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutUserInput | DebtorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutUserInput | DebtorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type MembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutUserInput | MembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutUserInput | MembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutUserInput | MembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type TenantInvitationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TenantInvitationCreateWithoutUserInput, TenantInvitationUncheckedCreateWithoutUserInput> | TenantInvitationCreateWithoutUserInput[] | TenantInvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TenantInvitationCreateOrConnectWithoutUserInput | TenantInvitationCreateOrConnectWithoutUserInput[]
    upsert?: TenantInvitationUpsertWithWhereUniqueWithoutUserInput | TenantInvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TenantInvitationCreateManyUserInputEnvelope
    set?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    disconnect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    delete?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    connect?: TenantInvitationWhereUniqueInput | TenantInvitationWhereUniqueInput[]
    update?: TenantInvitationUpdateWithWhereUniqueWithoutUserInput | TenantInvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TenantInvitationUpdateManyWithWhereWithoutUserInput | TenantInvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TenantInvitationScalarWhereInput | TenantInvitationScalarWhereInput[]
  }

  export type VerdictUncheckedUpdateManyWithoutBailiffNestedInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutBailiffInput | VerdictUpsertWithWhereUniqueWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutBailiffInput | VerdictUpdateWithWhereUniqueWithoutBailiffInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutBailiffInput | VerdictUpdateManyWithWhereWithoutBailiffInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMembershipsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMembershipStatusFieldUpdateOperationsInput = {
    set?: $Enums.MembershipStatus
  }

  export type TenantUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMembershipsInput
    upsert?: TenantUpsertWithoutMembershipsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutMembershipsInput, TenantUpdateWithoutMembershipsInput>, TenantUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutVerdictBailiffsInput = {
    create?: XOR<UserCreateWithoutVerdictBailiffsInput, UserUncheckedCreateWithoutVerdictBailiffsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerdictBailiffsInput
    connect?: UserWhereUniqueInput
  }

  export type DebtorCreateNestedOneWithoutVerdictsInput = {
    create?: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutVerdictsInput
    connect?: DebtorWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutVerdictsInput = {
    create?: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVerdictsInput
    connect?: TenantWhereUniqueInput
  }

  export type VerdictAttachmentCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
  }

  export type VerdictBailiffServicesCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
  }

  export type VerdictEmbargoCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
  }

  export type VerdictInterestCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
  }

  export type VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
  }

  export type VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
  }

  export type VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
  }

  export type VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
  }

  export type EnumVerdictStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerdictStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutVerdictBailiffsNestedInput = {
    create?: XOR<UserCreateWithoutVerdictBailiffsInput, UserUncheckedCreateWithoutVerdictBailiffsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerdictBailiffsInput
    upsert?: UserUpsertWithoutVerdictBailiffsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerdictBailiffsInput, UserUpdateWithoutVerdictBailiffsInput>, UserUncheckedUpdateWithoutVerdictBailiffsInput>
  }

  export type DebtorUpdateOneRequiredWithoutVerdictsNestedInput = {
    create?: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutVerdictsInput
    upsert?: DebtorUpsertWithoutVerdictsInput
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutVerdictsInput, DebtorUpdateWithoutVerdictsInput>, DebtorUncheckedUpdateWithoutVerdictsInput>
  }

  export type TenantUpdateOneRequiredWithoutVerdictsNestedInput = {
    create?: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVerdictsInput
    upsert?: TenantUpsertWithoutVerdictsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVerdictsInput, TenantUpdateWithoutVerdictsInput>, TenantUncheckedUpdateWithoutVerdictsInput>
  }

  export type VerdictAttachmentUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    set?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    disconnect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    delete?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    update?: VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput | VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
  }

  export type VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    set?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    disconnect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    delete?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    update?: VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput | VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
  }

  export type VerdictEmbargoUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    set?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    disconnect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    delete?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    update?: VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput | VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
  }

  export type VerdictInterestUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput | VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    set?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    disconnect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    delete?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    update?: VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput | VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictInterestUpdateManyWithWhereWithoutVerdictInput | VerdictInterestUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
  }

  export type VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    set?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    disconnect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    delete?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    update?: VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput | VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
  }

  export type VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    set?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    disconnect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    delete?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    update?: VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput | VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
  }

  export type VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    set?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    disconnect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    delete?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    update?: VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput | VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
  }

  export type VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput | VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    set?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    disconnect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    delete?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    update?: VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput | VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictInterestUpdateManyWithWhereWithoutVerdictInput | VerdictInterestUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
  }

  export type VerdictCreateNestedOneWithoutVerdictInterestInput = {
    create?: XOR<VerdictCreateWithoutVerdictInterestInput, VerdictUncheckedCreateWithoutVerdictInterestInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdictInterestInput
    connect?: VerdictWhereUniqueInput
  }

  export type VerdictInterestDetailsCreateNestedManyWithoutVerdictInterestInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput> | VerdictInterestDetailsCreateWithoutVerdictInterestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdictInterestInputEnvelope
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
  }

  export type VerdictInterestDetailsUncheckedCreateNestedManyWithoutVerdictInterestInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput> | VerdictInterestDetailsCreateWithoutVerdictInterestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdictInterestInputEnvelope
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
  }

  export type VerdictUpdateOneWithoutVerdictInterestNestedInput = {
    create?: XOR<VerdictCreateWithoutVerdictInterestInput, VerdictUncheckedCreateWithoutVerdictInterestInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdictInterestInput
    upsert?: VerdictUpsertWithoutVerdictInterestInput
    disconnect?: VerdictWhereInput | boolean
    delete?: VerdictWhereInput | boolean
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutVerdictInterestInput, VerdictUpdateWithoutVerdictInterestInput>, VerdictUncheckedUpdateWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsUpdateManyWithoutVerdictInterestNestedInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput> | VerdictInterestDetailsCreateWithoutVerdictInterestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput[]
    upsert?: VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdictInterestInput | VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdictInterestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdictInterestInputEnvelope
    set?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    disconnect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    delete?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    update?: VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdictInterestInput | VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdictInterestInput[]
    updateMany?: VerdictInterestDetailsUpdateManyWithWhereWithoutVerdictInterestInput | VerdictInterestDetailsUpdateManyWithWhereWithoutVerdictInterestInput[]
    deleteMany?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
  }

  export type VerdictInterestDetailsUncheckedUpdateManyWithoutVerdictInterestNestedInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput> | VerdictInterestDetailsCreateWithoutVerdictInterestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput[]
    upsert?: VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdictInterestInput | VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdictInterestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdictInterestInputEnvelope
    set?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    disconnect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    delete?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    update?: VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdictInterestInput | VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdictInterestInput[]
    updateMany?: VerdictInterestDetailsUpdateManyWithWhereWithoutVerdictInterestInput | VerdictInterestDetailsUpdateManyWithWhereWithoutVerdictInterestInput[]
    deleteMany?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
  }

  export type VerdictInterestCreateNestedOneWithoutDetailsInput = {
    create?: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutDetailsInput
    connect?: VerdictInterestWhereUniqueInput
  }

  export type VerdictInterestUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutDetailsInput
    upsert?: VerdictInterestUpsertWithoutDetailsInput
    connect?: VerdictInterestWhereUniqueInput
    update?: XOR<XOR<VerdictInterestUpdateToOneWithWhereWithoutDetailsInput, VerdictInterestUpdateWithoutDetailsInput>, VerdictInterestUncheckedUpdateWithoutDetailsInput>
  }

  export type VerdictCreateNestedOneWithoutVerdictEmbargoInput = {
    create?: XOR<VerdictCreateWithoutVerdictEmbargoInput, VerdictUncheckedCreateWithoutVerdictEmbargoInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdictEmbargoInput
    connect?: VerdictWhereUniqueInput
  }

  export type VerdictUpdateOneRequiredWithoutVerdictEmbargoNestedInput = {
    create?: XOR<VerdictCreateWithoutVerdictEmbargoInput, VerdictUncheckedCreateWithoutVerdictEmbargoInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdictEmbargoInput
    upsert?: VerdictUpsertWithoutVerdictEmbargoInput
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutVerdictEmbargoInput, VerdictUpdateWithoutVerdictEmbargoInput>, VerdictUncheckedUpdateWithoutVerdictEmbargoInput>
  }

  export type VerdictCreateNestedOneWithoutBailiffServicesInput = {
    create?: XOR<VerdictCreateWithoutBailiffServicesInput, VerdictUncheckedCreateWithoutBailiffServicesInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffServicesInput
    connect?: VerdictWhereUniqueInput
  }

  export type VerdictUpdateOneRequiredWithoutBailiffServicesNestedInput = {
    create?: XOR<VerdictCreateWithoutBailiffServicesInput, VerdictUncheckedCreateWithoutBailiffServicesInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffServicesInput
    upsert?: VerdictUpsertWithoutBailiffServicesInput
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutBailiffServicesInput, VerdictUpdateWithoutBailiffServicesInput>, VerdictUncheckedUpdateWithoutBailiffServicesInput>
  }

  export type VerdictCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutAttachmentsInput
    connect?: VerdictWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type VerdictUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutAttachmentsInput
    upsert?: VerdictUpsertWithoutAttachmentsInput
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutAttachmentsInput, VerdictUpdateWithoutAttachmentsInput>, VerdictUncheckedUpdateWithoutAttachmentsInput>
  }

  export type InterestDetailCreateNestedManyWithoutInterestTypeInput = {
    create?: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput> | InterestDetailCreateWithoutInterestTypeInput[] | InterestDetailUncheckedCreateWithoutInterestTypeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterestTypeInput | InterestDetailCreateOrConnectWithoutInterestTypeInput[]
    createMany?: InterestDetailCreateManyInterestTypeInputEnvelope
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
  }

  export type InterestDetailUncheckedCreateNestedManyWithoutInterestTypeInput = {
    create?: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput> | InterestDetailCreateWithoutInterestTypeInput[] | InterestDetailUncheckedCreateWithoutInterestTypeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterestTypeInput | InterestDetailCreateOrConnectWithoutInterestTypeInput[]
    createMany?: InterestDetailCreateManyInterestTypeInputEnvelope
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
  }

  export type EnumCalculationTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.CalculationTypeEnum
  }

  export type InterestDetailUpdateManyWithoutInterestTypeNestedInput = {
    create?: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput> | InterestDetailCreateWithoutInterestTypeInput[] | InterestDetailUncheckedCreateWithoutInterestTypeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterestTypeInput | InterestDetailCreateOrConnectWithoutInterestTypeInput[]
    upsert?: InterestDetailUpsertWithWhereUniqueWithoutInterestTypeInput | InterestDetailUpsertWithWhereUniqueWithoutInterestTypeInput[]
    createMany?: InterestDetailCreateManyInterestTypeInputEnvelope
    set?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    disconnect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    delete?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    update?: InterestDetailUpdateWithWhereUniqueWithoutInterestTypeInput | InterestDetailUpdateWithWhereUniqueWithoutInterestTypeInput[]
    updateMany?: InterestDetailUpdateManyWithWhereWithoutInterestTypeInput | InterestDetailUpdateManyWithWhereWithoutInterestTypeInput[]
    deleteMany?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
  }

  export type InterestDetailUncheckedUpdateManyWithoutInterestTypeNestedInput = {
    create?: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput> | InterestDetailCreateWithoutInterestTypeInput[] | InterestDetailUncheckedCreateWithoutInterestTypeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterestTypeInput | InterestDetailCreateOrConnectWithoutInterestTypeInput[]
    upsert?: InterestDetailUpsertWithWhereUniqueWithoutInterestTypeInput | InterestDetailUpsertWithWhereUniqueWithoutInterestTypeInput[]
    createMany?: InterestDetailCreateManyInterestTypeInputEnvelope
    set?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    disconnect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    delete?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    update?: InterestDetailUpdateWithWhereUniqueWithoutInterestTypeInput | InterestDetailUpdateWithWhereUniqueWithoutInterestTypeInput[]
    updateMany?: InterestDetailUpdateManyWithWhereWithoutInterestTypeInput | InterestDetailUpdateManyWithWhereWithoutInterestTypeInput[]
    deleteMany?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
  }

  export type InterestTypeCreateNestedOneWithoutDetailsInput = {
    create?: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: InterestTypeCreateOrConnectWithoutDetailsInput
    connect?: InterestTypeWhereUniqueInput
  }

  export type InterestTypeUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: InterestTypeCreateOrConnectWithoutDetailsInput
    upsert?: InterestTypeUpsertWithoutDetailsInput
    connect?: InterestTypeWhereUniqueInput
    update?: XOR<XOR<InterestTypeUpdateToOneWithWhereWithoutDetailsInput, InterestTypeUpdateWithoutDetailsInput>, InterestTypeUncheckedUpdateWithoutDetailsInput>
  }

  export type TenantCreateNestedOneWithoutBillingInvoiceInput = {
    create?: XOR<TenantCreateWithoutBillingInvoiceInput, TenantUncheckedCreateWithoutBillingInvoiceInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBillingInvoiceInput
    connect?: TenantWhereUniqueInput
  }

  export type BillingInvoiceDetailCreateNestedManyWithoutBillingInvoiceInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput> | BillingInvoiceDetailCreateWithoutBillingInvoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBillingInvoiceInputEnvelope
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
  }

  export type BillingPaymentCreateNestedManyWithoutBillingInvoiceInput = {
    create?: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput> | BillingPaymentCreateWithoutBillingInvoiceInput[] | BillingPaymentUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBillingInvoiceInput | BillingPaymentCreateOrConnectWithoutBillingInvoiceInput[]
    createMany?: BillingPaymentCreateManyBillingInvoiceInputEnvelope
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
  }

  export type BillingSubscriptionCreateNestedManyWithoutLastInvoiceInput = {
    create?: XOR<BillingSubscriptionCreateWithoutLastInvoiceInput, BillingSubscriptionUncheckedCreateWithoutLastInvoiceInput> | BillingSubscriptionCreateWithoutLastInvoiceInput[] | BillingSubscriptionUncheckedCreateWithoutLastInvoiceInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutLastInvoiceInput | BillingSubscriptionCreateOrConnectWithoutLastInvoiceInput[]
    createMany?: BillingSubscriptionCreateManyLastInvoiceInputEnvelope
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
  }

  export type BillingInvoiceDetailUncheckedCreateNestedManyWithoutBillingInvoiceInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput> | BillingInvoiceDetailCreateWithoutBillingInvoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBillingInvoiceInputEnvelope
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
  }

  export type BillingPaymentUncheckedCreateNestedManyWithoutBillingInvoiceInput = {
    create?: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput> | BillingPaymentCreateWithoutBillingInvoiceInput[] | BillingPaymentUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBillingInvoiceInput | BillingPaymentCreateOrConnectWithoutBillingInvoiceInput[]
    createMany?: BillingPaymentCreateManyBillingInvoiceInputEnvelope
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
  }

  export type BillingSubscriptionUncheckedCreateNestedManyWithoutLastInvoiceInput = {
    create?: XOR<BillingSubscriptionCreateWithoutLastInvoiceInput, BillingSubscriptionUncheckedCreateWithoutLastInvoiceInput> | BillingSubscriptionCreateWithoutLastInvoiceInput[] | BillingSubscriptionUncheckedCreateWithoutLastInvoiceInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutLastInvoiceInput | BillingSubscriptionCreateOrConnectWithoutLastInvoiceInput[]
    createMany?: BillingSubscriptionCreateManyLastInvoiceInputEnvelope
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutBillingInvoiceNestedInput = {
    create?: XOR<TenantCreateWithoutBillingInvoiceInput, TenantUncheckedCreateWithoutBillingInvoiceInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBillingInvoiceInput
    upsert?: TenantUpsertWithoutBillingInvoiceInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBillingInvoiceInput, TenantUpdateWithoutBillingInvoiceInput>, TenantUncheckedUpdateWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailUpdateManyWithoutBillingInvoiceNestedInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput> | BillingInvoiceDetailCreateWithoutBillingInvoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput[]
    upsert?: BillingInvoiceDetailUpsertWithWhereUniqueWithoutBillingInvoiceInput | BillingInvoiceDetailUpsertWithWhereUniqueWithoutBillingInvoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBillingInvoiceInputEnvelope
    set?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    disconnect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    delete?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    update?: BillingInvoiceDetailUpdateWithWhereUniqueWithoutBillingInvoiceInput | BillingInvoiceDetailUpdateWithWhereUniqueWithoutBillingInvoiceInput[]
    updateMany?: BillingInvoiceDetailUpdateManyWithWhereWithoutBillingInvoiceInput | BillingInvoiceDetailUpdateManyWithWhereWithoutBillingInvoiceInput[]
    deleteMany?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
  }

  export type BillingPaymentUpdateManyWithoutBillingInvoiceNestedInput = {
    create?: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput> | BillingPaymentCreateWithoutBillingInvoiceInput[] | BillingPaymentUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBillingInvoiceInput | BillingPaymentCreateOrConnectWithoutBillingInvoiceInput[]
    upsert?: BillingPaymentUpsertWithWhereUniqueWithoutBillingInvoiceInput | BillingPaymentUpsertWithWhereUniqueWithoutBillingInvoiceInput[]
    createMany?: BillingPaymentCreateManyBillingInvoiceInputEnvelope
    set?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    disconnect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    delete?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    update?: BillingPaymentUpdateWithWhereUniqueWithoutBillingInvoiceInput | BillingPaymentUpdateWithWhereUniqueWithoutBillingInvoiceInput[]
    updateMany?: BillingPaymentUpdateManyWithWhereWithoutBillingInvoiceInput | BillingPaymentUpdateManyWithWhereWithoutBillingInvoiceInput[]
    deleteMany?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
  }

  export type BillingSubscriptionUpdateManyWithoutLastInvoiceNestedInput = {
    create?: XOR<BillingSubscriptionCreateWithoutLastInvoiceInput, BillingSubscriptionUncheckedCreateWithoutLastInvoiceInput> | BillingSubscriptionCreateWithoutLastInvoiceInput[] | BillingSubscriptionUncheckedCreateWithoutLastInvoiceInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutLastInvoiceInput | BillingSubscriptionCreateOrConnectWithoutLastInvoiceInput[]
    upsert?: BillingSubscriptionUpsertWithWhereUniqueWithoutLastInvoiceInput | BillingSubscriptionUpsertWithWhereUniqueWithoutLastInvoiceInput[]
    createMany?: BillingSubscriptionCreateManyLastInvoiceInputEnvelope
    set?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    disconnect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    delete?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    update?: BillingSubscriptionUpdateWithWhereUniqueWithoutLastInvoiceInput | BillingSubscriptionUpdateWithWhereUniqueWithoutLastInvoiceInput[]
    updateMany?: BillingSubscriptionUpdateManyWithWhereWithoutLastInvoiceInput | BillingSubscriptionUpdateManyWithWhereWithoutLastInvoiceInput[]
    deleteMany?: BillingSubscriptionScalarWhereInput | BillingSubscriptionScalarWhereInput[]
  }

  export type BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceNestedInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput> | BillingInvoiceDetailCreateWithoutBillingInvoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput[]
    upsert?: BillingInvoiceDetailUpsertWithWhereUniqueWithoutBillingInvoiceInput | BillingInvoiceDetailUpsertWithWhereUniqueWithoutBillingInvoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBillingInvoiceInputEnvelope
    set?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    disconnect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    delete?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    update?: BillingInvoiceDetailUpdateWithWhereUniqueWithoutBillingInvoiceInput | BillingInvoiceDetailUpdateWithWhereUniqueWithoutBillingInvoiceInput[]
    updateMany?: BillingInvoiceDetailUpdateManyWithWhereWithoutBillingInvoiceInput | BillingInvoiceDetailUpdateManyWithWhereWithoutBillingInvoiceInput[]
    deleteMany?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
  }

  export type BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceNestedInput = {
    create?: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput> | BillingPaymentCreateWithoutBillingInvoiceInput[] | BillingPaymentUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBillingInvoiceInput | BillingPaymentCreateOrConnectWithoutBillingInvoiceInput[]
    upsert?: BillingPaymentUpsertWithWhereUniqueWithoutBillingInvoiceInput | BillingPaymentUpsertWithWhereUniqueWithoutBillingInvoiceInput[]
    createMany?: BillingPaymentCreateManyBillingInvoiceInputEnvelope
    set?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    disconnect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    delete?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    update?: BillingPaymentUpdateWithWhereUniqueWithoutBillingInvoiceInput | BillingPaymentUpdateWithWhereUniqueWithoutBillingInvoiceInput[]
    updateMany?: BillingPaymentUpdateManyWithWhereWithoutBillingInvoiceInput | BillingPaymentUpdateManyWithWhereWithoutBillingInvoiceInput[]
    deleteMany?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
  }

  export type BillingSubscriptionUncheckedUpdateManyWithoutLastInvoiceNestedInput = {
    create?: XOR<BillingSubscriptionCreateWithoutLastInvoiceInput, BillingSubscriptionUncheckedCreateWithoutLastInvoiceInput> | BillingSubscriptionCreateWithoutLastInvoiceInput[] | BillingSubscriptionUncheckedCreateWithoutLastInvoiceInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutLastInvoiceInput | BillingSubscriptionCreateOrConnectWithoutLastInvoiceInput[]
    upsert?: BillingSubscriptionUpsertWithWhereUniqueWithoutLastInvoiceInput | BillingSubscriptionUpsertWithWhereUniqueWithoutLastInvoiceInput[]
    createMany?: BillingSubscriptionCreateManyLastInvoiceInputEnvelope
    set?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    disconnect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    delete?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    update?: BillingSubscriptionUpdateWithWhereUniqueWithoutLastInvoiceInput | BillingSubscriptionUpdateWithWhereUniqueWithoutLastInvoiceInput[]
    updateMany?: BillingSubscriptionUpdateManyWithWhereWithoutLastInvoiceInput | BillingSubscriptionUpdateManyWithWhereWithoutLastInvoiceInput[]
    deleteMany?: BillingSubscriptionScalarWhereInput | BillingSubscriptionScalarWhereInput[]
  }

  export type BillingInvoiceCreateNestedOneWithoutDetailsInput = {
    create?: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutDetailsInput
    connect?: BillingInvoiceWhereUniqueInput
  }

  export type BillingInvoiceUpdateOneWithoutDetailsNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutDetailsInput
    upsert?: BillingInvoiceUpsertWithoutDetailsInput
    disconnect?: BillingInvoiceWhereInput | boolean
    delete?: BillingInvoiceWhereInput | boolean
    connect?: BillingInvoiceWhereUniqueInput
    update?: XOR<XOR<BillingInvoiceUpdateToOneWithWhereWithoutDetailsInput, BillingInvoiceUpdateWithoutDetailsInput>, BillingInvoiceUncheckedUpdateWithoutDetailsInput>
  }

  export type BillingSubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<BillingSubscriptionCreateWithoutPlanInput, BillingSubscriptionUncheckedCreateWithoutPlanInput> | BillingSubscriptionCreateWithoutPlanInput[] | BillingSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutPlanInput | BillingSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: BillingSubscriptionCreateManyPlanInputEnvelope
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
  }

  export type BillingSubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<BillingSubscriptionCreateWithoutPlanInput, BillingSubscriptionUncheckedCreateWithoutPlanInput> | BillingSubscriptionCreateWithoutPlanInput[] | BillingSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutPlanInput | BillingSubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: BillingSubscriptionCreateManyPlanInputEnvelope
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
  }

  export type BillingSubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<BillingSubscriptionCreateWithoutPlanInput, BillingSubscriptionUncheckedCreateWithoutPlanInput> | BillingSubscriptionCreateWithoutPlanInput[] | BillingSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutPlanInput | BillingSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: BillingSubscriptionUpsertWithWhereUniqueWithoutPlanInput | BillingSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: BillingSubscriptionCreateManyPlanInputEnvelope
    set?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    disconnect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    delete?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    update?: BillingSubscriptionUpdateWithWhereUniqueWithoutPlanInput | BillingSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: BillingSubscriptionUpdateManyWithWhereWithoutPlanInput | BillingSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: BillingSubscriptionScalarWhereInput | BillingSubscriptionScalarWhereInput[]
  }

  export type BillingSubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<BillingSubscriptionCreateWithoutPlanInput, BillingSubscriptionUncheckedCreateWithoutPlanInput> | BillingSubscriptionCreateWithoutPlanInput[] | BillingSubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BillingSubscriptionCreateOrConnectWithoutPlanInput | BillingSubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: BillingSubscriptionUpsertWithWhereUniqueWithoutPlanInput | BillingSubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: BillingSubscriptionCreateManyPlanInputEnvelope
    set?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    disconnect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    delete?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    connect?: BillingSubscriptionWhereUniqueInput | BillingSubscriptionWhereUniqueInput[]
    update?: BillingSubscriptionUpdateWithWhereUniqueWithoutPlanInput | BillingSubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: BillingSubscriptionUpdateManyWithWhereWithoutPlanInput | BillingSubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: BillingSubscriptionScalarWhereInput | BillingSubscriptionScalarWhereInput[]
  }

  export type BillingInvoiceCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<BillingInvoiceCreateWithoutSubscriptionInput, BillingInvoiceUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutSubscriptionInput
    connect?: BillingInvoiceWhereUniqueInput
  }

  export type BillingPlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<BillingPlanCreateWithoutSubscriptionsInput, BillingPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: BillingPlanCreateOrConnectWithoutSubscriptionsInput
    connect?: BillingPlanWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<TenantCreateWithoutSubscriptionInput, TenantUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSubscriptionInput
    connect?: TenantWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumBillingSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.BillingSubscriptionStatus
  }

  export type BillingInvoiceUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutSubscriptionInput, BillingInvoiceUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutSubscriptionInput
    upsert?: BillingInvoiceUpsertWithoutSubscriptionInput
    disconnect?: BillingInvoiceWhereInput | boolean
    delete?: BillingInvoiceWhereInput | boolean
    connect?: BillingInvoiceWhereUniqueInput
    update?: XOR<XOR<BillingInvoiceUpdateToOneWithWhereWithoutSubscriptionInput, BillingInvoiceUpdateWithoutSubscriptionInput>, BillingInvoiceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type BillingPlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<BillingPlanCreateWithoutSubscriptionsInput, BillingPlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: BillingPlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: BillingPlanUpsertWithoutSubscriptionsInput
    connect?: BillingPlanWhereUniqueInput
    update?: XOR<XOR<BillingPlanUpdateToOneWithWhereWithoutSubscriptionsInput, BillingPlanUpdateWithoutSubscriptionsInput>, BillingPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type TenantUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<TenantCreateWithoutSubscriptionInput, TenantUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSubscriptionInput
    upsert?: TenantUpsertWithoutSubscriptionInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSubscriptionInput, TenantUpdateWithoutSubscriptionInput>, TenantUncheckedUpdateWithoutSubscriptionInput>
  }

  export type BillingInvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutPaymentsInput
    connect?: BillingInvoiceWhereUniqueInput
  }

  export type BillingInvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: BillingInvoiceUpsertWithoutPaymentsInput
    disconnect?: BillingInvoiceWhereInput | boolean
    delete?: BillingInvoiceWhereInput | boolean
    connect?: BillingInvoiceWhereUniqueInput
    update?: XOR<XOR<BillingInvoiceUpdateToOneWithWhereWithoutPaymentsInput, BillingInvoiceUpdateWithoutPaymentsInput>, BillingInvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type DebtorCreateNestedOneWithoutCollectionCasesInput = {
    create?: XOR<DebtorCreateWithoutCollectionCasesInput, DebtorUncheckedCreateWithoutCollectionCasesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutCollectionCasesInput
    connect?: DebtorWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutCollectionCasesInput = {
    create?: XOR<TenantCreateWithoutCollectionCasesInput, TenantUncheckedCreateWithoutCollectionCasesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCollectionCasesInput
    connect?: TenantWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput> | NotificationCreateWithoutCollectionCaseInput[] | NotificationUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCollectionCaseInput | NotificationCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: NotificationCreateManyCollectionCaseInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput> | PaymentCreateWithoutCollectionCaseInput[] | PaymentUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectionCaseInput | PaymentCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PaymentCreateManyCollectionCaseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentAgreementCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput> | PaymentAgreementCreateWithoutCollectionCaseInput[] | PaymentAgreementUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutCollectionCaseInput | PaymentAgreementCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PaymentAgreementCreateManyCollectionCaseInputEnvelope
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
  }

  export type PenaltyCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput> | PenaltyCreateWithoutCollectionCaseInput[] | PenaltyUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutCollectionCaseInput | PenaltyCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PenaltyCreateManyCollectionCaseInputEnvelope
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput> | NotificationCreateWithoutCollectionCaseInput[] | NotificationUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCollectionCaseInput | NotificationCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: NotificationCreateManyCollectionCaseInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput> | PaymentCreateWithoutCollectionCaseInput[] | PaymentUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectionCaseInput | PaymentCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PaymentCreateManyCollectionCaseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput> | PaymentAgreementCreateWithoutCollectionCaseInput[] | PaymentAgreementUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutCollectionCaseInput | PaymentAgreementCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PaymentAgreementCreateManyCollectionCaseInputEnvelope
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
  }

  export type PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput> | PenaltyCreateWithoutCollectionCaseInput[] | PenaltyUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutCollectionCaseInput | PenaltyCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PenaltyCreateManyCollectionCaseInputEnvelope
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumCollectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.CollectionStatus
  }

  export type DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput = {
    create?: XOR<DebtorCreateWithoutCollectionCasesInput, DebtorUncheckedCreateWithoutCollectionCasesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutCollectionCasesInput
    upsert?: DebtorUpsertWithoutCollectionCasesInput
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutCollectionCasesInput, DebtorUpdateWithoutCollectionCasesInput>, DebtorUncheckedUpdateWithoutCollectionCasesInput>
  }

  export type TenantUpdateOneRequiredWithoutCollectionCasesNestedInput = {
    create?: XOR<TenantCreateWithoutCollectionCasesInput, TenantUncheckedCreateWithoutCollectionCasesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCollectionCasesInput
    upsert?: TenantUpsertWithoutCollectionCasesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCollectionCasesInput, TenantUpdateWithoutCollectionCasesInput>, TenantUncheckedUpdateWithoutCollectionCasesInput>
  }

  export type NotificationUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput> | NotificationCreateWithoutCollectionCaseInput[] | NotificationUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCollectionCaseInput | NotificationCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCollectionCaseInput | NotificationUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: NotificationCreateManyCollectionCaseInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCollectionCaseInput | NotificationUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCollectionCaseInput | NotificationUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput> | PaymentCreateWithoutCollectionCaseInput[] | PaymentUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectionCaseInput | PaymentCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCollectionCaseInput | PaymentUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PaymentCreateManyCollectionCaseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCollectionCaseInput | PaymentUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCollectionCaseInput | PaymentUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput> | PaymentAgreementCreateWithoutCollectionCaseInput[] | PaymentAgreementUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutCollectionCaseInput | PaymentAgreementCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PaymentAgreementUpsertWithWhereUniqueWithoutCollectionCaseInput | PaymentAgreementUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PaymentAgreementCreateManyCollectionCaseInputEnvelope
    set?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    disconnect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    delete?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    update?: PaymentAgreementUpdateWithWhereUniqueWithoutCollectionCaseInput | PaymentAgreementUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PaymentAgreementUpdateManyWithWhereWithoutCollectionCaseInput | PaymentAgreementUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
  }

  export type PenaltyUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput> | PenaltyCreateWithoutCollectionCaseInput[] | PenaltyUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutCollectionCaseInput | PenaltyCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PenaltyUpsertWithWhereUniqueWithoutCollectionCaseInput | PenaltyUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PenaltyCreateManyCollectionCaseInputEnvelope
    set?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    disconnect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    delete?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    update?: PenaltyUpdateWithWhereUniqueWithoutCollectionCaseInput | PenaltyUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PenaltyUpdateManyWithWhereWithoutCollectionCaseInput | PenaltyUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput> | NotificationCreateWithoutCollectionCaseInput[] | NotificationUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCollectionCaseInput | NotificationCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCollectionCaseInput | NotificationUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: NotificationCreateManyCollectionCaseInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCollectionCaseInput | NotificationUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCollectionCaseInput | NotificationUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput> | PaymentCreateWithoutCollectionCaseInput[] | PaymentUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectionCaseInput | PaymentCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCollectionCaseInput | PaymentUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PaymentCreateManyCollectionCaseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCollectionCaseInput | PaymentUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCollectionCaseInput | PaymentUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput> | PaymentAgreementCreateWithoutCollectionCaseInput[] | PaymentAgreementUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutCollectionCaseInput | PaymentAgreementCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PaymentAgreementUpsertWithWhereUniqueWithoutCollectionCaseInput | PaymentAgreementUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PaymentAgreementCreateManyCollectionCaseInputEnvelope
    set?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    disconnect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    delete?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    update?: PaymentAgreementUpdateWithWhereUniqueWithoutCollectionCaseInput | PaymentAgreementUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PaymentAgreementUpdateManyWithWhereWithoutCollectionCaseInput | PaymentAgreementUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
  }

  export type PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput> | PenaltyCreateWithoutCollectionCaseInput[] | PenaltyUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutCollectionCaseInput | PenaltyCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PenaltyUpsertWithWhereUniqueWithoutCollectionCaseInput | PenaltyUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PenaltyCreateManyCollectionCaseInputEnvelope
    set?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    disconnect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    delete?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    update?: PenaltyUpdateWithWhereUniqueWithoutCollectionCaseInput | PenaltyUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PenaltyUpdateManyWithWhereWithoutCollectionCaseInput | PenaltyUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
  }

  export type CollectionCaseCreateNestedOneWithoutPenaltiesInput = {
    create?: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPenaltiesInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type CollectionCaseUpdateOneRequiredWithoutPenaltiesNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPenaltiesInput
    upsert?: CollectionCaseUpsertWithoutPenaltiesInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutPenaltiesInput, CollectionCaseUpdateWithoutPenaltiesInput>, CollectionCaseUncheckedUpdateWithoutPenaltiesInput>
  }

  export type CollectionCaseCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutNotificationsInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type CollectionCaseUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutNotificationsInput
    upsert?: CollectionCaseUpsertWithoutNotificationsInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutNotificationsInput, CollectionCaseUpdateWithoutNotificationsInput>, CollectionCaseUncheckedUpdateWithoutNotificationsInput>
  }

  export type CollectionCaseCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPaymentsInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type CollectionCaseUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPaymentsInput
    upsert?: CollectionCaseUpsertWithoutPaymentsInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutPaymentsInput, CollectionCaseUpdateWithoutPaymentsInput>, CollectionCaseUncheckedUpdateWithoutPaymentsInput>
  }

  export type CollectionCaseCreateNestedOneWithoutAgreementsInput = {
    create?: XOR<CollectionCaseCreateWithoutAgreementsInput, CollectionCaseUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutAgreementsInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type DebtorCreateNestedOneWithoutPaymentAgreementsInput = {
    create?: XOR<DebtorCreateWithoutPaymentAgreementsInput, DebtorUncheckedCreateWithoutPaymentAgreementsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutPaymentAgreementsInput
    connect?: DebtorWhereUniqueInput
  }

  export type EnumAgreementStatusFieldUpdateOperationsInput = {
    set?: $Enums.AgreementStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CollectionCaseUpdateOneRequiredWithoutAgreementsNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutAgreementsInput, CollectionCaseUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutAgreementsInput
    upsert?: CollectionCaseUpsertWithoutAgreementsInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutAgreementsInput, CollectionCaseUpdateWithoutAgreementsInput>, CollectionCaseUncheckedUpdateWithoutAgreementsInput>
  }

  export type DebtorUpdateOneWithoutPaymentAgreementsNestedInput = {
    create?: XOR<DebtorCreateWithoutPaymentAgreementsInput, DebtorUncheckedCreateWithoutPaymentAgreementsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutPaymentAgreementsInput
    upsert?: DebtorUpsertWithoutPaymentAgreementsInput
    disconnect?: DebtorWhereInput | boolean
    delete?: DebtorWhereInput | boolean
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutPaymentAgreementsInput, DebtorUpdateWithoutPaymentAgreementsInput>, DebtorUncheckedUpdateWithoutPaymentAgreementsInput>
  }

  export type CollectionCaseCreateNestedManyWithoutDebtorInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutDebtorsInput = {
    create?: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDebtorsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDebtorsInput = {
    create?: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtorsInput
    connect?: UserWhereUniqueInput
  }

  export type DebtorIncomeCreateNestedManyWithoutDebtorInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
  }

  export type PaymentAgreementCreateNestedManyWithoutDebtorInput = {
    create?: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput> | PaymentAgreementCreateWithoutDebtorInput[] | PaymentAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutDebtorInput | PaymentAgreementCreateOrConnectWithoutDebtorInput[]
    createMany?: PaymentAgreementCreateManyDebtorInputEnvelope
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
  }

  export type VerdictCreateNestedManyWithoutDebtorInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
  }

  export type PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput> | PaymentAgreementCreateWithoutDebtorInput[] | PaymentAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutDebtorInput | PaymentAgreementCreateOrConnectWithoutDebtorInput[]
    createMany?: PaymentAgreementCreateManyDebtorInputEnvelope
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
  }

  export type VerdictUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type NullableEnumIdentificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.IdentificationType | null
  }

  export type CollectionCaseUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput | CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput | CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutDebtorInput | CollectionCaseUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutDebtorsNestedInput = {
    create?: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDebtorsInput
    upsert?: TenantUpsertWithoutDebtorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDebtorsInput, TenantUpdateWithoutDebtorsInput>, TenantUncheckedUpdateWithoutDebtorsInput>
  }

  export type UserUpdateOneWithoutDebtorsNestedInput = {
    create?: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtorsInput
    upsert?: UserUpsertWithoutDebtorsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDebtorsInput, UserUpdateWithoutDebtorsInput>, UserUncheckedUpdateWithoutDebtorsInput>
  }

  export type DebtorIncomeUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    upsert?: DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    set?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    disconnect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    delete?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    update?: DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: DebtorIncomeUpdateManyWithWhereWithoutDebtorInput | DebtorIncomeUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
  }

  export type PaymentAgreementUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput> | PaymentAgreementCreateWithoutDebtorInput[] | PaymentAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutDebtorInput | PaymentAgreementCreateOrConnectWithoutDebtorInput[]
    upsert?: PaymentAgreementUpsertWithWhereUniqueWithoutDebtorInput | PaymentAgreementUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: PaymentAgreementCreateManyDebtorInputEnvelope
    set?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    disconnect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    delete?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    update?: PaymentAgreementUpdateWithWhereUniqueWithoutDebtorInput | PaymentAgreementUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: PaymentAgreementUpdateManyWithWhereWithoutDebtorInput | PaymentAgreementUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
  }

  export type VerdictUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutDebtorInput | VerdictUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutDebtorInput | VerdictUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutDebtorInput | VerdictUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput | CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput | CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutDebtorInput | CollectionCaseUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    upsert?: DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    set?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    disconnect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    delete?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    update?: DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: DebtorIncomeUpdateManyWithWhereWithoutDebtorInput | DebtorIncomeUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
  }

  export type PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput> | PaymentAgreementCreateWithoutDebtorInput[] | PaymentAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutDebtorInput | PaymentAgreementCreateOrConnectWithoutDebtorInput[]
    upsert?: PaymentAgreementUpsertWithWhereUniqueWithoutDebtorInput | PaymentAgreementUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: PaymentAgreementCreateManyDebtorInputEnvelope
    set?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    disconnect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    delete?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    update?: PaymentAgreementUpdateWithWhereUniqueWithoutDebtorInput | PaymentAgreementUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: PaymentAgreementUpdateManyWithWhereWithoutDebtorInput | PaymentAgreementUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
  }

  export type VerdictUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutDebtorInput | VerdictUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutDebtorInput | VerdictUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutDebtorInput | VerdictUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type DebtorCreateNestedOneWithoutIncomesInput = {
    create?: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutIncomesInput
    connect?: DebtorWhereUniqueInput
  }

  export type DebtorUpdateOneRequiredWithoutIncomesNestedInput = {
    create?: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutIncomesInput
    upsert?: DebtorUpsertWithoutIncomesInput
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutIncomesInput, DebtorUpdateWithoutIncomesInput>, DebtorUncheckedUpdateWithoutIncomesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumroleEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumFilter<$PrismaModel> | $Enums.roleEnum
  }

  export type NestedEnumroleEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumWithAggregatesFilter<$PrismaModel> | $Enums.roleEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleEnumFilter<$PrismaModel>
    _max?: NestedEnumroleEnumFilter<$PrismaModel>
  }

  export type NestedEnumMembershipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipStatus | EnumMembershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipStatus[] | ListEnumMembershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipStatus[] | ListEnumMembershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipStatusFilter<$PrismaModel> | $Enums.MembershipStatus
  }

  export type NestedEnumMembershipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MembershipStatus | EnumMembershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MembershipStatus[] | ListEnumMembershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MembershipStatus[] | ListEnumMembershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMembershipStatusWithAggregatesFilter<$PrismaModel> | $Enums.MembershipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMembershipStatusFilter<$PrismaModel>
    _max?: NestedEnumMembershipStatusFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumVerdictStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusFilter<$PrismaModel> | $Enums.VerdictStatus
  }

  export type NestedEnumVerdictStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerdictStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerdictStatusFilter<$PrismaModel>
    _max?: NestedEnumVerdictStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumCalculationTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumFilter<$PrismaModel> | $Enums.CalculationTypeEnum
  }

  export type NestedEnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.CalculationTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumBillingSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingSubscriptionStatus | EnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingSubscriptionStatus[] | ListEnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingSubscriptionStatus[] | ListEnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingSubscriptionStatusFilter<$PrismaModel> | $Enums.BillingSubscriptionStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBillingSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingSubscriptionStatus | EnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingSubscriptionStatus[] | ListEnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingSubscriptionStatus[] | ListEnumBillingSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillingSubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumBillingSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumCollectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionStatus | EnumCollectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionStatusFilter<$PrismaModel> | $Enums.CollectionStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumCollectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionStatus | EnumCollectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CollectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCollectionStatusFilter<$PrismaModel>
    _max?: NestedEnumCollectionStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumAgreementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusFilter<$PrismaModel> | $Enums.AgreementStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumAgreementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgreementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgreementStatusFilter<$PrismaModel>
    _max?: NestedEnumAgreementStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumIdentificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel> | $Enums.IdentificationType | null
  }

  export type NestedEnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.IdentificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
  }

  export type BillingInvoiceCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BillingInvoiceDetailCreateNestedManyWithoutBillingInvoiceInput
    payments?: BillingPaymentCreateNestedManyWithoutBillingInvoiceInput
    subscription?: BillingSubscriptionCreateNestedManyWithoutLastInvoiceInput
  }

  export type BillingInvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BillingInvoiceDetailUncheckedCreateNestedManyWithoutBillingInvoiceInput
    payments?: BillingPaymentUncheckedCreateNestedManyWithoutBillingInvoiceInput
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutLastInvoiceInput
  }

  export type BillingInvoiceCreateOrConnectWithoutTenantInput = {
    where: BillingInvoiceWhereUniqueInput
    create: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput>
  }

  export type BillingInvoiceCreateManyTenantInputEnvelope = {
    data: BillingInvoiceCreateManyTenantInput | BillingInvoiceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BillingSubscriptionCreateWithoutTenantInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
    lastInvoice?: BillingInvoiceCreateNestedOneWithoutSubscriptionInput
    plan: BillingPlanCreateNestedOneWithoutSubscriptionsInput
  }

  export type BillingSubscriptionUncheckedCreateWithoutTenantInput = {
    id?: string
    planId: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    lastInvoiceId?: string | null
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionCreateOrConnectWithoutTenantInput = {
    where: BillingSubscriptionWhereUniqueInput
    create: XOR<BillingSubscriptionCreateWithoutTenantInput, BillingSubscriptionUncheckedCreateWithoutTenantInput>
  }

  export type BillingSubscriptionCreateManyTenantInputEnvelope = {
    data: BillingSubscriptionCreateManyTenantInput | BillingSubscriptionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCaseCreateWithoutTenantInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutTenantInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutTenantInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput>
  }

  export type CollectionCaseCreateManyTenantInputEnvelope = {
    data: CollectionCaseCreateManyTenantInput | CollectionCaseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DebtorCreateWithoutTenantInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutTenantInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput>
  }

  export type DebtorCreateManyTenantInputEnvelope = {
    data: DebtorCreateManyTenantInput | DebtorCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type MembershipCreateWithoutTenantInput = {
    id?: string
    status?: $Enums.MembershipStatus
    joinedAt?: Date | string
    role?: $Enums.roleEnum
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type MembershipUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    status?: $Enums.MembershipStatus
    joinedAt?: Date | string
    role?: $Enums.roleEnum
  }

  export type MembershipCreateOrConnectWithoutTenantInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput>
  }

  export type MembershipCreateManyTenantInputEnvelope = {
    data: MembershipCreateManyTenantInput | MembershipCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantInvitationCreateWithoutTenantInput = {
    id?: string
    email: string
    status?: string
    invitedBy: string
    createdAt?: Date | string
    role?: $Enums.roleEnum
    User?: UserCreateNestedOneWithoutTenantInvitationsInput
  }

  export type TenantInvitationUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    status?: string
    invitedBy: string
    createdAt?: Date | string
    userId?: string | null
    role?: $Enums.roleEnum
  }

  export type TenantInvitationCreateOrConnectWithoutTenantInput = {
    where: TenantInvitationWhereUniqueInput
    create: XOR<TenantInvitationCreateWithoutTenantInput, TenantInvitationUncheckedCreateWithoutTenantInput>
  }

  export type TenantInvitationCreateManyTenantInputEnvelope = {
    data: TenantInvitationCreateManyTenantInput | TenantInvitationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantRegistryCreateWithoutTenantInput = {
    id?: string
    kvk?: string | null
    crib?: string | null
    taxId?: string | null
    vatNumber?: string | null
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantRegistryUncheckedCreateWithoutTenantInput = {
    id?: string
    kvk?: string | null
    crib?: string | null
    taxId?: string | null
    vatNumber?: string | null
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantRegistryCreateOrConnectWithoutTenantInput = {
    where: TenantRegistryWhereUniqueInput
    create: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
  }

  export type VerdictCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutTenantInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput>
  }

  export type VerdictCreateManyTenantInputEnvelope = {
    data: VerdictCreateManyTenantInput | VerdictCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: BillingInvoiceWhereUniqueInput
    update: XOR<BillingInvoiceUpdateWithoutTenantInput, BillingInvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput>
  }

  export type BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: BillingInvoiceWhereUniqueInput
    data: XOR<BillingInvoiceUpdateWithoutTenantInput, BillingInvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type BillingInvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: BillingInvoiceScalarWhereInput
    data: XOR<BillingInvoiceUpdateManyMutationInput, BillingInvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type BillingInvoiceScalarWhereInput = {
    AND?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
    OR?: BillingInvoiceScalarWhereInput[]
    NOT?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
    id?: StringFilter<"BillingInvoice"> | string
    tenantId?: StringFilter<"BillingInvoice"> | string
    invoiceNumber?: StringFilter<"BillingInvoice"> | string
    amount?: FloatFilter<"BillingInvoice"> | number
    currency?: StringFilter<"BillingInvoice"> | string
    issueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    dueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    description?: StringNullableFilter<"BillingInvoice"> | string | null
    status?: StringFilter<"BillingInvoice"> | string
    createdAt?: DateTimeFilter<"BillingInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoice"> | Date | string
  }

  export type BillingSubscriptionUpsertWithWhereUniqueWithoutTenantInput = {
    where: BillingSubscriptionWhereUniqueInput
    update: XOR<BillingSubscriptionUpdateWithoutTenantInput, BillingSubscriptionUncheckedUpdateWithoutTenantInput>
    create: XOR<BillingSubscriptionCreateWithoutTenantInput, BillingSubscriptionUncheckedCreateWithoutTenantInput>
  }

  export type BillingSubscriptionUpdateWithWhereUniqueWithoutTenantInput = {
    where: BillingSubscriptionWhereUniqueInput
    data: XOR<BillingSubscriptionUpdateWithoutTenantInput, BillingSubscriptionUncheckedUpdateWithoutTenantInput>
  }

  export type BillingSubscriptionUpdateManyWithWhereWithoutTenantInput = {
    where: BillingSubscriptionScalarWhereInput
    data: XOR<BillingSubscriptionUpdateManyMutationInput, BillingSubscriptionUncheckedUpdateManyWithoutTenantInput>
  }

  export type BillingSubscriptionScalarWhereInput = {
    AND?: BillingSubscriptionScalarWhereInput | BillingSubscriptionScalarWhereInput[]
    OR?: BillingSubscriptionScalarWhereInput[]
    NOT?: BillingSubscriptionScalarWhereInput | BillingSubscriptionScalarWhereInput[]
    id?: StringFilter<"BillingSubscription"> | string
    tenantId?: StringFilter<"BillingSubscription"> | string
    planId?: StringFilter<"BillingSubscription"> | string
    startDate?: DateTimeFilter<"BillingSubscription"> | Date | string
    endDate?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    nextBillingDate?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    billingCycle?: StringFilter<"BillingSubscription"> | string
    amount?: FloatFilter<"BillingSubscription"> | number
    currency?: StringFilter<"BillingSubscription"> | string
    lastInvoiceId?: StringNullableFilter<"BillingSubscription"> | string | null
    trialEndsAt?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"BillingSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"BillingSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"BillingSubscription"> | Date | string
    status?: EnumBillingSubscriptionStatusFilter<"BillingSubscription"> | $Enums.BillingSubscriptionStatus
  }

  export type CollectionCaseUpsertWithWhereUniqueWithoutTenantInput = {
    where: CollectionCaseWhereUniqueInput
    update: XOR<CollectionCaseUpdateWithoutTenantInput, CollectionCaseUncheckedUpdateWithoutTenantInput>
    create: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput>
  }

  export type CollectionCaseUpdateWithWhereUniqueWithoutTenantInput = {
    where: CollectionCaseWhereUniqueInput
    data: XOR<CollectionCaseUpdateWithoutTenantInput, CollectionCaseUncheckedUpdateWithoutTenantInput>
  }

  export type CollectionCaseUpdateManyWithWhereWithoutTenantInput = {
    where: CollectionCaseScalarWhereInput
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyWithoutTenantInput>
  }

  export type CollectionCaseScalarWhereInput = {
    AND?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
    OR?: CollectionCaseScalarWhereInput[]
    NOT?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
    id?: StringFilter<"CollectionCase"> | string
    referenceNumber?: StringNullableFilter<"CollectionCase"> | string | null
    issueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    tenantId?: StringFilter<"CollectionCase"> | string
    debtorId?: StringFilter<"CollectionCase"> | string
    amountOriginal?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFilter<"CollectionCase"> | $Enums.CollectionStatus
    createdAt?: DateTimeFilter<"CollectionCase"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionCase"> | Date | string
  }

  export type DebtorUpsertWithWhereUniqueWithoutTenantInput = {
    where: DebtorWhereUniqueInput
    update: XOR<DebtorUpdateWithoutTenantInput, DebtorUncheckedUpdateWithoutTenantInput>
    create: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput>
  }

  export type DebtorUpdateWithWhereUniqueWithoutTenantInput = {
    where: DebtorWhereUniqueInput
    data: XOR<DebtorUpdateWithoutTenantInput, DebtorUncheckedUpdateWithoutTenantInput>
  }

  export type DebtorUpdateManyWithWhereWithoutTenantInput = {
    where: DebtorScalarWhereInput
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyWithoutTenantInput>
  }

  export type DebtorScalarWhereInput = {
    AND?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
    OR?: DebtorScalarWhereInput[]
    NOT?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
    id?: StringFilter<"Debtor"> | string
    tenantId?: StringFilter<"Debtor"> | string
    userId?: StringNullableFilter<"Debtor"> | string | null
    fullname?: StringFilter<"Debtor"> | string
    email?: StringFilter<"Debtor"> | string
    phone?: StringNullableFilter<"Debtor"> | string | null
    address?: StringNullableFilter<"Debtor"> | string | null
    personType?: StringNullableFilter<"Debtor"> | string | null
    identificationType?: EnumIdentificationTypeNullableFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableFilter<"Debtor"> | string | null
    totalIncome?: FloatNullableFilter<"Debtor"> | number | null
    createdAt?: DateTimeFilter<"Debtor"> | Date | string
    updatedAt?: DateTimeFilter<"Debtor"> | Date | string
  }

  export type MembershipUpsertWithWhereUniqueWithoutTenantInput = {
    where: MembershipWhereUniqueInput
    update: XOR<MembershipUpdateWithoutTenantInput, MembershipUncheckedUpdateWithoutTenantInput>
    create: XOR<MembershipCreateWithoutTenantInput, MembershipUncheckedCreateWithoutTenantInput>
  }

  export type MembershipUpdateWithWhereUniqueWithoutTenantInput = {
    where: MembershipWhereUniqueInput
    data: XOR<MembershipUpdateWithoutTenantInput, MembershipUncheckedUpdateWithoutTenantInput>
  }

  export type MembershipUpdateManyWithWhereWithoutTenantInput = {
    where: MembershipScalarWhereInput
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyWithoutTenantInput>
  }

  export type MembershipScalarWhereInput = {
    AND?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
    OR?: MembershipScalarWhereInput[]
    NOT?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
    id?: StringFilter<"Membership"> | string
    userId?: StringFilter<"Membership"> | string
    tenantId?: StringFilter<"Membership"> | string
    status?: EnumMembershipStatusFilter<"Membership"> | $Enums.MembershipStatus
    joinedAt?: DateTimeFilter<"Membership"> | Date | string
    role?: EnumroleEnumFilter<"Membership"> | $Enums.roleEnum
  }

  export type TenantInvitationUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantInvitationWhereUniqueInput
    update: XOR<TenantInvitationUpdateWithoutTenantInput, TenantInvitationUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantInvitationCreateWithoutTenantInput, TenantInvitationUncheckedCreateWithoutTenantInput>
  }

  export type TenantInvitationUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantInvitationWhereUniqueInput
    data: XOR<TenantInvitationUpdateWithoutTenantInput, TenantInvitationUncheckedUpdateWithoutTenantInput>
  }

  export type TenantInvitationUpdateManyWithWhereWithoutTenantInput = {
    where: TenantInvitationScalarWhereInput
    data: XOR<TenantInvitationUpdateManyMutationInput, TenantInvitationUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantInvitationScalarWhereInput = {
    AND?: TenantInvitationScalarWhereInput | TenantInvitationScalarWhereInput[]
    OR?: TenantInvitationScalarWhereInput[]
    NOT?: TenantInvitationScalarWhereInput | TenantInvitationScalarWhereInput[]
    id?: StringFilter<"TenantInvitation"> | string
    tenantId?: StringFilter<"TenantInvitation"> | string
    email?: StringFilter<"TenantInvitation"> | string
    status?: StringFilter<"TenantInvitation"> | string
    invitedBy?: StringFilter<"TenantInvitation"> | string
    createdAt?: DateTimeFilter<"TenantInvitation"> | Date | string
    userId?: StringNullableFilter<"TenantInvitation"> | string | null
    role?: EnumroleEnumFilter<"TenantInvitation"> | $Enums.roleEnum
  }

  export type TenantRegistryUpsertWithoutTenantInput = {
    update: XOR<TenantRegistryUpdateWithoutTenantInput, TenantRegistryUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
    where?: TenantRegistryWhereInput
  }

  export type TenantRegistryUpdateToOneWithWhereWithoutTenantInput = {
    where?: TenantRegistryWhereInput
    data: XOR<TenantRegistryUpdateWithoutTenantInput, TenantRegistryUncheckedUpdateWithoutTenantInput>
  }

  export type TenantRegistryUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantRegistryUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUpsertWithWhereUniqueWithoutTenantInput = {
    where: VerdictWhereUniqueInput
    update: XOR<VerdictUpdateWithoutTenantInput, VerdictUncheckedUpdateWithoutTenantInput>
    create: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput>
  }

  export type VerdictUpdateWithWhereUniqueWithoutTenantInput = {
    where: VerdictWhereUniqueInput
    data: XOR<VerdictUpdateWithoutTenantInput, VerdictUncheckedUpdateWithoutTenantInput>
  }

  export type VerdictUpdateManyWithWhereWithoutTenantInput = {
    where: VerdictScalarWhereInput
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyWithoutTenantInput>
  }

  export type VerdictScalarWhereInput = {
    AND?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
    OR?: VerdictScalarWhereInput[]
    NOT?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
    id?: StringFilter<"Verdict"> | string
    invoiceNumber?: StringFilter<"Verdict"> | string
    creditorName?: StringFilter<"Verdict"> | string
    debtorId?: StringFilter<"Verdict"> | string
    registrationNumber?: StringFilter<"Verdict"> | string
    sentenceAmount?: FloatFilter<"Verdict"> | number
    sentenceDate?: DateTimeFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusFilter<"Verdict"> | $Enums.VerdictStatus
    createdAt?: DateTimeFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeFilter<"Verdict"> | Date | string
    procesalCost?: FloatNullableFilter<"Verdict"> | number | null
    tenantId?: StringFilter<"Verdict"> | string
    notes?: StringNullableFilter<"Verdict"> | string | null
    bailiffId?: StringNullableFilter<"Verdict"> | string | null
  }

  export type TenantCreateWithoutRegistryInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRegistryInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRegistryInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRegistryInput, TenantUncheckedCreateWithoutRegistryInput>
  }

  export type TenantUpsertWithoutRegistryInput = {
    update: XOR<TenantUpdateWithoutRegistryInput, TenantUncheckedUpdateWithoutRegistryInput>
    create: XOR<TenantCreateWithoutRegistryInput, TenantUncheckedCreateWithoutRegistryInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRegistryInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRegistryInput, TenantUncheckedUpdateWithoutRegistryInput>
  }

  export type TenantUpdateWithoutRegistryInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRegistryInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutTenantInvitationsInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTenantInvitationsInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTenantInvitationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTenantInvitationsInput, TenantUncheckedCreateWithoutTenantInvitationsInput>
  }

  export type UserCreateWithoutTenantInvitationsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictCreateNestedManyWithoutBailiffInput
  }

  export type UserUncheckedCreateWithoutTenantInvitationsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
  }

  export type UserCreateOrConnectWithoutTenantInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInvitationsInput, UserUncheckedCreateWithoutTenantInvitationsInput>
  }

  export type TenantUpsertWithoutTenantInvitationsInput = {
    update: XOR<TenantUpdateWithoutTenantInvitationsInput, TenantUncheckedUpdateWithoutTenantInvitationsInput>
    create: XOR<TenantCreateWithoutTenantInvitationsInput, TenantUncheckedCreateWithoutTenantInvitationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTenantInvitationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTenantInvitationsInput, TenantUncheckedUpdateWithoutTenantInvitationsInput>
  }

  export type TenantUpdateWithoutTenantInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTenantInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutTenantInvitationsInput = {
    update: XOR<UserUpdateWithoutTenantInvitationsInput, UserUncheckedUpdateWithoutTenantInvitationsInput>
    create: XOR<UserCreateWithoutTenantInvitationsInput, UserUncheckedCreateWithoutTenantInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTenantInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTenantInvitationsInput, UserUncheckedUpdateWithoutTenantInvitationsInput>
  }

  export type UserUpdateWithoutTenantInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
  }

  export type DebtorCreateWithoutUserInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutUserInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput>
  }

  export type DebtorCreateManyUserInputEnvelope = {
    data: DebtorCreateManyUserInput | DebtorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MembershipCreateWithoutUserInput = {
    id?: string
    status?: $Enums.MembershipStatus
    joinedAt?: Date | string
    role?: $Enums.roleEnum
    tenant: TenantCreateNestedOneWithoutMembershipsInput
  }

  export type MembershipUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    status?: $Enums.MembershipStatus
    joinedAt?: Date | string
    role?: $Enums.roleEnum
  }

  export type MembershipCreateOrConnectWithoutUserInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
  }

  export type MembershipCreateManyUserInputEnvelope = {
    data: MembershipCreateManyUserInput | MembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantInvitationCreateWithoutUserInput = {
    id?: string
    email: string
    status?: string
    invitedBy: string
    createdAt?: Date | string
    role?: $Enums.roleEnum
    tenant: TenantCreateNestedOneWithoutTenantInvitationsInput
  }

  export type TenantInvitationUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    email: string
    status?: string
    invitedBy: string
    createdAt?: Date | string
    role?: $Enums.roleEnum
  }

  export type TenantInvitationCreateOrConnectWithoutUserInput = {
    where: TenantInvitationWhereUniqueInput
    create: XOR<TenantInvitationCreateWithoutUserInput, TenantInvitationUncheckedCreateWithoutUserInput>
  }

  export type TenantInvitationCreateManyUserInputEnvelope = {
    data: TenantInvitationCreateManyUserInput | TenantInvitationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VerdictCreateWithoutBailiffInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutBailiffInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutBailiffInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput>
  }

  export type VerdictCreateManyBailiffInputEnvelope = {
    data: VerdictCreateManyBailiffInput | VerdictCreateManyBailiffInput[]
    skipDuplicates?: boolean
  }

  export type DebtorUpsertWithWhereUniqueWithoutUserInput = {
    where: DebtorWhereUniqueInput
    update: XOR<DebtorUpdateWithoutUserInput, DebtorUncheckedUpdateWithoutUserInput>
    create: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput>
  }

  export type DebtorUpdateWithWhereUniqueWithoutUserInput = {
    where: DebtorWhereUniqueInput
    data: XOR<DebtorUpdateWithoutUserInput, DebtorUncheckedUpdateWithoutUserInput>
  }

  export type DebtorUpdateManyWithWhereWithoutUserInput = {
    where: DebtorScalarWhereInput
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyWithoutUserInput>
  }

  export type MembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput
    update: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
  }

  export type MembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput
    data: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>
  }

  export type MembershipUpdateManyWithWhereWithoutUserInput = {
    where: MembershipScalarWhereInput
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type TenantInvitationUpsertWithWhereUniqueWithoutUserInput = {
    where: TenantInvitationWhereUniqueInput
    update: XOR<TenantInvitationUpdateWithoutUserInput, TenantInvitationUncheckedUpdateWithoutUserInput>
    create: XOR<TenantInvitationCreateWithoutUserInput, TenantInvitationUncheckedCreateWithoutUserInput>
  }

  export type TenantInvitationUpdateWithWhereUniqueWithoutUserInput = {
    where: TenantInvitationWhereUniqueInput
    data: XOR<TenantInvitationUpdateWithoutUserInput, TenantInvitationUncheckedUpdateWithoutUserInput>
  }

  export type TenantInvitationUpdateManyWithWhereWithoutUserInput = {
    where: TenantInvitationScalarWhereInput
    data: XOR<TenantInvitationUpdateManyMutationInput, TenantInvitationUncheckedUpdateManyWithoutUserInput>
  }

  export type VerdictUpsertWithWhereUniqueWithoutBailiffInput = {
    where: VerdictWhereUniqueInput
    update: XOR<VerdictUpdateWithoutBailiffInput, VerdictUncheckedUpdateWithoutBailiffInput>
    create: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput>
  }

  export type VerdictUpdateWithWhereUniqueWithoutBailiffInput = {
    where: VerdictWhereUniqueInput
    data: XOR<VerdictUpdateWithoutBailiffInput, VerdictUncheckedUpdateWithoutBailiffInput>
  }

  export type VerdictUpdateManyWithWhereWithoutBailiffInput = {
    where: VerdictScalarWhereInput
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyWithoutBailiffInput>
  }

  export type TenantCreateWithoutMembershipsInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutMembershipsInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutMembershipsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorCreateNestedManyWithoutUserInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictCreateNestedManyWithoutBailiffInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type TenantUpsertWithoutMembershipsInput = {
    update: XOR<TenantUpdateWithoutMembershipsInput, TenantUncheckedUpdateWithoutMembershipsInput>
    create: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutMembershipsInput, TenantUncheckedUpdateWithoutMembershipsInput>
  }

  export type TenantUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
  }

  export type UserCreateWithoutVerdictBailiffsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVerdictBailiffsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVerdictBailiffsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerdictBailiffsInput, UserUncheckedCreateWithoutVerdictBailiffsInput>
  }

  export type DebtorCreateWithoutVerdictsInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutVerdictsInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutVerdictsInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
  }

  export type TenantCreateWithoutVerdictsInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVerdictsInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVerdictsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
  }

  export type VerdictAttachmentCreateWithoutVerdictInput = {
    id?: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
  }

  export type VerdictAttachmentUncheckedCreateWithoutVerdictInput = {
    id?: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
  }

  export type VerdictAttachmentCreateOrConnectWithoutVerdictInput = {
    where: VerdictAttachmentWhereUniqueInput
    create: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictAttachmentCreateManyVerdictInputEnvelope = {
    data: VerdictAttachmentCreateManyVerdictInput | VerdictAttachmentCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type VerdictBailiffServicesCreateWithoutVerdictInput = {
    id?: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictBailiffServicesUncheckedCreateWithoutVerdictInput = {
    id?: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictBailiffServicesCreateOrConnectWithoutVerdictInput = {
    where: VerdictBailiffServicesWhereUniqueInput
    create: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictBailiffServicesCreateManyVerdictInputEnvelope = {
    data: VerdictBailiffServicesCreateManyVerdictInput | VerdictBailiffServicesCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type VerdictEmbargoCreateWithoutVerdictInput = {
    id?: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictEmbargoUncheckedCreateWithoutVerdictInput = {
    id?: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictEmbargoCreateOrConnectWithoutVerdictInput = {
    where: VerdictEmbargoWhereUniqueInput
    create: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictEmbargoCreateManyVerdictInputEnvelope = {
    data: VerdictEmbargoCreateManyVerdictInput | VerdictEmbargoCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type VerdictInterestCreateWithoutVerdictInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: VerdictInterestDetailsCreateNestedManyWithoutVerdictInterestInput
  }

  export type VerdictInterestUncheckedCreateWithoutVerdictInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: VerdictInterestDetailsUncheckedCreateNestedManyWithoutVerdictInterestInput
  }

  export type VerdictInterestCreateOrConnectWithoutVerdictInput = {
    where: VerdictInterestWhereUniqueInput
    create: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictInterestCreateManyVerdictInputEnvelope = {
    data: VerdictInterestCreateManyVerdictInput | VerdictInterestCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutVerdictBailiffsInput = {
    update: XOR<UserUpdateWithoutVerdictBailiffsInput, UserUncheckedUpdateWithoutVerdictBailiffsInput>
    create: XOR<UserCreateWithoutVerdictBailiffsInput, UserUncheckedCreateWithoutVerdictBailiffsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerdictBailiffsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerdictBailiffsInput, UserUncheckedUpdateWithoutVerdictBailiffsInput>
  }

  export type UserUpdateWithoutVerdictBailiffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVerdictBailiffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DebtorUpsertWithoutVerdictsInput = {
    update: XOR<DebtorUpdateWithoutVerdictsInput, DebtorUncheckedUpdateWithoutVerdictsInput>
    create: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutVerdictsInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutVerdictsInput, DebtorUncheckedUpdateWithoutVerdictsInput>
  }

  export type DebtorUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type TenantUpsertWithoutVerdictsInput = {
    update: XOR<TenantUpdateWithoutVerdictsInput, TenantUncheckedUpdateWithoutVerdictsInput>
    create: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVerdictsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVerdictsInput, TenantUncheckedUpdateWithoutVerdictsInput>
  }

  export type TenantUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
  }

  export type VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictAttachmentWhereUniqueInput
    update: XOR<VerdictAttachmentUpdateWithoutVerdictInput, VerdictAttachmentUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictAttachmentWhereUniqueInput
    data: XOR<VerdictAttachmentUpdateWithoutVerdictInput, VerdictAttachmentUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictAttachmentScalarWhereInput
    data: XOR<VerdictAttachmentUpdateManyMutationInput, VerdictAttachmentUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictAttachmentScalarWhereInput = {
    AND?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
    OR?: VerdictAttachmentScalarWhereInput[]
    NOT?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
    id?: StringFilter<"VerdictAttachment"> | string
    verdictId?: StringFilter<"VerdictAttachment"> | string
    filePath?: StringFilter<"VerdictAttachment"> | string
    fileSize?: BigIntFilter<"VerdictAttachment"> | bigint | number
    createdAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    fileName?: StringFilter<"VerdictAttachment"> | string
  }

  export type VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictBailiffServicesWhereUniqueInput
    update: XOR<VerdictBailiffServicesUpdateWithoutVerdictInput, VerdictBailiffServicesUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictBailiffServicesWhereUniqueInput
    data: XOR<VerdictBailiffServicesUpdateWithoutVerdictInput, VerdictBailiffServicesUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictBailiffServicesScalarWhereInput
    data: XOR<VerdictBailiffServicesUpdateManyMutationInput, VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictBailiffServicesScalarWhereInput = {
    AND?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
    OR?: VerdictBailiffServicesScalarWhereInput[]
    NOT?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
    id?: StringFilter<"VerdictBailiffServices"> | string
    verdictId?: StringFilter<"VerdictBailiffServices"> | string
    serviceType?: StringFilter<"VerdictBailiffServices"> | string
    serviceCost?: FloatFilter<"VerdictBailiffServices"> | number
    createdAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
  }

  export type VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictEmbargoWhereUniqueInput
    update: XOR<VerdictEmbargoUpdateWithoutVerdictInput, VerdictEmbargoUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictEmbargoWhereUniqueInput
    data: XOR<VerdictEmbargoUpdateWithoutVerdictInput, VerdictEmbargoUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictEmbargoScalarWhereInput
    data: XOR<VerdictEmbargoUpdateManyMutationInput, VerdictEmbargoUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictEmbargoScalarWhereInput = {
    AND?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
    OR?: VerdictEmbargoScalarWhereInput[]
    NOT?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
    id?: StringFilter<"VerdictEmbargo"> | string
    verdictId?: StringFilter<"VerdictEmbargo"> | string
    companyName?: StringFilter<"VerdictEmbargo"> | string
    companyPhone?: StringFilter<"VerdictEmbargo"> | string
    companyEmail?: StringFilter<"VerdictEmbargo"> | string
    companyAddress?: StringFilter<"VerdictEmbargo"> | string
    embargoType?: StringFilter<"VerdictEmbargo"> | string
    embargoDate?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    embargoAmount?: FloatFilter<"VerdictEmbargo"> | number
    totalAmount?: FloatFilter<"VerdictEmbargo"> | number
    createdAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
  }

  export type VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictInterestWhereUniqueInput
    update: XOR<VerdictInterestUpdateWithoutVerdictInput, VerdictInterestUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictInterestWhereUniqueInput
    data: XOR<VerdictInterestUpdateWithoutVerdictInput, VerdictInterestUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictInterestUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictInterestScalarWhereInput
    data: XOR<VerdictInterestUpdateManyMutationInput, VerdictInterestUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictInterestScalarWhereInput = {
    AND?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
    OR?: VerdictInterestScalarWhereInput[]
    NOT?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
    id?: StringFilter<"VerdictInterest"> | string
    interestType?: IntFilter<"VerdictInterest"> | number
    baseAmount?: FloatFilter<"VerdictInterest"> | number
    calculatedInterest?: FloatNullableFilter<"VerdictInterest"> | number | null
    calculationStart?: DateTimeFilter<"VerdictInterest"> | Date | string
    calculationEnd?: DateTimeFilter<"VerdictInterest"> | Date | string
    totalInterest?: FloatFilter<"VerdictInterest"> | number
    createdAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    verdictId?: StringNullableFilter<"VerdictInterest"> | string | null
  }

  export type VerdictCreateWithoutVerdictInterestInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutVerdictInterestInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutVerdictInterestInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutVerdictInterestInput, VerdictUncheckedCreateWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsCreateWithoutVerdictInterestInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput = {
    where: VerdictInterestDetailsWhereUniqueInput
    create: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsCreateManyVerdictInterestInputEnvelope = {
    data: VerdictInterestDetailsCreateManyVerdictInterestInput | VerdictInterestDetailsCreateManyVerdictInterestInput[]
    skipDuplicates?: boolean
  }

  export type VerdictUpsertWithoutVerdictInterestInput = {
    update: XOR<VerdictUpdateWithoutVerdictInterestInput, VerdictUncheckedUpdateWithoutVerdictInterestInput>
    create: XOR<VerdictCreateWithoutVerdictInterestInput, VerdictUncheckedCreateWithoutVerdictInterestInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutVerdictInterestInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutVerdictInterestInput, VerdictUncheckedUpdateWithoutVerdictInterestInput>
  }

  export type VerdictUpdateWithoutVerdictInterestInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutVerdictInterestInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdictInterestInput = {
    where: VerdictInterestDetailsWhereUniqueInput
    update: XOR<VerdictInterestDetailsUpdateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedUpdateWithoutVerdictInterestInput>
    create: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdictInterestInput = {
    where: VerdictInterestDetailsWhereUniqueInput
    data: XOR<VerdictInterestDetailsUpdateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedUpdateWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsUpdateManyWithWhereWithoutVerdictInterestInput = {
    where: VerdictInterestDetailsScalarWhereInput
    data: XOR<VerdictInterestDetailsUpdateManyMutationInput, VerdictInterestDetailsUncheckedUpdateManyWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsScalarWhereInput = {
    AND?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
    OR?: VerdictInterestDetailsScalarWhereInput[]
    NOT?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
    id?: StringFilter<"VerdictInterestDetails"> | string
    period?: StringFilter<"VerdictInterestDetails"> | string
    periodStart?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    periodEnd?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    days?: IntFilter<"VerdictInterestDetails"> | number
    annualRate?: FloatFilter<"VerdictInterestDetails"> | number
    proportionalRate?: FloatFilter<"VerdictInterestDetails"> | number
    baseAmount?: FloatFilter<"VerdictInterestDetails"> | number
    interest?: FloatFilter<"VerdictInterestDetails"> | number
    total?: FloatFilter<"VerdictInterestDetails"> | number
    verdictInterestId?: StringFilter<"VerdictInterestDetails"> | string
    createdAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
  }

  export type VerdictInterestCreateWithoutDetailsInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdict?: VerdictCreateNestedOneWithoutVerdictInterestInput
  }

  export type VerdictInterestUncheckedCreateWithoutDetailsInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdictId?: string | null
  }

  export type VerdictInterestCreateOrConnectWithoutDetailsInput = {
    where: VerdictInterestWhereUniqueInput
    create: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
  }

  export type VerdictInterestUpsertWithoutDetailsInput = {
    update: XOR<VerdictInterestUpdateWithoutDetailsInput, VerdictInterestUncheckedUpdateWithoutDetailsInput>
    create: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
    where?: VerdictInterestWhereInput
  }

  export type VerdictInterestUpdateToOneWithWhereWithoutDetailsInput = {
    where?: VerdictInterestWhereInput
    data: XOR<VerdictInterestUpdateWithoutDetailsInput, VerdictInterestUncheckedUpdateWithoutDetailsInput>
  }

  export type VerdictInterestUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneWithoutVerdictInterestNestedInput
  }

  export type VerdictInterestUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdictId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictCreateWithoutVerdictEmbargoInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutVerdictEmbargoInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutVerdictEmbargoInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutVerdictEmbargoInput, VerdictUncheckedCreateWithoutVerdictEmbargoInput>
  }

  export type VerdictUpsertWithoutVerdictEmbargoInput = {
    update: XOR<VerdictUpdateWithoutVerdictEmbargoInput, VerdictUncheckedUpdateWithoutVerdictEmbargoInput>
    create: XOR<VerdictCreateWithoutVerdictEmbargoInput, VerdictUncheckedCreateWithoutVerdictEmbargoInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutVerdictEmbargoInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutVerdictEmbargoInput, VerdictUncheckedUpdateWithoutVerdictEmbargoInput>
  }

  export type VerdictUpdateWithoutVerdictEmbargoInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutVerdictEmbargoInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictCreateWithoutBailiffServicesInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutBailiffServicesInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutBailiffServicesInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutBailiffServicesInput, VerdictUncheckedCreateWithoutBailiffServicesInput>
  }

  export type VerdictUpsertWithoutBailiffServicesInput = {
    update: XOR<VerdictUpdateWithoutBailiffServicesInput, VerdictUncheckedUpdateWithoutBailiffServicesInput>
    create: XOR<VerdictCreateWithoutBailiffServicesInput, VerdictUncheckedCreateWithoutBailiffServicesInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutBailiffServicesInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutBailiffServicesInput, VerdictUncheckedUpdateWithoutBailiffServicesInput>
  }

  export type VerdictUpdateWithoutBailiffServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutBailiffServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictCreateWithoutAttachmentsInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutAttachmentsInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
  }

  export type VerdictUpsertWithoutAttachmentsInput = {
    update: XOR<VerdictUpdateWithoutAttachmentsInput, VerdictUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutAttachmentsInput, VerdictUncheckedUpdateWithoutAttachmentsInput>
  }

  export type VerdictUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type InterestDetailCreateWithoutInterestTypeInput = {
    date: string
    rate: number
  }

  export type InterestDetailUncheckedCreateWithoutInterestTypeInput = {
    id?: number
    date: string
    rate: number
  }

  export type InterestDetailCreateOrConnectWithoutInterestTypeInput = {
    where: InterestDetailWhereUniqueInput
    create: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput>
  }

  export type InterestDetailCreateManyInterestTypeInputEnvelope = {
    data: InterestDetailCreateManyInterestTypeInput | InterestDetailCreateManyInterestTypeInput[]
    skipDuplicates?: boolean
  }

  export type InterestDetailUpsertWithWhereUniqueWithoutInterestTypeInput = {
    where: InterestDetailWhereUniqueInput
    update: XOR<InterestDetailUpdateWithoutInterestTypeInput, InterestDetailUncheckedUpdateWithoutInterestTypeInput>
    create: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput>
  }

  export type InterestDetailUpdateWithWhereUniqueWithoutInterestTypeInput = {
    where: InterestDetailWhereUniqueInput
    data: XOR<InterestDetailUpdateWithoutInterestTypeInput, InterestDetailUncheckedUpdateWithoutInterestTypeInput>
  }

  export type InterestDetailUpdateManyWithWhereWithoutInterestTypeInput = {
    where: InterestDetailScalarWhereInput
    data: XOR<InterestDetailUpdateManyMutationInput, InterestDetailUncheckedUpdateManyWithoutInterestTypeInput>
  }

  export type InterestDetailScalarWhereInput = {
    AND?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
    OR?: InterestDetailScalarWhereInput[]
    NOT?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
    id?: IntFilter<"InterestDetail"> | number
    date?: StringFilter<"InterestDetail"> | string
    rate?: FloatFilter<"InterestDetail"> | number
    interestTypeId?: IntFilter<"InterestDetail"> | number
  }

  export type InterestTypeCreateWithoutDetailsInput = {
    name: string
    calculationType: $Enums.CalculationTypeEnum
  }

  export type InterestTypeUncheckedCreateWithoutDetailsInput = {
    id?: number
    name: string
    calculationType: $Enums.CalculationTypeEnum
  }

  export type InterestTypeCreateOrConnectWithoutDetailsInput = {
    where: InterestTypeWhereUniqueInput
    create: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
  }

  export type InterestTypeUpsertWithoutDetailsInput = {
    update: XOR<InterestTypeUpdateWithoutDetailsInput, InterestTypeUncheckedUpdateWithoutDetailsInput>
    create: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
    where?: InterestTypeWhereInput
  }

  export type InterestTypeUpdateToOneWithWhereWithoutDetailsInput = {
    where?: InterestTypeWhereInput
    data: XOR<InterestTypeUpdateWithoutDetailsInput, InterestTypeUncheckedUpdateWithoutDetailsInput>
  }

  export type InterestTypeUpdateWithoutDetailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type InterestTypeUncheckedUpdateWithoutDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type TenantCreateWithoutBillingInvoiceInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    subscription?: BillingSubscriptionCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBillingInvoiceInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBillingInvoiceInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBillingInvoiceInput, TenantUncheckedCreateWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailCreateWithoutBillingInvoiceInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput = {
    where: BillingInvoiceDetailWhereUniqueInput
    create: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailCreateManyBillingInvoiceInputEnvelope = {
    data: BillingInvoiceDetailCreateManyBillingInvoiceInput | BillingInvoiceDetailCreateManyBillingInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type BillingPaymentCreateWithoutBillingInvoiceInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPaymentUncheckedCreateWithoutBillingInvoiceInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPaymentCreateOrConnectWithoutBillingInvoiceInput = {
    where: BillingPaymentWhereUniqueInput
    create: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput>
  }

  export type BillingPaymentCreateManyBillingInvoiceInputEnvelope = {
    data: BillingPaymentCreateManyBillingInvoiceInput | BillingPaymentCreateManyBillingInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type BillingSubscriptionCreateWithoutLastInvoiceInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
    plan: BillingPlanCreateNestedOneWithoutSubscriptionsInput
    tenant: TenantCreateNestedOneWithoutSubscriptionInput
  }

  export type BillingSubscriptionUncheckedCreateWithoutLastInvoiceInput = {
    id?: string
    tenantId: string
    planId: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionCreateOrConnectWithoutLastInvoiceInput = {
    where: BillingSubscriptionWhereUniqueInput
    create: XOR<BillingSubscriptionCreateWithoutLastInvoiceInput, BillingSubscriptionUncheckedCreateWithoutLastInvoiceInput>
  }

  export type BillingSubscriptionCreateManyLastInvoiceInputEnvelope = {
    data: BillingSubscriptionCreateManyLastInvoiceInput | BillingSubscriptionCreateManyLastInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutBillingInvoiceInput = {
    update: XOR<TenantUpdateWithoutBillingInvoiceInput, TenantUncheckedUpdateWithoutBillingInvoiceInput>
    create: XOR<TenantCreateWithoutBillingInvoiceInput, TenantUncheckedCreateWithoutBillingInvoiceInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBillingInvoiceInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBillingInvoiceInput, TenantUncheckedUpdateWithoutBillingInvoiceInput>
  }

  export type TenantUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: BillingSubscriptionUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BillingInvoiceDetailUpsertWithWhereUniqueWithoutBillingInvoiceInput = {
    where: BillingInvoiceDetailWhereUniqueInput
    update: XOR<BillingInvoiceDetailUpdateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedUpdateWithoutBillingInvoiceInput>
    create: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailUpdateWithWhereUniqueWithoutBillingInvoiceInput = {
    where: BillingInvoiceDetailWhereUniqueInput
    data: XOR<BillingInvoiceDetailUpdateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedUpdateWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailUpdateManyWithWhereWithoutBillingInvoiceInput = {
    where: BillingInvoiceDetailScalarWhereInput
    data: XOR<BillingInvoiceDetailUpdateManyMutationInput, BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailScalarWhereInput = {
    AND?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
    OR?: BillingInvoiceDetailScalarWhereInput[]
    NOT?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
    id?: StringFilter<"BillingInvoiceDetail"> | string
    itemDescription?: StringFilter<"BillingInvoiceDetail"> | string
    itemQuantity?: IntFilter<"BillingInvoiceDetail"> | number
    itemUnitPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxRate?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxAmount?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalWithTax?: FloatFilter<"BillingInvoiceDetail"> | number
    createdAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingInvoiceDetail"> | string | null
  }

  export type BillingPaymentUpsertWithWhereUniqueWithoutBillingInvoiceInput = {
    where: BillingPaymentWhereUniqueInput
    update: XOR<BillingPaymentUpdateWithoutBillingInvoiceInput, BillingPaymentUncheckedUpdateWithoutBillingInvoiceInput>
    create: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput>
  }

  export type BillingPaymentUpdateWithWhereUniqueWithoutBillingInvoiceInput = {
    where: BillingPaymentWhereUniqueInput
    data: XOR<BillingPaymentUpdateWithoutBillingInvoiceInput, BillingPaymentUncheckedUpdateWithoutBillingInvoiceInput>
  }

  export type BillingPaymentUpdateManyWithWhereWithoutBillingInvoiceInput = {
    where: BillingPaymentScalarWhereInput
    data: XOR<BillingPaymentUpdateManyMutationInput, BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceInput>
  }

  export type BillingPaymentScalarWhereInput = {
    AND?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
    OR?: BillingPaymentScalarWhereInput[]
    NOT?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
    id?: StringFilter<"BillingPayment"> | string
    paymentDate?: DateTimeFilter<"BillingPayment"> | Date | string
    amount?: FloatFilter<"BillingPayment"> | number
    paymentMethod?: StringFilter<"BillingPayment"> | string
    transactionId?: StringNullableFilter<"BillingPayment"> | string | null
    status?: StringFilter<"BillingPayment"> | string
    createdAt?: DateTimeFilter<"BillingPayment"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPayment"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingPayment"> | string | null
  }

  export type BillingSubscriptionUpsertWithWhereUniqueWithoutLastInvoiceInput = {
    where: BillingSubscriptionWhereUniqueInput
    update: XOR<BillingSubscriptionUpdateWithoutLastInvoiceInput, BillingSubscriptionUncheckedUpdateWithoutLastInvoiceInput>
    create: XOR<BillingSubscriptionCreateWithoutLastInvoiceInput, BillingSubscriptionUncheckedCreateWithoutLastInvoiceInput>
  }

  export type BillingSubscriptionUpdateWithWhereUniqueWithoutLastInvoiceInput = {
    where: BillingSubscriptionWhereUniqueInput
    data: XOR<BillingSubscriptionUpdateWithoutLastInvoiceInput, BillingSubscriptionUncheckedUpdateWithoutLastInvoiceInput>
  }

  export type BillingSubscriptionUpdateManyWithWhereWithoutLastInvoiceInput = {
    where: BillingSubscriptionScalarWhereInput
    data: XOR<BillingSubscriptionUpdateManyMutationInput, BillingSubscriptionUncheckedUpdateManyWithoutLastInvoiceInput>
  }

  export type BillingInvoiceCreateWithoutDetailsInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBillingInvoiceInput
    payments?: BillingPaymentCreateNestedManyWithoutBillingInvoiceInput
    subscription?: BillingSubscriptionCreateNestedManyWithoutLastInvoiceInput
  }

  export type BillingInvoiceUncheckedCreateWithoutDetailsInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: BillingPaymentUncheckedCreateNestedManyWithoutBillingInvoiceInput
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutLastInvoiceInput
  }

  export type BillingInvoiceCreateOrConnectWithoutDetailsInput = {
    where: BillingInvoiceWhereUniqueInput
    create: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
  }

  export type BillingInvoiceUpsertWithoutDetailsInput = {
    update: XOR<BillingInvoiceUpdateWithoutDetailsInput, BillingInvoiceUncheckedUpdateWithoutDetailsInput>
    create: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
    where?: BillingInvoiceWhereInput
  }

  export type BillingInvoiceUpdateToOneWithWhereWithoutDetailsInput = {
    where?: BillingInvoiceWhereInput
    data: XOR<BillingInvoiceUpdateWithoutDetailsInput, BillingInvoiceUncheckedUpdateWithoutDetailsInput>
  }

  export type BillingInvoiceUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUpdateManyWithoutBillingInvoiceNestedInput
    subscription?: BillingSubscriptionUpdateManyWithoutLastInvoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceNestedInput
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutLastInvoiceNestedInput
  }

  export type BillingSubscriptionCreateWithoutPlanInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
    lastInvoice?: BillingInvoiceCreateNestedOneWithoutSubscriptionInput
    tenant: TenantCreateNestedOneWithoutSubscriptionInput
  }

  export type BillingSubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    tenantId: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    lastInvoiceId?: string | null
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionCreateOrConnectWithoutPlanInput = {
    where: BillingSubscriptionWhereUniqueInput
    create: XOR<BillingSubscriptionCreateWithoutPlanInput, BillingSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type BillingSubscriptionCreateManyPlanInputEnvelope = {
    data: BillingSubscriptionCreateManyPlanInput | BillingSubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type BillingSubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: BillingSubscriptionWhereUniqueInput
    update: XOR<BillingSubscriptionUpdateWithoutPlanInput, BillingSubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<BillingSubscriptionCreateWithoutPlanInput, BillingSubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type BillingSubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: BillingSubscriptionWhereUniqueInput
    data: XOR<BillingSubscriptionUpdateWithoutPlanInput, BillingSubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type BillingSubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: BillingSubscriptionScalarWhereInput
    data: XOR<BillingSubscriptionUpdateManyMutationInput, BillingSubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type BillingInvoiceCreateWithoutSubscriptionInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBillingInvoiceInput
    details?: BillingInvoiceDetailCreateNestedManyWithoutBillingInvoiceInput
    payments?: BillingPaymentCreateNestedManyWithoutBillingInvoiceInput
  }

  export type BillingInvoiceUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BillingInvoiceDetailUncheckedCreateNestedManyWithoutBillingInvoiceInput
    payments?: BillingPaymentUncheckedCreateNestedManyWithoutBillingInvoiceInput
  }

  export type BillingInvoiceCreateOrConnectWithoutSubscriptionInput = {
    where: BillingInvoiceWhereUniqueInput
    create: XOR<BillingInvoiceCreateWithoutSubscriptionInput, BillingInvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type BillingPlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    billingCycle?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    currency?: string
    billingCycle?: string
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPlanCreateOrConnectWithoutSubscriptionsInput = {
    where: BillingPlanWhereUniqueInput
    create: XOR<BillingPlanCreateWithoutSubscriptionsInput, BillingPlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type TenantCreateWithoutSubscriptionInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSubscriptionInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSubscriptionInput, TenantUncheckedCreateWithoutSubscriptionInput>
  }

  export type BillingInvoiceUpsertWithoutSubscriptionInput = {
    update: XOR<BillingInvoiceUpdateWithoutSubscriptionInput, BillingInvoiceUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<BillingInvoiceCreateWithoutSubscriptionInput, BillingInvoiceUncheckedCreateWithoutSubscriptionInput>
    where?: BillingInvoiceWhereInput
  }

  export type BillingInvoiceUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: BillingInvoiceWhereInput
    data: XOR<BillingInvoiceUpdateWithoutSubscriptionInput, BillingInvoiceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type BillingInvoiceUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBillingInvoiceNestedInput
    details?: BillingInvoiceDetailUpdateManyWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUpdateManyWithoutBillingInvoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceNestedInput
  }

  export type BillingPlanUpsertWithoutSubscriptionsInput = {
    update: XOR<BillingPlanUpdateWithoutSubscriptionsInput, BillingPlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<BillingPlanCreateWithoutSubscriptionsInput, BillingPlanUncheckedCreateWithoutSubscriptionsInput>
    where?: BillingPlanWhereInput
  }

  export type BillingPlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: BillingPlanWhereInput
    data: XOR<BillingPlanUpdateWithoutSubscriptionsInput, BillingPlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type BillingPlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    billingCycle?: StringFieldUpdateOperationsInput | string
    features?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUpsertWithoutSubscriptionInput = {
    update: XOR<TenantUpdateWithoutSubscriptionInput, TenantUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<TenantCreateWithoutSubscriptionInput, TenantUncheckedCreateWithoutSubscriptionInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSubscriptionInput, TenantUncheckedUpdateWithoutSubscriptionInput>
  }

  export type TenantUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BillingInvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBillingInvoiceInput
    details?: BillingInvoiceDetailCreateNestedManyWithoutBillingInvoiceInput
    subscription?: BillingSubscriptionCreateNestedManyWithoutLastInvoiceInput
  }

  export type BillingInvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BillingInvoiceDetailUncheckedCreateNestedManyWithoutBillingInvoiceInput
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutLastInvoiceInput
  }

  export type BillingInvoiceCreateOrConnectWithoutPaymentsInput = {
    where: BillingInvoiceWhereUniqueInput
    create: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type BillingInvoiceUpsertWithoutPaymentsInput = {
    update: XOR<BillingInvoiceUpdateWithoutPaymentsInput, BillingInvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
    where?: BillingInvoiceWhereInput
  }

  export type BillingInvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BillingInvoiceWhereInput
    data: XOR<BillingInvoiceUpdateWithoutPaymentsInput, BillingInvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type BillingInvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBillingInvoiceNestedInput
    details?: BillingInvoiceDetailUpdateManyWithoutBillingInvoiceNestedInput
    subscription?: BillingSubscriptionUpdateManyWithoutLastInvoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceNestedInput
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutLastInvoiceNestedInput
  }

  export type DebtorCreateWithoutCollectionCasesInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutCollectionCasesInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutCollectionCasesInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutCollectionCasesInput, DebtorUncheckedCreateWithoutCollectionCasesInput>
  }

  export type TenantCreateWithoutCollectionCasesInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCollectionCasesInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCollectionCasesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCollectionCasesInput, TenantUncheckedCreateWithoutCollectionCasesInput>
  }

  export type NotificationCreateWithoutCollectionCaseInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutCollectionCaseInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutCollectionCaseInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput>
  }

  export type NotificationCreateManyCollectionCaseInputEnvelope = {
    data: NotificationCreateManyCollectionCaseInput | NotificationCreateManyCollectionCaseInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCollectionCaseInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutCollectionCaseInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutCollectionCaseInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PaymentCreateManyCollectionCaseInputEnvelope = {
    data: PaymentCreateManyCollectionCaseInput | PaymentCreateManyCollectionCaseInput[]
    skipDuplicates?: boolean
  }

  export type PaymentAgreementCreateWithoutCollectionCaseInput = {
    id?: string
    agreementDate: Date | string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    installmentAmount?: Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: Date | string | null
    notes?: string | null
    totalInstallments?: number | null
    Debtor?: DebtorCreateNestedOneWithoutPaymentAgreementsInput
  }

  export type PaymentAgreementUncheckedCreateWithoutCollectionCaseInput = {
    id?: string
    debtorId?: string | null
    agreementDate: Date | string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    installmentAmount?: Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: Date | string | null
    notes?: string | null
    totalInstallments?: number | null
  }

  export type PaymentAgreementCreateOrConnectWithoutCollectionCaseInput = {
    where: PaymentAgreementWhereUniqueInput
    create: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PaymentAgreementCreateManyCollectionCaseInputEnvelope = {
    data: PaymentAgreementCreateManyCollectionCaseInput | PaymentAgreementCreateManyCollectionCaseInput[]
    skipDuplicates?: boolean
  }

  export type PenaltyCreateWithoutCollectionCaseInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PenaltyUncheckedCreateWithoutCollectionCaseInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PenaltyCreateOrConnectWithoutCollectionCaseInput = {
    where: PenaltyWhereUniqueInput
    create: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PenaltyCreateManyCollectionCaseInputEnvelope = {
    data: PenaltyCreateManyCollectionCaseInput | PenaltyCreateManyCollectionCaseInput[]
    skipDuplicates?: boolean
  }

  export type DebtorUpsertWithoutCollectionCasesInput = {
    update: XOR<DebtorUpdateWithoutCollectionCasesInput, DebtorUncheckedUpdateWithoutCollectionCasesInput>
    create: XOR<DebtorCreateWithoutCollectionCasesInput, DebtorUncheckedCreateWithoutCollectionCasesInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutCollectionCasesInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutCollectionCasesInput, DebtorUncheckedUpdateWithoutCollectionCasesInput>
  }

  export type DebtorUpdateWithoutCollectionCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutCollectionCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type TenantUpsertWithoutCollectionCasesInput = {
    update: XOR<TenantUpdateWithoutCollectionCasesInput, TenantUncheckedUpdateWithoutCollectionCasesInput>
    create: XOR<TenantCreateWithoutCollectionCasesInput, TenantUncheckedCreateWithoutCollectionCasesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCollectionCasesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCollectionCasesInput, TenantUncheckedUpdateWithoutCollectionCasesInput>
  }

  export type TenantUpdateWithoutCollectionCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCollectionCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutCollectionCaseInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCollectionCaseInput, NotificationUncheckedUpdateWithoutCollectionCaseInput>
    create: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCollectionCaseInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCollectionCaseInput, NotificationUncheckedUpdateWithoutCollectionCaseInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCollectionCaseInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutCollectionCaseInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    collectionCaseId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    sentAt?: DateTimeFilter<"Notification"> | Date | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutCollectionCaseInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCollectionCaseInput, PaymentUncheckedUpdateWithoutCollectionCaseInput>
    create: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCollectionCaseInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCollectionCaseInput, PaymentUncheckedUpdateWithoutCollectionCaseInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCollectionCaseInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCollectionCaseInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    collectionCaseId?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type PaymentAgreementUpsertWithWhereUniqueWithoutCollectionCaseInput = {
    where: PaymentAgreementWhereUniqueInput
    update: XOR<PaymentAgreementUpdateWithoutCollectionCaseInput, PaymentAgreementUncheckedUpdateWithoutCollectionCaseInput>
    create: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PaymentAgreementUpdateWithWhereUniqueWithoutCollectionCaseInput = {
    where: PaymentAgreementWhereUniqueInput
    data: XOR<PaymentAgreementUpdateWithoutCollectionCaseInput, PaymentAgreementUncheckedUpdateWithoutCollectionCaseInput>
  }

  export type PaymentAgreementUpdateManyWithWhereWithoutCollectionCaseInput = {
    where: PaymentAgreementScalarWhereInput
    data: XOR<PaymentAgreementUpdateManyMutationInput, PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseInput>
  }

  export type PaymentAgreementScalarWhereInput = {
    AND?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
    OR?: PaymentAgreementScalarWhereInput[]
    NOT?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
    id?: StringFilter<"PaymentAgreement"> | string
    debtorId?: StringNullableFilter<"PaymentAgreement"> | string | null
    agreementDate?: DateTimeFilter<"PaymentAgreement"> | Date | string
    status?: EnumAgreementStatusFilter<"PaymentAgreement"> | $Enums.AgreementStatus
    createdAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    collectionCaseId?: StringFilter<"PaymentAgreement"> | string
    installmentAmount?: DecimalNullableFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: DateTimeNullableFilter<"PaymentAgreement"> | Date | string | null
    notes?: StringNullableFilter<"PaymentAgreement"> | string | null
    totalInstallments?: IntNullableFilter<"PaymentAgreement"> | number | null
  }

  export type PenaltyUpsertWithWhereUniqueWithoutCollectionCaseInput = {
    where: PenaltyWhereUniqueInput
    update: XOR<PenaltyUpdateWithoutCollectionCaseInput, PenaltyUncheckedUpdateWithoutCollectionCaseInput>
    create: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PenaltyUpdateWithWhereUniqueWithoutCollectionCaseInput = {
    where: PenaltyWhereUniqueInput
    data: XOR<PenaltyUpdateWithoutCollectionCaseInput, PenaltyUncheckedUpdateWithoutCollectionCaseInput>
  }

  export type PenaltyUpdateManyWithWhereWithoutCollectionCaseInput = {
    where: PenaltyScalarWhereInput
    data: XOR<PenaltyUpdateManyMutationInput, PenaltyUncheckedUpdateManyWithoutCollectionCaseInput>
  }

  export type PenaltyScalarWhereInput = {
    AND?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
    OR?: PenaltyScalarWhereInput[]
    NOT?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
    id?: StringFilter<"Penalty"> | string
    collectionCaseId?: StringFilter<"Penalty"> | string
    description?: StringNullableFilter<"Penalty"> | string | null
    amount?: DecimalFilter<"Penalty"> | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFilter<"Penalty"> | Date | string
    isPaid?: BoolFilter<"Penalty"> | boolean
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
    updatedAt?: DateTimeFilter<"Penalty"> | Date | string
  }

  export type CollectionCaseCreateWithoutPenaltiesInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutPenaltiesInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutPenaltiesInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
  }

  export type CollectionCaseUpsertWithoutPenaltiesInput = {
    update: XOR<CollectionCaseUpdateWithoutPenaltiesInput, CollectionCaseUncheckedUpdateWithoutPenaltiesInput>
    create: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutPenaltiesInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutPenaltiesInput, CollectionCaseUncheckedUpdateWithoutPenaltiesInput>
  }

  export type CollectionCaseUpdateWithoutPenaltiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutPenaltiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseCreateWithoutNotificationsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutNotificationsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutNotificationsInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
  }

  export type CollectionCaseUpsertWithoutNotificationsInput = {
    update: XOR<CollectionCaseUpdateWithoutNotificationsInput, CollectionCaseUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutNotificationsInput, CollectionCaseUncheckedUpdateWithoutNotificationsInput>
  }

  export type CollectionCaseUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseCreateWithoutPaymentsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutPaymentsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutPaymentsInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
  }

  export type CollectionCaseUpsertWithoutPaymentsInput = {
    update: XOR<CollectionCaseUpdateWithoutPaymentsInput, CollectionCaseUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutPaymentsInput, CollectionCaseUncheckedUpdateWithoutPaymentsInput>
  }

  export type CollectionCaseUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseCreateWithoutAgreementsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutAgreementsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutAgreementsInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutAgreementsInput, CollectionCaseUncheckedCreateWithoutAgreementsInput>
  }

  export type DebtorCreateWithoutPaymentAgreementsInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutPaymentAgreementsInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutPaymentAgreementsInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutPaymentAgreementsInput, DebtorUncheckedCreateWithoutPaymentAgreementsInput>
  }

  export type CollectionCaseUpsertWithoutAgreementsInput = {
    update: XOR<CollectionCaseUpdateWithoutAgreementsInput, CollectionCaseUncheckedUpdateWithoutAgreementsInput>
    create: XOR<CollectionCaseCreateWithoutAgreementsInput, CollectionCaseUncheckedCreateWithoutAgreementsInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutAgreementsInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutAgreementsInput, CollectionCaseUncheckedUpdateWithoutAgreementsInput>
  }

  export type CollectionCaseUpdateWithoutAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type DebtorUpsertWithoutPaymentAgreementsInput = {
    update: XOR<DebtorUpdateWithoutPaymentAgreementsInput, DebtorUncheckedUpdateWithoutPaymentAgreementsInput>
    create: XOR<DebtorCreateWithoutPaymentAgreementsInput, DebtorUncheckedCreateWithoutPaymentAgreementsInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutPaymentAgreementsInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutPaymentAgreementsInput, DebtorUncheckedUpdateWithoutPaymentAgreementsInput>
  }

  export type DebtorUpdateWithoutPaymentAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutPaymentAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type CollectionCaseCreateWithoutDebtorInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutDebtorInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    tenantId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    agreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutDebtorInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput>
  }

  export type CollectionCaseCreateManyDebtorInputEnvelope = {
    data: CollectionCaseCreateManyDebtorInput | CollectionCaseCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutDebtorsInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    memberships?: MembershipCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDebtorsInput = {
    id?: string
    subdomain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactEmail: string
    countryCode: string
    name: string
    planStatus?: string
    termsAccepted?: boolean
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    isActive?: boolean
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    subscription?: BillingSubscriptionUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutTenantInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDebtorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
  }

  export type UserCreateWithoutDebtorsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipCreateNestedManyWithoutUserInput
    tenantInvitations?: TenantInvitationCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictCreateNestedManyWithoutBailiffInput
  }

  export type UserUncheckedCreateWithoutDebtorsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
    tenantInvitations?: TenantInvitationUncheckedCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
  }

  export type UserCreateOrConnectWithoutDebtorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
  }

  export type DebtorIncomeCreateWithoutDebtorInput = {
    id?: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorIncomeUncheckedCreateWithoutDebtorInput = {
    id?: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorIncomeCreateOrConnectWithoutDebtorInput = {
    where: DebtorIncomeWhereUniqueInput
    create: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput>
  }

  export type DebtorIncomeCreateManyDebtorInputEnvelope = {
    data: DebtorIncomeCreateManyDebtorInput | DebtorIncomeCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type PaymentAgreementCreateWithoutDebtorInput = {
    id?: string
    agreementDate: Date | string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    installmentAmount?: Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: Date | string | null
    notes?: string | null
    totalInstallments?: number | null
    collectionCase: CollectionCaseCreateNestedOneWithoutAgreementsInput
  }

  export type PaymentAgreementUncheckedCreateWithoutDebtorInput = {
    id?: string
    agreementDate: Date | string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCaseId: string
    installmentAmount?: Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: Date | string | null
    notes?: string | null
    totalInstallments?: number | null
  }

  export type PaymentAgreementCreateOrConnectWithoutDebtorInput = {
    where: PaymentAgreementWhereUniqueInput
    create: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput>
  }

  export type PaymentAgreementCreateManyDebtorInputEnvelope = {
    data: PaymentAgreementCreateManyDebtorInput | PaymentAgreementCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type VerdictCreateWithoutDebtorInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutDebtorInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutDebtorInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput>
  }

  export type VerdictCreateManyDebtorInputEnvelope = {
    data: VerdictCreateManyDebtorInput | VerdictCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput = {
    where: CollectionCaseWhereUniqueInput
    update: XOR<CollectionCaseUpdateWithoutDebtorInput, CollectionCaseUncheckedUpdateWithoutDebtorInput>
    create: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput>
  }

  export type CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput = {
    where: CollectionCaseWhereUniqueInput
    data: XOR<CollectionCaseUpdateWithoutDebtorInput, CollectionCaseUncheckedUpdateWithoutDebtorInput>
  }

  export type CollectionCaseUpdateManyWithWhereWithoutDebtorInput = {
    where: CollectionCaseScalarWhereInput
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyWithoutDebtorInput>
  }

  export type TenantUpsertWithoutDebtorsInput = {
    update: XOR<TenantUpdateWithoutDebtorsInput, TenantUncheckedUpdateWithoutDebtorsInput>
    create: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDebtorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDebtorsInput, TenantUncheckedUpdateWithoutDebtorsInput>
  }

  export type TenantUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutTenantNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutDebtorsInput = {
    update: XOR<UserUpdateWithoutDebtorsInput, UserUncheckedUpdateWithoutDebtorsInput>
    create: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDebtorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDebtorsInput, UserUncheckedUpdateWithoutDebtorsInput>
  }

  export type UserUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUpdateManyWithoutUserNestedInput
    tenantInvitations?: TenantInvitationUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
  }

  export type UserUncheckedUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
    tenantInvitations?: TenantInvitationUncheckedUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
  }

  export type DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput = {
    where: DebtorIncomeWhereUniqueInput
    update: XOR<DebtorIncomeUpdateWithoutDebtorInput, DebtorIncomeUncheckedUpdateWithoutDebtorInput>
    create: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput>
  }

  export type DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput = {
    where: DebtorIncomeWhereUniqueInput
    data: XOR<DebtorIncomeUpdateWithoutDebtorInput, DebtorIncomeUncheckedUpdateWithoutDebtorInput>
  }

  export type DebtorIncomeUpdateManyWithWhereWithoutDebtorInput = {
    where: DebtorIncomeScalarWhereInput
    data: XOR<DebtorIncomeUpdateManyMutationInput, DebtorIncomeUncheckedUpdateManyWithoutDebtorInput>
  }

  export type DebtorIncomeScalarWhereInput = {
    AND?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
    OR?: DebtorIncomeScalarWhereInput[]
    NOT?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
    id?: StringFilter<"DebtorIncome"> | string
    debtorId?: StringFilter<"DebtorIncome"> | string
    amount?: FloatFilter<"DebtorIncome"> | number
    source?: StringFilter<"DebtorIncome"> | string
    createdAt?: DateTimeFilter<"DebtorIncome"> | Date | string
    updatedAt?: DateTimeFilter<"DebtorIncome"> | Date | string
  }

  export type PaymentAgreementUpsertWithWhereUniqueWithoutDebtorInput = {
    where: PaymentAgreementWhereUniqueInput
    update: XOR<PaymentAgreementUpdateWithoutDebtorInput, PaymentAgreementUncheckedUpdateWithoutDebtorInput>
    create: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput>
  }

  export type PaymentAgreementUpdateWithWhereUniqueWithoutDebtorInput = {
    where: PaymentAgreementWhereUniqueInput
    data: XOR<PaymentAgreementUpdateWithoutDebtorInput, PaymentAgreementUncheckedUpdateWithoutDebtorInput>
  }

  export type PaymentAgreementUpdateManyWithWhereWithoutDebtorInput = {
    where: PaymentAgreementScalarWhereInput
    data: XOR<PaymentAgreementUpdateManyMutationInput, PaymentAgreementUncheckedUpdateManyWithoutDebtorInput>
  }

  export type VerdictUpsertWithWhereUniqueWithoutDebtorInput = {
    where: VerdictWhereUniqueInput
    update: XOR<VerdictUpdateWithoutDebtorInput, VerdictUncheckedUpdateWithoutDebtorInput>
    create: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput>
  }

  export type VerdictUpdateWithWhereUniqueWithoutDebtorInput = {
    where: VerdictWhereUniqueInput
    data: XOR<VerdictUpdateWithoutDebtorInput, VerdictUncheckedUpdateWithoutDebtorInput>
  }

  export type VerdictUpdateManyWithWhereWithoutDebtorInput = {
    where: VerdictScalarWhereInput
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyWithoutDebtorInput>
  }

  export type DebtorCreateWithoutIncomesInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutIncomesInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutIncomesInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
  }

  export type DebtorUpsertWithoutIncomesInput = {
    update: XOR<DebtorUpdateWithoutIncomesInput, DebtorUncheckedUpdateWithoutIncomesInput>
    create: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutIncomesInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutIncomesInput, DebtorUncheckedUpdateWithoutIncomesInput>
  }

  export type DebtorUpdateWithoutIncomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutIncomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type BillingInvoiceCreateManyTenantInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingSubscriptionCreateManyTenantInput = {
    id?: string
    planId: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    lastInvoiceId?: string | null
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
  }

  export type CollectionCaseCreateManyTenantInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorCreateManyTenantInput = {
    id?: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipCreateManyTenantInput = {
    id?: string
    userId: string
    status?: $Enums.MembershipStatus
    joinedAt?: Date | string
    role?: $Enums.roleEnum
  }

  export type TenantInvitationCreateManyTenantInput = {
    id?: string
    email: string
    status?: string
    invitedBy: string
    createdAt?: Date | string
    userId?: string | null
    role?: $Enums.roleEnum
  }

  export type VerdictCreateManyTenantInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiffId?: string | null
  }

  export type BillingInvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUpdateManyWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUpdateManyWithoutBillingInvoiceNestedInput
    subscription?: BillingSubscriptionUpdateManyWithoutLastInvoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceNestedInput
    subscription?: BillingSubscriptionUncheckedUpdateManyWithoutLastInvoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingSubscriptionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
    lastInvoice?: BillingInvoiceUpdateOneWithoutSubscriptionNestedInput
    plan?: BillingPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type BillingSubscriptionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
  }

  export type CollectionCaseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMembershipStatusFieldUpdateOperationsInput | $Enums.MembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type MembershipUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumMembershipStatusFieldUpdateOperationsInput | $Enums.MembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type MembershipUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumMembershipStatusFieldUpdateOperationsInput | $Enums.MembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type TenantInvitationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    User?: UserUpdateOneWithoutTenantInvitationsNestedInput
  }

  export type TenantInvitationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type TenantInvitationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type VerdictUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DebtorCreateManyUserInput = {
    id?: string
    tenantId: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: string | null
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipCreateManyUserInput = {
    id?: string
    tenantId: string
    status?: $Enums.MembershipStatus
    joinedAt?: Date | string
    role?: $Enums.roleEnum
  }

  export type TenantInvitationCreateManyUserInput = {
    id?: string
    tenantId: string
    email: string
    status?: string
    invitedBy: string
    createdAt?: Date | string
    role?: $Enums.roleEnum
  }

  export type VerdictCreateManyBailiffInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
  }

  export type DebtorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: NullableStringFieldUpdateOperationsInput | string | null
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumMembershipStatusFieldUpdateOperationsInput | $Enums.MembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    tenant?: TenantUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type MembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumMembershipStatusFieldUpdateOperationsInput | $Enums.MembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type MembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: EnumMembershipStatusFieldUpdateOperationsInput | $Enums.MembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type TenantInvitationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    tenant?: TenantUpdateOneRequiredWithoutTenantInvitationsNestedInput
  }

  export type TenantInvitationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type TenantInvitationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
  }

  export type VerdictUpdateWithoutBailiffInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutBailiffInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateManyWithoutBailiffInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictAttachmentCreateManyVerdictInput = {
    id?: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
  }

  export type VerdictBailiffServicesCreateManyVerdictInput = {
    id?: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictEmbargoCreateManyVerdictInput = {
    id?: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestCreateManyVerdictInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictAttachmentUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictBailiffServicesUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: VerdictInterestDetailsUpdateManyWithoutVerdictInterestNestedInput
  }

  export type VerdictInterestUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: VerdictInterestDetailsUncheckedUpdateManyWithoutVerdictInterestNestedInput
  }

  export type VerdictInterestUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsCreateManyVerdictInterestInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestDetailsUpdateWithoutVerdictInterestInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsUncheckedUpdateWithoutVerdictInterestInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsUncheckedUpdateManyWithoutVerdictInterestInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestDetailCreateManyInterestTypeInput = {
    id?: number
    date: string
    rate: number
  }

  export type InterestDetailUpdateWithoutInterestTypeInput = {
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type InterestDetailUncheckedUpdateWithoutInterestTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type InterestDetailUncheckedUpdateManyWithoutInterestTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type BillingInvoiceDetailCreateManyBillingInvoiceInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPaymentCreateManyBillingInvoiceInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingSubscriptionCreateManyLastInvoiceInput = {
    id?: string
    tenantId: string
    planId: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
  }

  export type BillingInvoiceDetailUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailUncheckedUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUncheckedUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingSubscriptionUpdateWithoutLastInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
    plan?: BillingPlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type BillingSubscriptionUncheckedUpdateWithoutLastInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionUncheckedUpdateManyWithoutLastInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionCreateManyPlanInput = {
    id?: string
    tenantId: string
    startDate?: Date | string
    endDate?: Date | string | null
    nextBillingDate?: Date | string | null
    billingCycle?: string
    amount: number
    currency?: string
    lastInvoiceId?: string | null
    trialEndsAt?: Date | string | null
    canceledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
    lastInvoice?: BillingInvoiceUpdateOneWithoutSubscriptionNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type BillingSubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
  }

  export type BillingSubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBillingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billingCycle?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    lastInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBillingSubscriptionStatusFieldUpdateOperationsInput | $Enums.BillingSubscriptionStatus
  }

  export type NotificationCreateManyCollectionCaseInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
  }

  export type PaymentCreateManyCollectionCaseInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
  }

  export type PaymentAgreementCreateManyCollectionCaseInput = {
    id?: string
    debtorId?: string | null
    agreementDate: Date | string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    installmentAmount?: Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: Date | string | null
    notes?: string | null
    totalInstallments?: number | null
  }

  export type PenaltyCreateManyCollectionCaseInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAgreementUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installmentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    Debtor?: DebtorUpdateOneWithoutPaymentAgreementsNestedInput
  }

  export type PaymentAgreementUncheckedUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    agreementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installmentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstallments?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    agreementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installmentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstallments?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PenaltyUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateManyWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseCreateManyDebtorInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    tenantId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorIncomeCreateManyDebtorInput = {
    id?: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentAgreementCreateManyDebtorInput = {
    id?: string
    agreementDate: Date | string
    status?: $Enums.AgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCaseId: string
    installmentAmount?: Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: Date | string | null
    notes?: string | null
    totalInstallments?: number | null
  }

  export type VerdictCreateManyDebtorInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
  }

  export type CollectionCaseUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    agreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAgreementUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installmentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstallments?: NullableIntFieldUpdateOperationsInput | number | null
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutAgreementsNestedInput
  }

  export type PaymentAgreementUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    installmentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstallments?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentAgreementUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    installmentAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    nextPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    totalInstallments?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VerdictUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}