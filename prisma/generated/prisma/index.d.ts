
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model TenantRegistry
 * 
 */
export type TenantRegistry = $Result.DefaultSelection<Prisma.$TenantRegistryPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Parameter
 * 
 */
export type Parameter = $Result.DefaultSelection<Prisma.$ParameterPayload>
/**
 * Model Verdict
 * 
 */
export type Verdict = $Result.DefaultSelection<Prisma.$VerdictPayload>
/**
 * Model VerdictInterest
 * 
 */
export type VerdictInterest = $Result.DefaultSelection<Prisma.$VerdictInterestPayload>
/**
 * Model VerdictInterestDetails
 * 
 */
export type VerdictInterestDetails = $Result.DefaultSelection<Prisma.$VerdictInterestDetailsPayload>
/**
 * Model VerdictEmbargo
 * 
 */
export type VerdictEmbargo = $Result.DefaultSelection<Prisma.$VerdictEmbargoPayload>
/**
 * Model VerdictBailiffServices
 * 
 */
export type VerdictBailiffServices = $Result.DefaultSelection<Prisma.$VerdictBailiffServicesPayload>
/**
 * Model VerdictAttachment
 * 
 */
export type VerdictAttachment = $Result.DefaultSelection<Prisma.$VerdictAttachmentPayload>
/**
 * Model InterestType
 * 
 */
export type InterestType = $Result.DefaultSelection<Prisma.$InterestTypePayload>
/**
 * Model InterestDetail
 * 
 */
export type InterestDetail = $Result.DefaultSelection<Prisma.$InterestDetailPayload>
/**
 * Model BillingInvoice
 * 
 */
export type BillingInvoice = $Result.DefaultSelection<Prisma.$BillingInvoicePayload>
/**
 * Model BillingInvoiceDetail
 * 
 */
export type BillingInvoiceDetail = $Result.DefaultSelection<Prisma.$BillingInvoiceDetailPayload>
/**
 * Model BillingPayment
 * 
 */
export type BillingPayment = $Result.DefaultSelection<Prisma.$BillingPaymentPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model CollectionCase
 * 
 */
export type CollectionCase = $Result.DefaultSelection<Prisma.$CollectionCasePayload>
/**
 * Model Penalty
 * 
 */
export type Penalty = $Result.DefaultSelection<Prisma.$PenaltyPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Debtor
 * 
 */
export type Debtor = $Result.DefaultSelection<Prisma.$DebtorPayload>
/**
 * Model ChatRoom
 * 
 */
export type ChatRoom = $Result.DefaultSelection<Prisma.$ChatRoomPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model DebtorIncome
 * 
 */
export type DebtorIncome = $Result.DefaultSelection<Prisma.$DebtorIncomePayload>
/**
 * Model PaymentAgreement
 * 
 */
export type PaymentAgreement = $Result.DefaultSelection<Prisma.$PaymentAgreementPayload>
/**
 * Model Installment
 * 
 */
export type Installment = $Result.DefaultSelection<Prisma.$InstallmentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InstallmentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE'
};

export type InstallmentStatus = (typeof InstallmentStatus)[keyof typeof InstallmentStatus]


export const PaymentAgreementStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  OVERDUE: 'OVERDUE',
  PAID: 'PAID'
};

export type PaymentAgreementStatus = (typeof PaymentAgreementStatus)[keyof typeof PaymentAgreementStatus]


export const CalculationTypeEnum: {
  FIXED: 'FIXED',
  VARIABLE: 'VARIABLE'
};

export type CalculationTypeEnum = (typeof CalculationTypeEnum)[keyof typeof CalculationTypeEnum]


export const VerdictStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type VerdictStatus = (typeof VerdictStatus)[keyof typeof VerdictStatus]


export const NotificationType: {
  AANMANING: 'AANMANING',
  SOMMATIE: 'SOMMATIE',
  INGEBREKESTELLING: 'INGEBREKESTELLING',
  BLOKKADE: 'BLOKKADE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const IdentificationType: {
  DNI: 'DNI',
  PASSPORT: 'PASSPORT',
  NIE: 'NIE',
  CIF: 'CIF',
  KVK: 'KVK',
  OTHER: 'OTHER'
};

export type IdentificationType = (typeof IdentificationType)[keyof typeof IdentificationType]


export const roleEnum: {
  SUPERADMIN: 'SUPERADMIN',
  ADMIN: 'ADMIN',
  DEBTOR: 'DEBTOR',
  BAILIFF: 'BAILIFF'
};

export type roleEnum = (typeof roleEnum)[keyof typeof roleEnum]


export const PaymentMethod: {
  CASH: 'CASH',
  TRANSFER: 'TRANSFER',
  CREDIT_CARD: 'CREDIT_CARD',
  CHECK: 'CHECK',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const CollectionStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type CollectionStatus = (typeof CollectionStatus)[keyof typeof CollectionStatus]


export const PersonType: {
  INDIVIDUAL: 'INDIVIDUAL',
  COMPANY: 'COMPANY'
};

export type PersonType = (typeof PersonType)[keyof typeof PersonType]

}

export type InstallmentStatus = $Enums.InstallmentStatus

export const InstallmentStatus: typeof $Enums.InstallmentStatus

export type PaymentAgreementStatus = $Enums.PaymentAgreementStatus

export const PaymentAgreementStatus: typeof $Enums.PaymentAgreementStatus

export type CalculationTypeEnum = $Enums.CalculationTypeEnum

export const CalculationTypeEnum: typeof $Enums.CalculationTypeEnum

export type VerdictStatus = $Enums.VerdictStatus

export const VerdictStatus: typeof $Enums.VerdictStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type IdentificationType = $Enums.IdentificationType

export const IdentificationType: typeof $Enums.IdentificationType

export type roleEnum = $Enums.roleEnum

export const roleEnum: typeof $Enums.roleEnum

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type CollectionStatus = $Enums.CollectionStatus

export const CollectionStatus: typeof $Enums.CollectionStatus

export type PersonType = $Enums.PersonType

export const PersonType: typeof $Enums.PersonType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantRegistry`: Exposes CRUD operations for the **TenantRegistry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantRegistries
    * const tenantRegistries = await prisma.tenantRegistry.findMany()
    * ```
    */
  get tenantRegistry(): Prisma.TenantRegistryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parameter`: Exposes CRUD operations for the **Parameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parameters
    * const parameters = await prisma.parameter.findMany()
    * ```
    */
  get parameter(): Prisma.ParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdict`: Exposes CRUD operations for the **Verdict** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verdicts
    * const verdicts = await prisma.verdict.findMany()
    * ```
    */
  get verdict(): Prisma.VerdictDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictInterest`: Exposes CRUD operations for the **VerdictInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictInterests
    * const verdictInterests = await prisma.verdictInterest.findMany()
    * ```
    */
  get verdictInterest(): Prisma.VerdictInterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictInterestDetails`: Exposes CRUD operations for the **VerdictInterestDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictInterestDetails
    * const verdictInterestDetails = await prisma.verdictInterestDetails.findMany()
    * ```
    */
  get verdictInterestDetails(): Prisma.VerdictInterestDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictEmbargo`: Exposes CRUD operations for the **VerdictEmbargo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictEmbargos
    * const verdictEmbargos = await prisma.verdictEmbargo.findMany()
    * ```
    */
  get verdictEmbargo(): Prisma.VerdictEmbargoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictBailiffServices`: Exposes CRUD operations for the **VerdictBailiffServices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictBailiffServices
    * const verdictBailiffServices = await prisma.verdictBailiffServices.findMany()
    * ```
    */
  get verdictBailiffServices(): Prisma.VerdictBailiffServicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictAttachment`: Exposes CRUD operations for the **VerdictAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictAttachments
    * const verdictAttachments = await prisma.verdictAttachment.findMany()
    * ```
    */
  get verdictAttachment(): Prisma.VerdictAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interestType`: Exposes CRUD operations for the **InterestType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterestTypes
    * const interestTypes = await prisma.interestType.findMany()
    * ```
    */
  get interestType(): Prisma.InterestTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interestDetail`: Exposes CRUD operations for the **InterestDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterestDetails
    * const interestDetails = await prisma.interestDetail.findMany()
    * ```
    */
  get interestDetail(): Prisma.InterestDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingInvoice`: Exposes CRUD operations for the **BillingInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingInvoices
    * const billingInvoices = await prisma.billingInvoice.findMany()
    * ```
    */
  get billingInvoice(): Prisma.BillingInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingInvoiceDetail`: Exposes CRUD operations for the **BillingInvoiceDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingInvoiceDetails
    * const billingInvoiceDetails = await prisma.billingInvoiceDetail.findMany()
    * ```
    */
  get billingInvoiceDetail(): Prisma.BillingInvoiceDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingPayment`: Exposes CRUD operations for the **BillingPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingPayments
    * const billingPayments = await prisma.billingPayment.findMany()
    * ```
    */
  get billingPayment(): Prisma.BillingPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionCase`: Exposes CRUD operations for the **CollectionCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionCases
    * const collectionCases = await prisma.collectionCase.findMany()
    * ```
    */
  get collectionCase(): Prisma.CollectionCaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.penalty`: Exposes CRUD operations for the **Penalty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Penalties
    * const penalties = await prisma.penalty.findMany()
    * ```
    */
  get penalty(): Prisma.PenaltyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debtor`: Exposes CRUD operations for the **Debtor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Debtors
    * const debtors = await prisma.debtor.findMany()
    * ```
    */
  get debtor(): Prisma.DebtorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatRoom`: Exposes CRUD operations for the **ChatRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatRooms
    * const chatRooms = await prisma.chatRoom.findMany()
    * ```
    */
  get chatRoom(): Prisma.ChatRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debtorIncome`: Exposes CRUD operations for the **DebtorIncome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DebtorIncomes
    * const debtorIncomes = await prisma.debtorIncome.findMany()
    * ```
    */
  get debtorIncome(): Prisma.DebtorIncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentAgreement`: Exposes CRUD operations for the **PaymentAgreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentAgreements
    * const paymentAgreements = await prisma.paymentAgreement.findMany()
    * ```
    */
  get paymentAgreement(): Prisma.PaymentAgreementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.installment`: Exposes CRUD operations for the **Installment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Installments
    * const installments = await prisma.installment.findMany()
    * ```
    */
  get installment(): Prisma.InstallmentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    TenantRegistry: 'TenantRegistry',
    User: 'User',
    Parameter: 'Parameter',
    Verdict: 'Verdict',
    VerdictInterest: 'VerdictInterest',
    VerdictInterestDetails: 'VerdictInterestDetails',
    VerdictEmbargo: 'VerdictEmbargo',
    VerdictBailiffServices: 'VerdictBailiffServices',
    VerdictAttachment: 'VerdictAttachment',
    InterestType: 'InterestType',
    InterestDetail: 'InterestDetail',
    BillingInvoice: 'BillingInvoice',
    BillingInvoiceDetail: 'BillingInvoiceDetail',
    BillingPayment: 'BillingPayment',
    Plan: 'Plan',
    CollectionCase: 'CollectionCase',
    Penalty: 'Penalty',
    Notification: 'Notification',
    Payment: 'Payment',
    Debtor: 'Debtor',
    ChatRoom: 'ChatRoom',
    ChatMessage: 'ChatMessage',
    DebtorIncome: 'DebtorIncome',
    PaymentAgreement: 'PaymentAgreement',
    Installment: 'Installment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "tenantRegistry" | "user" | "parameter" | "verdict" | "verdictInterest" | "verdictInterestDetails" | "verdictEmbargo" | "verdictBailiffServices" | "verdictAttachment" | "interestType" | "interestDetail" | "billingInvoice" | "billingInvoiceDetail" | "billingPayment" | "plan" | "collectionCase" | "penalty" | "notification" | "payment" | "debtor" | "chatRoom" | "chatMessage" | "debtorIncome" | "paymentAgreement" | "installment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      TenantRegistry: {
        payload: Prisma.$TenantRegistryPayload<ExtArgs>
        fields: Prisma.TenantRegistryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantRegistryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantRegistryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          findFirst: {
            args: Prisma.TenantRegistryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantRegistryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          findMany: {
            args: Prisma.TenantRegistryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>[]
          }
          create: {
            args: Prisma.TenantRegistryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          createMany: {
            args: Prisma.TenantRegistryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantRegistryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>[]
          }
          delete: {
            args: Prisma.TenantRegistryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          update: {
            args: Prisma.TenantRegistryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          deleteMany: {
            args: Prisma.TenantRegistryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantRegistryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantRegistryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>[]
          }
          upsert: {
            args: Prisma.TenantRegistryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantRegistryPayload>
          }
          aggregate: {
            args: Prisma.TenantRegistryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantRegistry>
          }
          groupBy: {
            args: Prisma.TenantRegistryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantRegistryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantRegistryCountArgs<ExtArgs>
            result: $Utils.Optional<TenantRegistryCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Parameter: {
        payload: Prisma.$ParameterPayload<ExtArgs>
        fields: Prisma.ParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          findFirst: {
            args: Prisma.ParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          findMany: {
            args: Prisma.ParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>[]
          }
          create: {
            args: Prisma.ParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          createMany: {
            args: Prisma.ParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>[]
          }
          delete: {
            args: Prisma.ParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          update: {
            args: Prisma.ParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          deleteMany: {
            args: Prisma.ParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>[]
          }
          upsert: {
            args: Prisma.ParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          aggregate: {
            args: Prisma.ParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParameter>
          }
          groupBy: {
            args: Prisma.ParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParameterCountArgs<ExtArgs>
            result: $Utils.Optional<ParameterCountAggregateOutputType> | number
          }
        }
      }
      Verdict: {
        payload: Prisma.$VerdictPayload<ExtArgs>
        fields: Prisma.VerdictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          findFirst: {
            args: Prisma.VerdictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          findMany: {
            args: Prisma.VerdictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          create: {
            args: Prisma.VerdictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          createMany: {
            args: Prisma.VerdictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          delete: {
            args: Prisma.VerdictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          update: {
            args: Prisma.VerdictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          deleteMany: {
            args: Prisma.VerdictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          upsert: {
            args: Prisma.VerdictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          aggregate: {
            args: Prisma.VerdictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdict>
          }
          groupBy: {
            args: Prisma.VerdictGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictCountAggregateOutputType> | number
          }
        }
      }
      VerdictInterest: {
        payload: Prisma.$VerdictInterestPayload<ExtArgs>
        fields: Prisma.VerdictInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          findFirst: {
            args: Prisma.VerdictInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          findMany: {
            args: Prisma.VerdictInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>[]
          }
          create: {
            args: Prisma.VerdictInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          createMany: {
            args: Prisma.VerdictInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>[]
          }
          delete: {
            args: Prisma.VerdictInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          update: {
            args: Prisma.VerdictInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          deleteMany: {
            args: Prisma.VerdictInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictInterestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>[]
          }
          upsert: {
            args: Prisma.VerdictInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          aggregate: {
            args: Prisma.VerdictInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictInterest>
          }
          groupBy: {
            args: Prisma.VerdictInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictInterestCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestCountAggregateOutputType> | number
          }
        }
      }
      VerdictInterestDetails: {
        payload: Prisma.$VerdictInterestDetailsPayload<ExtArgs>
        fields: Prisma.VerdictInterestDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictInterestDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictInterestDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          findFirst: {
            args: Prisma.VerdictInterestDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictInterestDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          findMany: {
            args: Prisma.VerdictInterestDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>[]
          }
          create: {
            args: Prisma.VerdictInterestDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          createMany: {
            args: Prisma.VerdictInterestDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictInterestDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>[]
          }
          delete: {
            args: Prisma.VerdictInterestDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          update: {
            args: Prisma.VerdictInterestDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          deleteMany: {
            args: Prisma.VerdictInterestDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictInterestDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictInterestDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>[]
          }
          upsert: {
            args: Prisma.VerdictInterestDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          aggregate: {
            args: Prisma.VerdictInterestDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictInterestDetails>
          }
          groupBy: {
            args: Prisma.VerdictInterestDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictInterestDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestDetailsCountAggregateOutputType> | number
          }
        }
      }
      VerdictEmbargo: {
        payload: Prisma.$VerdictEmbargoPayload<ExtArgs>
        fields: Prisma.VerdictEmbargoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictEmbargoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictEmbargoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          findFirst: {
            args: Prisma.VerdictEmbargoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictEmbargoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          findMany: {
            args: Prisma.VerdictEmbargoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>[]
          }
          create: {
            args: Prisma.VerdictEmbargoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          createMany: {
            args: Prisma.VerdictEmbargoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictEmbargoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>[]
          }
          delete: {
            args: Prisma.VerdictEmbargoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          update: {
            args: Prisma.VerdictEmbargoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          deleteMany: {
            args: Prisma.VerdictEmbargoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictEmbargoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictEmbargoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>[]
          }
          upsert: {
            args: Prisma.VerdictEmbargoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          aggregate: {
            args: Prisma.VerdictEmbargoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictEmbargo>
          }
          groupBy: {
            args: Prisma.VerdictEmbargoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictEmbargoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictEmbargoCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictEmbargoCountAggregateOutputType> | number
          }
        }
      }
      VerdictBailiffServices: {
        payload: Prisma.$VerdictBailiffServicesPayload<ExtArgs>
        fields: Prisma.VerdictBailiffServicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictBailiffServicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictBailiffServicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          findFirst: {
            args: Prisma.VerdictBailiffServicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictBailiffServicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          findMany: {
            args: Prisma.VerdictBailiffServicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>[]
          }
          create: {
            args: Prisma.VerdictBailiffServicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          createMany: {
            args: Prisma.VerdictBailiffServicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictBailiffServicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>[]
          }
          delete: {
            args: Prisma.VerdictBailiffServicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          update: {
            args: Prisma.VerdictBailiffServicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          deleteMany: {
            args: Prisma.VerdictBailiffServicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictBailiffServicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictBailiffServicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>[]
          }
          upsert: {
            args: Prisma.VerdictBailiffServicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          aggregate: {
            args: Prisma.VerdictBailiffServicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictBailiffServices>
          }
          groupBy: {
            args: Prisma.VerdictBailiffServicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictBailiffServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictBailiffServicesCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictBailiffServicesCountAggregateOutputType> | number
          }
        }
      }
      VerdictAttachment: {
        payload: Prisma.$VerdictAttachmentPayload<ExtArgs>
        fields: Prisma.VerdictAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          findFirst: {
            args: Prisma.VerdictAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          findMany: {
            args: Prisma.VerdictAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>[]
          }
          create: {
            args: Prisma.VerdictAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          createMany: {
            args: Prisma.VerdictAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>[]
          }
          delete: {
            args: Prisma.VerdictAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          update: {
            args: Prisma.VerdictAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.VerdictAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.VerdictAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          aggregate: {
            args: Prisma.VerdictAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictAttachment>
          }
          groupBy: {
            args: Prisma.VerdictAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictAttachmentCountAggregateOutputType> | number
          }
        }
      }
      InterestType: {
        payload: Prisma.$InterestTypePayload<ExtArgs>
        fields: Prisma.InterestTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          findFirst: {
            args: Prisma.InterestTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          findMany: {
            args: Prisma.InterestTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>[]
          }
          create: {
            args: Prisma.InterestTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          createMany: {
            args: Prisma.InterestTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>[]
          }
          delete: {
            args: Prisma.InterestTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          update: {
            args: Prisma.InterestTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          deleteMany: {
            args: Prisma.InterestTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterestTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>[]
          }
          upsert: {
            args: Prisma.InterestTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          aggregate: {
            args: Prisma.InterestTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterestType>
          }
          groupBy: {
            args: Prisma.InterestTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestTypeCountArgs<ExtArgs>
            result: $Utils.Optional<InterestTypeCountAggregateOutputType> | number
          }
        }
      }
      InterestDetail: {
        payload: Prisma.$InterestDetailPayload<ExtArgs>
        fields: Prisma.InterestDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          findFirst: {
            args: Prisma.InterestDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          findMany: {
            args: Prisma.InterestDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>[]
          }
          create: {
            args: Prisma.InterestDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          createMany: {
            args: Prisma.InterestDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>[]
          }
          delete: {
            args: Prisma.InterestDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          update: {
            args: Prisma.InterestDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          deleteMany: {
            args: Prisma.InterestDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterestDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>[]
          }
          upsert: {
            args: Prisma.InterestDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          aggregate: {
            args: Prisma.InterestDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterestDetail>
          }
          groupBy: {
            args: Prisma.InterestDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestDetailCountArgs<ExtArgs>
            result: $Utils.Optional<InterestDetailCountAggregateOutputType> | number
          }
        }
      }
      BillingInvoice: {
        payload: Prisma.$BillingInvoicePayload<ExtArgs>
        fields: Prisma.BillingInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          findFirst: {
            args: Prisma.BillingInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          findMany: {
            args: Prisma.BillingInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>[]
          }
          create: {
            args: Prisma.BillingInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          createMany: {
            args: Prisma.BillingInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>[]
          }
          delete: {
            args: Prisma.BillingInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          update: {
            args: Prisma.BillingInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          deleteMany: {
            args: Prisma.BillingInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>[]
          }
          upsert: {
            args: Prisma.BillingInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          aggregate: {
            args: Prisma.BillingInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingInvoice>
          }
          groupBy: {
            args: Prisma.BillingInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceCountAggregateOutputType> | number
          }
        }
      }
      BillingInvoiceDetail: {
        payload: Prisma.$BillingInvoiceDetailPayload<ExtArgs>
        fields: Prisma.BillingInvoiceDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingInvoiceDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingInvoiceDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          findFirst: {
            args: Prisma.BillingInvoiceDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingInvoiceDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          findMany: {
            args: Prisma.BillingInvoiceDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>[]
          }
          create: {
            args: Prisma.BillingInvoiceDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          createMany: {
            args: Prisma.BillingInvoiceDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingInvoiceDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>[]
          }
          delete: {
            args: Prisma.BillingInvoiceDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          update: {
            args: Prisma.BillingInvoiceDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          deleteMany: {
            args: Prisma.BillingInvoiceDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingInvoiceDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingInvoiceDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>[]
          }
          upsert: {
            args: Prisma.BillingInvoiceDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          aggregate: {
            args: Prisma.BillingInvoiceDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingInvoiceDetail>
          }
          groupBy: {
            args: Prisma.BillingInvoiceDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingInvoiceDetailCountArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceDetailCountAggregateOutputType> | number
          }
        }
      }
      BillingPayment: {
        payload: Prisma.$BillingPaymentPayload<ExtArgs>
        fields: Prisma.BillingPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          findFirst: {
            args: Prisma.BillingPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          findMany: {
            args: Prisma.BillingPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>[]
          }
          create: {
            args: Prisma.BillingPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          createMany: {
            args: Prisma.BillingPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>[]
          }
          delete: {
            args: Prisma.BillingPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          update: {
            args: Prisma.BillingPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          deleteMany: {
            args: Prisma.BillingPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>[]
          }
          upsert: {
            args: Prisma.BillingPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          aggregate: {
            args: Prisma.BillingPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingPayment>
          }
          groupBy: {
            args: Prisma.BillingPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<BillingPaymentCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      CollectionCase: {
        payload: Prisma.$CollectionCasePayload<ExtArgs>
        fields: Prisma.CollectionCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          findFirst: {
            args: Prisma.CollectionCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          findMany: {
            args: Prisma.CollectionCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>[]
          }
          create: {
            args: Prisma.CollectionCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          createMany: {
            args: Prisma.CollectionCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>[]
          }
          delete: {
            args: Prisma.CollectionCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          update: {
            args: Prisma.CollectionCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          deleteMany: {
            args: Prisma.CollectionCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionCaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>[]
          }
          upsert: {
            args: Prisma.CollectionCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          aggregate: {
            args: Prisma.CollectionCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionCase>
          }
          groupBy: {
            args: Prisma.CollectionCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCaseCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseCountAggregateOutputType> | number
          }
        }
      }
      Penalty: {
        payload: Prisma.$PenaltyPayload<ExtArgs>
        fields: Prisma.PenaltyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PenaltyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PenaltyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          findFirst: {
            args: Prisma.PenaltyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PenaltyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          findMany: {
            args: Prisma.PenaltyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>[]
          }
          create: {
            args: Prisma.PenaltyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          createMany: {
            args: Prisma.PenaltyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PenaltyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>[]
          }
          delete: {
            args: Prisma.PenaltyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          update: {
            args: Prisma.PenaltyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          deleteMany: {
            args: Prisma.PenaltyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PenaltyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PenaltyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>[]
          }
          upsert: {
            args: Prisma.PenaltyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          aggregate: {
            args: Prisma.PenaltyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePenalty>
          }
          groupBy: {
            args: Prisma.PenaltyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PenaltyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PenaltyCountArgs<ExtArgs>
            result: $Utils.Optional<PenaltyCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Debtor: {
        payload: Prisma.$DebtorPayload<ExtArgs>
        fields: Prisma.DebtorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          findFirst: {
            args: Prisma.DebtorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          findMany: {
            args: Prisma.DebtorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>[]
          }
          create: {
            args: Prisma.DebtorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          createMany: {
            args: Prisma.DebtorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DebtorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>[]
          }
          delete: {
            args: Prisma.DebtorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          update: {
            args: Prisma.DebtorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          deleteMany: {
            args: Prisma.DebtorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DebtorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>[]
          }
          upsert: {
            args: Prisma.DebtorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          aggregate: {
            args: Prisma.DebtorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebtor>
          }
          groupBy: {
            args: Prisma.DebtorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DebtorCountArgs<ExtArgs>
            result: $Utils.Optional<DebtorCountAggregateOutputType> | number
          }
        }
      }
      ChatRoom: {
        payload: Prisma.$ChatRoomPayload<ExtArgs>
        fields: Prisma.ChatRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          findFirst: {
            args: Prisma.ChatRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          findMany: {
            args: Prisma.ChatRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>[]
          }
          create: {
            args: Prisma.ChatRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          createMany: {
            args: Prisma.ChatRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>[]
          }
          delete: {
            args: Prisma.ChatRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          update: {
            args: Prisma.ChatRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          deleteMany: {
            args: Prisma.ChatRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatRoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>[]
          }
          upsert: {
            args: Prisma.ChatRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          aggregate: {
            args: Prisma.ChatRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatRoom>
          }
          groupBy: {
            args: Prisma.ChatRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatRoomCountArgs<ExtArgs>
            result: $Utils.Optional<ChatRoomCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      DebtorIncome: {
        payload: Prisma.$DebtorIncomePayload<ExtArgs>
        fields: Prisma.DebtorIncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtorIncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtorIncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          findFirst: {
            args: Prisma.DebtorIncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtorIncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          findMany: {
            args: Prisma.DebtorIncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>[]
          }
          create: {
            args: Prisma.DebtorIncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          createMany: {
            args: Prisma.DebtorIncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DebtorIncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>[]
          }
          delete: {
            args: Prisma.DebtorIncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          update: {
            args: Prisma.DebtorIncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          deleteMany: {
            args: Prisma.DebtorIncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtorIncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DebtorIncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>[]
          }
          upsert: {
            args: Prisma.DebtorIncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          aggregate: {
            args: Prisma.DebtorIncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebtorIncome>
          }
          groupBy: {
            args: Prisma.DebtorIncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtorIncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DebtorIncomeCountArgs<ExtArgs>
            result: $Utils.Optional<DebtorIncomeCountAggregateOutputType> | number
          }
        }
      }
      PaymentAgreement: {
        payload: Prisma.$PaymentAgreementPayload<ExtArgs>
        fields: Prisma.PaymentAgreementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentAgreementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentAgreementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          findFirst: {
            args: Prisma.PaymentAgreementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentAgreementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          findMany: {
            args: Prisma.PaymentAgreementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>[]
          }
          create: {
            args: Prisma.PaymentAgreementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          createMany: {
            args: Prisma.PaymentAgreementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentAgreementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>[]
          }
          delete: {
            args: Prisma.PaymentAgreementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          update: {
            args: Prisma.PaymentAgreementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          deleteMany: {
            args: Prisma.PaymentAgreementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentAgreementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentAgreementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>[]
          }
          upsert: {
            args: Prisma.PaymentAgreementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentAgreementPayload>
          }
          aggregate: {
            args: Prisma.PaymentAgreementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentAgreement>
          }
          groupBy: {
            args: Prisma.PaymentAgreementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentAgreementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentAgreementCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentAgreementCountAggregateOutputType> | number
          }
        }
      }
      Installment: {
        payload: Prisma.$InstallmentPayload<ExtArgs>
        fields: Prisma.InstallmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstallmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstallmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          findFirst: {
            args: Prisma.InstallmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstallmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          findMany: {
            args: Prisma.InstallmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>[]
          }
          create: {
            args: Prisma.InstallmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          createMany: {
            args: Prisma.InstallmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstallmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>[]
          }
          delete: {
            args: Prisma.InstallmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          update: {
            args: Prisma.InstallmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          deleteMany: {
            args: Prisma.InstallmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstallmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstallmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>[]
          }
          upsert: {
            args: Prisma.InstallmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          aggregate: {
            args: Prisma.InstallmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstallment>
          }
          groupBy: {
            args: Prisma.InstallmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstallmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstallmentCountArgs<ExtArgs>
            result: $Utils.Optional<InstallmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    tenantRegistry?: TenantRegistryOmit
    user?: UserOmit
    parameter?: ParameterOmit
    verdict?: VerdictOmit
    verdictInterest?: VerdictInterestOmit
    verdictInterestDetails?: VerdictInterestDetailsOmit
    verdictEmbargo?: VerdictEmbargoOmit
    verdictBailiffServices?: VerdictBailiffServicesOmit
    verdictAttachment?: VerdictAttachmentOmit
    interestType?: InterestTypeOmit
    interestDetail?: InterestDetailOmit
    billingInvoice?: BillingInvoiceOmit
    billingInvoiceDetail?: BillingInvoiceDetailOmit
    billingPayment?: BillingPaymentOmit
    plan?: PlanOmit
    collectionCase?: CollectionCaseOmit
    penalty?: PenaltyOmit
    notification?: NotificationOmit
    payment?: PaymentOmit
    debtor?: DebtorOmit
    chatRoom?: ChatRoomOmit
    chatMessage?: ChatMessageOmit
    debtorIncome?: DebtorIncomeOmit
    paymentAgreement?: PaymentAgreementOmit
    installment?: InstallmentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    billingInvoice: number
    collectionCases: number
    debtors: number
    verdicts: number
    users: number
    chatRooms: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingInvoice?: boolean | TenantCountOutputTypeCountBillingInvoiceArgs
    collectionCases?: boolean | TenantCountOutputTypeCountCollectionCasesArgs
    debtors?: boolean | TenantCountOutputTypeCountDebtorsArgs
    verdicts?: boolean | TenantCountOutputTypeCountVerdictsArgs
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    chatRooms?: boolean | TenantCountOutputTypeCountChatRoomsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBillingInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCollectionCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDebtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVerdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountChatRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatRoomWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    debtors: number
    verdictBailiffs: number
    messages: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtors?: boolean | UserCountOutputTypeCountDebtorsArgs
    verdictBailiffs?: boolean | UserCountOutputTypeCountVerdictBailiffsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDebtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerdictBailiffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type VerdictCountOutputType
   */

  export type VerdictCountOutputType = {
    attachments: number
    bailiffServices: number
    verdictEmbargo: number
    verdictInterest: number
  }

  export type VerdictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | VerdictCountOutputTypeCountAttachmentsArgs
    bailiffServices?: boolean | VerdictCountOutputTypeCountBailiffServicesArgs
    verdictEmbargo?: boolean | VerdictCountOutputTypeCountVerdictEmbargoArgs
    verdictInterest?: boolean | VerdictCountOutputTypeCountVerdictInterestArgs
  }

  // Custom InputTypes
  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictCountOutputType
     */
    select?: VerdictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictAttachmentWhereInput
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountBailiffServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictBailiffServicesWhereInput
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountVerdictEmbargoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictEmbargoWhereInput
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountVerdictInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestWhereInput
  }


  /**
   * Count Type VerdictInterestCountOutputType
   */

  export type VerdictInterestCountOutputType = {
    details: number
  }

  export type VerdictInterestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | VerdictInterestCountOutputTypeCountDetailsArgs
  }

  // Custom InputTypes
  /**
   * VerdictInterestCountOutputType without action
   */
  export type VerdictInterestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestCountOutputType
     */
    select?: VerdictInterestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VerdictInterestCountOutputType without action
   */
  export type VerdictInterestCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestDetailsWhereInput
  }


  /**
   * Count Type InterestTypeCountOutputType
   */

  export type InterestTypeCountOutputType = {
    details: number
  }

  export type InterestTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | InterestTypeCountOutputTypeCountDetailsArgs
  }

  // Custom InputTypes
  /**
   * InterestTypeCountOutputType without action
   */
  export type InterestTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestTypeCountOutputType
     */
    select?: InterestTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterestTypeCountOutputType without action
   */
  export type InterestTypeCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestDetailWhereInput
  }


  /**
   * Count Type BillingInvoiceCountOutputType
   */

  export type BillingInvoiceCountOutputType = {
    details: number
    payments: number
  }

  export type BillingInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | BillingInvoiceCountOutputTypeCountDetailsArgs
    payments?: boolean | BillingInvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * BillingInvoiceCountOutputType without action
   */
  export type BillingInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceCountOutputType
     */
    select?: BillingInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillingInvoiceCountOutputType without action
   */
  export type BillingInvoiceCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceDetailWhereInput
  }

  /**
   * BillingInvoiceCountOutputType without action
   */
  export type BillingInvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingPaymentWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    tenants: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenants?: boolean | PlanCountOutputTypeCountTenantsArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountTenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
  }


  /**
   * Count Type CollectionCaseCountOutputType
   */

  export type CollectionCaseCountOutputType = {
    notifications: number
    payments: number
    paymentAgreements: number
    penalties: number
    chatRooms: number
  }

  export type CollectionCaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | CollectionCaseCountOutputTypeCountNotificationsArgs
    payments?: boolean | CollectionCaseCountOutputTypeCountPaymentsArgs
    paymentAgreements?: boolean | CollectionCaseCountOutputTypeCountPaymentAgreementsArgs
    penalties?: boolean | CollectionCaseCountOutputTypeCountPenaltiesArgs
    chatRooms?: boolean | CollectionCaseCountOutputTypeCountChatRoomsArgs
  }

  // Custom InputTypes
  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseCountOutputType
     */
    select?: CollectionCaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountPaymentAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAgreementWhereInput
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountPenaltiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PenaltyWhereInput
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountChatRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatRoomWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    Installment: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Installment?: boolean | PaymentCountOutputTypeCountInstallmentArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountInstallmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentWhereInput
  }


  /**
   * Count Type DebtorCountOutputType
   */

  export type DebtorCountOutputType = {
    collectionCases: number
    incomes: number
    paymentAgreements: number
    verdicts: number
  }

  export type DebtorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCases?: boolean | DebtorCountOutputTypeCountCollectionCasesArgs
    incomes?: boolean | DebtorCountOutputTypeCountIncomesArgs
    paymentAgreements?: boolean | DebtorCountOutputTypeCountPaymentAgreementsArgs
    verdicts?: boolean | DebtorCountOutputTypeCountVerdictsArgs
  }

  // Custom InputTypes
  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorCountOutputType
     */
    select?: DebtorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountCollectionCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseWhereInput
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountIncomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorIncomeWhereInput
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountPaymentAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAgreementWhereInput
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountVerdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
  }


  /**
   * Count Type ChatRoomCountOutputType
   */

  export type ChatRoomCountOutputType = {
    messages: number
  }

  export type ChatRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatRoomCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatRoomCountOutputType without action
   */
  export type ChatRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoomCountOutputType
     */
    select?: ChatRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatRoomCountOutputType without action
   */
  export type ChatRoomCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type PaymentAgreementCountOutputType
   */

  export type PaymentAgreementCountOutputType = {
    installments: number
    payments: number
  }

  export type PaymentAgreementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installments?: boolean | PaymentAgreementCountOutputTypeCountInstallmentsArgs
    payments?: boolean | PaymentAgreementCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PaymentAgreementCountOutputType without action
   */
  export type PaymentAgreementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreementCountOutputType
     */
    select?: PaymentAgreementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentAgreementCountOutputType without action
   */
  export type PaymentAgreementCountOutputTypeCountInstallmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentWhereInput
  }

  /**
   * PaymentAgreementCountOutputType without action
   */
  export type PaymentAgreementCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    numberOfEmployees: number | null
  }

  export type TenantSumAggregateOutputType = {
    numberOfEmployees: number | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    contactEmail: string | null
    countryCode: string | null
    address: string | null
    city: string | null
    logoUrl: string | null
    numberOfEmployees: number | null
    phone: string | null
    website: string | null
    planId: string | null
    planStatus: string | null
    planExpiresAt: Date | null
    termsAccepted: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    contactEmail: string | null
    countryCode: string | null
    address: string | null
    city: string | null
    logoUrl: string | null
    numberOfEmployees: number | null
    phone: string | null
    website: string | null
    planId: string | null
    planStatus: string | null
    planExpiresAt: Date | null
    termsAccepted: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    subdomain: number
    contactEmail: number
    countryCode: number
    address: number
    city: number
    logoUrl: number
    numberOfEmployees: number
    phone: number
    website: number
    planId: number
    planStatus: number
    planExpiresAt: number
    termsAccepted: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    numberOfEmployees?: true
  }

  export type TenantSumAggregateInputType = {
    numberOfEmployees?: true
  }

  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    contactEmail?: true
    countryCode?: true
    address?: true
    city?: true
    logoUrl?: true
    numberOfEmployees?: true
    phone?: true
    website?: true
    planId?: true
    planStatus?: true
    planExpiresAt?: true
    termsAccepted?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    contactEmail?: true
    countryCode?: true
    address?: true
    city?: true
    logoUrl?: true
    numberOfEmployees?: true
    phone?: true
    website?: true
    planId?: true
    planStatus?: true
    planExpiresAt?: true
    termsAccepted?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    contactEmail?: true
    countryCode?: true
    address?: true
    city?: true
    logoUrl?: true
    numberOfEmployees?: true
    phone?: true
    website?: true
    planId?: true
    planStatus?: true
    planExpiresAt?: true
    termsAccepted?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address: string | null
    city: string | null
    logoUrl: string | null
    numberOfEmployees: number | null
    phone: string | null
    website: string | null
    planId: string | null
    planStatus: string
    planExpiresAt: Date | null
    termsAccepted: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    contactEmail?: boolean
    countryCode?: boolean
    address?: boolean
    city?: boolean
    logoUrl?: boolean
    numberOfEmployees?: boolean
    phone?: boolean
    website?: boolean
    planId?: boolean
    planStatus?: boolean
    planExpiresAt?: boolean
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | Tenant$planArgs<ExtArgs>
    billingInvoice?: boolean | Tenant$billingInvoiceArgs<ExtArgs>
    collectionCases?: boolean | Tenant$collectionCasesArgs<ExtArgs>
    debtors?: boolean | Tenant$debtorsArgs<ExtArgs>
    registry?: boolean | Tenant$registryArgs<ExtArgs>
    verdicts?: boolean | Tenant$verdictsArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    chatRooms?: boolean | Tenant$chatRoomsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    contactEmail?: boolean
    countryCode?: boolean
    address?: boolean
    city?: boolean
    logoUrl?: boolean
    numberOfEmployees?: boolean
    phone?: boolean
    website?: boolean
    planId?: boolean
    planStatus?: boolean
    planExpiresAt?: boolean
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | Tenant$planArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    contactEmail?: boolean
    countryCode?: boolean
    address?: boolean
    city?: boolean
    logoUrl?: boolean
    numberOfEmployees?: boolean
    phone?: boolean
    website?: boolean
    planId?: boolean
    planStatus?: boolean
    planExpiresAt?: boolean
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | Tenant$planArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    subdomain?: boolean
    contactEmail?: boolean
    countryCode?: boolean
    address?: boolean
    city?: boolean
    logoUrl?: boolean
    numberOfEmployees?: boolean
    phone?: boolean
    website?: boolean
    planId?: boolean
    planStatus?: boolean
    planExpiresAt?: boolean
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subdomain" | "contactEmail" | "countryCode" | "address" | "city" | "logoUrl" | "numberOfEmployees" | "phone" | "website" | "planId" | "planStatus" | "planExpiresAt" | "termsAccepted" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | Tenant$planArgs<ExtArgs>
    billingInvoice?: boolean | Tenant$billingInvoiceArgs<ExtArgs>
    collectionCases?: boolean | Tenant$collectionCasesArgs<ExtArgs>
    debtors?: boolean | Tenant$debtorsArgs<ExtArgs>
    registry?: boolean | Tenant$registryArgs<ExtArgs>
    verdicts?: boolean | Tenant$verdictsArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    chatRooms?: boolean | Tenant$chatRoomsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | Tenant$planArgs<ExtArgs>
  }
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | Tenant$planArgs<ExtArgs>
  }

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs> | null
      billingInvoice: Prisma.$BillingInvoicePayload<ExtArgs>[]
      collectionCases: Prisma.$CollectionCasePayload<ExtArgs>[]
      debtors: Prisma.$DebtorPayload<ExtArgs>[]
      registry: Prisma.$TenantRegistryPayload<ExtArgs> | null
      verdicts: Prisma.$VerdictPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      chatRooms: Prisma.$ChatRoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subdomain: string
      contactEmail: string
      countryCode: string
      address: string | null
      city: string | null
      logoUrl: string | null
      numberOfEmployees: number | null
      phone: string | null
      website: string | null
      planId: string | null
      planStatus: string
      planExpiresAt: Date | null
      termsAccepted: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends Tenant$planArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$planArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    billingInvoice<T extends Tenant$billingInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$billingInvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collectionCases<T extends Tenant$collectionCasesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$collectionCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    debtors<T extends Tenant$debtorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$debtorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registry<T extends Tenant$registryArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$registryArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    verdicts<T extends Tenant$verdictsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$verdictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatRooms<T extends Tenant$chatRoomsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$chatRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly subdomain: FieldRef<"Tenant", 'String'>
    readonly contactEmail: FieldRef<"Tenant", 'String'>
    readonly countryCode: FieldRef<"Tenant", 'String'>
    readonly address: FieldRef<"Tenant", 'String'>
    readonly city: FieldRef<"Tenant", 'String'>
    readonly logoUrl: FieldRef<"Tenant", 'String'>
    readonly numberOfEmployees: FieldRef<"Tenant", 'Int'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly website: FieldRef<"Tenant", 'String'>
    readonly planId: FieldRef<"Tenant", 'String'>
    readonly planStatus: FieldRef<"Tenant", 'String'>
    readonly planExpiresAt: FieldRef<"Tenant", 'DateTime'>
    readonly termsAccepted: FieldRef<"Tenant", 'Boolean'>
    readonly isActive: FieldRef<"Tenant", 'Boolean'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.plan
   */
  export type Tenant$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
  }

  /**
   * Tenant.billingInvoice
   */
  export type Tenant$billingInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    where?: BillingInvoiceWhereInput
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    cursor?: BillingInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.collectionCases
   */
  export type Tenant$collectionCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    where?: CollectionCaseWhereInput
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    cursor?: CollectionCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * Tenant.debtors
   */
  export type Tenant$debtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    where?: DebtorWhereInput
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    cursor?: DebtorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Tenant.registry
   */
  export type Tenant$registryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    where?: TenantRegistryWhereInput
  }

  /**
   * Tenant.verdicts
   */
  export type Tenant$verdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    cursor?: VerdictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.chatRooms
   */
  export type Tenant$chatRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    where?: ChatRoomWhereInput
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    cursor?: ChatRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model TenantRegistry
   */

  export type AggregateTenantRegistry = {
    _count: TenantRegistryCountAggregateOutputType | null
    _min: TenantRegistryMinAggregateOutputType | null
    _max: TenantRegistryMaxAggregateOutputType | null
  }

  export type TenantRegistryMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    kvk: string | null
    crib: string | null
    taxId: string | null
    vatNumber: string | null
    legalName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantRegistryMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    kvk: string | null
    crib: string | null
    taxId: string | null
    vatNumber: string | null
    legalName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantRegistryCountAggregateOutputType = {
    id: number
    tenantId: number
    kvk: number
    crib: number
    taxId: number
    vatNumber: number
    legalName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantRegistryMinAggregateInputType = {
    id?: true
    tenantId?: true
    kvk?: true
    crib?: true
    taxId?: true
    vatNumber?: true
    legalName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantRegistryMaxAggregateInputType = {
    id?: true
    tenantId?: true
    kvk?: true
    crib?: true
    taxId?: true
    vatNumber?: true
    legalName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantRegistryCountAggregateInputType = {
    id?: true
    tenantId?: true
    kvk?: true
    crib?: true
    taxId?: true
    vatNumber?: true
    legalName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantRegistryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantRegistry to aggregate.
     */
    where?: TenantRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantRegistries to fetch.
     */
    orderBy?: TenantRegistryOrderByWithRelationInput | TenantRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantRegistries
    **/
    _count?: true | TenantRegistryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantRegistryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantRegistryMaxAggregateInputType
  }

  export type GetTenantRegistryAggregateType<T extends TenantRegistryAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantRegistry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantRegistry[P]>
      : GetScalarType<T[P], AggregateTenantRegistry[P]>
  }




  export type TenantRegistryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantRegistryWhereInput
    orderBy?: TenantRegistryOrderByWithAggregationInput | TenantRegistryOrderByWithAggregationInput[]
    by: TenantRegistryScalarFieldEnum[] | TenantRegistryScalarFieldEnum
    having?: TenantRegistryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantRegistryCountAggregateInputType | true
    _min?: TenantRegistryMinAggregateInputType
    _max?: TenantRegistryMaxAggregateInputType
  }

  export type TenantRegistryGroupByOutputType = {
    id: string
    tenantId: string
    kvk: string | null
    crib: string | null
    taxId: string | null
    vatNumber: string | null
    legalName: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantRegistryCountAggregateOutputType | null
    _min: TenantRegistryMinAggregateOutputType | null
    _max: TenantRegistryMaxAggregateOutputType | null
  }

  type GetTenantRegistryGroupByPayload<T extends TenantRegistryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantRegistryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantRegistryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantRegistryGroupByOutputType[P]>
            : GetScalarType<T[P], TenantRegistryGroupByOutputType[P]>
        }
      >
    >


  export type TenantRegistrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kvk?: boolean
    crib?: boolean
    taxId?: boolean
    vatNumber?: boolean
    legalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantRegistry"]>

  export type TenantRegistrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kvk?: boolean
    crib?: boolean
    taxId?: boolean
    vatNumber?: boolean
    legalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantRegistry"]>

  export type TenantRegistrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    kvk?: boolean
    crib?: boolean
    taxId?: boolean
    vatNumber?: boolean
    legalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantRegistry"]>

  export type TenantRegistrySelectScalar = {
    id?: boolean
    tenantId?: boolean
    kvk?: boolean
    crib?: boolean
    taxId?: boolean
    vatNumber?: boolean
    legalName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantRegistryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "kvk" | "crib" | "taxId" | "vatNumber" | "legalName" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantRegistry"]>
  export type TenantRegistryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantRegistryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantRegistryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantRegistryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantRegistry"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      kvk: string | null
      crib: string | null
      taxId: string | null
      vatNumber: string | null
      legalName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantRegistry"]>
    composites: {}
  }

  type TenantRegistryGetPayload<S extends boolean | null | undefined | TenantRegistryDefaultArgs> = $Result.GetResult<Prisma.$TenantRegistryPayload, S>

  type TenantRegistryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantRegistryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantRegistryCountAggregateInputType | true
    }

  export interface TenantRegistryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantRegistry'], meta: { name: 'TenantRegistry' } }
    /**
     * Find zero or one TenantRegistry that matches the filter.
     * @param {TenantRegistryFindUniqueArgs} args - Arguments to find a TenantRegistry
     * @example
     * // Get one TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantRegistryFindUniqueArgs>(args: SelectSubset<T, TenantRegistryFindUniqueArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantRegistry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantRegistryFindUniqueOrThrowArgs} args - Arguments to find a TenantRegistry
     * @example
     * // Get one TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantRegistryFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantRegistryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantRegistry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryFindFirstArgs} args - Arguments to find a TenantRegistry
     * @example
     * // Get one TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantRegistryFindFirstArgs>(args?: SelectSubset<T, TenantRegistryFindFirstArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantRegistry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryFindFirstOrThrowArgs} args - Arguments to find a TenantRegistry
     * @example
     * // Get one TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantRegistryFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantRegistryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantRegistries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantRegistries
     * const tenantRegistries = await prisma.tenantRegistry.findMany()
     * 
     * // Get first 10 TenantRegistries
     * const tenantRegistries = await prisma.tenantRegistry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantRegistryWithIdOnly = await prisma.tenantRegistry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantRegistryFindManyArgs>(args?: SelectSubset<T, TenantRegistryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantRegistry.
     * @param {TenantRegistryCreateArgs} args - Arguments to create a TenantRegistry.
     * @example
     * // Create one TenantRegistry
     * const TenantRegistry = await prisma.tenantRegistry.create({
     *   data: {
     *     // ... data to create a TenantRegistry
     *   }
     * })
     * 
     */
    create<T extends TenantRegistryCreateArgs>(args: SelectSubset<T, TenantRegistryCreateArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantRegistries.
     * @param {TenantRegistryCreateManyArgs} args - Arguments to create many TenantRegistries.
     * @example
     * // Create many TenantRegistries
     * const tenantRegistry = await prisma.tenantRegistry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantRegistryCreateManyArgs>(args?: SelectSubset<T, TenantRegistryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantRegistries and returns the data saved in the database.
     * @param {TenantRegistryCreateManyAndReturnArgs} args - Arguments to create many TenantRegistries.
     * @example
     * // Create many TenantRegistries
     * const tenantRegistry = await prisma.tenantRegistry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantRegistries and only return the `id`
     * const tenantRegistryWithIdOnly = await prisma.tenantRegistry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantRegistryCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantRegistryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantRegistry.
     * @param {TenantRegistryDeleteArgs} args - Arguments to delete one TenantRegistry.
     * @example
     * // Delete one TenantRegistry
     * const TenantRegistry = await prisma.tenantRegistry.delete({
     *   where: {
     *     // ... filter to delete one TenantRegistry
     *   }
     * })
     * 
     */
    delete<T extends TenantRegistryDeleteArgs>(args: SelectSubset<T, TenantRegistryDeleteArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantRegistry.
     * @param {TenantRegistryUpdateArgs} args - Arguments to update one TenantRegistry.
     * @example
     * // Update one TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantRegistryUpdateArgs>(args: SelectSubset<T, TenantRegistryUpdateArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantRegistries.
     * @param {TenantRegistryDeleteManyArgs} args - Arguments to filter TenantRegistries to delete.
     * @example
     * // Delete a few TenantRegistries
     * const { count } = await prisma.tenantRegistry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantRegistryDeleteManyArgs>(args?: SelectSubset<T, TenantRegistryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantRegistries
     * const tenantRegistry = await prisma.tenantRegistry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantRegistryUpdateManyArgs>(args: SelectSubset<T, TenantRegistryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantRegistries and returns the data updated in the database.
     * @param {TenantRegistryUpdateManyAndReturnArgs} args - Arguments to update many TenantRegistries.
     * @example
     * // Update many TenantRegistries
     * const tenantRegistry = await prisma.tenantRegistry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantRegistries and only return the `id`
     * const tenantRegistryWithIdOnly = await prisma.tenantRegistry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantRegistryUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantRegistryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantRegistry.
     * @param {TenantRegistryUpsertArgs} args - Arguments to update or create a TenantRegistry.
     * @example
     * // Update or create a TenantRegistry
     * const tenantRegistry = await prisma.tenantRegistry.upsert({
     *   create: {
     *     // ... data to create a TenantRegistry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantRegistry we want to update
     *   }
     * })
     */
    upsert<T extends TenantRegistryUpsertArgs>(args: SelectSubset<T, TenantRegistryUpsertArgs<ExtArgs>>): Prisma__TenantRegistryClient<$Result.GetResult<Prisma.$TenantRegistryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantRegistries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryCountArgs} args - Arguments to filter TenantRegistries to count.
     * @example
     * // Count the number of TenantRegistries
     * const count = await prisma.tenantRegistry.count({
     *   where: {
     *     // ... the filter for the TenantRegistries we want to count
     *   }
     * })
    **/
    count<T extends TenantRegistryCountArgs>(
      args?: Subset<T, TenantRegistryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantRegistryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantRegistryAggregateArgs>(args: Subset<T, TenantRegistryAggregateArgs>): Prisma.PrismaPromise<GetTenantRegistryAggregateType<T>>

    /**
     * Group by TenantRegistry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantRegistryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantRegistryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantRegistryGroupByArgs['orderBy'] }
        : { orderBy?: TenantRegistryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantRegistryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantRegistryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantRegistry model
   */
  readonly fields: TenantRegistryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantRegistry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantRegistryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantRegistry model
   */
  interface TenantRegistryFieldRefs {
    readonly id: FieldRef<"TenantRegistry", 'String'>
    readonly tenantId: FieldRef<"TenantRegistry", 'String'>
    readonly kvk: FieldRef<"TenantRegistry", 'String'>
    readonly crib: FieldRef<"TenantRegistry", 'String'>
    readonly taxId: FieldRef<"TenantRegistry", 'String'>
    readonly vatNumber: FieldRef<"TenantRegistry", 'String'>
    readonly legalName: FieldRef<"TenantRegistry", 'String'>
    readonly createdAt: FieldRef<"TenantRegistry", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantRegistry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantRegistry findUnique
   */
  export type TenantRegistryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter, which TenantRegistry to fetch.
     */
    where: TenantRegistryWhereUniqueInput
  }

  /**
   * TenantRegistry findUniqueOrThrow
   */
  export type TenantRegistryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter, which TenantRegistry to fetch.
     */
    where: TenantRegistryWhereUniqueInput
  }

  /**
   * TenantRegistry findFirst
   */
  export type TenantRegistryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter, which TenantRegistry to fetch.
     */
    where?: TenantRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantRegistries to fetch.
     */
    orderBy?: TenantRegistryOrderByWithRelationInput | TenantRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantRegistries.
     */
    cursor?: TenantRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantRegistries.
     */
    distinct?: TenantRegistryScalarFieldEnum | TenantRegistryScalarFieldEnum[]
  }

  /**
   * TenantRegistry findFirstOrThrow
   */
  export type TenantRegistryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter, which TenantRegistry to fetch.
     */
    where?: TenantRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantRegistries to fetch.
     */
    orderBy?: TenantRegistryOrderByWithRelationInput | TenantRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantRegistries.
     */
    cursor?: TenantRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantRegistries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantRegistries.
     */
    distinct?: TenantRegistryScalarFieldEnum | TenantRegistryScalarFieldEnum[]
  }

  /**
   * TenantRegistry findMany
   */
  export type TenantRegistryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter, which TenantRegistries to fetch.
     */
    where?: TenantRegistryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantRegistries to fetch.
     */
    orderBy?: TenantRegistryOrderByWithRelationInput | TenantRegistryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantRegistries.
     */
    cursor?: TenantRegistryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantRegistries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantRegistries.
     */
    skip?: number
    distinct?: TenantRegistryScalarFieldEnum | TenantRegistryScalarFieldEnum[]
  }

  /**
   * TenantRegistry create
   */
  export type TenantRegistryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantRegistry.
     */
    data: XOR<TenantRegistryCreateInput, TenantRegistryUncheckedCreateInput>
  }

  /**
   * TenantRegistry createMany
   */
  export type TenantRegistryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantRegistries.
     */
    data: TenantRegistryCreateManyInput | TenantRegistryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantRegistry createManyAndReturn
   */
  export type TenantRegistryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * The data used to create many TenantRegistries.
     */
    data: TenantRegistryCreateManyInput | TenantRegistryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantRegistry update
   */
  export type TenantRegistryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantRegistry.
     */
    data: XOR<TenantRegistryUpdateInput, TenantRegistryUncheckedUpdateInput>
    /**
     * Choose, which TenantRegistry to update.
     */
    where: TenantRegistryWhereUniqueInput
  }

  /**
   * TenantRegistry updateMany
   */
  export type TenantRegistryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantRegistries.
     */
    data: XOR<TenantRegistryUpdateManyMutationInput, TenantRegistryUncheckedUpdateManyInput>
    /**
     * Filter which TenantRegistries to update
     */
    where?: TenantRegistryWhereInput
    /**
     * Limit how many TenantRegistries to update.
     */
    limit?: number
  }

  /**
   * TenantRegistry updateManyAndReturn
   */
  export type TenantRegistryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * The data used to update TenantRegistries.
     */
    data: XOR<TenantRegistryUpdateManyMutationInput, TenantRegistryUncheckedUpdateManyInput>
    /**
     * Filter which TenantRegistries to update
     */
    where?: TenantRegistryWhereInput
    /**
     * Limit how many TenantRegistries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantRegistry upsert
   */
  export type TenantRegistryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantRegistry to update in case it exists.
     */
    where: TenantRegistryWhereUniqueInput
    /**
     * In case the TenantRegistry found by the `where` argument doesn't exist, create a new TenantRegistry with this data.
     */
    create: XOR<TenantRegistryCreateInput, TenantRegistryUncheckedCreateInput>
    /**
     * In case the TenantRegistry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantRegistryUpdateInput, TenantRegistryUncheckedUpdateInput>
  }

  /**
   * TenantRegistry delete
   */
  export type TenantRegistryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
    /**
     * Filter which TenantRegistry to delete.
     */
    where: TenantRegistryWhereUniqueInput
  }

  /**
   * TenantRegistry deleteMany
   */
  export type TenantRegistryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantRegistries to delete
     */
    where?: TenantRegistryWhereInput
    /**
     * Limit how many TenantRegistries to delete.
     */
    limit?: number
  }

  /**
   * TenantRegistry without action
   */
  export type TenantRegistryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantRegistry
     */
    select?: TenantRegistrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantRegistry
     */
    omit?: TenantRegistryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantRegistryInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullname: string | null
    phone: string | null
    tenantId: string | null
    role: $Enums.roleEnum | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullname: string | null
    phone: string | null
    tenantId: string | null
    role: $Enums.roleEnum | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    fullname: number
    phone: number
    tenantId: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullname?: true
    phone?: true
    tenantId?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullname?: true
    phone?: true
    tenantId?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullname?: true
    phone?: true
    tenantId?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    fullname: string | null
    phone: string | null
    tenantId: string
    role: $Enums.roleEnum
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullname?: boolean
    phone?: boolean
    tenantId?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    debtors?: boolean | User$debtorsArgs<ExtArgs>
    verdictBailiffs?: boolean | User$verdictBailiffsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullname?: boolean
    phone?: boolean
    tenantId?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullname?: boolean
    phone?: boolean
    tenantId?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullname?: boolean
    phone?: boolean
    tenantId?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "fullname" | "phone" | "tenantId" | "role" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    debtors?: boolean | User$debtorsArgs<ExtArgs>
    verdictBailiffs?: boolean | User$verdictBailiffsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      debtors: Prisma.$DebtorPayload<ExtArgs>[]
      verdictBailiffs: Prisma.$VerdictPayload<ExtArgs>[]
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      fullname: string | null
      phone: string | null
      tenantId: string
      role: $Enums.roleEnum
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    debtors<T extends User$debtorsArgs<ExtArgs> = {}>(args?: Subset<T, User$debtorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdictBailiffs<T extends User$verdictBailiffsArgs<ExtArgs> = {}>(args?: Subset<T, User$verdictBailiffsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly fullname: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'roleEnum'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.debtors
   */
  export type User$debtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    where?: DebtorWhereInput
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    cursor?: DebtorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * User.verdictBailiffs
   */
  export type User$verdictBailiffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    cursor?: VerdictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Parameter
   */

  export type AggregateParameter = {
    _count: ParameterCountAggregateOutputType | null
    _avg: ParameterAvgAggregateOutputType | null
    _sum: ParameterSumAggregateOutputType | null
    _min: ParameterMinAggregateOutputType | null
    _max: ParameterMaxAggregateOutputType | null
  }

  export type ParameterAvgAggregateOutputType = {
    porcCobranza: number | null
    porcAbb: number | null
    diasPlazoEmpresaAanmaning: number | null
    diasPlazoConsumidorAanmaning: number | null
    diasPlazoEmpresaSommatie: number | null
    diasPlazoConsumidorSommatie: number | null
    precioEmpresaPequena: number | null
    contribucionEmpresaPequenaPfc: number | null
    precioEmpresaGrande: number | null
    contribucionEmpresaGrandePfc: number | null
    multaAanmaningEmpresa: number | null
    multaAanmaningNatural: number | null
    multaSommatieEmpresa: number | null
    multaSommatieNatural: number | null
    limiteDiasReaccionEmpresa: number | null
    multaNoReaccionEmpresa: number | null
    multaNoReaccionNatural: number | null
    multaAcuerdoPagoEmpresa: number | null
    multaAcuerdoPagoNatural: number | null
    invoiceNumberLength: number | null
    invoiceSecuence: number | null
  }

  export type ParameterSumAggregateOutputType = {
    porcCobranza: number | null
    porcAbb: number | null
    diasPlazoEmpresaAanmaning: number | null
    diasPlazoConsumidorAanmaning: number | null
    diasPlazoEmpresaSommatie: number | null
    diasPlazoConsumidorSommatie: number | null
    precioEmpresaPequena: number | null
    contribucionEmpresaPequenaPfc: number | null
    precioEmpresaGrande: number | null
    contribucionEmpresaGrandePfc: number | null
    multaAanmaningEmpresa: number | null
    multaAanmaningNatural: number | null
    multaSommatieEmpresa: number | null
    multaSommatieNatural: number | null
    limiteDiasReaccionEmpresa: number | null
    multaNoReaccionEmpresa: number | null
    multaNoReaccionNatural: number | null
    multaAcuerdoPagoEmpresa: number | null
    multaAcuerdoPagoNatural: number | null
    invoiceNumberLength: number | null
    invoiceSecuence: number | null
  }

  export type ParameterMinAggregateOutputType = {
    id: string | null
    porcCobranza: number | null
    porcAbb: number | null
    diasPlazoEmpresaAanmaning: number | null
    diasPlazoConsumidorAanmaning: number | null
    diasPlazoEmpresaSommatie: number | null
    diasPlazoConsumidorSommatie: number | null
    precioEmpresaPequena: number | null
    contribucionEmpresaPequenaPfc: number | null
    precioEmpresaGrande: number | null
    contribucionEmpresaGrandePfc: number | null
    createdAt: Date | null
    updatedAt: Date | null
    multaAanmaningEmpresa: number | null
    multaAanmaningNatural: number | null
    multaSommatieEmpresa: number | null
    multaSommatieNatural: number | null
    limiteDiasReaccionEmpresa: number | null
    multaNoReaccionEmpresa: number | null
    multaNoReaccionNatural: number | null
    multaAcuerdoPagoEmpresa: number | null
    multaAcuerdoPagoNatural: number | null
    invoiceNumberLength: number | null
    invoicePrefix: string | null
    invoiceSecuence: number | null
    bankAccount: string | null
    bankName: string | null
  }

  export type ParameterMaxAggregateOutputType = {
    id: string | null
    porcCobranza: number | null
    porcAbb: number | null
    diasPlazoEmpresaAanmaning: number | null
    diasPlazoConsumidorAanmaning: number | null
    diasPlazoEmpresaSommatie: number | null
    diasPlazoConsumidorSommatie: number | null
    precioEmpresaPequena: number | null
    contribucionEmpresaPequenaPfc: number | null
    precioEmpresaGrande: number | null
    contribucionEmpresaGrandePfc: number | null
    createdAt: Date | null
    updatedAt: Date | null
    multaAanmaningEmpresa: number | null
    multaAanmaningNatural: number | null
    multaSommatieEmpresa: number | null
    multaSommatieNatural: number | null
    limiteDiasReaccionEmpresa: number | null
    multaNoReaccionEmpresa: number | null
    multaNoReaccionNatural: number | null
    multaAcuerdoPagoEmpresa: number | null
    multaAcuerdoPagoNatural: number | null
    invoiceNumberLength: number | null
    invoicePrefix: string | null
    invoiceSecuence: number | null
    bankAccount: string | null
    bankName: string | null
  }

  export type ParameterCountAggregateOutputType = {
    id: number
    porcCobranza: number
    porcAbb: number
    diasPlazoEmpresaAanmaning: number
    diasPlazoConsumidorAanmaning: number
    diasPlazoEmpresaSommatie: number
    diasPlazoConsumidorSommatie: number
    precioEmpresaPequena: number
    contribucionEmpresaPequenaPfc: number
    precioEmpresaGrande: number
    contribucionEmpresaGrandePfc: number
    createdAt: number
    updatedAt: number
    multaAanmaningEmpresa: number
    multaAanmaningNatural: number
    multaSommatieEmpresa: number
    multaSommatieNatural: number
    limiteDiasReaccionEmpresa: number
    multaNoReaccionEmpresa: number
    multaNoReaccionNatural: number
    multaAcuerdoPagoEmpresa: number
    multaAcuerdoPagoNatural: number
    invoiceNumberLength: number
    invoicePrefix: number
    invoiceSecuence: number
    bankAccount: number
    bankName: number
    _all: number
  }


  export type ParameterAvgAggregateInputType = {
    porcCobranza?: true
    porcAbb?: true
    diasPlazoEmpresaAanmaning?: true
    diasPlazoConsumidorAanmaning?: true
    diasPlazoEmpresaSommatie?: true
    diasPlazoConsumidorSommatie?: true
    precioEmpresaPequena?: true
    contribucionEmpresaPequenaPfc?: true
    precioEmpresaGrande?: true
    contribucionEmpresaGrandePfc?: true
    multaAanmaningEmpresa?: true
    multaAanmaningNatural?: true
    multaSommatieEmpresa?: true
    multaSommatieNatural?: true
    limiteDiasReaccionEmpresa?: true
    multaNoReaccionEmpresa?: true
    multaNoReaccionNatural?: true
    multaAcuerdoPagoEmpresa?: true
    multaAcuerdoPagoNatural?: true
    invoiceNumberLength?: true
    invoiceSecuence?: true
  }

  export type ParameterSumAggregateInputType = {
    porcCobranza?: true
    porcAbb?: true
    diasPlazoEmpresaAanmaning?: true
    diasPlazoConsumidorAanmaning?: true
    diasPlazoEmpresaSommatie?: true
    diasPlazoConsumidorSommatie?: true
    precioEmpresaPequena?: true
    contribucionEmpresaPequenaPfc?: true
    precioEmpresaGrande?: true
    contribucionEmpresaGrandePfc?: true
    multaAanmaningEmpresa?: true
    multaAanmaningNatural?: true
    multaSommatieEmpresa?: true
    multaSommatieNatural?: true
    limiteDiasReaccionEmpresa?: true
    multaNoReaccionEmpresa?: true
    multaNoReaccionNatural?: true
    multaAcuerdoPagoEmpresa?: true
    multaAcuerdoPagoNatural?: true
    invoiceNumberLength?: true
    invoiceSecuence?: true
  }

  export type ParameterMinAggregateInputType = {
    id?: true
    porcCobranza?: true
    porcAbb?: true
    diasPlazoEmpresaAanmaning?: true
    diasPlazoConsumidorAanmaning?: true
    diasPlazoEmpresaSommatie?: true
    diasPlazoConsumidorSommatie?: true
    precioEmpresaPequena?: true
    contribucionEmpresaPequenaPfc?: true
    precioEmpresaGrande?: true
    contribucionEmpresaGrandePfc?: true
    createdAt?: true
    updatedAt?: true
    multaAanmaningEmpresa?: true
    multaAanmaningNatural?: true
    multaSommatieEmpresa?: true
    multaSommatieNatural?: true
    limiteDiasReaccionEmpresa?: true
    multaNoReaccionEmpresa?: true
    multaNoReaccionNatural?: true
    multaAcuerdoPagoEmpresa?: true
    multaAcuerdoPagoNatural?: true
    invoiceNumberLength?: true
    invoicePrefix?: true
    invoiceSecuence?: true
    bankAccount?: true
    bankName?: true
  }

  export type ParameterMaxAggregateInputType = {
    id?: true
    porcCobranza?: true
    porcAbb?: true
    diasPlazoEmpresaAanmaning?: true
    diasPlazoConsumidorAanmaning?: true
    diasPlazoEmpresaSommatie?: true
    diasPlazoConsumidorSommatie?: true
    precioEmpresaPequena?: true
    contribucionEmpresaPequenaPfc?: true
    precioEmpresaGrande?: true
    contribucionEmpresaGrandePfc?: true
    createdAt?: true
    updatedAt?: true
    multaAanmaningEmpresa?: true
    multaAanmaningNatural?: true
    multaSommatieEmpresa?: true
    multaSommatieNatural?: true
    limiteDiasReaccionEmpresa?: true
    multaNoReaccionEmpresa?: true
    multaNoReaccionNatural?: true
    multaAcuerdoPagoEmpresa?: true
    multaAcuerdoPagoNatural?: true
    invoiceNumberLength?: true
    invoicePrefix?: true
    invoiceSecuence?: true
    bankAccount?: true
    bankName?: true
  }

  export type ParameterCountAggregateInputType = {
    id?: true
    porcCobranza?: true
    porcAbb?: true
    diasPlazoEmpresaAanmaning?: true
    diasPlazoConsumidorAanmaning?: true
    diasPlazoEmpresaSommatie?: true
    diasPlazoConsumidorSommatie?: true
    precioEmpresaPequena?: true
    contribucionEmpresaPequenaPfc?: true
    precioEmpresaGrande?: true
    contribucionEmpresaGrandePfc?: true
    createdAt?: true
    updatedAt?: true
    multaAanmaningEmpresa?: true
    multaAanmaningNatural?: true
    multaSommatieEmpresa?: true
    multaSommatieNatural?: true
    limiteDiasReaccionEmpresa?: true
    multaNoReaccionEmpresa?: true
    multaNoReaccionNatural?: true
    multaAcuerdoPagoEmpresa?: true
    multaAcuerdoPagoNatural?: true
    invoiceNumberLength?: true
    invoicePrefix?: true
    invoiceSecuence?: true
    bankAccount?: true
    bankName?: true
    _all?: true
  }

  export type ParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parameter to aggregate.
     */
    where?: ParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParameterOrderByWithRelationInput | ParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parameters
    **/
    _count?: true | ParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParameterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParameterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParameterMaxAggregateInputType
  }

  export type GetParameterAggregateType<T extends ParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParameter[P]>
      : GetScalarType<T[P], AggregateParameter[P]>
  }




  export type ParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParameterWhereInput
    orderBy?: ParameterOrderByWithAggregationInput | ParameterOrderByWithAggregationInput[]
    by: ParameterScalarFieldEnum[] | ParameterScalarFieldEnum
    having?: ParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParameterCountAggregateInputType | true
    _avg?: ParameterAvgAggregateInputType
    _sum?: ParameterSumAggregateInputType
    _min?: ParameterMinAggregateInputType
    _max?: ParameterMaxAggregateInputType
  }

  export type ParameterGroupByOutputType = {
    id: string
    porcCobranza: number
    porcAbb: number
    diasPlazoEmpresaAanmaning: number
    diasPlazoConsumidorAanmaning: number
    diasPlazoEmpresaSommatie: number
    diasPlazoConsumidorSommatie: number
    precioEmpresaPequena: number
    contribucionEmpresaPequenaPfc: number
    precioEmpresaGrande: number
    contribucionEmpresaGrandePfc: number
    createdAt: Date
    updatedAt: Date
    multaAanmaningEmpresa: number
    multaAanmaningNatural: number
    multaSommatieEmpresa: number
    multaSommatieNatural: number
    limiteDiasReaccionEmpresa: number
    multaNoReaccionEmpresa: number
    multaNoReaccionNatural: number
    multaAcuerdoPagoEmpresa: number
    multaAcuerdoPagoNatural: number
    invoiceNumberLength: number
    invoicePrefix: string
    invoiceSecuence: number
    bankAccount: string
    bankName: string
    _count: ParameterCountAggregateOutputType | null
    _avg: ParameterAvgAggregateOutputType | null
    _sum: ParameterSumAggregateOutputType | null
    _min: ParameterMinAggregateOutputType | null
    _max: ParameterMaxAggregateOutputType | null
  }

  type GetParameterGroupByPayload<T extends ParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParameterGroupByOutputType[P]>
            : GetScalarType<T[P], ParameterGroupByOutputType[P]>
        }
      >
    >


  export type ParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    porcCobranza?: boolean
    porcAbb?: boolean
    diasPlazoEmpresaAanmaning?: boolean
    diasPlazoConsumidorAanmaning?: boolean
    diasPlazoEmpresaSommatie?: boolean
    diasPlazoConsumidorSommatie?: boolean
    precioEmpresaPequena?: boolean
    contribucionEmpresaPequenaPfc?: boolean
    precioEmpresaGrande?: boolean
    contribucionEmpresaGrandePfc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    multaAanmaningEmpresa?: boolean
    multaAanmaningNatural?: boolean
    multaSommatieEmpresa?: boolean
    multaSommatieNatural?: boolean
    limiteDiasReaccionEmpresa?: boolean
    multaNoReaccionEmpresa?: boolean
    multaNoReaccionNatural?: boolean
    multaAcuerdoPagoEmpresa?: boolean
    multaAcuerdoPagoNatural?: boolean
    invoiceNumberLength?: boolean
    invoicePrefix?: boolean
    invoiceSecuence?: boolean
    bankAccount?: boolean
    bankName?: boolean
  }, ExtArgs["result"]["parameter"]>

  export type ParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    porcCobranza?: boolean
    porcAbb?: boolean
    diasPlazoEmpresaAanmaning?: boolean
    diasPlazoConsumidorAanmaning?: boolean
    diasPlazoEmpresaSommatie?: boolean
    diasPlazoConsumidorSommatie?: boolean
    precioEmpresaPequena?: boolean
    contribucionEmpresaPequenaPfc?: boolean
    precioEmpresaGrande?: boolean
    contribucionEmpresaGrandePfc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    multaAanmaningEmpresa?: boolean
    multaAanmaningNatural?: boolean
    multaSommatieEmpresa?: boolean
    multaSommatieNatural?: boolean
    limiteDiasReaccionEmpresa?: boolean
    multaNoReaccionEmpresa?: boolean
    multaNoReaccionNatural?: boolean
    multaAcuerdoPagoEmpresa?: boolean
    multaAcuerdoPagoNatural?: boolean
    invoiceNumberLength?: boolean
    invoicePrefix?: boolean
    invoiceSecuence?: boolean
    bankAccount?: boolean
    bankName?: boolean
  }, ExtArgs["result"]["parameter"]>

  export type ParameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    porcCobranza?: boolean
    porcAbb?: boolean
    diasPlazoEmpresaAanmaning?: boolean
    diasPlazoConsumidorAanmaning?: boolean
    diasPlazoEmpresaSommatie?: boolean
    diasPlazoConsumidorSommatie?: boolean
    precioEmpresaPequena?: boolean
    contribucionEmpresaPequenaPfc?: boolean
    precioEmpresaGrande?: boolean
    contribucionEmpresaGrandePfc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    multaAanmaningEmpresa?: boolean
    multaAanmaningNatural?: boolean
    multaSommatieEmpresa?: boolean
    multaSommatieNatural?: boolean
    limiteDiasReaccionEmpresa?: boolean
    multaNoReaccionEmpresa?: boolean
    multaNoReaccionNatural?: boolean
    multaAcuerdoPagoEmpresa?: boolean
    multaAcuerdoPagoNatural?: boolean
    invoiceNumberLength?: boolean
    invoicePrefix?: boolean
    invoiceSecuence?: boolean
    bankAccount?: boolean
    bankName?: boolean
  }, ExtArgs["result"]["parameter"]>

  export type ParameterSelectScalar = {
    id?: boolean
    porcCobranza?: boolean
    porcAbb?: boolean
    diasPlazoEmpresaAanmaning?: boolean
    diasPlazoConsumidorAanmaning?: boolean
    diasPlazoEmpresaSommatie?: boolean
    diasPlazoConsumidorSommatie?: boolean
    precioEmpresaPequena?: boolean
    contribucionEmpresaPequenaPfc?: boolean
    precioEmpresaGrande?: boolean
    contribucionEmpresaGrandePfc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    multaAanmaningEmpresa?: boolean
    multaAanmaningNatural?: boolean
    multaSommatieEmpresa?: boolean
    multaSommatieNatural?: boolean
    limiteDiasReaccionEmpresa?: boolean
    multaNoReaccionEmpresa?: boolean
    multaNoReaccionNatural?: boolean
    multaAcuerdoPagoEmpresa?: boolean
    multaAcuerdoPagoNatural?: boolean
    invoiceNumberLength?: boolean
    invoicePrefix?: boolean
    invoiceSecuence?: boolean
    bankAccount?: boolean
    bankName?: boolean
  }

  export type ParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "porcCobranza" | "porcAbb" | "diasPlazoEmpresaAanmaning" | "diasPlazoConsumidorAanmaning" | "diasPlazoEmpresaSommatie" | "diasPlazoConsumidorSommatie" | "precioEmpresaPequena" | "contribucionEmpresaPequenaPfc" | "precioEmpresaGrande" | "contribucionEmpresaGrandePfc" | "createdAt" | "updatedAt" | "multaAanmaningEmpresa" | "multaAanmaningNatural" | "multaSommatieEmpresa" | "multaSommatieNatural" | "limiteDiasReaccionEmpresa" | "multaNoReaccionEmpresa" | "multaNoReaccionNatural" | "multaAcuerdoPagoEmpresa" | "multaAcuerdoPagoNatural" | "invoiceNumberLength" | "invoicePrefix" | "invoiceSecuence" | "bankAccount" | "bankName", ExtArgs["result"]["parameter"]>

  export type $ParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parameter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      porcCobranza: number
      porcAbb: number
      diasPlazoEmpresaAanmaning: number
      diasPlazoConsumidorAanmaning: number
      diasPlazoEmpresaSommatie: number
      diasPlazoConsumidorSommatie: number
      precioEmpresaPequena: number
      contribucionEmpresaPequenaPfc: number
      precioEmpresaGrande: number
      contribucionEmpresaGrandePfc: number
      createdAt: Date
      updatedAt: Date
      multaAanmaningEmpresa: number
      multaAanmaningNatural: number
      multaSommatieEmpresa: number
      multaSommatieNatural: number
      limiteDiasReaccionEmpresa: number
      multaNoReaccionEmpresa: number
      multaNoReaccionNatural: number
      multaAcuerdoPagoEmpresa: number
      multaAcuerdoPagoNatural: number
      invoiceNumberLength: number
      invoicePrefix: string
      invoiceSecuence: number
      bankAccount: string
      bankName: string
    }, ExtArgs["result"]["parameter"]>
    composites: {}
  }

  type ParameterGetPayload<S extends boolean | null | undefined | ParameterDefaultArgs> = $Result.GetResult<Prisma.$ParameterPayload, S>

  type ParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParameterCountAggregateInputType | true
    }

  export interface ParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parameter'], meta: { name: 'Parameter' } }
    /**
     * Find zero or one Parameter that matches the filter.
     * @param {ParameterFindUniqueArgs} args - Arguments to find a Parameter
     * @example
     * // Get one Parameter
     * const parameter = await prisma.parameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParameterFindUniqueArgs>(args: SelectSubset<T, ParameterFindUniqueArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParameterFindUniqueOrThrowArgs} args - Arguments to find a Parameter
     * @example
     * // Get one Parameter
     * const parameter = await prisma.parameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, ParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterFindFirstArgs} args - Arguments to find a Parameter
     * @example
     * // Get one Parameter
     * const parameter = await prisma.parameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParameterFindFirstArgs>(args?: SelectSubset<T, ParameterFindFirstArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterFindFirstOrThrowArgs} args - Arguments to find a Parameter
     * @example
     * // Get one Parameter
     * const parameter = await prisma.parameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, ParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parameters
     * const parameters = await prisma.parameter.findMany()
     * 
     * // Get first 10 Parameters
     * const parameters = await prisma.parameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parameterWithIdOnly = await prisma.parameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParameterFindManyArgs>(args?: SelectSubset<T, ParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parameter.
     * @param {ParameterCreateArgs} args - Arguments to create a Parameter.
     * @example
     * // Create one Parameter
     * const Parameter = await prisma.parameter.create({
     *   data: {
     *     // ... data to create a Parameter
     *   }
     * })
     * 
     */
    create<T extends ParameterCreateArgs>(args: SelectSubset<T, ParameterCreateArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parameters.
     * @param {ParameterCreateManyArgs} args - Arguments to create many Parameters.
     * @example
     * // Create many Parameters
     * const parameter = await prisma.parameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParameterCreateManyArgs>(args?: SelectSubset<T, ParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parameters and returns the data saved in the database.
     * @param {ParameterCreateManyAndReturnArgs} args - Arguments to create many Parameters.
     * @example
     * // Create many Parameters
     * const parameter = await prisma.parameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parameters and only return the `id`
     * const parameterWithIdOnly = await prisma.parameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, ParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parameter.
     * @param {ParameterDeleteArgs} args - Arguments to delete one Parameter.
     * @example
     * // Delete one Parameter
     * const Parameter = await prisma.parameter.delete({
     *   where: {
     *     // ... filter to delete one Parameter
     *   }
     * })
     * 
     */
    delete<T extends ParameterDeleteArgs>(args: SelectSubset<T, ParameterDeleteArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parameter.
     * @param {ParameterUpdateArgs} args - Arguments to update one Parameter.
     * @example
     * // Update one Parameter
     * const parameter = await prisma.parameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParameterUpdateArgs>(args: SelectSubset<T, ParameterUpdateArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parameters.
     * @param {ParameterDeleteManyArgs} args - Arguments to filter Parameters to delete.
     * @example
     * // Delete a few Parameters
     * const { count } = await prisma.parameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParameterDeleteManyArgs>(args?: SelectSubset<T, ParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parameters
     * const parameter = await prisma.parameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParameterUpdateManyArgs>(args: SelectSubset<T, ParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parameters and returns the data updated in the database.
     * @param {ParameterUpdateManyAndReturnArgs} args - Arguments to update many Parameters.
     * @example
     * // Update many Parameters
     * const parameter = await prisma.parameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parameters and only return the `id`
     * const parameterWithIdOnly = await prisma.parameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParameterUpdateManyAndReturnArgs>(args: SelectSubset<T, ParameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parameter.
     * @param {ParameterUpsertArgs} args - Arguments to update or create a Parameter.
     * @example
     * // Update or create a Parameter
     * const parameter = await prisma.parameter.upsert({
     *   create: {
     *     // ... data to create a Parameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parameter we want to update
     *   }
     * })
     */
    upsert<T extends ParameterUpsertArgs>(args: SelectSubset<T, ParameterUpsertArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterCountArgs} args - Arguments to filter Parameters to count.
     * @example
     * // Count the number of Parameters
     * const count = await prisma.parameter.count({
     *   where: {
     *     // ... the filter for the Parameters we want to count
     *   }
     * })
    **/
    count<T extends ParameterCountArgs>(
      args?: Subset<T, ParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParameterAggregateArgs>(args: Subset<T, ParameterAggregateArgs>): Prisma.PrismaPromise<GetParameterAggregateType<T>>

    /**
     * Group by Parameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParameterGroupByArgs['orderBy'] }
        : { orderBy?: ParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parameter model
   */
  readonly fields: ParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parameter model
   */
  interface ParameterFieldRefs {
    readonly id: FieldRef<"Parameter", 'String'>
    readonly porcCobranza: FieldRef<"Parameter", 'Float'>
    readonly porcAbb: FieldRef<"Parameter", 'Float'>
    readonly diasPlazoEmpresaAanmaning: FieldRef<"Parameter", 'Int'>
    readonly diasPlazoConsumidorAanmaning: FieldRef<"Parameter", 'Int'>
    readonly diasPlazoEmpresaSommatie: FieldRef<"Parameter", 'Int'>
    readonly diasPlazoConsumidorSommatie: FieldRef<"Parameter", 'Int'>
    readonly precioEmpresaPequena: FieldRef<"Parameter", 'Float'>
    readonly contribucionEmpresaPequenaPfc: FieldRef<"Parameter", 'Float'>
    readonly precioEmpresaGrande: FieldRef<"Parameter", 'Float'>
    readonly contribucionEmpresaGrandePfc: FieldRef<"Parameter", 'Float'>
    readonly createdAt: FieldRef<"Parameter", 'DateTime'>
    readonly updatedAt: FieldRef<"Parameter", 'DateTime'>
    readonly multaAanmaningEmpresa: FieldRef<"Parameter", 'Float'>
    readonly multaAanmaningNatural: FieldRef<"Parameter", 'Float'>
    readonly multaSommatieEmpresa: FieldRef<"Parameter", 'Float'>
    readonly multaSommatieNatural: FieldRef<"Parameter", 'Float'>
    readonly limiteDiasReaccionEmpresa: FieldRef<"Parameter", 'Int'>
    readonly multaNoReaccionEmpresa: FieldRef<"Parameter", 'Float'>
    readonly multaNoReaccionNatural: FieldRef<"Parameter", 'Float'>
    readonly multaAcuerdoPagoEmpresa: FieldRef<"Parameter", 'Float'>
    readonly multaAcuerdoPagoNatural: FieldRef<"Parameter", 'Float'>
    readonly invoiceNumberLength: FieldRef<"Parameter", 'Int'>
    readonly invoicePrefix: FieldRef<"Parameter", 'String'>
    readonly invoiceSecuence: FieldRef<"Parameter", 'Int'>
    readonly bankAccount: FieldRef<"Parameter", 'String'>
    readonly bankName: FieldRef<"Parameter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Parameter findUnique
   */
  export type ParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter, which Parameter to fetch.
     */
    where: ParameterWhereUniqueInput
  }

  /**
   * Parameter findUniqueOrThrow
   */
  export type ParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter, which Parameter to fetch.
     */
    where: ParameterWhereUniqueInput
  }

  /**
   * Parameter findFirst
   */
  export type ParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter, which Parameter to fetch.
     */
    where?: ParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParameterOrderByWithRelationInput | ParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parameters.
     */
    cursor?: ParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parameters.
     */
    distinct?: ParameterScalarFieldEnum | ParameterScalarFieldEnum[]
  }

  /**
   * Parameter findFirstOrThrow
   */
  export type ParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter, which Parameter to fetch.
     */
    where?: ParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParameterOrderByWithRelationInput | ParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parameters.
     */
    cursor?: ParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parameters.
     */
    distinct?: ParameterScalarFieldEnum | ParameterScalarFieldEnum[]
  }

  /**
   * Parameter findMany
   */
  export type ParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter, which Parameters to fetch.
     */
    where?: ParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParameterOrderByWithRelationInput | ParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parameters.
     */
    cursor?: ParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    distinct?: ParameterScalarFieldEnum | ParameterScalarFieldEnum[]
  }

  /**
   * Parameter create
   */
  export type ParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * The data needed to create a Parameter.
     */
    data: XOR<ParameterCreateInput, ParameterUncheckedCreateInput>
  }

  /**
   * Parameter createMany
   */
  export type ParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parameters.
     */
    data: ParameterCreateManyInput | ParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parameter createManyAndReturn
   */
  export type ParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * The data used to create many Parameters.
     */
    data: ParameterCreateManyInput | ParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parameter update
   */
  export type ParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * The data needed to update a Parameter.
     */
    data: XOR<ParameterUpdateInput, ParameterUncheckedUpdateInput>
    /**
     * Choose, which Parameter to update.
     */
    where: ParameterWhereUniqueInput
  }

  /**
   * Parameter updateMany
   */
  export type ParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parameters.
     */
    data: XOR<ParameterUpdateManyMutationInput, ParameterUncheckedUpdateManyInput>
    /**
     * Filter which Parameters to update
     */
    where?: ParameterWhereInput
    /**
     * Limit how many Parameters to update.
     */
    limit?: number
  }

  /**
   * Parameter updateManyAndReturn
   */
  export type ParameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * The data used to update Parameters.
     */
    data: XOR<ParameterUpdateManyMutationInput, ParameterUncheckedUpdateManyInput>
    /**
     * Filter which Parameters to update
     */
    where?: ParameterWhereInput
    /**
     * Limit how many Parameters to update.
     */
    limit?: number
  }

  /**
   * Parameter upsert
   */
  export type ParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * The filter to search for the Parameter to update in case it exists.
     */
    where: ParameterWhereUniqueInput
    /**
     * In case the Parameter found by the `where` argument doesn't exist, create a new Parameter with this data.
     */
    create: XOR<ParameterCreateInput, ParameterUncheckedCreateInput>
    /**
     * In case the Parameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParameterUpdateInput, ParameterUncheckedUpdateInput>
  }

  /**
   * Parameter delete
   */
  export type ParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter which Parameter to delete.
     */
    where: ParameterWhereUniqueInput
  }

  /**
   * Parameter deleteMany
   */
  export type ParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parameters to delete
     */
    where?: ParameterWhereInput
    /**
     * Limit how many Parameters to delete.
     */
    limit?: number
  }

  /**
   * Parameter without action
   */
  export type ParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
  }


  /**
   * Model Verdict
   */

  export type AggregateVerdict = {
    _count: VerdictCountAggregateOutputType | null
    _avg: VerdictAvgAggregateOutputType | null
    _sum: VerdictSumAggregateOutputType | null
    _min: VerdictMinAggregateOutputType | null
    _max: VerdictMaxAggregateOutputType | null
  }

  export type VerdictAvgAggregateOutputType = {
    sentenceAmount: number | null
    procesalCost: number | null
  }

  export type VerdictSumAggregateOutputType = {
    sentenceAmount: number | null
    procesalCost: number | null
  }

  export type VerdictMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    creditorName: string | null
    debtorId: string | null
    registrationNumber: string | null
    sentenceAmount: number | null
    sentenceDate: Date | null
    status: $Enums.VerdictStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    procesalCost: number | null
    tenantId: string | null
    notes: string | null
    bailiffId: string | null
  }

  export type VerdictMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    creditorName: string | null
    debtorId: string | null
    registrationNumber: string | null
    sentenceAmount: number | null
    sentenceDate: Date | null
    status: $Enums.VerdictStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    procesalCost: number | null
    tenantId: string | null
    notes: string | null
    bailiffId: string | null
  }

  export type VerdictCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    creditorName: number
    debtorId: number
    registrationNumber: number
    sentenceAmount: number
    sentenceDate: number
    status: number
    createdAt: number
    updatedAt: number
    procesalCost: number
    tenantId: number
    notes: number
    bailiffId: number
    _all: number
  }


  export type VerdictAvgAggregateInputType = {
    sentenceAmount?: true
    procesalCost?: true
  }

  export type VerdictSumAggregateInputType = {
    sentenceAmount?: true
    procesalCost?: true
  }

  export type VerdictMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    creditorName?: true
    debtorId?: true
    registrationNumber?: true
    sentenceAmount?: true
    sentenceDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    procesalCost?: true
    tenantId?: true
    notes?: true
    bailiffId?: true
  }

  export type VerdictMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    creditorName?: true
    debtorId?: true
    registrationNumber?: true
    sentenceAmount?: true
    sentenceDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    procesalCost?: true
    tenantId?: true
    notes?: true
    bailiffId?: true
  }

  export type VerdictCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    creditorName?: true
    debtorId?: true
    registrationNumber?: true
    sentenceAmount?: true
    sentenceDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    procesalCost?: true
    tenantId?: true
    notes?: true
    bailiffId?: true
    _all?: true
  }

  export type VerdictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verdict to aggregate.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verdicts
    **/
    _count?: true | VerdictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictMaxAggregateInputType
  }

  export type GetVerdictAggregateType<T extends VerdictAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdict[P]>
      : GetScalarType<T[P], AggregateVerdict[P]>
  }




  export type VerdictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithAggregationInput | VerdictOrderByWithAggregationInput[]
    by: VerdictScalarFieldEnum[] | VerdictScalarFieldEnum
    having?: VerdictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictCountAggregateInputType | true
    _avg?: VerdictAvgAggregateInputType
    _sum?: VerdictSumAggregateInputType
    _min?: VerdictMinAggregateInputType
    _max?: VerdictMaxAggregateInputType
  }

  export type VerdictGroupByOutputType = {
    id: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date
    status: $Enums.VerdictStatus
    createdAt: Date
    updatedAt: Date
    procesalCost: number | null
    tenantId: string
    notes: string | null
    bailiffId: string | null
    _count: VerdictCountAggregateOutputType | null
    _avg: VerdictAvgAggregateOutputType | null
    _sum: VerdictSumAggregateOutputType | null
    _min: VerdictMinAggregateOutputType | null
    _max: VerdictMaxAggregateOutputType | null
  }

  type GetVerdictGroupByPayload<T extends VerdictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictGroupByOutputType[P]>
        }
      >
    >


  export type VerdictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    creditorName?: boolean
    debtorId?: boolean
    registrationNumber?: boolean
    sentenceAmount?: boolean
    sentenceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    procesalCost?: boolean
    tenantId?: boolean
    notes?: boolean
    bailiffId?: boolean
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    attachments?: boolean | Verdict$attachmentsArgs<ExtArgs>
    bailiffServices?: boolean | Verdict$bailiffServicesArgs<ExtArgs>
    verdictEmbargo?: boolean | Verdict$verdictEmbargoArgs<ExtArgs>
    verdictInterest?: boolean | Verdict$verdictInterestArgs<ExtArgs>
    _count?: boolean | VerdictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    creditorName?: boolean
    debtorId?: boolean
    registrationNumber?: boolean
    sentenceAmount?: boolean
    sentenceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    procesalCost?: boolean
    tenantId?: boolean
    notes?: boolean
    bailiffId?: boolean
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    creditorName?: boolean
    debtorId?: boolean
    registrationNumber?: boolean
    sentenceAmount?: boolean
    sentenceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    procesalCost?: boolean
    tenantId?: boolean
    notes?: boolean
    bailiffId?: boolean
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    creditorName?: boolean
    debtorId?: boolean
    registrationNumber?: boolean
    sentenceAmount?: boolean
    sentenceDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    procesalCost?: boolean
    tenantId?: boolean
    notes?: boolean
    bailiffId?: boolean
  }

  export type VerdictOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "creditorName" | "debtorId" | "registrationNumber" | "sentenceAmount" | "sentenceDate" | "status" | "createdAt" | "updatedAt" | "procesalCost" | "tenantId" | "notes" | "bailiffId", ExtArgs["result"]["verdict"]>
  export type VerdictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    attachments?: boolean | Verdict$attachmentsArgs<ExtArgs>
    bailiffServices?: boolean | Verdict$bailiffServicesArgs<ExtArgs>
    verdictEmbargo?: boolean | Verdict$verdictEmbargoArgs<ExtArgs>
    verdictInterest?: boolean | Verdict$verdictInterestArgs<ExtArgs>
    _count?: boolean | VerdictCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VerdictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VerdictIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $VerdictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verdict"
    objects: {
      bailiff: Prisma.$UserPayload<ExtArgs> | null
      debtor: Prisma.$DebtorPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      attachments: Prisma.$VerdictAttachmentPayload<ExtArgs>[]
      bailiffServices: Prisma.$VerdictBailiffServicesPayload<ExtArgs>[]
      verdictEmbargo: Prisma.$VerdictEmbargoPayload<ExtArgs>[]
      verdictInterest: Prisma.$VerdictInterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      creditorName: string
      debtorId: string
      registrationNumber: string
      sentenceAmount: number
      sentenceDate: Date
      status: $Enums.VerdictStatus
      createdAt: Date
      updatedAt: Date
      procesalCost: number | null
      tenantId: string
      notes: string | null
      bailiffId: string | null
    }, ExtArgs["result"]["verdict"]>
    composites: {}
  }

  type VerdictGetPayload<S extends boolean | null | undefined | VerdictDefaultArgs> = $Result.GetResult<Prisma.$VerdictPayload, S>

  type VerdictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictCountAggregateInputType | true
    }

  export interface VerdictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verdict'], meta: { name: 'Verdict' } }
    /**
     * Find zero or one Verdict that matches the filter.
     * @param {VerdictFindUniqueArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictFindUniqueArgs>(args: SelectSubset<T, VerdictFindUniqueArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verdict that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictFindUniqueOrThrowArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verdict that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindFirstArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictFindFirstArgs>(args?: SelectSubset<T, VerdictFindFirstArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verdict that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindFirstOrThrowArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verdicts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verdicts
     * const verdicts = await prisma.verdict.findMany()
     * 
     * // Get first 10 Verdicts
     * const verdicts = await prisma.verdict.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictWithIdOnly = await prisma.verdict.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictFindManyArgs>(args?: SelectSubset<T, VerdictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verdict.
     * @param {VerdictCreateArgs} args - Arguments to create a Verdict.
     * @example
     * // Create one Verdict
     * const Verdict = await prisma.verdict.create({
     *   data: {
     *     // ... data to create a Verdict
     *   }
     * })
     * 
     */
    create<T extends VerdictCreateArgs>(args: SelectSubset<T, VerdictCreateArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verdicts.
     * @param {VerdictCreateManyArgs} args - Arguments to create many Verdicts.
     * @example
     * // Create many Verdicts
     * const verdict = await prisma.verdict.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictCreateManyArgs>(args?: SelectSubset<T, VerdictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verdicts and returns the data saved in the database.
     * @param {VerdictCreateManyAndReturnArgs} args - Arguments to create many Verdicts.
     * @example
     * // Create many Verdicts
     * const verdict = await prisma.verdict.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verdicts and only return the `id`
     * const verdictWithIdOnly = await prisma.verdict.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verdict.
     * @param {VerdictDeleteArgs} args - Arguments to delete one Verdict.
     * @example
     * // Delete one Verdict
     * const Verdict = await prisma.verdict.delete({
     *   where: {
     *     // ... filter to delete one Verdict
     *   }
     * })
     * 
     */
    delete<T extends VerdictDeleteArgs>(args: SelectSubset<T, VerdictDeleteArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verdict.
     * @param {VerdictUpdateArgs} args - Arguments to update one Verdict.
     * @example
     * // Update one Verdict
     * const verdict = await prisma.verdict.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictUpdateArgs>(args: SelectSubset<T, VerdictUpdateArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verdicts.
     * @param {VerdictDeleteManyArgs} args - Arguments to filter Verdicts to delete.
     * @example
     * // Delete a few Verdicts
     * const { count } = await prisma.verdict.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictDeleteManyArgs>(args?: SelectSubset<T, VerdictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verdicts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verdicts
     * const verdict = await prisma.verdict.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictUpdateManyArgs>(args: SelectSubset<T, VerdictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verdicts and returns the data updated in the database.
     * @param {VerdictUpdateManyAndReturnArgs} args - Arguments to update many Verdicts.
     * @example
     * // Update many Verdicts
     * const verdict = await prisma.verdict.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verdicts and only return the `id`
     * const verdictWithIdOnly = await prisma.verdict.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verdict.
     * @param {VerdictUpsertArgs} args - Arguments to update or create a Verdict.
     * @example
     * // Update or create a Verdict
     * const verdict = await prisma.verdict.upsert({
     *   create: {
     *     // ... data to create a Verdict
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verdict we want to update
     *   }
     * })
     */
    upsert<T extends VerdictUpsertArgs>(args: SelectSubset<T, VerdictUpsertArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verdicts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictCountArgs} args - Arguments to filter Verdicts to count.
     * @example
     * // Count the number of Verdicts
     * const count = await prisma.verdict.count({
     *   where: {
     *     // ... the filter for the Verdicts we want to count
     *   }
     * })
    **/
    count<T extends VerdictCountArgs>(
      args?: Subset<T, VerdictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verdict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictAggregateArgs>(args: Subset<T, VerdictAggregateArgs>): Prisma.PrismaPromise<GetVerdictAggregateType<T>>

    /**
     * Group by Verdict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictGroupByArgs['orderBy'] }
        : { orderBy?: VerdictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verdict model
   */
  readonly fields: VerdictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verdict.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bailiff<T extends Verdict$bailiffArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$bailiffArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    debtor<T extends DebtorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtorDefaultArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Verdict$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bailiffServices<T extends Verdict$bailiffServicesArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$bailiffServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdictEmbargo<T extends Verdict$verdictEmbargoArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$verdictEmbargoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdictInterest<T extends Verdict$verdictInterestArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$verdictInterestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verdict model
   */
  interface VerdictFieldRefs {
    readonly id: FieldRef<"Verdict", 'String'>
    readonly invoiceNumber: FieldRef<"Verdict", 'String'>
    readonly creditorName: FieldRef<"Verdict", 'String'>
    readonly debtorId: FieldRef<"Verdict", 'String'>
    readonly registrationNumber: FieldRef<"Verdict", 'String'>
    readonly sentenceAmount: FieldRef<"Verdict", 'Float'>
    readonly sentenceDate: FieldRef<"Verdict", 'DateTime'>
    readonly status: FieldRef<"Verdict", 'VerdictStatus'>
    readonly createdAt: FieldRef<"Verdict", 'DateTime'>
    readonly updatedAt: FieldRef<"Verdict", 'DateTime'>
    readonly procesalCost: FieldRef<"Verdict", 'Float'>
    readonly tenantId: FieldRef<"Verdict", 'String'>
    readonly notes: FieldRef<"Verdict", 'String'>
    readonly bailiffId: FieldRef<"Verdict", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Verdict findUnique
   */
  export type VerdictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict findUniqueOrThrow
   */
  export type VerdictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict findFirst
   */
  export type VerdictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verdicts.
     */
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict findFirstOrThrow
   */
  export type VerdictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verdicts.
     */
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict findMany
   */
  export type VerdictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdicts to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict create
   */
  export type VerdictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The data needed to create a Verdict.
     */
    data: XOR<VerdictCreateInput, VerdictUncheckedCreateInput>
  }

  /**
   * Verdict createMany
   */
  export type VerdictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verdicts.
     */
    data: VerdictCreateManyInput | VerdictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verdict createManyAndReturn
   */
  export type VerdictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * The data used to create many Verdicts.
     */
    data: VerdictCreateManyInput | VerdictCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verdict update
   */
  export type VerdictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The data needed to update a Verdict.
     */
    data: XOR<VerdictUpdateInput, VerdictUncheckedUpdateInput>
    /**
     * Choose, which Verdict to update.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict updateMany
   */
  export type VerdictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verdicts.
     */
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyInput>
    /**
     * Filter which Verdicts to update
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to update.
     */
    limit?: number
  }

  /**
   * Verdict updateManyAndReturn
   */
  export type VerdictUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * The data used to update Verdicts.
     */
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyInput>
    /**
     * Filter which Verdicts to update
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verdict upsert
   */
  export type VerdictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The filter to search for the Verdict to update in case it exists.
     */
    where: VerdictWhereUniqueInput
    /**
     * In case the Verdict found by the `where` argument doesn't exist, create a new Verdict with this data.
     */
    create: XOR<VerdictCreateInput, VerdictUncheckedCreateInput>
    /**
     * In case the Verdict was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictUpdateInput, VerdictUncheckedUpdateInput>
  }

  /**
   * Verdict delete
   */
  export type VerdictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter which Verdict to delete.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict deleteMany
   */
  export type VerdictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verdicts to delete
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to delete.
     */
    limit?: number
  }

  /**
   * Verdict.bailiff
   */
  export type Verdict$bailiffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Verdict.attachments
   */
  export type Verdict$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    where?: VerdictAttachmentWhereInput
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    cursor?: VerdictAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * Verdict.bailiffServices
   */
  export type Verdict$bailiffServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    where?: VerdictBailiffServicesWhereInput
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    cursor?: VerdictBailiffServicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * Verdict.verdictEmbargo
   */
  export type Verdict$verdictEmbargoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    where?: VerdictEmbargoWhereInput
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    cursor?: VerdictEmbargoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * Verdict.verdictInterest
   */
  export type Verdict$verdictInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    where?: VerdictInterestWhereInput
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    cursor?: VerdictInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * Verdict without action
   */
  export type VerdictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
  }


  /**
   * Model VerdictInterest
   */

  export type AggregateVerdictInterest = {
    _count: VerdictInterestCountAggregateOutputType | null
    _avg: VerdictInterestAvgAggregateOutputType | null
    _sum: VerdictInterestSumAggregateOutputType | null
    _min: VerdictInterestMinAggregateOutputType | null
    _max: VerdictInterestMaxAggregateOutputType | null
  }

  export type VerdictInterestAvgAggregateOutputType = {
    interestType: number | null
    baseAmount: number | null
    calculatedInterest: number | null
    totalInterest: number | null
  }

  export type VerdictInterestSumAggregateOutputType = {
    interestType: number | null
    baseAmount: number | null
    calculatedInterest: number | null
    totalInterest: number | null
  }

  export type VerdictInterestMinAggregateOutputType = {
    id: string | null
    interestType: number | null
    baseAmount: number | null
    calculatedInterest: number | null
    calculationStart: Date | null
    calculationEnd: Date | null
    totalInterest: number | null
    createdAt: Date | null
    updatedAt: Date | null
    verdictId: string | null
  }

  export type VerdictInterestMaxAggregateOutputType = {
    id: string | null
    interestType: number | null
    baseAmount: number | null
    calculatedInterest: number | null
    calculationStart: Date | null
    calculationEnd: Date | null
    totalInterest: number | null
    createdAt: Date | null
    updatedAt: Date | null
    verdictId: string | null
  }

  export type VerdictInterestCountAggregateOutputType = {
    id: number
    interestType: number
    baseAmount: number
    calculatedInterest: number
    calculationStart: number
    calculationEnd: number
    totalInterest: number
    createdAt: number
    updatedAt: number
    verdictId: number
    _all: number
  }


  export type VerdictInterestAvgAggregateInputType = {
    interestType?: true
    baseAmount?: true
    calculatedInterest?: true
    totalInterest?: true
  }

  export type VerdictInterestSumAggregateInputType = {
    interestType?: true
    baseAmount?: true
    calculatedInterest?: true
    totalInterest?: true
  }

  export type VerdictInterestMinAggregateInputType = {
    id?: true
    interestType?: true
    baseAmount?: true
    calculatedInterest?: true
    calculationStart?: true
    calculationEnd?: true
    totalInterest?: true
    createdAt?: true
    updatedAt?: true
    verdictId?: true
  }

  export type VerdictInterestMaxAggregateInputType = {
    id?: true
    interestType?: true
    baseAmount?: true
    calculatedInterest?: true
    calculationStart?: true
    calculationEnd?: true
    totalInterest?: true
    createdAt?: true
    updatedAt?: true
    verdictId?: true
  }

  export type VerdictInterestCountAggregateInputType = {
    id?: true
    interestType?: true
    baseAmount?: true
    calculatedInterest?: true
    calculationStart?: true
    calculationEnd?: true
    totalInterest?: true
    createdAt?: true
    updatedAt?: true
    verdictId?: true
    _all?: true
  }

  export type VerdictInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterest to aggregate.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictInterests
    **/
    _count?: true | VerdictInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictInterestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictInterestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictInterestMaxAggregateInputType
  }

  export type GetVerdictInterestAggregateType<T extends VerdictInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictInterest[P]>
      : GetScalarType<T[P], AggregateVerdictInterest[P]>
  }




  export type VerdictInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestWhereInput
    orderBy?: VerdictInterestOrderByWithAggregationInput | VerdictInterestOrderByWithAggregationInput[]
    by: VerdictInterestScalarFieldEnum[] | VerdictInterestScalarFieldEnum
    having?: VerdictInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictInterestCountAggregateInputType | true
    _avg?: VerdictInterestAvgAggregateInputType
    _sum?: VerdictInterestSumAggregateInputType
    _min?: VerdictInterestMinAggregateInputType
    _max?: VerdictInterestMaxAggregateInputType
  }

  export type VerdictInterestGroupByOutputType = {
    id: string
    interestType: number
    baseAmount: number
    calculatedInterest: number | null
    calculationStart: Date
    calculationEnd: Date
    totalInterest: number
    createdAt: Date
    updatedAt: Date
    verdictId: string | null
    _count: VerdictInterestCountAggregateOutputType | null
    _avg: VerdictInterestAvgAggregateOutputType | null
    _sum: VerdictInterestSumAggregateOutputType | null
    _min: VerdictInterestMinAggregateOutputType | null
    _max: VerdictInterestMaxAggregateOutputType | null
  }

  type GetVerdictInterestGroupByPayload<T extends VerdictInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictInterestGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictInterestGroupByOutputType[P]>
        }
      >
    >


  export type VerdictInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interestType?: boolean
    baseAmount?: boolean
    calculatedInterest?: boolean
    calculationStart?: boolean
    calculationEnd?: boolean
    totalInterest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictId?: boolean
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
    details?: boolean | VerdictInterest$detailsArgs<ExtArgs>
    _count?: boolean | VerdictInterestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterest"]>

  export type VerdictInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interestType?: boolean
    baseAmount?: boolean
    calculatedInterest?: boolean
    calculationStart?: boolean
    calculationEnd?: boolean
    totalInterest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictId?: boolean
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterest"]>

  export type VerdictInterestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interestType?: boolean
    baseAmount?: boolean
    calculatedInterest?: boolean
    calculationStart?: boolean
    calculationEnd?: boolean
    totalInterest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictId?: boolean
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterest"]>

  export type VerdictInterestSelectScalar = {
    id?: boolean
    interestType?: boolean
    baseAmount?: boolean
    calculatedInterest?: boolean
    calculationStart?: boolean
    calculationEnd?: boolean
    totalInterest?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictId?: boolean
  }

  export type VerdictInterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interestType" | "baseAmount" | "calculatedInterest" | "calculationStart" | "calculationEnd" | "totalInterest" | "createdAt" | "updatedAt" | "verdictId", ExtArgs["result"]["verdictInterest"]>
  export type VerdictInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
    details?: boolean | VerdictInterest$detailsArgs<ExtArgs>
    _count?: boolean | VerdictInterestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VerdictInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }
  export type VerdictInterestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }

  export type $VerdictInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictInterest"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs> | null
      details: Prisma.$VerdictInterestDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      interestType: number
      baseAmount: number
      calculatedInterest: number | null
      calculationStart: Date
      calculationEnd: Date
      totalInterest: number
      createdAt: Date
      updatedAt: Date
      verdictId: string | null
    }, ExtArgs["result"]["verdictInterest"]>
    composites: {}
  }

  type VerdictInterestGetPayload<S extends boolean | null | undefined | VerdictInterestDefaultArgs> = $Result.GetResult<Prisma.$VerdictInterestPayload, S>

  type VerdictInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictInterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictInterestCountAggregateInputType | true
    }

  export interface VerdictInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictInterest'], meta: { name: 'VerdictInterest' } }
    /**
     * Find zero or one VerdictInterest that matches the filter.
     * @param {VerdictInterestFindUniqueArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictInterestFindUniqueArgs>(args: SelectSubset<T, VerdictInterestFindUniqueArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictInterest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictInterestFindUniqueOrThrowArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestFindFirstArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictInterestFindFirstArgs>(args?: SelectSubset<T, VerdictInterestFindFirstArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestFindFirstOrThrowArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictInterests
     * const verdictInterests = await prisma.verdictInterest.findMany()
     * 
     * // Get first 10 VerdictInterests
     * const verdictInterests = await prisma.verdictInterest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictInterestWithIdOnly = await prisma.verdictInterest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictInterestFindManyArgs>(args?: SelectSubset<T, VerdictInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictInterest.
     * @param {VerdictInterestCreateArgs} args - Arguments to create a VerdictInterest.
     * @example
     * // Create one VerdictInterest
     * const VerdictInterest = await prisma.verdictInterest.create({
     *   data: {
     *     // ... data to create a VerdictInterest
     *   }
     * })
     * 
     */
    create<T extends VerdictInterestCreateArgs>(args: SelectSubset<T, VerdictInterestCreateArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictInterests.
     * @param {VerdictInterestCreateManyArgs} args - Arguments to create many VerdictInterests.
     * @example
     * // Create many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictInterestCreateManyArgs>(args?: SelectSubset<T, VerdictInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictInterests and returns the data saved in the database.
     * @param {VerdictInterestCreateManyAndReturnArgs} args - Arguments to create many VerdictInterests.
     * @example
     * // Create many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictInterests and only return the `id`
     * const verdictInterestWithIdOnly = await prisma.verdictInterest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictInterest.
     * @param {VerdictInterestDeleteArgs} args - Arguments to delete one VerdictInterest.
     * @example
     * // Delete one VerdictInterest
     * const VerdictInterest = await prisma.verdictInterest.delete({
     *   where: {
     *     // ... filter to delete one VerdictInterest
     *   }
     * })
     * 
     */
    delete<T extends VerdictInterestDeleteArgs>(args: SelectSubset<T, VerdictInterestDeleteArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictInterest.
     * @param {VerdictInterestUpdateArgs} args - Arguments to update one VerdictInterest.
     * @example
     * // Update one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictInterestUpdateArgs>(args: SelectSubset<T, VerdictInterestUpdateArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictInterests.
     * @param {VerdictInterestDeleteManyArgs} args - Arguments to filter VerdictInterests to delete.
     * @example
     * // Delete a few VerdictInterests
     * const { count } = await prisma.verdictInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictInterestDeleteManyArgs>(args?: SelectSubset<T, VerdictInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictInterestUpdateManyArgs>(args: SelectSubset<T, VerdictInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterests and returns the data updated in the database.
     * @param {VerdictInterestUpdateManyAndReturnArgs} args - Arguments to update many VerdictInterests.
     * @example
     * // Update many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictInterests and only return the `id`
     * const verdictInterestWithIdOnly = await prisma.verdictInterest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictInterestUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictInterestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictInterest.
     * @param {VerdictInterestUpsertArgs} args - Arguments to update or create a VerdictInterest.
     * @example
     * // Update or create a VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.upsert({
     *   create: {
     *     // ... data to create a VerdictInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictInterest we want to update
     *   }
     * })
     */
    upsert<T extends VerdictInterestUpsertArgs>(args: SelectSubset<T, VerdictInterestUpsertArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestCountArgs} args - Arguments to filter VerdictInterests to count.
     * @example
     * // Count the number of VerdictInterests
     * const count = await prisma.verdictInterest.count({
     *   where: {
     *     // ... the filter for the VerdictInterests we want to count
     *   }
     * })
    **/
    count<T extends VerdictInterestCountArgs>(
      args?: Subset<T, VerdictInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictInterestAggregateArgs>(args: Subset<T, VerdictInterestAggregateArgs>): Prisma.PrismaPromise<GetVerdictInterestAggregateType<T>>

    /**
     * Group by VerdictInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictInterestGroupByArgs['orderBy'] }
        : { orderBy?: VerdictInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictInterest model
   */
  readonly fields: VerdictInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictInterest$verdictArgs<ExtArgs> = {}>(args?: Subset<T, VerdictInterest$verdictArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    details<T extends VerdictInterest$detailsArgs<ExtArgs> = {}>(args?: Subset<T, VerdictInterest$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictInterest model
   */
  interface VerdictInterestFieldRefs {
    readonly id: FieldRef<"VerdictInterest", 'String'>
    readonly interestType: FieldRef<"VerdictInterest", 'Int'>
    readonly baseAmount: FieldRef<"VerdictInterest", 'Float'>
    readonly calculatedInterest: FieldRef<"VerdictInterest", 'Float'>
    readonly calculationStart: FieldRef<"VerdictInterest", 'DateTime'>
    readonly calculationEnd: FieldRef<"VerdictInterest", 'DateTime'>
    readonly totalInterest: FieldRef<"VerdictInterest", 'Float'>
    readonly createdAt: FieldRef<"VerdictInterest", 'DateTime'>
    readonly updatedAt: FieldRef<"VerdictInterest", 'DateTime'>
    readonly verdictId: FieldRef<"VerdictInterest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VerdictInterest findUnique
   */
  export type VerdictInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest findUniqueOrThrow
   */
  export type VerdictInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest findFirst
   */
  export type VerdictInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterests.
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterests.
     */
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * VerdictInterest findFirstOrThrow
   */
  export type VerdictInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterests.
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterests.
     */
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * VerdictInterest findMany
   */
  export type VerdictInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterests to fetch.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictInterests.
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * VerdictInterest create
   */
  export type VerdictInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictInterest.
     */
    data: XOR<VerdictInterestCreateInput, VerdictInterestUncheckedCreateInput>
  }

  /**
   * VerdictInterest createMany
   */
  export type VerdictInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictInterests.
     */
    data: VerdictInterestCreateManyInput | VerdictInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictInterest createManyAndReturn
   */
  export type VerdictInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictInterests.
     */
    data: VerdictInterestCreateManyInput | VerdictInterestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterest update
   */
  export type VerdictInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictInterest.
     */
    data: XOR<VerdictInterestUpdateInput, VerdictInterestUncheckedUpdateInput>
    /**
     * Choose, which VerdictInterest to update.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest updateMany
   */
  export type VerdictInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictInterests.
     */
    data: XOR<VerdictInterestUpdateManyMutationInput, VerdictInterestUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterests to update
     */
    where?: VerdictInterestWhereInput
    /**
     * Limit how many VerdictInterests to update.
     */
    limit?: number
  }

  /**
   * VerdictInterest updateManyAndReturn
   */
  export type VerdictInterestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * The data used to update VerdictInterests.
     */
    data: XOR<VerdictInterestUpdateManyMutationInput, VerdictInterestUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterests to update
     */
    where?: VerdictInterestWhereInput
    /**
     * Limit how many VerdictInterests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterest upsert
   */
  export type VerdictInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictInterest to update in case it exists.
     */
    where: VerdictInterestWhereUniqueInput
    /**
     * In case the VerdictInterest found by the `where` argument doesn't exist, create a new VerdictInterest with this data.
     */
    create: XOR<VerdictInterestCreateInput, VerdictInterestUncheckedCreateInput>
    /**
     * In case the VerdictInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictInterestUpdateInput, VerdictInterestUncheckedUpdateInput>
  }

  /**
   * VerdictInterest delete
   */
  export type VerdictInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter which VerdictInterest to delete.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest deleteMany
   */
  export type VerdictInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterests to delete
     */
    where?: VerdictInterestWhereInput
    /**
     * Limit how many VerdictInterests to delete.
     */
    limit?: number
  }

  /**
   * VerdictInterest.verdict
   */
  export type VerdictInterest$verdictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
  }

  /**
   * VerdictInterest.details
   */
  export type VerdictInterest$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    where?: VerdictInterestDetailsWhereInput
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    cursor?: VerdictInterestDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterest without action
   */
  export type VerdictInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
  }


  /**
   * Model VerdictInterestDetails
   */

  export type AggregateVerdictInterestDetails = {
    _count: VerdictInterestDetailsCountAggregateOutputType | null
    _avg: VerdictInterestDetailsAvgAggregateOutputType | null
    _sum: VerdictInterestDetailsSumAggregateOutputType | null
    _min: VerdictInterestDetailsMinAggregateOutputType | null
    _max: VerdictInterestDetailsMaxAggregateOutputType | null
  }

  export type VerdictInterestDetailsAvgAggregateOutputType = {
    days: number | null
    annualRate: number | null
    proportionalRate: number | null
    baseAmount: number | null
    interest: number | null
    total: number | null
  }

  export type VerdictInterestDetailsSumAggregateOutputType = {
    days: number | null
    annualRate: number | null
    proportionalRate: number | null
    baseAmount: number | null
    interest: number | null
    total: number | null
  }

  export type VerdictInterestDetailsMinAggregateOutputType = {
    id: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    days: number | null
    annualRate: number | null
    proportionalRate: number | null
    baseAmount: number | null
    interest: number | null
    total: number | null
    verdictInterestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictInterestDetailsMaxAggregateOutputType = {
    id: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    days: number | null
    annualRate: number | null
    proportionalRate: number | null
    baseAmount: number | null
    interest: number | null
    total: number | null
    verdictInterestId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictInterestDetailsCountAggregateOutputType = {
    id: number
    period: number
    periodStart: number
    periodEnd: number
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    verdictInterestId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerdictInterestDetailsAvgAggregateInputType = {
    days?: true
    annualRate?: true
    proportionalRate?: true
    baseAmount?: true
    interest?: true
    total?: true
  }

  export type VerdictInterestDetailsSumAggregateInputType = {
    days?: true
    annualRate?: true
    proportionalRate?: true
    baseAmount?: true
    interest?: true
    total?: true
  }

  export type VerdictInterestDetailsMinAggregateInputType = {
    id?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    days?: true
    annualRate?: true
    proportionalRate?: true
    baseAmount?: true
    interest?: true
    total?: true
    verdictInterestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictInterestDetailsMaxAggregateInputType = {
    id?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    days?: true
    annualRate?: true
    proportionalRate?: true
    baseAmount?: true
    interest?: true
    total?: true
    verdictInterestId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictInterestDetailsCountAggregateInputType = {
    id?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    days?: true
    annualRate?: true
    proportionalRate?: true
    baseAmount?: true
    interest?: true
    total?: true
    verdictInterestId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerdictInterestDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterestDetails to aggregate.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictInterestDetails
    **/
    _count?: true | VerdictInterestDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictInterestDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictInterestDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictInterestDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictInterestDetailsMaxAggregateInputType
  }

  export type GetVerdictInterestDetailsAggregateType<T extends VerdictInterestDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictInterestDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictInterestDetails[P]>
      : GetScalarType<T[P], AggregateVerdictInterestDetails[P]>
  }




  export type VerdictInterestDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestDetailsWhereInput
    orderBy?: VerdictInterestDetailsOrderByWithAggregationInput | VerdictInterestDetailsOrderByWithAggregationInput[]
    by: VerdictInterestDetailsScalarFieldEnum[] | VerdictInterestDetailsScalarFieldEnum
    having?: VerdictInterestDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictInterestDetailsCountAggregateInputType | true
    _avg?: VerdictInterestDetailsAvgAggregateInputType
    _sum?: VerdictInterestDetailsSumAggregateInputType
    _min?: VerdictInterestDetailsMinAggregateInputType
    _max?: VerdictInterestDetailsMaxAggregateInputType
  }

  export type VerdictInterestDetailsGroupByOutputType = {
    id: string
    period: string
    periodStart: Date
    periodEnd: Date
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    verdictInterestId: string
    createdAt: Date
    updatedAt: Date
    _count: VerdictInterestDetailsCountAggregateOutputType | null
    _avg: VerdictInterestDetailsAvgAggregateOutputType | null
    _sum: VerdictInterestDetailsSumAggregateOutputType | null
    _min: VerdictInterestDetailsMinAggregateOutputType | null
    _max: VerdictInterestDetailsMaxAggregateOutputType | null
  }

  type GetVerdictInterestDetailsGroupByPayload<T extends VerdictInterestDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictInterestDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictInterestDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictInterestDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictInterestDetailsGroupByOutputType[P]>
        }
      >
    >


  export type VerdictInterestDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    days?: boolean
    annualRate?: boolean
    proportionalRate?: boolean
    baseAmount?: boolean
    interest?: boolean
    total?: boolean
    verdictInterestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterestDetails"]>

  export type VerdictInterestDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    days?: boolean
    annualRate?: boolean
    proportionalRate?: boolean
    baseAmount?: boolean
    interest?: boolean
    total?: boolean
    verdictInterestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterestDetails"]>

  export type VerdictInterestDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    days?: boolean
    annualRate?: boolean
    proportionalRate?: boolean
    baseAmount?: boolean
    interest?: boolean
    total?: boolean
    verdictInterestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterestDetails"]>

  export type VerdictInterestDetailsSelectScalar = {
    id?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    days?: boolean
    annualRate?: boolean
    proportionalRate?: boolean
    baseAmount?: boolean
    interest?: boolean
    total?: boolean
    verdictInterestId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerdictInterestDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "period" | "periodStart" | "periodEnd" | "days" | "annualRate" | "proportionalRate" | "baseAmount" | "interest" | "total" | "verdictInterestId" | "createdAt" | "updatedAt", ExtArgs["result"]["verdictInterestDetails"]>
  export type VerdictInterestDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }
  export type VerdictInterestDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }
  export type VerdictInterestDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdictInterest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }

  export type $VerdictInterestDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictInterestDetails"
    objects: {
      verdictInterest: Prisma.$VerdictInterestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      period: string
      periodStart: Date
      periodEnd: Date
      days: number
      annualRate: number
      proportionalRate: number
      baseAmount: number
      interest: number
      total: number
      verdictInterestId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verdictInterestDetails"]>
    composites: {}
  }

  type VerdictInterestDetailsGetPayload<S extends boolean | null | undefined | VerdictInterestDetailsDefaultArgs> = $Result.GetResult<Prisma.$VerdictInterestDetailsPayload, S>

  type VerdictInterestDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictInterestDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictInterestDetailsCountAggregateInputType | true
    }

  export interface VerdictInterestDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictInterestDetails'], meta: { name: 'VerdictInterestDetails' } }
    /**
     * Find zero or one VerdictInterestDetails that matches the filter.
     * @param {VerdictInterestDetailsFindUniqueArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictInterestDetailsFindUniqueArgs>(args: SelectSubset<T, VerdictInterestDetailsFindUniqueArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictInterestDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictInterestDetailsFindUniqueOrThrowArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictInterestDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictInterestDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterestDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsFindFirstArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictInterestDetailsFindFirstArgs>(args?: SelectSubset<T, VerdictInterestDetailsFindFirstArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterestDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsFindFirstOrThrowArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictInterestDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictInterestDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictInterestDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findMany()
     * 
     * // Get first 10 VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictInterestDetailsWithIdOnly = await prisma.verdictInterestDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictInterestDetailsFindManyArgs>(args?: SelectSubset<T, VerdictInterestDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictInterestDetails.
     * @param {VerdictInterestDetailsCreateArgs} args - Arguments to create a VerdictInterestDetails.
     * @example
     * // Create one VerdictInterestDetails
     * const VerdictInterestDetails = await prisma.verdictInterestDetails.create({
     *   data: {
     *     // ... data to create a VerdictInterestDetails
     *   }
     * })
     * 
     */
    create<T extends VerdictInterestDetailsCreateArgs>(args: SelectSubset<T, VerdictInterestDetailsCreateArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictInterestDetails.
     * @param {VerdictInterestDetailsCreateManyArgs} args - Arguments to create many VerdictInterestDetails.
     * @example
     * // Create many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictInterestDetailsCreateManyArgs>(args?: SelectSubset<T, VerdictInterestDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictInterestDetails and returns the data saved in the database.
     * @param {VerdictInterestDetailsCreateManyAndReturnArgs} args - Arguments to create many VerdictInterestDetails.
     * @example
     * // Create many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictInterestDetails and only return the `id`
     * const verdictInterestDetailsWithIdOnly = await prisma.verdictInterestDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictInterestDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictInterestDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictInterestDetails.
     * @param {VerdictInterestDetailsDeleteArgs} args - Arguments to delete one VerdictInterestDetails.
     * @example
     * // Delete one VerdictInterestDetails
     * const VerdictInterestDetails = await prisma.verdictInterestDetails.delete({
     *   where: {
     *     // ... filter to delete one VerdictInterestDetails
     *   }
     * })
     * 
     */
    delete<T extends VerdictInterestDetailsDeleteArgs>(args: SelectSubset<T, VerdictInterestDetailsDeleteArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictInterestDetails.
     * @param {VerdictInterestDetailsUpdateArgs} args - Arguments to update one VerdictInterestDetails.
     * @example
     * // Update one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictInterestDetailsUpdateArgs>(args: SelectSubset<T, VerdictInterestDetailsUpdateArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictInterestDetails.
     * @param {VerdictInterestDetailsDeleteManyArgs} args - Arguments to filter VerdictInterestDetails to delete.
     * @example
     * // Delete a few VerdictInterestDetails
     * const { count } = await prisma.verdictInterestDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictInterestDetailsDeleteManyArgs>(args?: SelectSubset<T, VerdictInterestDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictInterestDetailsUpdateManyArgs>(args: SelectSubset<T, VerdictInterestDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterestDetails and returns the data updated in the database.
     * @param {VerdictInterestDetailsUpdateManyAndReturnArgs} args - Arguments to update many VerdictInterestDetails.
     * @example
     * // Update many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictInterestDetails and only return the `id`
     * const verdictInterestDetailsWithIdOnly = await prisma.verdictInterestDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictInterestDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictInterestDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictInterestDetails.
     * @param {VerdictInterestDetailsUpsertArgs} args - Arguments to update or create a VerdictInterestDetails.
     * @example
     * // Update or create a VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.upsert({
     *   create: {
     *     // ... data to create a VerdictInterestDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictInterestDetails we want to update
     *   }
     * })
     */
    upsert<T extends VerdictInterestDetailsUpsertArgs>(args: SelectSubset<T, VerdictInterestDetailsUpsertArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsCountArgs} args - Arguments to filter VerdictInterestDetails to count.
     * @example
     * // Count the number of VerdictInterestDetails
     * const count = await prisma.verdictInterestDetails.count({
     *   where: {
     *     // ... the filter for the VerdictInterestDetails we want to count
     *   }
     * })
    **/
    count<T extends VerdictInterestDetailsCountArgs>(
      args?: Subset<T, VerdictInterestDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictInterestDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictInterestDetailsAggregateArgs>(args: Subset<T, VerdictInterestDetailsAggregateArgs>): Prisma.PrismaPromise<GetVerdictInterestDetailsAggregateType<T>>

    /**
     * Group by VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictInterestDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictInterestDetailsGroupByArgs['orderBy'] }
        : { orderBy?: VerdictInterestDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictInterestDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictInterestDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictInterestDetails model
   */
  readonly fields: VerdictInterestDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictInterestDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictInterestDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdictInterest<T extends VerdictInterestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictInterestDefaultArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictInterestDetails model
   */
  interface VerdictInterestDetailsFieldRefs {
    readonly id: FieldRef<"VerdictInterestDetails", 'String'>
    readonly period: FieldRef<"VerdictInterestDetails", 'String'>
    readonly periodStart: FieldRef<"VerdictInterestDetails", 'DateTime'>
    readonly periodEnd: FieldRef<"VerdictInterestDetails", 'DateTime'>
    readonly days: FieldRef<"VerdictInterestDetails", 'Int'>
    readonly annualRate: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly proportionalRate: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly baseAmount: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly interest: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly total: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly verdictInterestId: FieldRef<"VerdictInterestDetails", 'String'>
    readonly createdAt: FieldRef<"VerdictInterestDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"VerdictInterestDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerdictInterestDetails findUnique
   */
  export type VerdictInterestDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails findUniqueOrThrow
   */
  export type VerdictInterestDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails findFirst
   */
  export type VerdictInterestDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterestDetails.
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterestDetails.
     */
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterestDetails findFirstOrThrow
   */
  export type VerdictInterestDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterestDetails.
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterestDetails.
     */
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterestDetails findMany
   */
  export type VerdictInterestDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictInterestDetails.
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterestDetails create
   */
  export type VerdictInterestDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsCreateInput, VerdictInterestDetailsUncheckedCreateInput>
  }

  /**
   * VerdictInterestDetails createMany
   */
  export type VerdictInterestDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictInterestDetails.
     */
    data: VerdictInterestDetailsCreateManyInput | VerdictInterestDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictInterestDetails createManyAndReturn
   */
  export type VerdictInterestDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictInterestDetails.
     */
    data: VerdictInterestDetailsCreateManyInput | VerdictInterestDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterestDetails update
   */
  export type VerdictInterestDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsUpdateInput, VerdictInterestDetailsUncheckedUpdateInput>
    /**
     * Choose, which VerdictInterestDetails to update.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails updateMany
   */
  export type VerdictInterestDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsUpdateManyMutationInput, VerdictInterestDetailsUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterestDetails to update
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * Limit how many VerdictInterestDetails to update.
     */
    limit?: number
  }

  /**
   * VerdictInterestDetails updateManyAndReturn
   */
  export type VerdictInterestDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * The data used to update VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsUpdateManyMutationInput, VerdictInterestDetailsUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterestDetails to update
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * Limit how many VerdictInterestDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterestDetails upsert
   */
  export type VerdictInterestDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictInterestDetails to update in case it exists.
     */
    where: VerdictInterestDetailsWhereUniqueInput
    /**
     * In case the VerdictInterestDetails found by the `where` argument doesn't exist, create a new VerdictInterestDetails with this data.
     */
    create: XOR<VerdictInterestDetailsCreateInput, VerdictInterestDetailsUncheckedCreateInput>
    /**
     * In case the VerdictInterestDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictInterestDetailsUpdateInput, VerdictInterestDetailsUncheckedUpdateInput>
  }

  /**
   * VerdictInterestDetails delete
   */
  export type VerdictInterestDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter which VerdictInterestDetails to delete.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails deleteMany
   */
  export type VerdictInterestDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterestDetails to delete
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * Limit how many VerdictInterestDetails to delete.
     */
    limit?: number
  }

  /**
   * VerdictInterestDetails without action
   */
  export type VerdictInterestDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
  }


  /**
   * Model VerdictEmbargo
   */

  export type AggregateVerdictEmbargo = {
    _count: VerdictEmbargoCountAggregateOutputType | null
    _avg: VerdictEmbargoAvgAggregateOutputType | null
    _sum: VerdictEmbargoSumAggregateOutputType | null
    _min: VerdictEmbargoMinAggregateOutputType | null
    _max: VerdictEmbargoMaxAggregateOutputType | null
  }

  export type VerdictEmbargoAvgAggregateOutputType = {
    embargoAmount: number | null
    totalAmount: number | null
  }

  export type VerdictEmbargoSumAggregateOutputType = {
    embargoAmount: number | null
    totalAmount: number | null
  }

  export type VerdictEmbargoMinAggregateOutputType = {
    id: string | null
    verdictId: string | null
    companyName: string | null
    companyPhone: string | null
    companyEmail: string | null
    companyAddress: string | null
    embargoType: string | null
    embargoDate: Date | null
    embargoAmount: number | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictEmbargoMaxAggregateOutputType = {
    id: string | null
    verdictId: string | null
    companyName: string | null
    companyPhone: string | null
    companyEmail: string | null
    companyAddress: string | null
    embargoType: string | null
    embargoDate: Date | null
    embargoAmount: number | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictEmbargoCountAggregateOutputType = {
    id: number
    verdictId: number
    companyName: number
    companyPhone: number
    companyEmail: number
    companyAddress: number
    embargoType: number
    embargoDate: number
    embargoAmount: number
    totalAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerdictEmbargoAvgAggregateInputType = {
    embargoAmount?: true
    totalAmount?: true
  }

  export type VerdictEmbargoSumAggregateInputType = {
    embargoAmount?: true
    totalAmount?: true
  }

  export type VerdictEmbargoMinAggregateInputType = {
    id?: true
    verdictId?: true
    companyName?: true
    companyPhone?: true
    companyEmail?: true
    companyAddress?: true
    embargoType?: true
    embargoDate?: true
    embargoAmount?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictEmbargoMaxAggregateInputType = {
    id?: true
    verdictId?: true
    companyName?: true
    companyPhone?: true
    companyEmail?: true
    companyAddress?: true
    embargoType?: true
    embargoDate?: true
    embargoAmount?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictEmbargoCountAggregateInputType = {
    id?: true
    verdictId?: true
    companyName?: true
    companyPhone?: true
    companyEmail?: true
    companyAddress?: true
    embargoType?: true
    embargoDate?: true
    embargoAmount?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerdictEmbargoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictEmbargo to aggregate.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictEmbargos
    **/
    _count?: true | VerdictEmbargoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictEmbargoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictEmbargoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictEmbargoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictEmbargoMaxAggregateInputType
  }

  export type GetVerdictEmbargoAggregateType<T extends VerdictEmbargoAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictEmbargo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictEmbargo[P]>
      : GetScalarType<T[P], AggregateVerdictEmbargo[P]>
  }




  export type VerdictEmbargoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictEmbargoWhereInput
    orderBy?: VerdictEmbargoOrderByWithAggregationInput | VerdictEmbargoOrderByWithAggregationInput[]
    by: VerdictEmbargoScalarFieldEnum[] | VerdictEmbargoScalarFieldEnum
    having?: VerdictEmbargoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictEmbargoCountAggregateInputType | true
    _avg?: VerdictEmbargoAvgAggregateInputType
    _sum?: VerdictEmbargoSumAggregateInputType
    _min?: VerdictEmbargoMinAggregateInputType
    _max?: VerdictEmbargoMaxAggregateInputType
  }

  export type VerdictEmbargoGroupByOutputType = {
    id: string
    verdictId: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date
    embargoAmount: number
    totalAmount: number
    createdAt: Date
    updatedAt: Date
    _count: VerdictEmbargoCountAggregateOutputType | null
    _avg: VerdictEmbargoAvgAggregateOutputType | null
    _sum: VerdictEmbargoSumAggregateOutputType | null
    _min: VerdictEmbargoMinAggregateOutputType | null
    _max: VerdictEmbargoMaxAggregateOutputType | null
  }

  type GetVerdictEmbargoGroupByPayload<T extends VerdictEmbargoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictEmbargoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictEmbargoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictEmbargoGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictEmbargoGroupByOutputType[P]>
        }
      >
    >


  export type VerdictEmbargoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    companyName?: boolean
    companyPhone?: boolean
    companyEmail?: boolean
    companyAddress?: boolean
    embargoType?: boolean
    embargoDate?: boolean
    embargoAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictEmbargo"]>

  export type VerdictEmbargoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    companyName?: boolean
    companyPhone?: boolean
    companyEmail?: boolean
    companyAddress?: boolean
    embargoType?: boolean
    embargoDate?: boolean
    embargoAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictEmbargo"]>

  export type VerdictEmbargoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    companyName?: boolean
    companyPhone?: boolean
    companyEmail?: boolean
    companyAddress?: boolean
    embargoType?: boolean
    embargoDate?: boolean
    embargoAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictEmbargo"]>

  export type VerdictEmbargoSelectScalar = {
    id?: boolean
    verdictId?: boolean
    companyName?: boolean
    companyPhone?: boolean
    companyEmail?: boolean
    companyAddress?: boolean
    embargoType?: boolean
    embargoDate?: boolean
    embargoAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerdictEmbargoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "verdictId" | "companyName" | "companyPhone" | "companyEmail" | "companyAddress" | "embargoType" | "embargoDate" | "embargoAmount" | "totalAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["verdictEmbargo"]>
  export type VerdictEmbargoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictEmbargoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictEmbargoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }

  export type $VerdictEmbargoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictEmbargo"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      verdictId: string
      companyName: string
      companyPhone: string
      companyEmail: string
      companyAddress: string
      embargoType: string
      embargoDate: Date
      embargoAmount: number
      totalAmount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verdictEmbargo"]>
    composites: {}
  }

  type VerdictEmbargoGetPayload<S extends boolean | null | undefined | VerdictEmbargoDefaultArgs> = $Result.GetResult<Prisma.$VerdictEmbargoPayload, S>

  type VerdictEmbargoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictEmbargoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictEmbargoCountAggregateInputType | true
    }

  export interface VerdictEmbargoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictEmbargo'], meta: { name: 'VerdictEmbargo' } }
    /**
     * Find zero or one VerdictEmbargo that matches the filter.
     * @param {VerdictEmbargoFindUniqueArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictEmbargoFindUniqueArgs>(args: SelectSubset<T, VerdictEmbargoFindUniqueArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictEmbargo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictEmbargoFindUniqueOrThrowArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictEmbargoFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictEmbargoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictEmbargo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoFindFirstArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictEmbargoFindFirstArgs>(args?: SelectSubset<T, VerdictEmbargoFindFirstArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictEmbargo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoFindFirstOrThrowArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictEmbargoFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictEmbargoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictEmbargos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictEmbargos
     * const verdictEmbargos = await prisma.verdictEmbargo.findMany()
     * 
     * // Get first 10 VerdictEmbargos
     * const verdictEmbargos = await prisma.verdictEmbargo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictEmbargoWithIdOnly = await prisma.verdictEmbargo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictEmbargoFindManyArgs>(args?: SelectSubset<T, VerdictEmbargoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictEmbargo.
     * @param {VerdictEmbargoCreateArgs} args - Arguments to create a VerdictEmbargo.
     * @example
     * // Create one VerdictEmbargo
     * const VerdictEmbargo = await prisma.verdictEmbargo.create({
     *   data: {
     *     // ... data to create a VerdictEmbargo
     *   }
     * })
     * 
     */
    create<T extends VerdictEmbargoCreateArgs>(args: SelectSubset<T, VerdictEmbargoCreateArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictEmbargos.
     * @param {VerdictEmbargoCreateManyArgs} args - Arguments to create many VerdictEmbargos.
     * @example
     * // Create many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictEmbargoCreateManyArgs>(args?: SelectSubset<T, VerdictEmbargoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictEmbargos and returns the data saved in the database.
     * @param {VerdictEmbargoCreateManyAndReturnArgs} args - Arguments to create many VerdictEmbargos.
     * @example
     * // Create many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictEmbargos and only return the `id`
     * const verdictEmbargoWithIdOnly = await prisma.verdictEmbargo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictEmbargoCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictEmbargoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictEmbargo.
     * @param {VerdictEmbargoDeleteArgs} args - Arguments to delete one VerdictEmbargo.
     * @example
     * // Delete one VerdictEmbargo
     * const VerdictEmbargo = await prisma.verdictEmbargo.delete({
     *   where: {
     *     // ... filter to delete one VerdictEmbargo
     *   }
     * })
     * 
     */
    delete<T extends VerdictEmbargoDeleteArgs>(args: SelectSubset<T, VerdictEmbargoDeleteArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictEmbargo.
     * @param {VerdictEmbargoUpdateArgs} args - Arguments to update one VerdictEmbargo.
     * @example
     * // Update one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictEmbargoUpdateArgs>(args: SelectSubset<T, VerdictEmbargoUpdateArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictEmbargos.
     * @param {VerdictEmbargoDeleteManyArgs} args - Arguments to filter VerdictEmbargos to delete.
     * @example
     * // Delete a few VerdictEmbargos
     * const { count } = await prisma.verdictEmbargo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictEmbargoDeleteManyArgs>(args?: SelectSubset<T, VerdictEmbargoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictEmbargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictEmbargoUpdateManyArgs>(args: SelectSubset<T, VerdictEmbargoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictEmbargos and returns the data updated in the database.
     * @param {VerdictEmbargoUpdateManyAndReturnArgs} args - Arguments to update many VerdictEmbargos.
     * @example
     * // Update many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictEmbargos and only return the `id`
     * const verdictEmbargoWithIdOnly = await prisma.verdictEmbargo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictEmbargoUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictEmbargoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictEmbargo.
     * @param {VerdictEmbargoUpsertArgs} args - Arguments to update or create a VerdictEmbargo.
     * @example
     * // Update or create a VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.upsert({
     *   create: {
     *     // ... data to create a VerdictEmbargo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictEmbargo we want to update
     *   }
     * })
     */
    upsert<T extends VerdictEmbargoUpsertArgs>(args: SelectSubset<T, VerdictEmbargoUpsertArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictEmbargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoCountArgs} args - Arguments to filter VerdictEmbargos to count.
     * @example
     * // Count the number of VerdictEmbargos
     * const count = await prisma.verdictEmbargo.count({
     *   where: {
     *     // ... the filter for the VerdictEmbargos we want to count
     *   }
     * })
    **/
    count<T extends VerdictEmbargoCountArgs>(
      args?: Subset<T, VerdictEmbargoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictEmbargoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictEmbargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictEmbargoAggregateArgs>(args: Subset<T, VerdictEmbargoAggregateArgs>): Prisma.PrismaPromise<GetVerdictEmbargoAggregateType<T>>

    /**
     * Group by VerdictEmbargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictEmbargoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictEmbargoGroupByArgs['orderBy'] }
        : { orderBy?: VerdictEmbargoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictEmbargoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictEmbargoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictEmbargo model
   */
  readonly fields: VerdictEmbargoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictEmbargo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictEmbargoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictDefaultArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictEmbargo model
   */
  interface VerdictEmbargoFieldRefs {
    readonly id: FieldRef<"VerdictEmbargo", 'String'>
    readonly verdictId: FieldRef<"VerdictEmbargo", 'String'>
    readonly companyName: FieldRef<"VerdictEmbargo", 'String'>
    readonly companyPhone: FieldRef<"VerdictEmbargo", 'String'>
    readonly companyEmail: FieldRef<"VerdictEmbargo", 'String'>
    readonly companyAddress: FieldRef<"VerdictEmbargo", 'String'>
    readonly embargoType: FieldRef<"VerdictEmbargo", 'String'>
    readonly embargoDate: FieldRef<"VerdictEmbargo", 'DateTime'>
    readonly embargoAmount: FieldRef<"VerdictEmbargo", 'Float'>
    readonly totalAmount: FieldRef<"VerdictEmbargo", 'Float'>
    readonly createdAt: FieldRef<"VerdictEmbargo", 'DateTime'>
    readonly updatedAt: FieldRef<"VerdictEmbargo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerdictEmbargo findUnique
   */
  export type VerdictEmbargoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo findUniqueOrThrow
   */
  export type VerdictEmbargoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo findFirst
   */
  export type VerdictEmbargoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictEmbargos.
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictEmbargos.
     */
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * VerdictEmbargo findFirstOrThrow
   */
  export type VerdictEmbargoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictEmbargos.
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictEmbargos.
     */
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * VerdictEmbargo findMany
   */
  export type VerdictEmbargoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargos to fetch.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictEmbargos.
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * VerdictEmbargo create
   */
  export type VerdictEmbargoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictEmbargo.
     */
    data: XOR<VerdictEmbargoCreateInput, VerdictEmbargoUncheckedCreateInput>
  }

  /**
   * VerdictEmbargo createMany
   */
  export type VerdictEmbargoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictEmbargos.
     */
    data: VerdictEmbargoCreateManyInput | VerdictEmbargoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictEmbargo createManyAndReturn
   */
  export type VerdictEmbargoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictEmbargos.
     */
    data: VerdictEmbargoCreateManyInput | VerdictEmbargoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictEmbargo update
   */
  export type VerdictEmbargoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictEmbargo.
     */
    data: XOR<VerdictEmbargoUpdateInput, VerdictEmbargoUncheckedUpdateInput>
    /**
     * Choose, which VerdictEmbargo to update.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo updateMany
   */
  export type VerdictEmbargoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictEmbargos.
     */
    data: XOR<VerdictEmbargoUpdateManyMutationInput, VerdictEmbargoUncheckedUpdateManyInput>
    /**
     * Filter which VerdictEmbargos to update
     */
    where?: VerdictEmbargoWhereInput
    /**
     * Limit how many VerdictEmbargos to update.
     */
    limit?: number
  }

  /**
   * VerdictEmbargo updateManyAndReturn
   */
  export type VerdictEmbargoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * The data used to update VerdictEmbargos.
     */
    data: XOR<VerdictEmbargoUpdateManyMutationInput, VerdictEmbargoUncheckedUpdateManyInput>
    /**
     * Filter which VerdictEmbargos to update
     */
    where?: VerdictEmbargoWhereInput
    /**
     * Limit how many VerdictEmbargos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictEmbargo upsert
   */
  export type VerdictEmbargoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictEmbargo to update in case it exists.
     */
    where: VerdictEmbargoWhereUniqueInput
    /**
     * In case the VerdictEmbargo found by the `where` argument doesn't exist, create a new VerdictEmbargo with this data.
     */
    create: XOR<VerdictEmbargoCreateInput, VerdictEmbargoUncheckedCreateInput>
    /**
     * In case the VerdictEmbargo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictEmbargoUpdateInput, VerdictEmbargoUncheckedUpdateInput>
  }

  /**
   * VerdictEmbargo delete
   */
  export type VerdictEmbargoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter which VerdictEmbargo to delete.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo deleteMany
   */
  export type VerdictEmbargoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictEmbargos to delete
     */
    where?: VerdictEmbargoWhereInput
    /**
     * Limit how many VerdictEmbargos to delete.
     */
    limit?: number
  }

  /**
   * VerdictEmbargo without action
   */
  export type VerdictEmbargoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
  }


  /**
   * Model VerdictBailiffServices
   */

  export type AggregateVerdictBailiffServices = {
    _count: VerdictBailiffServicesCountAggregateOutputType | null
    _avg: VerdictBailiffServicesAvgAggregateOutputType | null
    _sum: VerdictBailiffServicesSumAggregateOutputType | null
    _min: VerdictBailiffServicesMinAggregateOutputType | null
    _max: VerdictBailiffServicesMaxAggregateOutputType | null
  }

  export type VerdictBailiffServicesAvgAggregateOutputType = {
    serviceCost: number | null
  }

  export type VerdictBailiffServicesSumAggregateOutputType = {
    serviceCost: number | null
  }

  export type VerdictBailiffServicesMinAggregateOutputType = {
    id: string | null
    verdictId: string | null
    serviceType: string | null
    serviceCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictBailiffServicesMaxAggregateOutputType = {
    id: string | null
    verdictId: string | null
    serviceType: string | null
    serviceCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerdictBailiffServicesCountAggregateOutputType = {
    id: number
    verdictId: number
    serviceType: number
    serviceCost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerdictBailiffServicesAvgAggregateInputType = {
    serviceCost?: true
  }

  export type VerdictBailiffServicesSumAggregateInputType = {
    serviceCost?: true
  }

  export type VerdictBailiffServicesMinAggregateInputType = {
    id?: true
    verdictId?: true
    serviceType?: true
    serviceCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictBailiffServicesMaxAggregateInputType = {
    id?: true
    verdictId?: true
    serviceType?: true
    serviceCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerdictBailiffServicesCountAggregateInputType = {
    id?: true
    verdictId?: true
    serviceType?: true
    serviceCost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerdictBailiffServicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictBailiffServices to aggregate.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictBailiffServices
    **/
    _count?: true | VerdictBailiffServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictBailiffServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictBailiffServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictBailiffServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictBailiffServicesMaxAggregateInputType
  }

  export type GetVerdictBailiffServicesAggregateType<T extends VerdictBailiffServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictBailiffServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictBailiffServices[P]>
      : GetScalarType<T[P], AggregateVerdictBailiffServices[P]>
  }




  export type VerdictBailiffServicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictBailiffServicesWhereInput
    orderBy?: VerdictBailiffServicesOrderByWithAggregationInput | VerdictBailiffServicesOrderByWithAggregationInput[]
    by: VerdictBailiffServicesScalarFieldEnum[] | VerdictBailiffServicesScalarFieldEnum
    having?: VerdictBailiffServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictBailiffServicesCountAggregateInputType | true
    _avg?: VerdictBailiffServicesAvgAggregateInputType
    _sum?: VerdictBailiffServicesSumAggregateInputType
    _min?: VerdictBailiffServicesMinAggregateInputType
    _max?: VerdictBailiffServicesMaxAggregateInputType
  }

  export type VerdictBailiffServicesGroupByOutputType = {
    id: string
    verdictId: string
    serviceType: string
    serviceCost: number
    createdAt: Date
    updatedAt: Date
    _count: VerdictBailiffServicesCountAggregateOutputType | null
    _avg: VerdictBailiffServicesAvgAggregateOutputType | null
    _sum: VerdictBailiffServicesSumAggregateOutputType | null
    _min: VerdictBailiffServicesMinAggregateOutputType | null
    _max: VerdictBailiffServicesMaxAggregateOutputType | null
  }

  type GetVerdictBailiffServicesGroupByPayload<T extends VerdictBailiffServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictBailiffServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictBailiffServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictBailiffServicesGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictBailiffServicesGroupByOutputType[P]>
        }
      >
    >


  export type VerdictBailiffServicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    serviceType?: boolean
    serviceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictBailiffServices"]>

  export type VerdictBailiffServicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    serviceType?: boolean
    serviceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictBailiffServices"]>

  export type VerdictBailiffServicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    serviceType?: boolean
    serviceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictBailiffServices"]>

  export type VerdictBailiffServicesSelectScalar = {
    id?: boolean
    verdictId?: boolean
    serviceType?: boolean
    serviceCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerdictBailiffServicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "verdictId" | "serviceType" | "serviceCost" | "createdAt" | "updatedAt", ExtArgs["result"]["verdictBailiffServices"]>
  export type VerdictBailiffServicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictBailiffServicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictBailiffServicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }

  export type $VerdictBailiffServicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictBailiffServices"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      verdictId: string
      serviceType: string
      serviceCost: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verdictBailiffServices"]>
    composites: {}
  }

  type VerdictBailiffServicesGetPayload<S extends boolean | null | undefined | VerdictBailiffServicesDefaultArgs> = $Result.GetResult<Prisma.$VerdictBailiffServicesPayload, S>

  type VerdictBailiffServicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictBailiffServicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictBailiffServicesCountAggregateInputType | true
    }

  export interface VerdictBailiffServicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictBailiffServices'], meta: { name: 'VerdictBailiffServices' } }
    /**
     * Find zero or one VerdictBailiffServices that matches the filter.
     * @param {VerdictBailiffServicesFindUniqueArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictBailiffServicesFindUniqueArgs>(args: SelectSubset<T, VerdictBailiffServicesFindUniqueArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictBailiffServices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictBailiffServicesFindUniqueOrThrowArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictBailiffServicesFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictBailiffServicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictBailiffServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesFindFirstArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictBailiffServicesFindFirstArgs>(args?: SelectSubset<T, VerdictBailiffServicesFindFirstArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictBailiffServices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesFindFirstOrThrowArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictBailiffServicesFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictBailiffServicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictBailiffServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findMany()
     * 
     * // Get first 10 VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictBailiffServicesWithIdOnly = await prisma.verdictBailiffServices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictBailiffServicesFindManyArgs>(args?: SelectSubset<T, VerdictBailiffServicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictBailiffServices.
     * @param {VerdictBailiffServicesCreateArgs} args - Arguments to create a VerdictBailiffServices.
     * @example
     * // Create one VerdictBailiffServices
     * const VerdictBailiffServices = await prisma.verdictBailiffServices.create({
     *   data: {
     *     // ... data to create a VerdictBailiffServices
     *   }
     * })
     * 
     */
    create<T extends VerdictBailiffServicesCreateArgs>(args: SelectSubset<T, VerdictBailiffServicesCreateArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictBailiffServices.
     * @param {VerdictBailiffServicesCreateManyArgs} args - Arguments to create many VerdictBailiffServices.
     * @example
     * // Create many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictBailiffServicesCreateManyArgs>(args?: SelectSubset<T, VerdictBailiffServicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictBailiffServices and returns the data saved in the database.
     * @param {VerdictBailiffServicesCreateManyAndReturnArgs} args - Arguments to create many VerdictBailiffServices.
     * @example
     * // Create many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictBailiffServices and only return the `id`
     * const verdictBailiffServicesWithIdOnly = await prisma.verdictBailiffServices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictBailiffServicesCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictBailiffServicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictBailiffServices.
     * @param {VerdictBailiffServicesDeleteArgs} args - Arguments to delete one VerdictBailiffServices.
     * @example
     * // Delete one VerdictBailiffServices
     * const VerdictBailiffServices = await prisma.verdictBailiffServices.delete({
     *   where: {
     *     // ... filter to delete one VerdictBailiffServices
     *   }
     * })
     * 
     */
    delete<T extends VerdictBailiffServicesDeleteArgs>(args: SelectSubset<T, VerdictBailiffServicesDeleteArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictBailiffServices.
     * @param {VerdictBailiffServicesUpdateArgs} args - Arguments to update one VerdictBailiffServices.
     * @example
     * // Update one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictBailiffServicesUpdateArgs>(args: SelectSubset<T, VerdictBailiffServicesUpdateArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictBailiffServices.
     * @param {VerdictBailiffServicesDeleteManyArgs} args - Arguments to filter VerdictBailiffServices to delete.
     * @example
     * // Delete a few VerdictBailiffServices
     * const { count } = await prisma.verdictBailiffServices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictBailiffServicesDeleteManyArgs>(args?: SelectSubset<T, VerdictBailiffServicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictBailiffServicesUpdateManyArgs>(args: SelectSubset<T, VerdictBailiffServicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictBailiffServices and returns the data updated in the database.
     * @param {VerdictBailiffServicesUpdateManyAndReturnArgs} args - Arguments to update many VerdictBailiffServices.
     * @example
     * // Update many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictBailiffServices and only return the `id`
     * const verdictBailiffServicesWithIdOnly = await prisma.verdictBailiffServices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictBailiffServicesUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictBailiffServicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictBailiffServices.
     * @param {VerdictBailiffServicesUpsertArgs} args - Arguments to update or create a VerdictBailiffServices.
     * @example
     * // Update or create a VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.upsert({
     *   create: {
     *     // ... data to create a VerdictBailiffServices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictBailiffServices we want to update
     *   }
     * })
     */
    upsert<T extends VerdictBailiffServicesUpsertArgs>(args: SelectSubset<T, VerdictBailiffServicesUpsertArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesCountArgs} args - Arguments to filter VerdictBailiffServices to count.
     * @example
     * // Count the number of VerdictBailiffServices
     * const count = await prisma.verdictBailiffServices.count({
     *   where: {
     *     // ... the filter for the VerdictBailiffServices we want to count
     *   }
     * })
    **/
    count<T extends VerdictBailiffServicesCountArgs>(
      args?: Subset<T, VerdictBailiffServicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictBailiffServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictBailiffServicesAggregateArgs>(args: Subset<T, VerdictBailiffServicesAggregateArgs>): Prisma.PrismaPromise<GetVerdictBailiffServicesAggregateType<T>>

    /**
     * Group by VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictBailiffServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictBailiffServicesGroupByArgs['orderBy'] }
        : { orderBy?: VerdictBailiffServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictBailiffServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictBailiffServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictBailiffServices model
   */
  readonly fields: VerdictBailiffServicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictBailiffServices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictBailiffServicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictDefaultArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictBailiffServices model
   */
  interface VerdictBailiffServicesFieldRefs {
    readonly id: FieldRef<"VerdictBailiffServices", 'String'>
    readonly verdictId: FieldRef<"VerdictBailiffServices", 'String'>
    readonly serviceType: FieldRef<"VerdictBailiffServices", 'String'>
    readonly serviceCost: FieldRef<"VerdictBailiffServices", 'Float'>
    readonly createdAt: FieldRef<"VerdictBailiffServices", 'DateTime'>
    readonly updatedAt: FieldRef<"VerdictBailiffServices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerdictBailiffServices findUnique
   */
  export type VerdictBailiffServicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices findUniqueOrThrow
   */
  export type VerdictBailiffServicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices findFirst
   */
  export type VerdictBailiffServicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictBailiffServices.
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictBailiffServices.
     */
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * VerdictBailiffServices findFirstOrThrow
   */
  export type VerdictBailiffServicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictBailiffServices.
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictBailiffServices.
     */
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * VerdictBailiffServices findMany
   */
  export type VerdictBailiffServicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictBailiffServices.
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * VerdictBailiffServices create
   */
  export type VerdictBailiffServicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesCreateInput, VerdictBailiffServicesUncheckedCreateInput>
  }

  /**
   * VerdictBailiffServices createMany
   */
  export type VerdictBailiffServicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictBailiffServices.
     */
    data: VerdictBailiffServicesCreateManyInput | VerdictBailiffServicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictBailiffServices createManyAndReturn
   */
  export type VerdictBailiffServicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictBailiffServices.
     */
    data: VerdictBailiffServicesCreateManyInput | VerdictBailiffServicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictBailiffServices update
   */
  export type VerdictBailiffServicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesUpdateInput, VerdictBailiffServicesUncheckedUpdateInput>
    /**
     * Choose, which VerdictBailiffServices to update.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices updateMany
   */
  export type VerdictBailiffServicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesUpdateManyMutationInput, VerdictBailiffServicesUncheckedUpdateManyInput>
    /**
     * Filter which VerdictBailiffServices to update
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * Limit how many VerdictBailiffServices to update.
     */
    limit?: number
  }

  /**
   * VerdictBailiffServices updateManyAndReturn
   */
  export type VerdictBailiffServicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * The data used to update VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesUpdateManyMutationInput, VerdictBailiffServicesUncheckedUpdateManyInput>
    /**
     * Filter which VerdictBailiffServices to update
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * Limit how many VerdictBailiffServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictBailiffServices upsert
   */
  export type VerdictBailiffServicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictBailiffServices to update in case it exists.
     */
    where: VerdictBailiffServicesWhereUniqueInput
    /**
     * In case the VerdictBailiffServices found by the `where` argument doesn't exist, create a new VerdictBailiffServices with this data.
     */
    create: XOR<VerdictBailiffServicesCreateInput, VerdictBailiffServicesUncheckedCreateInput>
    /**
     * In case the VerdictBailiffServices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictBailiffServicesUpdateInput, VerdictBailiffServicesUncheckedUpdateInput>
  }

  /**
   * VerdictBailiffServices delete
   */
  export type VerdictBailiffServicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter which VerdictBailiffServices to delete.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices deleteMany
   */
  export type VerdictBailiffServicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictBailiffServices to delete
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * Limit how many VerdictBailiffServices to delete.
     */
    limit?: number
  }

  /**
   * VerdictBailiffServices without action
   */
  export type VerdictBailiffServicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
  }


  /**
   * Model VerdictAttachment
   */

  export type AggregateVerdictAttachment = {
    _count: VerdictAttachmentCountAggregateOutputType | null
    _avg: VerdictAttachmentAvgAggregateOutputType | null
    _sum: VerdictAttachmentSumAggregateOutputType | null
    _min: VerdictAttachmentMinAggregateOutputType | null
    _max: VerdictAttachmentMaxAggregateOutputType | null
  }

  export type VerdictAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type VerdictAttachmentSumAggregateOutputType = {
    fileSize: bigint | null
  }

  export type VerdictAttachmentMinAggregateOutputType = {
    id: string | null
    verdictId: string | null
    filePath: string | null
    fileSize: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    fileName: string | null
  }

  export type VerdictAttachmentMaxAggregateOutputType = {
    id: string | null
    verdictId: string | null
    filePath: string | null
    fileSize: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    fileName: string | null
  }

  export type VerdictAttachmentCountAggregateOutputType = {
    id: number
    verdictId: number
    filePath: number
    fileSize: number
    createdAt: number
    updatedAt: number
    fileName: number
    _all: number
  }


  export type VerdictAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type VerdictAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type VerdictAttachmentMinAggregateInputType = {
    id?: true
    verdictId?: true
    filePath?: true
    fileSize?: true
    createdAt?: true
    updatedAt?: true
    fileName?: true
  }

  export type VerdictAttachmentMaxAggregateInputType = {
    id?: true
    verdictId?: true
    filePath?: true
    fileSize?: true
    createdAt?: true
    updatedAt?: true
    fileName?: true
  }

  export type VerdictAttachmentCountAggregateInputType = {
    id?: true
    verdictId?: true
    filePath?: true
    fileSize?: true
    createdAt?: true
    updatedAt?: true
    fileName?: true
    _all?: true
  }

  export type VerdictAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictAttachment to aggregate.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictAttachments
    **/
    _count?: true | VerdictAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictAttachmentMaxAggregateInputType
  }

  export type GetVerdictAttachmentAggregateType<T extends VerdictAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictAttachment[P]>
      : GetScalarType<T[P], AggregateVerdictAttachment[P]>
  }




  export type VerdictAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictAttachmentWhereInput
    orderBy?: VerdictAttachmentOrderByWithAggregationInput | VerdictAttachmentOrderByWithAggregationInput[]
    by: VerdictAttachmentScalarFieldEnum[] | VerdictAttachmentScalarFieldEnum
    having?: VerdictAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictAttachmentCountAggregateInputType | true
    _avg?: VerdictAttachmentAvgAggregateInputType
    _sum?: VerdictAttachmentSumAggregateInputType
    _min?: VerdictAttachmentMinAggregateInputType
    _max?: VerdictAttachmentMaxAggregateInputType
  }

  export type VerdictAttachmentGroupByOutputType = {
    id: string
    verdictId: string
    filePath: string
    fileSize: bigint
    createdAt: Date
    updatedAt: Date
    fileName: string
    _count: VerdictAttachmentCountAggregateOutputType | null
    _avg: VerdictAttachmentAvgAggregateOutputType | null
    _sum: VerdictAttachmentSumAggregateOutputType | null
    _min: VerdictAttachmentMinAggregateOutputType | null
    _max: VerdictAttachmentMaxAggregateOutputType | null
  }

  type GetVerdictAttachmentGroupByPayload<T extends VerdictAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type VerdictAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    filePath?: boolean
    fileSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictAttachment"]>

  export type VerdictAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    filePath?: boolean
    fileSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictAttachment"]>

  export type VerdictAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdictId?: boolean
    filePath?: boolean
    fileSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictAttachment"]>

  export type VerdictAttachmentSelectScalar = {
    id?: boolean
    verdictId?: boolean
    filePath?: boolean
    fileSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fileName?: boolean
  }

  export type VerdictAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "verdictId" | "filePath" | "fileSize" | "createdAt" | "updatedAt" | "fileName", ExtArgs["result"]["verdictAttachment"]>
  export type VerdictAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }

  export type $VerdictAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictAttachment"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      verdictId: string
      filePath: string
      fileSize: bigint
      createdAt: Date
      updatedAt: Date
      fileName: string
    }, ExtArgs["result"]["verdictAttachment"]>
    composites: {}
  }

  type VerdictAttachmentGetPayload<S extends boolean | null | undefined | VerdictAttachmentDefaultArgs> = $Result.GetResult<Prisma.$VerdictAttachmentPayload, S>

  type VerdictAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictAttachmentCountAggregateInputType | true
    }

  export interface VerdictAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictAttachment'], meta: { name: 'VerdictAttachment' } }
    /**
     * Find zero or one VerdictAttachment that matches the filter.
     * @param {VerdictAttachmentFindUniqueArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictAttachmentFindUniqueArgs>(args: SelectSubset<T, VerdictAttachmentFindUniqueArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictAttachmentFindUniqueOrThrowArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentFindFirstArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictAttachmentFindFirstArgs>(args?: SelectSubset<T, VerdictAttachmentFindFirstArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentFindFirstOrThrowArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictAttachments
     * const verdictAttachments = await prisma.verdictAttachment.findMany()
     * 
     * // Get first 10 VerdictAttachments
     * const verdictAttachments = await prisma.verdictAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictAttachmentWithIdOnly = await prisma.verdictAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictAttachmentFindManyArgs>(args?: SelectSubset<T, VerdictAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictAttachment.
     * @param {VerdictAttachmentCreateArgs} args - Arguments to create a VerdictAttachment.
     * @example
     * // Create one VerdictAttachment
     * const VerdictAttachment = await prisma.verdictAttachment.create({
     *   data: {
     *     // ... data to create a VerdictAttachment
     *   }
     * })
     * 
     */
    create<T extends VerdictAttachmentCreateArgs>(args: SelectSubset<T, VerdictAttachmentCreateArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictAttachments.
     * @param {VerdictAttachmentCreateManyArgs} args - Arguments to create many VerdictAttachments.
     * @example
     * // Create many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictAttachmentCreateManyArgs>(args?: SelectSubset<T, VerdictAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictAttachments and returns the data saved in the database.
     * @param {VerdictAttachmentCreateManyAndReturnArgs} args - Arguments to create many VerdictAttachments.
     * @example
     * // Create many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictAttachments and only return the `id`
     * const verdictAttachmentWithIdOnly = await prisma.verdictAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictAttachment.
     * @param {VerdictAttachmentDeleteArgs} args - Arguments to delete one VerdictAttachment.
     * @example
     * // Delete one VerdictAttachment
     * const VerdictAttachment = await prisma.verdictAttachment.delete({
     *   where: {
     *     // ... filter to delete one VerdictAttachment
     *   }
     * })
     * 
     */
    delete<T extends VerdictAttachmentDeleteArgs>(args: SelectSubset<T, VerdictAttachmentDeleteArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictAttachment.
     * @param {VerdictAttachmentUpdateArgs} args - Arguments to update one VerdictAttachment.
     * @example
     * // Update one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictAttachmentUpdateArgs>(args: SelectSubset<T, VerdictAttachmentUpdateArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictAttachments.
     * @param {VerdictAttachmentDeleteManyArgs} args - Arguments to filter VerdictAttachments to delete.
     * @example
     * // Delete a few VerdictAttachments
     * const { count } = await prisma.verdictAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictAttachmentDeleteManyArgs>(args?: SelectSubset<T, VerdictAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictAttachmentUpdateManyArgs>(args: SelectSubset<T, VerdictAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictAttachments and returns the data updated in the database.
     * @param {VerdictAttachmentUpdateManyAndReturnArgs} args - Arguments to update many VerdictAttachments.
     * @example
     * // Update many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictAttachments and only return the `id`
     * const verdictAttachmentWithIdOnly = await prisma.verdictAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictAttachment.
     * @param {VerdictAttachmentUpsertArgs} args - Arguments to update or create a VerdictAttachment.
     * @example
     * // Update or create a VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.upsert({
     *   create: {
     *     // ... data to create a VerdictAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictAttachment we want to update
     *   }
     * })
     */
    upsert<T extends VerdictAttachmentUpsertArgs>(args: SelectSubset<T, VerdictAttachmentUpsertArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentCountArgs} args - Arguments to filter VerdictAttachments to count.
     * @example
     * // Count the number of VerdictAttachments
     * const count = await prisma.verdictAttachment.count({
     *   where: {
     *     // ... the filter for the VerdictAttachments we want to count
     *   }
     * })
    **/
    count<T extends VerdictAttachmentCountArgs>(
      args?: Subset<T, VerdictAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictAttachmentAggregateArgs>(args: Subset<T, VerdictAttachmentAggregateArgs>): Prisma.PrismaPromise<GetVerdictAttachmentAggregateType<T>>

    /**
     * Group by VerdictAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: VerdictAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictAttachment model
   */
  readonly fields: VerdictAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictDefaultArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictAttachment model
   */
  interface VerdictAttachmentFieldRefs {
    readonly id: FieldRef<"VerdictAttachment", 'String'>
    readonly verdictId: FieldRef<"VerdictAttachment", 'String'>
    readonly filePath: FieldRef<"VerdictAttachment", 'String'>
    readonly fileSize: FieldRef<"VerdictAttachment", 'BigInt'>
    readonly createdAt: FieldRef<"VerdictAttachment", 'DateTime'>
    readonly updatedAt: FieldRef<"VerdictAttachment", 'DateTime'>
    readonly fileName: FieldRef<"VerdictAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VerdictAttachment findUnique
   */
  export type VerdictAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment findUniqueOrThrow
   */
  export type VerdictAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment findFirst
   */
  export type VerdictAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictAttachments.
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictAttachments.
     */
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * VerdictAttachment findFirstOrThrow
   */
  export type VerdictAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictAttachments.
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictAttachments.
     */
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * VerdictAttachment findMany
   */
  export type VerdictAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachments to fetch.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictAttachments.
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * VerdictAttachment create
   */
  export type VerdictAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictAttachment.
     */
    data: XOR<VerdictAttachmentCreateInput, VerdictAttachmentUncheckedCreateInput>
  }

  /**
   * VerdictAttachment createMany
   */
  export type VerdictAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictAttachments.
     */
    data: VerdictAttachmentCreateManyInput | VerdictAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictAttachment createManyAndReturn
   */
  export type VerdictAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictAttachments.
     */
    data: VerdictAttachmentCreateManyInput | VerdictAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictAttachment update
   */
  export type VerdictAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictAttachment.
     */
    data: XOR<VerdictAttachmentUpdateInput, VerdictAttachmentUncheckedUpdateInput>
    /**
     * Choose, which VerdictAttachment to update.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment updateMany
   */
  export type VerdictAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictAttachments.
     */
    data: XOR<VerdictAttachmentUpdateManyMutationInput, VerdictAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which VerdictAttachments to update
     */
    where?: VerdictAttachmentWhereInput
    /**
     * Limit how many VerdictAttachments to update.
     */
    limit?: number
  }

  /**
   * VerdictAttachment updateManyAndReturn
   */
  export type VerdictAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update VerdictAttachments.
     */
    data: XOR<VerdictAttachmentUpdateManyMutationInput, VerdictAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which VerdictAttachments to update
     */
    where?: VerdictAttachmentWhereInput
    /**
     * Limit how many VerdictAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictAttachment upsert
   */
  export type VerdictAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictAttachment to update in case it exists.
     */
    where: VerdictAttachmentWhereUniqueInput
    /**
     * In case the VerdictAttachment found by the `where` argument doesn't exist, create a new VerdictAttachment with this data.
     */
    create: XOR<VerdictAttachmentCreateInput, VerdictAttachmentUncheckedCreateInput>
    /**
     * In case the VerdictAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictAttachmentUpdateInput, VerdictAttachmentUncheckedUpdateInput>
  }

  /**
   * VerdictAttachment delete
   */
  export type VerdictAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter which VerdictAttachment to delete.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment deleteMany
   */
  export type VerdictAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictAttachments to delete
     */
    where?: VerdictAttachmentWhereInput
    /**
     * Limit how many VerdictAttachments to delete.
     */
    limit?: number
  }

  /**
   * VerdictAttachment without action
   */
  export type VerdictAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model InterestType
   */

  export type AggregateInterestType = {
    _count: InterestTypeCountAggregateOutputType | null
    _avg: InterestTypeAvgAggregateOutputType | null
    _sum: InterestTypeSumAggregateOutputType | null
    _min: InterestTypeMinAggregateOutputType | null
    _max: InterestTypeMaxAggregateOutputType | null
  }

  export type InterestTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type InterestTypeSumAggregateOutputType = {
    id: number | null
  }

  export type InterestTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    calculationType: $Enums.CalculationTypeEnum | null
  }

  export type InterestTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    calculationType: $Enums.CalculationTypeEnum | null
  }

  export type InterestTypeCountAggregateOutputType = {
    id: number
    name: number
    calculationType: number
    _all: number
  }


  export type InterestTypeAvgAggregateInputType = {
    id?: true
  }

  export type InterestTypeSumAggregateInputType = {
    id?: true
  }

  export type InterestTypeMinAggregateInputType = {
    id?: true
    name?: true
    calculationType?: true
  }

  export type InterestTypeMaxAggregateInputType = {
    id?: true
    name?: true
    calculationType?: true
  }

  export type InterestTypeCountAggregateInputType = {
    id?: true
    name?: true
    calculationType?: true
    _all?: true
  }

  export type InterestTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestType to aggregate.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterestTypes
    **/
    _count?: true | InterestTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterestTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterestTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestTypeMaxAggregateInputType
  }

  export type GetInterestTypeAggregateType<T extends InterestTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateInterestType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterestType[P]>
      : GetScalarType<T[P], AggregateInterestType[P]>
  }




  export type InterestTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestTypeWhereInput
    orderBy?: InterestTypeOrderByWithAggregationInput | InterestTypeOrderByWithAggregationInput[]
    by: InterestTypeScalarFieldEnum[] | InterestTypeScalarFieldEnum
    having?: InterestTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestTypeCountAggregateInputType | true
    _avg?: InterestTypeAvgAggregateInputType
    _sum?: InterestTypeSumAggregateInputType
    _min?: InterestTypeMinAggregateInputType
    _max?: InterestTypeMaxAggregateInputType
  }

  export type InterestTypeGroupByOutputType = {
    id: number
    name: string
    calculationType: $Enums.CalculationTypeEnum
    _count: InterestTypeCountAggregateOutputType | null
    _avg: InterestTypeAvgAggregateOutputType | null
    _sum: InterestTypeSumAggregateOutputType | null
    _min: InterestTypeMinAggregateOutputType | null
    _max: InterestTypeMaxAggregateOutputType | null
  }

  type GetInterestTypeGroupByPayload<T extends InterestTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestTypeGroupByOutputType[P]>
            : GetScalarType<T[P], InterestTypeGroupByOutputType[P]>
        }
      >
    >


  export type InterestTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calculationType?: boolean
    details?: boolean | InterestType$detailsArgs<ExtArgs>
    _count?: boolean | InterestTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestType"]>

  export type InterestTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calculationType?: boolean
  }, ExtArgs["result"]["interestType"]>

  export type InterestTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calculationType?: boolean
  }, ExtArgs["result"]["interestType"]>

  export type InterestTypeSelectScalar = {
    id?: boolean
    name?: boolean
    calculationType?: boolean
  }

  export type InterestTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "calculationType", ExtArgs["result"]["interestType"]>
  export type InterestTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | InterestType$detailsArgs<ExtArgs>
    _count?: boolean | InterestTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InterestTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InterestTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InterestTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterestType"
    objects: {
      details: Prisma.$InterestDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      calculationType: $Enums.CalculationTypeEnum
    }, ExtArgs["result"]["interestType"]>
    composites: {}
  }

  type InterestTypeGetPayload<S extends boolean | null | undefined | InterestTypeDefaultArgs> = $Result.GetResult<Prisma.$InterestTypePayload, S>

  type InterestTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterestTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterestTypeCountAggregateInputType | true
    }

  export interface InterestTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterestType'], meta: { name: 'InterestType' } }
    /**
     * Find zero or one InterestType that matches the filter.
     * @param {InterestTypeFindUniqueArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestTypeFindUniqueArgs>(args: SelectSubset<T, InterestTypeFindUniqueArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterestType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterestTypeFindUniqueOrThrowArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeFindFirstArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestTypeFindFirstArgs>(args?: SelectSubset<T, InterestTypeFindFirstArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeFindFirstOrThrowArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterestTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterestTypes
     * const interestTypes = await prisma.interestType.findMany()
     * 
     * // Get first 10 InterestTypes
     * const interestTypes = await prisma.interestType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestTypeWithIdOnly = await prisma.interestType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestTypeFindManyArgs>(args?: SelectSubset<T, InterestTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterestType.
     * @param {InterestTypeCreateArgs} args - Arguments to create a InterestType.
     * @example
     * // Create one InterestType
     * const InterestType = await prisma.interestType.create({
     *   data: {
     *     // ... data to create a InterestType
     *   }
     * })
     * 
     */
    create<T extends InterestTypeCreateArgs>(args: SelectSubset<T, InterestTypeCreateArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterestTypes.
     * @param {InterestTypeCreateManyArgs} args - Arguments to create many InterestTypes.
     * @example
     * // Create many InterestTypes
     * const interestType = await prisma.interestType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestTypeCreateManyArgs>(args?: SelectSubset<T, InterestTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterestTypes and returns the data saved in the database.
     * @param {InterestTypeCreateManyAndReturnArgs} args - Arguments to create many InterestTypes.
     * @example
     * // Create many InterestTypes
     * const interestType = await prisma.interestType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterestTypes and only return the `id`
     * const interestTypeWithIdOnly = await prisma.interestType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterestType.
     * @param {InterestTypeDeleteArgs} args - Arguments to delete one InterestType.
     * @example
     * // Delete one InterestType
     * const InterestType = await prisma.interestType.delete({
     *   where: {
     *     // ... filter to delete one InterestType
     *   }
     * })
     * 
     */
    delete<T extends InterestTypeDeleteArgs>(args: SelectSubset<T, InterestTypeDeleteArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterestType.
     * @param {InterestTypeUpdateArgs} args - Arguments to update one InterestType.
     * @example
     * // Update one InterestType
     * const interestType = await prisma.interestType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestTypeUpdateArgs>(args: SelectSubset<T, InterestTypeUpdateArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterestTypes.
     * @param {InterestTypeDeleteManyArgs} args - Arguments to filter InterestTypes to delete.
     * @example
     * // Delete a few InterestTypes
     * const { count } = await prisma.interestType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestTypeDeleteManyArgs>(args?: SelectSubset<T, InterestTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterestTypes
     * const interestType = await prisma.interestType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestTypeUpdateManyArgs>(args: SelectSubset<T, InterestTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestTypes and returns the data updated in the database.
     * @param {InterestTypeUpdateManyAndReturnArgs} args - Arguments to update many InterestTypes.
     * @example
     * // Update many InterestTypes
     * const interestType = await prisma.interestType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterestTypes and only return the `id`
     * const interestTypeWithIdOnly = await prisma.interestType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterestTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, InterestTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterestType.
     * @param {InterestTypeUpsertArgs} args - Arguments to update or create a InterestType.
     * @example
     * // Update or create a InterestType
     * const interestType = await prisma.interestType.upsert({
     *   create: {
     *     // ... data to create a InterestType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterestType we want to update
     *   }
     * })
     */
    upsert<T extends InterestTypeUpsertArgs>(args: SelectSubset<T, InterestTypeUpsertArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterestTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeCountArgs} args - Arguments to filter InterestTypes to count.
     * @example
     * // Count the number of InterestTypes
     * const count = await prisma.interestType.count({
     *   where: {
     *     // ... the filter for the InterestTypes we want to count
     *   }
     * })
    **/
    count<T extends InterestTypeCountArgs>(
      args?: Subset<T, InterestTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterestType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestTypeAggregateArgs>(args: Subset<T, InterestTypeAggregateArgs>): Prisma.PrismaPromise<GetInterestTypeAggregateType<T>>

    /**
     * Group by InterestType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestTypeGroupByArgs['orderBy'] }
        : { orderBy?: InterestTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterestType model
   */
  readonly fields: InterestTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterestType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    details<T extends InterestType$detailsArgs<ExtArgs> = {}>(args?: Subset<T, InterestType$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterestType model
   */
  interface InterestTypeFieldRefs {
    readonly id: FieldRef<"InterestType", 'Int'>
    readonly name: FieldRef<"InterestType", 'String'>
    readonly calculationType: FieldRef<"InterestType", 'CalculationTypeEnum'>
  }
    

  // Custom InputTypes
  /**
   * InterestType findUnique
   */
  export type InterestTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType findUniqueOrThrow
   */
  export type InterestTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType findFirst
   */
  export type InterestTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestTypes.
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestTypes.
     */
    distinct?: InterestTypeScalarFieldEnum | InterestTypeScalarFieldEnum[]
  }

  /**
   * InterestType findFirstOrThrow
   */
  export type InterestTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestTypes.
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestTypes.
     */
    distinct?: InterestTypeScalarFieldEnum | InterestTypeScalarFieldEnum[]
  }

  /**
   * InterestType findMany
   */
  export type InterestTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestTypes to fetch.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterestTypes.
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    distinct?: InterestTypeScalarFieldEnum | InterestTypeScalarFieldEnum[]
  }

  /**
   * InterestType create
   */
  export type InterestTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a InterestType.
     */
    data: XOR<InterestTypeCreateInput, InterestTypeUncheckedCreateInput>
  }

  /**
   * InterestType createMany
   */
  export type InterestTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterestTypes.
     */
    data: InterestTypeCreateManyInput | InterestTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterestType createManyAndReturn
   */
  export type InterestTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * The data used to create many InterestTypes.
     */
    data: InterestTypeCreateManyInput | InterestTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterestType update
   */
  export type InterestTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a InterestType.
     */
    data: XOR<InterestTypeUpdateInput, InterestTypeUncheckedUpdateInput>
    /**
     * Choose, which InterestType to update.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType updateMany
   */
  export type InterestTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterestTypes.
     */
    data: XOR<InterestTypeUpdateManyMutationInput, InterestTypeUncheckedUpdateManyInput>
    /**
     * Filter which InterestTypes to update
     */
    where?: InterestTypeWhereInput
    /**
     * Limit how many InterestTypes to update.
     */
    limit?: number
  }

  /**
   * InterestType updateManyAndReturn
   */
  export type InterestTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * The data used to update InterestTypes.
     */
    data: XOR<InterestTypeUpdateManyMutationInput, InterestTypeUncheckedUpdateManyInput>
    /**
     * Filter which InterestTypes to update
     */
    where?: InterestTypeWhereInput
    /**
     * Limit how many InterestTypes to update.
     */
    limit?: number
  }

  /**
   * InterestType upsert
   */
  export type InterestTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the InterestType to update in case it exists.
     */
    where: InterestTypeWhereUniqueInput
    /**
     * In case the InterestType found by the `where` argument doesn't exist, create a new InterestType with this data.
     */
    create: XOR<InterestTypeCreateInput, InterestTypeUncheckedCreateInput>
    /**
     * In case the InterestType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestTypeUpdateInput, InterestTypeUncheckedUpdateInput>
  }

  /**
   * InterestType delete
   */
  export type InterestTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter which InterestType to delete.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType deleteMany
   */
  export type InterestTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestTypes to delete
     */
    where?: InterestTypeWhereInput
    /**
     * Limit how many InterestTypes to delete.
     */
    limit?: number
  }

  /**
   * InterestType.details
   */
  export type InterestType$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    where?: InterestDetailWhereInput
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    cursor?: InterestDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestType without action
   */
  export type InterestTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
  }


  /**
   * Model InterestDetail
   */

  export type AggregateInterestDetail = {
    _count: InterestDetailCountAggregateOutputType | null
    _avg: InterestDetailAvgAggregateOutputType | null
    _sum: InterestDetailSumAggregateOutputType | null
    _min: InterestDetailMinAggregateOutputType | null
    _max: InterestDetailMaxAggregateOutputType | null
  }

  export type InterestDetailAvgAggregateOutputType = {
    id: number | null
    rate: number | null
    interestTypeId: number | null
  }

  export type InterestDetailSumAggregateOutputType = {
    id: number | null
    rate: number | null
    interestTypeId: number | null
  }

  export type InterestDetailMinAggregateOutputType = {
    id: number | null
    date: string | null
    rate: number | null
    interestTypeId: number | null
  }

  export type InterestDetailMaxAggregateOutputType = {
    id: number | null
    date: string | null
    rate: number | null
    interestTypeId: number | null
  }

  export type InterestDetailCountAggregateOutputType = {
    id: number
    date: number
    rate: number
    interestTypeId: number
    _all: number
  }


  export type InterestDetailAvgAggregateInputType = {
    id?: true
    rate?: true
    interestTypeId?: true
  }

  export type InterestDetailSumAggregateInputType = {
    id?: true
    rate?: true
    interestTypeId?: true
  }

  export type InterestDetailMinAggregateInputType = {
    id?: true
    date?: true
    rate?: true
    interestTypeId?: true
  }

  export type InterestDetailMaxAggregateInputType = {
    id?: true
    date?: true
    rate?: true
    interestTypeId?: true
  }

  export type InterestDetailCountAggregateInputType = {
    id?: true
    date?: true
    rate?: true
    interestTypeId?: true
    _all?: true
  }

  export type InterestDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestDetail to aggregate.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterestDetails
    **/
    _count?: true | InterestDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterestDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterestDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestDetailMaxAggregateInputType
  }

  export type GetInterestDetailAggregateType<T extends InterestDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateInterestDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterestDetail[P]>
      : GetScalarType<T[P], AggregateInterestDetail[P]>
  }




  export type InterestDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestDetailWhereInput
    orderBy?: InterestDetailOrderByWithAggregationInput | InterestDetailOrderByWithAggregationInput[]
    by: InterestDetailScalarFieldEnum[] | InterestDetailScalarFieldEnum
    having?: InterestDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestDetailCountAggregateInputType | true
    _avg?: InterestDetailAvgAggregateInputType
    _sum?: InterestDetailSumAggregateInputType
    _min?: InterestDetailMinAggregateInputType
    _max?: InterestDetailMaxAggregateInputType
  }

  export type InterestDetailGroupByOutputType = {
    id: number
    date: string
    rate: number
    interestTypeId: number
    _count: InterestDetailCountAggregateOutputType | null
    _avg: InterestDetailAvgAggregateOutputType | null
    _sum: InterestDetailSumAggregateOutputType | null
    _min: InterestDetailMinAggregateOutputType | null
    _max: InterestDetailMaxAggregateOutputType | null
  }

  type GetInterestDetailGroupByPayload<T extends InterestDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestDetailGroupByOutputType[P]>
            : GetScalarType<T[P], InterestDetailGroupByOutputType[P]>
        }
      >
    >


  export type InterestDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    rate?: boolean
    interestTypeId?: boolean
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestDetail"]>

  export type InterestDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    rate?: boolean
    interestTypeId?: boolean
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestDetail"]>

  export type InterestDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    rate?: boolean
    interestTypeId?: boolean
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestDetail"]>

  export type InterestDetailSelectScalar = {
    id?: boolean
    date?: boolean
    rate?: boolean
    interestTypeId?: boolean
  }

  export type InterestDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "rate" | "interestTypeId", ExtArgs["result"]["interestDetail"]>
  export type InterestDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }
  export type InterestDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }
  export type InterestDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interestType?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }

  export type $InterestDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterestDetail"
    objects: {
      interestType: Prisma.$InterestTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: string
      rate: number
      interestTypeId: number
    }, ExtArgs["result"]["interestDetail"]>
    composites: {}
  }

  type InterestDetailGetPayload<S extends boolean | null | undefined | InterestDetailDefaultArgs> = $Result.GetResult<Prisma.$InterestDetailPayload, S>

  type InterestDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterestDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterestDetailCountAggregateInputType | true
    }

  export interface InterestDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterestDetail'], meta: { name: 'InterestDetail' } }
    /**
     * Find zero or one InterestDetail that matches the filter.
     * @param {InterestDetailFindUniqueArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestDetailFindUniqueArgs>(args: SelectSubset<T, InterestDetailFindUniqueArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterestDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterestDetailFindUniqueOrThrowArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailFindFirstArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestDetailFindFirstArgs>(args?: SelectSubset<T, InterestDetailFindFirstArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailFindFirstOrThrowArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterestDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterestDetails
     * const interestDetails = await prisma.interestDetail.findMany()
     * 
     * // Get first 10 InterestDetails
     * const interestDetails = await prisma.interestDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestDetailWithIdOnly = await prisma.interestDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestDetailFindManyArgs>(args?: SelectSubset<T, InterestDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterestDetail.
     * @param {InterestDetailCreateArgs} args - Arguments to create a InterestDetail.
     * @example
     * // Create one InterestDetail
     * const InterestDetail = await prisma.interestDetail.create({
     *   data: {
     *     // ... data to create a InterestDetail
     *   }
     * })
     * 
     */
    create<T extends InterestDetailCreateArgs>(args: SelectSubset<T, InterestDetailCreateArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterestDetails.
     * @param {InterestDetailCreateManyArgs} args - Arguments to create many InterestDetails.
     * @example
     * // Create many InterestDetails
     * const interestDetail = await prisma.interestDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestDetailCreateManyArgs>(args?: SelectSubset<T, InterestDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterestDetails and returns the data saved in the database.
     * @param {InterestDetailCreateManyAndReturnArgs} args - Arguments to create many InterestDetails.
     * @example
     * // Create many InterestDetails
     * const interestDetail = await prisma.interestDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterestDetails and only return the `id`
     * const interestDetailWithIdOnly = await prisma.interestDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterestDetail.
     * @param {InterestDetailDeleteArgs} args - Arguments to delete one InterestDetail.
     * @example
     * // Delete one InterestDetail
     * const InterestDetail = await prisma.interestDetail.delete({
     *   where: {
     *     // ... filter to delete one InterestDetail
     *   }
     * })
     * 
     */
    delete<T extends InterestDetailDeleteArgs>(args: SelectSubset<T, InterestDetailDeleteArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterestDetail.
     * @param {InterestDetailUpdateArgs} args - Arguments to update one InterestDetail.
     * @example
     * // Update one InterestDetail
     * const interestDetail = await prisma.interestDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestDetailUpdateArgs>(args: SelectSubset<T, InterestDetailUpdateArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterestDetails.
     * @param {InterestDetailDeleteManyArgs} args - Arguments to filter InterestDetails to delete.
     * @example
     * // Delete a few InterestDetails
     * const { count } = await prisma.interestDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestDetailDeleteManyArgs>(args?: SelectSubset<T, InterestDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterestDetails
     * const interestDetail = await prisma.interestDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestDetailUpdateManyArgs>(args: SelectSubset<T, InterestDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestDetails and returns the data updated in the database.
     * @param {InterestDetailUpdateManyAndReturnArgs} args - Arguments to update many InterestDetails.
     * @example
     * // Update many InterestDetails
     * const interestDetail = await prisma.interestDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterestDetails and only return the `id`
     * const interestDetailWithIdOnly = await prisma.interestDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterestDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, InterestDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterestDetail.
     * @param {InterestDetailUpsertArgs} args - Arguments to update or create a InterestDetail.
     * @example
     * // Update or create a InterestDetail
     * const interestDetail = await prisma.interestDetail.upsert({
     *   create: {
     *     // ... data to create a InterestDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterestDetail we want to update
     *   }
     * })
     */
    upsert<T extends InterestDetailUpsertArgs>(args: SelectSubset<T, InterestDetailUpsertArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailCountArgs} args - Arguments to filter InterestDetails to count.
     * @example
     * // Count the number of InterestDetails
     * const count = await prisma.interestDetail.count({
     *   where: {
     *     // ... the filter for the InterestDetails we want to count
     *   }
     * })
    **/
    count<T extends InterestDetailCountArgs>(
      args?: Subset<T, InterestDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterestDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestDetailAggregateArgs>(args: Subset<T, InterestDetailAggregateArgs>): Prisma.PrismaPromise<GetInterestDetailAggregateType<T>>

    /**
     * Group by InterestDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestDetailGroupByArgs['orderBy'] }
        : { orderBy?: InterestDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterestDetail model
   */
  readonly fields: InterestDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterestDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interestType<T extends InterestTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterestTypeDefaultArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterestDetail model
   */
  interface InterestDetailFieldRefs {
    readonly id: FieldRef<"InterestDetail", 'Int'>
    readonly date: FieldRef<"InterestDetail", 'String'>
    readonly rate: FieldRef<"InterestDetail", 'Float'>
    readonly interestTypeId: FieldRef<"InterestDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InterestDetail findUnique
   */
  export type InterestDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail findUniqueOrThrow
   */
  export type InterestDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail findFirst
   */
  export type InterestDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestDetails.
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestDetails.
     */
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestDetail findFirstOrThrow
   */
  export type InterestDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestDetails.
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestDetails.
     */
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestDetail findMany
   */
  export type InterestDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetails to fetch.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterestDetails.
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestDetail create
   */
  export type InterestDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a InterestDetail.
     */
    data: XOR<InterestDetailCreateInput, InterestDetailUncheckedCreateInput>
  }

  /**
   * InterestDetail createMany
   */
  export type InterestDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterestDetails.
     */
    data: InterestDetailCreateManyInput | InterestDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterestDetail createManyAndReturn
   */
  export type InterestDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * The data used to create many InterestDetails.
     */
    data: InterestDetailCreateManyInput | InterestDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterestDetail update
   */
  export type InterestDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a InterestDetail.
     */
    data: XOR<InterestDetailUpdateInput, InterestDetailUncheckedUpdateInput>
    /**
     * Choose, which InterestDetail to update.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail updateMany
   */
  export type InterestDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterestDetails.
     */
    data: XOR<InterestDetailUpdateManyMutationInput, InterestDetailUncheckedUpdateManyInput>
    /**
     * Filter which InterestDetails to update
     */
    where?: InterestDetailWhereInput
    /**
     * Limit how many InterestDetails to update.
     */
    limit?: number
  }

  /**
   * InterestDetail updateManyAndReturn
   */
  export type InterestDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * The data used to update InterestDetails.
     */
    data: XOR<InterestDetailUpdateManyMutationInput, InterestDetailUncheckedUpdateManyInput>
    /**
     * Filter which InterestDetails to update
     */
    where?: InterestDetailWhereInput
    /**
     * Limit how many InterestDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterestDetail upsert
   */
  export type InterestDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the InterestDetail to update in case it exists.
     */
    where: InterestDetailWhereUniqueInput
    /**
     * In case the InterestDetail found by the `where` argument doesn't exist, create a new InterestDetail with this data.
     */
    create: XOR<InterestDetailCreateInput, InterestDetailUncheckedCreateInput>
    /**
     * In case the InterestDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestDetailUpdateInput, InterestDetailUncheckedUpdateInput>
  }

  /**
   * InterestDetail delete
   */
  export type InterestDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter which InterestDetail to delete.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail deleteMany
   */
  export type InterestDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestDetails to delete
     */
    where?: InterestDetailWhereInput
    /**
     * Limit how many InterestDetails to delete.
     */
    limit?: number
  }

  /**
   * InterestDetail without action
   */
  export type InterestDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
  }


  /**
   * Model BillingInvoice
   */

  export type AggregateBillingInvoice = {
    _count: BillingInvoiceCountAggregateOutputType | null
    _avg: BillingInvoiceAvgAggregateOutputType | null
    _sum: BillingInvoiceSumAggregateOutputType | null
    _min: BillingInvoiceMinAggregateOutputType | null
    _max: BillingInvoiceMaxAggregateOutputType | null
  }

  export type BillingInvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillingInvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type BillingInvoiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceNumber: string | null
    amount: number | null
    currency: string | null
    issueDate: Date | null
    dueDate: Date | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingInvoiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    invoiceNumber: string | null
    amount: number | null
    currency: string | null
    issueDate: Date | null
    dueDate: Date | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillingInvoiceCountAggregateOutputType = {
    id: number
    tenantId: number
    invoiceNumber: number
    amount: number
    currency: number
    issueDate: number
    dueDate: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillingInvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type BillingInvoiceSumAggregateInputType = {
    amount?: true
  }

  export type BillingInvoiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    issueDate?: true
    dueDate?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingInvoiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    issueDate?: true
    dueDate?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillingInvoiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    issueDate?: true
    dueDate?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillingInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoice to aggregate.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingInvoices
    **/
    _count?: true | BillingInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingInvoiceMaxAggregateInputType
  }

  export type GetBillingInvoiceAggregateType<T extends BillingInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingInvoice[P]>
      : GetScalarType<T[P], AggregateBillingInvoice[P]>
  }




  export type BillingInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceWhereInput
    orderBy?: BillingInvoiceOrderByWithAggregationInput | BillingInvoiceOrderByWithAggregationInput[]
    by: BillingInvoiceScalarFieldEnum[] | BillingInvoiceScalarFieldEnum
    having?: BillingInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingInvoiceCountAggregateInputType | true
    _avg?: BillingInvoiceAvgAggregateInputType
    _sum?: BillingInvoiceSumAggregateInputType
    _min?: BillingInvoiceMinAggregateInputType
    _max?: BillingInvoiceMaxAggregateInputType
  }

  export type BillingInvoiceGroupByOutputType = {
    id: string
    tenantId: string
    invoiceNumber: string
    amount: number
    currency: string
    issueDate: Date
    dueDate: Date
    description: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: BillingInvoiceCountAggregateOutputType | null
    _avg: BillingInvoiceAvgAggregateOutputType | null
    _sum: BillingInvoiceSumAggregateOutputType | null
    _min: BillingInvoiceMinAggregateOutputType | null
    _max: BillingInvoiceMaxAggregateOutputType | null
  }

  type GetBillingInvoiceGroupByPayload<T extends BillingInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], BillingInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type BillingInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    issueDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    details?: boolean | BillingInvoice$detailsArgs<ExtArgs>
    payments?: boolean | BillingInvoice$paymentsArgs<ExtArgs>
    _count?: boolean | BillingInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoice"]>

  export type BillingInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    issueDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoice"]>

  export type BillingInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    issueDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoice"]>

  export type BillingInvoiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    issueDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillingInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "invoiceNumber" | "amount" | "currency" | "issueDate" | "dueDate" | "description" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["billingInvoice"]>
  export type BillingInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    details?: boolean | BillingInvoice$detailsArgs<ExtArgs>
    payments?: boolean | BillingInvoice$paymentsArgs<ExtArgs>
    _count?: boolean | BillingInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillingInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type BillingInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $BillingInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingInvoice"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      details: Prisma.$BillingInvoiceDetailPayload<ExtArgs>[]
      payments: Prisma.$BillingPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      invoiceNumber: string
      amount: number
      currency: string
      issueDate: Date
      dueDate: Date
      description: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billingInvoice"]>
    composites: {}
  }

  type BillingInvoiceGetPayload<S extends boolean | null | undefined | BillingInvoiceDefaultArgs> = $Result.GetResult<Prisma.$BillingInvoicePayload, S>

  type BillingInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingInvoiceCountAggregateInputType | true
    }

  export interface BillingInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingInvoice'], meta: { name: 'BillingInvoice' } }
    /**
     * Find zero or one BillingInvoice that matches the filter.
     * @param {BillingInvoiceFindUniqueArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingInvoiceFindUniqueArgs>(args: SelectSubset<T, BillingInvoiceFindUniqueArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingInvoiceFindUniqueOrThrowArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceFindFirstArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingInvoiceFindFirstArgs>(args?: SelectSubset<T, BillingInvoiceFindFirstArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceFindFirstOrThrowArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingInvoices
     * const billingInvoices = await prisma.billingInvoice.findMany()
     * 
     * // Get first 10 BillingInvoices
     * const billingInvoices = await prisma.billingInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingInvoiceWithIdOnly = await prisma.billingInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingInvoiceFindManyArgs>(args?: SelectSubset<T, BillingInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingInvoice.
     * @param {BillingInvoiceCreateArgs} args - Arguments to create a BillingInvoice.
     * @example
     * // Create one BillingInvoice
     * const BillingInvoice = await prisma.billingInvoice.create({
     *   data: {
     *     // ... data to create a BillingInvoice
     *   }
     * })
     * 
     */
    create<T extends BillingInvoiceCreateArgs>(args: SelectSubset<T, BillingInvoiceCreateArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingInvoices.
     * @param {BillingInvoiceCreateManyArgs} args - Arguments to create many BillingInvoices.
     * @example
     * // Create many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingInvoiceCreateManyArgs>(args?: SelectSubset<T, BillingInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingInvoices and returns the data saved in the database.
     * @param {BillingInvoiceCreateManyAndReturnArgs} args - Arguments to create many BillingInvoices.
     * @example
     * // Create many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingInvoices and only return the `id`
     * const billingInvoiceWithIdOnly = await prisma.billingInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingInvoice.
     * @param {BillingInvoiceDeleteArgs} args - Arguments to delete one BillingInvoice.
     * @example
     * // Delete one BillingInvoice
     * const BillingInvoice = await prisma.billingInvoice.delete({
     *   where: {
     *     // ... filter to delete one BillingInvoice
     *   }
     * })
     * 
     */
    delete<T extends BillingInvoiceDeleteArgs>(args: SelectSubset<T, BillingInvoiceDeleteArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingInvoice.
     * @param {BillingInvoiceUpdateArgs} args - Arguments to update one BillingInvoice.
     * @example
     * // Update one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingInvoiceUpdateArgs>(args: SelectSubset<T, BillingInvoiceUpdateArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingInvoices.
     * @param {BillingInvoiceDeleteManyArgs} args - Arguments to filter BillingInvoices to delete.
     * @example
     * // Delete a few BillingInvoices
     * const { count } = await prisma.billingInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingInvoiceDeleteManyArgs>(args?: SelectSubset<T, BillingInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingInvoiceUpdateManyArgs>(args: SelectSubset<T, BillingInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoices and returns the data updated in the database.
     * @param {BillingInvoiceUpdateManyAndReturnArgs} args - Arguments to update many BillingInvoices.
     * @example
     * // Update many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingInvoices and only return the `id`
     * const billingInvoiceWithIdOnly = await prisma.billingInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingInvoice.
     * @param {BillingInvoiceUpsertArgs} args - Arguments to update or create a BillingInvoice.
     * @example
     * // Update or create a BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.upsert({
     *   create: {
     *     // ... data to create a BillingInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingInvoice we want to update
     *   }
     * })
     */
    upsert<T extends BillingInvoiceUpsertArgs>(args: SelectSubset<T, BillingInvoiceUpsertArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceCountArgs} args - Arguments to filter BillingInvoices to count.
     * @example
     * // Count the number of BillingInvoices
     * const count = await prisma.billingInvoice.count({
     *   where: {
     *     // ... the filter for the BillingInvoices we want to count
     *   }
     * })
    **/
    count<T extends BillingInvoiceCountArgs>(
      args?: Subset<T, BillingInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingInvoiceAggregateArgs>(args: Subset<T, BillingInvoiceAggregateArgs>): Prisma.PrismaPromise<GetBillingInvoiceAggregateType<T>>

    /**
     * Group by BillingInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: BillingInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingInvoice model
   */
  readonly fields: BillingInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    details<T extends BillingInvoice$detailsArgs<ExtArgs> = {}>(args?: Subset<T, BillingInvoice$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends BillingInvoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, BillingInvoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingInvoice model
   */
  interface BillingInvoiceFieldRefs {
    readonly id: FieldRef<"BillingInvoice", 'String'>
    readonly tenantId: FieldRef<"BillingInvoice", 'String'>
    readonly invoiceNumber: FieldRef<"BillingInvoice", 'String'>
    readonly amount: FieldRef<"BillingInvoice", 'Float'>
    readonly currency: FieldRef<"BillingInvoice", 'String'>
    readonly issueDate: FieldRef<"BillingInvoice", 'DateTime'>
    readonly dueDate: FieldRef<"BillingInvoice", 'DateTime'>
    readonly description: FieldRef<"BillingInvoice", 'String'>
    readonly status: FieldRef<"BillingInvoice", 'String'>
    readonly createdAt: FieldRef<"BillingInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingInvoice findUnique
   */
  export type BillingInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice findUniqueOrThrow
   */
  export type BillingInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice findFirst
   */
  export type BillingInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoices.
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoices.
     */
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * BillingInvoice findFirstOrThrow
   */
  export type BillingInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoices.
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoices.
     */
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * BillingInvoice findMany
   */
  export type BillingInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoices to fetch.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingInvoices.
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * BillingInvoice create
   */
  export type BillingInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingInvoice.
     */
    data: XOR<BillingInvoiceCreateInput, BillingInvoiceUncheckedCreateInput>
  }

  /**
   * BillingInvoice createMany
   */
  export type BillingInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingInvoices.
     */
    data: BillingInvoiceCreateManyInput | BillingInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingInvoice createManyAndReturn
   */
  export type BillingInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many BillingInvoices.
     */
    data: BillingInvoiceCreateManyInput | BillingInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoice update
   */
  export type BillingInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingInvoice.
     */
    data: XOR<BillingInvoiceUpdateInput, BillingInvoiceUncheckedUpdateInput>
    /**
     * Choose, which BillingInvoice to update.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice updateMany
   */
  export type BillingInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingInvoices.
     */
    data: XOR<BillingInvoiceUpdateManyMutationInput, BillingInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoices to update
     */
    where?: BillingInvoiceWhereInput
    /**
     * Limit how many BillingInvoices to update.
     */
    limit?: number
  }

  /**
   * BillingInvoice updateManyAndReturn
   */
  export type BillingInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update BillingInvoices.
     */
    data: XOR<BillingInvoiceUpdateManyMutationInput, BillingInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoices to update
     */
    where?: BillingInvoiceWhereInput
    /**
     * Limit how many BillingInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoice upsert
   */
  export type BillingInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingInvoice to update in case it exists.
     */
    where: BillingInvoiceWhereUniqueInput
    /**
     * In case the BillingInvoice found by the `where` argument doesn't exist, create a new BillingInvoice with this data.
     */
    create: XOR<BillingInvoiceCreateInput, BillingInvoiceUncheckedCreateInput>
    /**
     * In case the BillingInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingInvoiceUpdateInput, BillingInvoiceUncheckedUpdateInput>
  }

  /**
   * BillingInvoice delete
   */
  export type BillingInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter which BillingInvoice to delete.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice deleteMany
   */
  export type BillingInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoices to delete
     */
    where?: BillingInvoiceWhereInput
    /**
     * Limit how many BillingInvoices to delete.
     */
    limit?: number
  }

  /**
   * BillingInvoice.details
   */
  export type BillingInvoice$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    where?: BillingInvoiceDetailWhereInput
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    cursor?: BillingInvoiceDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoice.payments
   */
  export type BillingInvoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    where?: BillingPaymentWhereInput
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    cursor?: BillingPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingInvoice without action
   */
  export type BillingInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model BillingInvoiceDetail
   */

  export type AggregateBillingInvoiceDetail = {
    _count: BillingInvoiceDetailCountAggregateOutputType | null
    _avg: BillingInvoiceDetailAvgAggregateOutputType | null
    _sum: BillingInvoiceDetailSumAggregateOutputType | null
    _min: BillingInvoiceDetailMinAggregateOutputType | null
    _max: BillingInvoiceDetailMaxAggregateOutputType | null
  }

  export type BillingInvoiceDetailAvgAggregateOutputType = {
    itemQuantity: number | null
    itemUnitPrice: number | null
    itemTotalPrice: number | null
    itemTaxRate: number | null
    itemTaxAmount: number | null
    itemTotalWithTax: number | null
  }

  export type BillingInvoiceDetailSumAggregateOutputType = {
    itemQuantity: number | null
    itemUnitPrice: number | null
    itemTotalPrice: number | null
    itemTaxRate: number | null
    itemTaxAmount: number | null
    itemTotalWithTax: number | null
  }

  export type BillingInvoiceDetailMinAggregateOutputType = {
    id: string | null
    itemDescription: string | null
    itemQuantity: number | null
    itemUnitPrice: number | null
    itemTotalPrice: number | null
    itemTaxRate: number | null
    itemTaxAmount: number | null
    itemTotalWithTax: number | null
    createdAt: Date | null
    updatedAt: Date | null
    billingInvoiceId: string | null
  }

  export type BillingInvoiceDetailMaxAggregateOutputType = {
    id: string | null
    itemDescription: string | null
    itemQuantity: number | null
    itemUnitPrice: number | null
    itemTotalPrice: number | null
    itemTaxRate: number | null
    itemTaxAmount: number | null
    itemTotalWithTax: number | null
    createdAt: Date | null
    updatedAt: Date | null
    billingInvoiceId: string | null
  }

  export type BillingInvoiceDetailCountAggregateOutputType = {
    id: number
    itemDescription: number
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt: number
    updatedAt: number
    billingInvoiceId: number
    _all: number
  }


  export type BillingInvoiceDetailAvgAggregateInputType = {
    itemQuantity?: true
    itemUnitPrice?: true
    itemTotalPrice?: true
    itemTaxRate?: true
    itemTaxAmount?: true
    itemTotalWithTax?: true
  }

  export type BillingInvoiceDetailSumAggregateInputType = {
    itemQuantity?: true
    itemUnitPrice?: true
    itemTotalPrice?: true
    itemTaxRate?: true
    itemTaxAmount?: true
    itemTotalWithTax?: true
  }

  export type BillingInvoiceDetailMinAggregateInputType = {
    id?: true
    itemDescription?: true
    itemQuantity?: true
    itemUnitPrice?: true
    itemTotalPrice?: true
    itemTaxRate?: true
    itemTaxAmount?: true
    itemTotalWithTax?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
  }

  export type BillingInvoiceDetailMaxAggregateInputType = {
    id?: true
    itemDescription?: true
    itemQuantity?: true
    itemUnitPrice?: true
    itemTotalPrice?: true
    itemTaxRate?: true
    itemTaxAmount?: true
    itemTotalWithTax?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
  }

  export type BillingInvoiceDetailCountAggregateInputType = {
    id?: true
    itemDescription?: true
    itemQuantity?: true
    itemUnitPrice?: true
    itemTotalPrice?: true
    itemTaxRate?: true
    itemTaxAmount?: true
    itemTotalWithTax?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
    _all?: true
  }

  export type BillingInvoiceDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoiceDetail to aggregate.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingInvoiceDetails
    **/
    _count?: true | BillingInvoiceDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingInvoiceDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingInvoiceDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingInvoiceDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingInvoiceDetailMaxAggregateInputType
  }

  export type GetBillingInvoiceDetailAggregateType<T extends BillingInvoiceDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingInvoiceDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingInvoiceDetail[P]>
      : GetScalarType<T[P], AggregateBillingInvoiceDetail[P]>
  }




  export type BillingInvoiceDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceDetailWhereInput
    orderBy?: BillingInvoiceDetailOrderByWithAggregationInput | BillingInvoiceDetailOrderByWithAggregationInput[]
    by: BillingInvoiceDetailScalarFieldEnum[] | BillingInvoiceDetailScalarFieldEnum
    having?: BillingInvoiceDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingInvoiceDetailCountAggregateInputType | true
    _avg?: BillingInvoiceDetailAvgAggregateInputType
    _sum?: BillingInvoiceDetailSumAggregateInputType
    _min?: BillingInvoiceDetailMinAggregateInputType
    _max?: BillingInvoiceDetailMaxAggregateInputType
  }

  export type BillingInvoiceDetailGroupByOutputType = {
    id: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt: Date
    updatedAt: Date
    billingInvoiceId: string | null
    _count: BillingInvoiceDetailCountAggregateOutputType | null
    _avg: BillingInvoiceDetailAvgAggregateOutputType | null
    _sum: BillingInvoiceDetailSumAggregateOutputType | null
    _min: BillingInvoiceDetailMinAggregateOutputType | null
    _max: BillingInvoiceDetailMaxAggregateOutputType | null
  }

  type GetBillingInvoiceDetailGroupByPayload<T extends BillingInvoiceDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingInvoiceDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingInvoiceDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingInvoiceDetailGroupByOutputType[P]>
            : GetScalarType<T[P], BillingInvoiceDetailGroupByOutputType[P]>
        }
      >
    >


  export type BillingInvoiceDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemDescription?: boolean
    itemQuantity?: boolean
    itemUnitPrice?: boolean
    itemTotalPrice?: boolean
    itemTaxRate?: boolean
    itemTaxAmount?: boolean
    itemTotalWithTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoiceDetail"]>

  export type BillingInvoiceDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemDescription?: boolean
    itemQuantity?: boolean
    itemUnitPrice?: boolean
    itemTotalPrice?: boolean
    itemTaxRate?: boolean
    itemTaxAmount?: boolean
    itemTotalWithTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoiceDetail"]>

  export type BillingInvoiceDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemDescription?: boolean
    itemQuantity?: boolean
    itemUnitPrice?: boolean
    itemTotalPrice?: boolean
    itemTaxRate?: boolean
    itemTaxAmount?: boolean
    itemTotalWithTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoiceDetail"]>

  export type BillingInvoiceDetailSelectScalar = {
    id?: boolean
    itemDescription?: boolean
    itemQuantity?: boolean
    itemUnitPrice?: boolean
    itemTotalPrice?: boolean
    itemTaxRate?: boolean
    itemTaxAmount?: boolean
    itemTotalWithTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
  }

  export type BillingInvoiceDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemDescription" | "itemQuantity" | "itemUnitPrice" | "itemTotalPrice" | "itemTaxRate" | "itemTaxAmount" | "itemTotalWithTax" | "createdAt" | "updatedAt" | "billingInvoiceId", ExtArgs["result"]["billingInvoiceDetail"]>
  export type BillingInvoiceDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }
  export type BillingInvoiceDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }
  export type BillingInvoiceDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billingInvoice?: boolean | BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>
  }

  export type $BillingInvoiceDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingInvoiceDetail"
    objects: {
      billingInvoice: Prisma.$BillingInvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemDescription: string
      itemQuantity: number
      itemUnitPrice: number
      itemTotalPrice: number
      itemTaxRate: number
      itemTaxAmount: number
      itemTotalWithTax: number
      createdAt: Date
      updatedAt: Date
      billingInvoiceId: string | null
    }, ExtArgs["result"]["billingInvoiceDetail"]>
    composites: {}
  }

  type BillingInvoiceDetailGetPayload<S extends boolean | null | undefined | BillingInvoiceDetailDefaultArgs> = $Result.GetResult<Prisma.$BillingInvoiceDetailPayload, S>

  type BillingInvoiceDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingInvoiceDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingInvoiceDetailCountAggregateInputType | true
    }

  export interface BillingInvoiceDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingInvoiceDetail'], meta: { name: 'BillingInvoiceDetail' } }
    /**
     * Find zero or one BillingInvoiceDetail that matches the filter.
     * @param {BillingInvoiceDetailFindUniqueArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingInvoiceDetailFindUniqueArgs>(args: SelectSubset<T, BillingInvoiceDetailFindUniqueArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingInvoiceDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingInvoiceDetailFindUniqueOrThrowArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingInvoiceDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingInvoiceDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoiceDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailFindFirstArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingInvoiceDetailFindFirstArgs>(args?: SelectSubset<T, BillingInvoiceDetailFindFirstArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoiceDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailFindFirstOrThrowArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingInvoiceDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingInvoiceDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingInvoiceDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingInvoiceDetails
     * const billingInvoiceDetails = await prisma.billingInvoiceDetail.findMany()
     * 
     * // Get first 10 BillingInvoiceDetails
     * const billingInvoiceDetails = await prisma.billingInvoiceDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingInvoiceDetailWithIdOnly = await prisma.billingInvoiceDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingInvoiceDetailFindManyArgs>(args?: SelectSubset<T, BillingInvoiceDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingInvoiceDetail.
     * @param {BillingInvoiceDetailCreateArgs} args - Arguments to create a BillingInvoiceDetail.
     * @example
     * // Create one BillingInvoiceDetail
     * const BillingInvoiceDetail = await prisma.billingInvoiceDetail.create({
     *   data: {
     *     // ... data to create a BillingInvoiceDetail
     *   }
     * })
     * 
     */
    create<T extends BillingInvoiceDetailCreateArgs>(args: SelectSubset<T, BillingInvoiceDetailCreateArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingInvoiceDetails.
     * @param {BillingInvoiceDetailCreateManyArgs} args - Arguments to create many BillingInvoiceDetails.
     * @example
     * // Create many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingInvoiceDetailCreateManyArgs>(args?: SelectSubset<T, BillingInvoiceDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingInvoiceDetails and returns the data saved in the database.
     * @param {BillingInvoiceDetailCreateManyAndReturnArgs} args - Arguments to create many BillingInvoiceDetails.
     * @example
     * // Create many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingInvoiceDetails and only return the `id`
     * const billingInvoiceDetailWithIdOnly = await prisma.billingInvoiceDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingInvoiceDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingInvoiceDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingInvoiceDetail.
     * @param {BillingInvoiceDetailDeleteArgs} args - Arguments to delete one BillingInvoiceDetail.
     * @example
     * // Delete one BillingInvoiceDetail
     * const BillingInvoiceDetail = await prisma.billingInvoiceDetail.delete({
     *   where: {
     *     // ... filter to delete one BillingInvoiceDetail
     *   }
     * })
     * 
     */
    delete<T extends BillingInvoiceDetailDeleteArgs>(args: SelectSubset<T, BillingInvoiceDetailDeleteArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingInvoiceDetail.
     * @param {BillingInvoiceDetailUpdateArgs} args - Arguments to update one BillingInvoiceDetail.
     * @example
     * // Update one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingInvoiceDetailUpdateArgs>(args: SelectSubset<T, BillingInvoiceDetailUpdateArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingInvoiceDetails.
     * @param {BillingInvoiceDetailDeleteManyArgs} args - Arguments to filter BillingInvoiceDetails to delete.
     * @example
     * // Delete a few BillingInvoiceDetails
     * const { count } = await prisma.billingInvoiceDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingInvoiceDetailDeleteManyArgs>(args?: SelectSubset<T, BillingInvoiceDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoiceDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingInvoiceDetailUpdateManyArgs>(args: SelectSubset<T, BillingInvoiceDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoiceDetails and returns the data updated in the database.
     * @param {BillingInvoiceDetailUpdateManyAndReturnArgs} args - Arguments to update many BillingInvoiceDetails.
     * @example
     * // Update many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingInvoiceDetails and only return the `id`
     * const billingInvoiceDetailWithIdOnly = await prisma.billingInvoiceDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingInvoiceDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingInvoiceDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingInvoiceDetail.
     * @param {BillingInvoiceDetailUpsertArgs} args - Arguments to update or create a BillingInvoiceDetail.
     * @example
     * // Update or create a BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.upsert({
     *   create: {
     *     // ... data to create a BillingInvoiceDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingInvoiceDetail we want to update
     *   }
     * })
     */
    upsert<T extends BillingInvoiceDetailUpsertArgs>(args: SelectSubset<T, BillingInvoiceDetailUpsertArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingInvoiceDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailCountArgs} args - Arguments to filter BillingInvoiceDetails to count.
     * @example
     * // Count the number of BillingInvoiceDetails
     * const count = await prisma.billingInvoiceDetail.count({
     *   where: {
     *     // ... the filter for the BillingInvoiceDetails we want to count
     *   }
     * })
    **/
    count<T extends BillingInvoiceDetailCountArgs>(
      args?: Subset<T, BillingInvoiceDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingInvoiceDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingInvoiceDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingInvoiceDetailAggregateArgs>(args: Subset<T, BillingInvoiceDetailAggregateArgs>): Prisma.PrismaPromise<GetBillingInvoiceDetailAggregateType<T>>

    /**
     * Group by BillingInvoiceDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingInvoiceDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingInvoiceDetailGroupByArgs['orderBy'] }
        : { orderBy?: BillingInvoiceDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingInvoiceDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingInvoiceDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingInvoiceDetail model
   */
  readonly fields: BillingInvoiceDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingInvoiceDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingInvoiceDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billingInvoice<T extends BillingInvoiceDetail$billingInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, BillingInvoiceDetail$billingInvoiceArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingInvoiceDetail model
   */
  interface BillingInvoiceDetailFieldRefs {
    readonly id: FieldRef<"BillingInvoiceDetail", 'String'>
    readonly itemDescription: FieldRef<"BillingInvoiceDetail", 'String'>
    readonly itemQuantity: FieldRef<"BillingInvoiceDetail", 'Int'>
    readonly itemUnitPrice: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly itemTotalPrice: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly itemTaxRate: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly itemTaxAmount: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly itemTotalWithTax: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly createdAt: FieldRef<"BillingInvoiceDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingInvoiceDetail", 'DateTime'>
    readonly billingInvoiceId: FieldRef<"BillingInvoiceDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BillingInvoiceDetail findUnique
   */
  export type BillingInvoiceDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail findUniqueOrThrow
   */
  export type BillingInvoiceDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail findFirst
   */
  export type BillingInvoiceDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoiceDetails.
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoiceDetails.
     */
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoiceDetail findFirstOrThrow
   */
  export type BillingInvoiceDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoiceDetails.
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoiceDetails.
     */
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoiceDetail findMany
   */
  export type BillingInvoiceDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetails to fetch.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingInvoiceDetails.
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoiceDetail create
   */
  export type BillingInvoiceDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingInvoiceDetail.
     */
    data: XOR<BillingInvoiceDetailCreateInput, BillingInvoiceDetailUncheckedCreateInput>
  }

  /**
   * BillingInvoiceDetail createMany
   */
  export type BillingInvoiceDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingInvoiceDetails.
     */
    data: BillingInvoiceDetailCreateManyInput | BillingInvoiceDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingInvoiceDetail createManyAndReturn
   */
  export type BillingInvoiceDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * The data used to create many BillingInvoiceDetails.
     */
    data: BillingInvoiceDetailCreateManyInput | BillingInvoiceDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoiceDetail update
   */
  export type BillingInvoiceDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingInvoiceDetail.
     */
    data: XOR<BillingInvoiceDetailUpdateInput, BillingInvoiceDetailUncheckedUpdateInput>
    /**
     * Choose, which BillingInvoiceDetail to update.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail updateMany
   */
  export type BillingInvoiceDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingInvoiceDetails.
     */
    data: XOR<BillingInvoiceDetailUpdateManyMutationInput, BillingInvoiceDetailUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoiceDetails to update
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * Limit how many BillingInvoiceDetails to update.
     */
    limit?: number
  }

  /**
   * BillingInvoiceDetail updateManyAndReturn
   */
  export type BillingInvoiceDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * The data used to update BillingInvoiceDetails.
     */
    data: XOR<BillingInvoiceDetailUpdateManyMutationInput, BillingInvoiceDetailUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoiceDetails to update
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * Limit how many BillingInvoiceDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoiceDetail upsert
   */
  export type BillingInvoiceDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingInvoiceDetail to update in case it exists.
     */
    where: BillingInvoiceDetailWhereUniqueInput
    /**
     * In case the BillingInvoiceDetail found by the `where` argument doesn't exist, create a new BillingInvoiceDetail with this data.
     */
    create: XOR<BillingInvoiceDetailCreateInput, BillingInvoiceDetailUncheckedCreateInput>
    /**
     * In case the BillingInvoiceDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingInvoiceDetailUpdateInput, BillingInvoiceDetailUncheckedUpdateInput>
  }

  /**
   * BillingInvoiceDetail delete
   */
  export type BillingInvoiceDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter which BillingInvoiceDetail to delete.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail deleteMany
   */
  export type BillingInvoiceDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoiceDetails to delete
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * Limit how many BillingInvoiceDetails to delete.
     */
    limit?: number
  }

  /**
   * BillingInvoiceDetail.billingInvoice
   */
  export type BillingInvoiceDetail$billingInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    where?: BillingInvoiceWhereInput
  }

  /**
   * BillingInvoiceDetail without action
   */
  export type BillingInvoiceDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
  }


  /**
   * Model BillingPayment
   */

  export type AggregateBillingPayment = {
    _count: BillingPaymentCountAggregateOutputType | null
    _avg: BillingPaymentAvgAggregateOutputType | null
    _sum: BillingPaymentSumAggregateOutputType | null
    _min: BillingPaymentMinAggregateOutputType | null
    _max: BillingPaymentMaxAggregateOutputType | null
  }

  export type BillingPaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillingPaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type BillingPaymentMinAggregateOutputType = {
    id: string | null
    paymentDate: Date | null
    amount: number | null
    paymentMethod: string | null
    transactionId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    billingInvoiceId: string | null
  }

  export type BillingPaymentMaxAggregateOutputType = {
    id: string | null
    paymentDate: Date | null
    amount: number | null
    paymentMethod: string | null
    transactionId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    billingInvoiceId: string | null
  }

  export type BillingPaymentCountAggregateOutputType = {
    id: number
    paymentDate: number
    amount: number
    paymentMethod: number
    transactionId: number
    status: number
    createdAt: number
    updatedAt: number
    billingInvoiceId: number
    _all: number
  }


  export type BillingPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type BillingPaymentSumAggregateInputType = {
    amount?: true
  }

  export type BillingPaymentMinAggregateInputType = {
    id?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    transactionId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
  }

  export type BillingPaymentMaxAggregateInputType = {
    id?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    transactionId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
  }

  export type BillingPaymentCountAggregateInputType = {
    id?: true
    paymentDate?: true
    amount?: true
    paymentMethod?: true
    transactionId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    billingInvoiceId?: true
    _all?: true
  }

  export type BillingPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPayment to aggregate.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingPayments
    **/
    _count?: true | BillingPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingPaymentMaxAggregateInputType
  }

  export type GetBillingPaymentAggregateType<T extends BillingPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingPayment[P]>
      : GetScalarType<T[P], AggregateBillingPayment[P]>
  }




  export type BillingPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingPaymentWhereInput
    orderBy?: BillingPaymentOrderByWithAggregationInput | BillingPaymentOrderByWithAggregationInput[]
    by: BillingPaymentScalarFieldEnum[] | BillingPaymentScalarFieldEnum
    having?: BillingPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingPaymentCountAggregateInputType | true
    _avg?: BillingPaymentAvgAggregateInputType
    _sum?: BillingPaymentSumAggregateInputType
    _min?: BillingPaymentMinAggregateInputType
    _max?: BillingPaymentMaxAggregateInputType
  }

  export type BillingPaymentGroupByOutputType = {
    id: string
    paymentDate: Date
    amount: number
    paymentMethod: string
    transactionId: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    billingInvoiceId: string | null
    _count: BillingPaymentCountAggregateOutputType | null
    _avg: BillingPaymentAvgAggregateOutputType | null
    _sum: BillingPaymentSumAggregateOutputType | null
    _min: BillingPaymentMinAggregateOutputType | null
    _max: BillingPaymentMaxAggregateOutputType | null
  }

  type GetBillingPaymentGroupByPayload<T extends BillingPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], BillingPaymentGroupByOutputType[P]>
        }
      >
    >


  export type BillingPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingPayment"]>

  export type BillingPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingPayment"]>

  export type BillingPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingPayment"]>

  export type BillingPaymentSelectScalar = {
    id?: boolean
    paymentDate?: boolean
    amount?: boolean
    paymentMethod?: boolean
    transactionId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    billingInvoiceId?: boolean
  }

  export type BillingPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentDate" | "amount" | "paymentMethod" | "transactionId" | "status" | "createdAt" | "updatedAt" | "billingInvoiceId", ExtArgs["result"]["billingPayment"]>
  export type BillingPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }
  export type BillingPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }
  export type BillingPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BillingInvoice?: boolean | BillingPayment$BillingInvoiceArgs<ExtArgs>
  }

  export type $BillingPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingPayment"
    objects: {
      BillingInvoice: Prisma.$BillingInvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentDate: Date
      amount: number
      paymentMethod: string
      transactionId: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      billingInvoiceId: string | null
    }, ExtArgs["result"]["billingPayment"]>
    composites: {}
  }

  type BillingPaymentGetPayload<S extends boolean | null | undefined | BillingPaymentDefaultArgs> = $Result.GetResult<Prisma.$BillingPaymentPayload, S>

  type BillingPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingPaymentCountAggregateInputType | true
    }

  export interface BillingPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingPayment'], meta: { name: 'BillingPayment' } }
    /**
     * Find zero or one BillingPayment that matches the filter.
     * @param {BillingPaymentFindUniqueArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingPaymentFindUniqueArgs>(args: SelectSubset<T, BillingPaymentFindUniqueArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingPaymentFindUniqueOrThrowArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentFindFirstArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingPaymentFindFirstArgs>(args?: SelectSubset<T, BillingPaymentFindFirstArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentFindFirstOrThrowArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingPayments
     * const billingPayments = await prisma.billingPayment.findMany()
     * 
     * // Get first 10 BillingPayments
     * const billingPayments = await prisma.billingPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingPaymentWithIdOnly = await prisma.billingPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingPaymentFindManyArgs>(args?: SelectSubset<T, BillingPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingPayment.
     * @param {BillingPaymentCreateArgs} args - Arguments to create a BillingPayment.
     * @example
     * // Create one BillingPayment
     * const BillingPayment = await prisma.billingPayment.create({
     *   data: {
     *     // ... data to create a BillingPayment
     *   }
     * })
     * 
     */
    create<T extends BillingPaymentCreateArgs>(args: SelectSubset<T, BillingPaymentCreateArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingPayments.
     * @param {BillingPaymentCreateManyArgs} args - Arguments to create many BillingPayments.
     * @example
     * // Create many BillingPayments
     * const billingPayment = await prisma.billingPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingPaymentCreateManyArgs>(args?: SelectSubset<T, BillingPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingPayments and returns the data saved in the database.
     * @param {BillingPaymentCreateManyAndReturnArgs} args - Arguments to create many BillingPayments.
     * @example
     * // Create many BillingPayments
     * const billingPayment = await prisma.billingPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingPayments and only return the `id`
     * const billingPaymentWithIdOnly = await prisma.billingPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingPayment.
     * @param {BillingPaymentDeleteArgs} args - Arguments to delete one BillingPayment.
     * @example
     * // Delete one BillingPayment
     * const BillingPayment = await prisma.billingPayment.delete({
     *   where: {
     *     // ... filter to delete one BillingPayment
     *   }
     * })
     * 
     */
    delete<T extends BillingPaymentDeleteArgs>(args: SelectSubset<T, BillingPaymentDeleteArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingPayment.
     * @param {BillingPaymentUpdateArgs} args - Arguments to update one BillingPayment.
     * @example
     * // Update one BillingPayment
     * const billingPayment = await prisma.billingPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingPaymentUpdateArgs>(args: SelectSubset<T, BillingPaymentUpdateArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingPayments.
     * @param {BillingPaymentDeleteManyArgs} args - Arguments to filter BillingPayments to delete.
     * @example
     * // Delete a few BillingPayments
     * const { count } = await prisma.billingPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingPaymentDeleteManyArgs>(args?: SelectSubset<T, BillingPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingPayments
     * const billingPayment = await prisma.billingPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingPaymentUpdateManyArgs>(args: SelectSubset<T, BillingPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingPayments and returns the data updated in the database.
     * @param {BillingPaymentUpdateManyAndReturnArgs} args - Arguments to update many BillingPayments.
     * @example
     * // Update many BillingPayments
     * const billingPayment = await prisma.billingPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingPayments and only return the `id`
     * const billingPaymentWithIdOnly = await prisma.billingPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingPayment.
     * @param {BillingPaymentUpsertArgs} args - Arguments to update or create a BillingPayment.
     * @example
     * // Update or create a BillingPayment
     * const billingPayment = await prisma.billingPayment.upsert({
     *   create: {
     *     // ... data to create a BillingPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingPayment we want to update
     *   }
     * })
     */
    upsert<T extends BillingPaymentUpsertArgs>(args: SelectSubset<T, BillingPaymentUpsertArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentCountArgs} args - Arguments to filter BillingPayments to count.
     * @example
     * // Count the number of BillingPayments
     * const count = await prisma.billingPayment.count({
     *   where: {
     *     // ... the filter for the BillingPayments we want to count
     *   }
     * })
    **/
    count<T extends BillingPaymentCountArgs>(
      args?: Subset<T, BillingPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingPaymentAggregateArgs>(args: Subset<T, BillingPaymentAggregateArgs>): Prisma.PrismaPromise<GetBillingPaymentAggregateType<T>>

    /**
     * Group by BillingPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingPaymentGroupByArgs['orderBy'] }
        : { orderBy?: BillingPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingPayment model
   */
  readonly fields: BillingPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BillingInvoice<T extends BillingPayment$BillingInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, BillingPayment$BillingInvoiceArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingPayment model
   */
  interface BillingPaymentFieldRefs {
    readonly id: FieldRef<"BillingPayment", 'String'>
    readonly paymentDate: FieldRef<"BillingPayment", 'DateTime'>
    readonly amount: FieldRef<"BillingPayment", 'Float'>
    readonly paymentMethod: FieldRef<"BillingPayment", 'String'>
    readonly transactionId: FieldRef<"BillingPayment", 'String'>
    readonly status: FieldRef<"BillingPayment", 'String'>
    readonly createdAt: FieldRef<"BillingPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"BillingPayment", 'DateTime'>
    readonly billingInvoiceId: FieldRef<"BillingPayment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BillingPayment findUnique
   */
  export type BillingPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment findUniqueOrThrow
   */
  export type BillingPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment findFirst
   */
  export type BillingPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPayments.
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPayments.
     */
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingPayment findFirstOrThrow
   */
  export type BillingPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPayments.
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPayments.
     */
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingPayment findMany
   */
  export type BillingPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayments to fetch.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingPayments.
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingPayment create
   */
  export type BillingPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingPayment.
     */
    data: XOR<BillingPaymentCreateInput, BillingPaymentUncheckedCreateInput>
  }

  /**
   * BillingPayment createMany
   */
  export type BillingPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingPayments.
     */
    data: BillingPaymentCreateManyInput | BillingPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingPayment createManyAndReturn
   */
  export type BillingPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many BillingPayments.
     */
    data: BillingPaymentCreateManyInput | BillingPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingPayment update
   */
  export type BillingPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingPayment.
     */
    data: XOR<BillingPaymentUpdateInput, BillingPaymentUncheckedUpdateInput>
    /**
     * Choose, which BillingPayment to update.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment updateMany
   */
  export type BillingPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingPayments.
     */
    data: XOR<BillingPaymentUpdateManyMutationInput, BillingPaymentUncheckedUpdateManyInput>
    /**
     * Filter which BillingPayments to update
     */
    where?: BillingPaymentWhereInput
    /**
     * Limit how many BillingPayments to update.
     */
    limit?: number
  }

  /**
   * BillingPayment updateManyAndReturn
   */
  export type BillingPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * The data used to update BillingPayments.
     */
    data: XOR<BillingPaymentUpdateManyMutationInput, BillingPaymentUncheckedUpdateManyInput>
    /**
     * Filter which BillingPayments to update
     */
    where?: BillingPaymentWhereInput
    /**
     * Limit how many BillingPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingPayment upsert
   */
  export type BillingPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingPayment to update in case it exists.
     */
    where: BillingPaymentWhereUniqueInput
    /**
     * In case the BillingPayment found by the `where` argument doesn't exist, create a new BillingPayment with this data.
     */
    create: XOR<BillingPaymentCreateInput, BillingPaymentUncheckedCreateInput>
    /**
     * In case the BillingPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingPaymentUpdateInput, BillingPaymentUncheckedUpdateInput>
  }

  /**
   * BillingPayment delete
   */
  export type BillingPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter which BillingPayment to delete.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment deleteMany
   */
  export type BillingPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPayments to delete
     */
    where?: BillingPaymentWhereInput
    /**
     * Limit how many BillingPayments to delete.
     */
    limit?: number
  }

  /**
   * BillingPayment.BillingInvoice
   */
  export type BillingPayment$BillingInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    where?: BillingInvoiceWhereInput
  }

  /**
   * BillingPayment without action
   */
  export type BillingPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    price: number | null
    durationDays: number | null
  }

  export type PlanSumAggregateOutputType = {
    price: number | null
    durationDays: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    description: string | null
    durationDays: number | null
    isActive: boolean | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    description: string | null
    durationDays: number | null
    isActive: boolean | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    price: number
    description: number
    durationDays: number
    isActive: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    price?: true
    durationDays?: true
  }

  export type PlanSumAggregateInputType = {
    price?: true
    durationDays?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    durationDays?: true
    isActive?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    durationDays?: true
    isActive?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    description?: true
    durationDays?: true
    isActive?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    price: number
    description: string | null
    durationDays: number
    isActive: boolean
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    durationDays?: boolean
    isActive?: boolean
    tenants?: boolean | Plan$tenantsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    durationDays?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    durationDays?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    durationDays?: boolean
    isActive?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "description" | "durationDays" | "isActive", ExtArgs["result"]["plan"]>
  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenants?: boolean | Plan$tenantsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      tenants: Prisma.$TenantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
      description: string | null
      durationDays: number
      isActive: boolean
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenants<T extends Plan$tenantsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$tenantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly price: FieldRef<"Plan", 'Float'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly durationDays: FieldRef<"Plan", 'Int'>
    readonly isActive: FieldRef<"Plan", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan.tenants
   */
  export type Plan$tenantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    cursor?: TenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model CollectionCase
   */

  export type AggregateCollectionCase = {
    _count: CollectionCaseCountAggregateOutputType | null
    _avg: CollectionCaseAvgAggregateOutputType | null
    _sum: CollectionCaseSumAggregateOutputType | null
    _min: CollectionCaseMinAggregateOutputType | null
    _max: CollectionCaseMaxAggregateOutputType | null
  }

  export type CollectionCaseAvgAggregateOutputType = {
    amountOriginal: Decimal | null
    amountDue: Decimal | null
    amountToReceive: Decimal | null
  }

  export type CollectionCaseSumAggregateOutputType = {
    amountOriginal: Decimal | null
    amountDue: Decimal | null
    amountToReceive: Decimal | null
  }

  export type CollectionCaseMinAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    issueDate: Date | null
    dueDate: Date | null
    reminder1SentAt: Date | null
    reminder1DueDate: Date | null
    reminder2SentAt: Date | null
    reminder2DueDate: Date | null
    tenantId: string | null
    debtorId: string | null
    amountOriginal: Decimal | null
    amountDue: Decimal | null
    amountToReceive: Decimal | null
    status: $Enums.CollectionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionCaseMaxAggregateOutputType = {
    id: string | null
    referenceNumber: string | null
    issueDate: Date | null
    dueDate: Date | null
    reminder1SentAt: Date | null
    reminder1DueDate: Date | null
    reminder2SentAt: Date | null
    reminder2DueDate: Date | null
    tenantId: string | null
    debtorId: string | null
    amountOriginal: Decimal | null
    amountDue: Decimal | null
    amountToReceive: Decimal | null
    status: $Enums.CollectionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionCaseCountAggregateOutputType = {
    id: number
    referenceNumber: number
    issueDate: number
    dueDate: number
    reminder1SentAt: number
    reminder1DueDate: number
    reminder2SentAt: number
    reminder2DueDate: number
    tenantId: number
    debtorId: number
    amountOriginal: number
    amountDue: number
    amountToReceive: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollectionCaseAvgAggregateInputType = {
    amountOriginal?: true
    amountDue?: true
    amountToReceive?: true
  }

  export type CollectionCaseSumAggregateInputType = {
    amountOriginal?: true
    amountDue?: true
    amountToReceive?: true
  }

  export type CollectionCaseMinAggregateInputType = {
    id?: true
    referenceNumber?: true
    issueDate?: true
    dueDate?: true
    reminder1SentAt?: true
    reminder1DueDate?: true
    reminder2SentAt?: true
    reminder2DueDate?: true
    tenantId?: true
    debtorId?: true
    amountOriginal?: true
    amountDue?: true
    amountToReceive?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionCaseMaxAggregateInputType = {
    id?: true
    referenceNumber?: true
    issueDate?: true
    dueDate?: true
    reminder1SentAt?: true
    reminder1DueDate?: true
    reminder2SentAt?: true
    reminder2DueDate?: true
    tenantId?: true
    debtorId?: true
    amountOriginal?: true
    amountDue?: true
    amountToReceive?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionCaseCountAggregateInputType = {
    id?: true
    referenceNumber?: true
    issueDate?: true
    dueDate?: true
    reminder1SentAt?: true
    reminder1DueDate?: true
    reminder2SentAt?: true
    reminder2DueDate?: true
    tenantId?: true
    debtorId?: true
    amountOriginal?: true
    amountDue?: true
    amountToReceive?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollectionCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCase to aggregate.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionCases
    **/
    _count?: true | CollectionCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionCaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionCaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionCaseMaxAggregateInputType
  }

  export type GetCollectionCaseAggregateType<T extends CollectionCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionCase[P]>
      : GetScalarType<T[P], AggregateCollectionCase[P]>
  }




  export type CollectionCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseWhereInput
    orderBy?: CollectionCaseOrderByWithAggregationInput | CollectionCaseOrderByWithAggregationInput[]
    by: CollectionCaseScalarFieldEnum[] | CollectionCaseScalarFieldEnum
    having?: CollectionCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCaseCountAggregateInputType | true
    _avg?: CollectionCaseAvgAggregateInputType
    _sum?: CollectionCaseSumAggregateInputType
    _min?: CollectionCaseMinAggregateInputType
    _max?: CollectionCaseMaxAggregateInputType
  }

  export type CollectionCaseGroupByOutputType = {
    id: string
    referenceNumber: string | null
    issueDate: Date | null
    dueDate: Date | null
    reminder1SentAt: Date | null
    reminder1DueDate: Date | null
    reminder2SentAt: Date | null
    reminder2DueDate: Date | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal
    amountDue: Decimal
    amountToReceive: Decimal
    status: $Enums.CollectionStatus
    createdAt: Date
    updatedAt: Date
    _count: CollectionCaseCountAggregateOutputType | null
    _avg: CollectionCaseAvgAggregateOutputType | null
    _sum: CollectionCaseSumAggregateOutputType | null
    _min: CollectionCaseMinAggregateOutputType | null
    _max: CollectionCaseMaxAggregateOutputType | null
  }

  type GetCollectionCaseGroupByPayload<T extends CollectionCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionCaseGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionCaseGroupByOutputType[P]>
        }
      >
    >


  export type CollectionCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    issueDate?: boolean
    dueDate?: boolean
    reminder1SentAt?: boolean
    reminder1DueDate?: boolean
    reminder2SentAt?: boolean
    reminder2DueDate?: boolean
    tenantId?: boolean
    debtorId?: boolean
    amountOriginal?: boolean
    amountDue?: boolean
    amountToReceive?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    notifications?: boolean | CollectionCase$notificationsArgs<ExtArgs>
    payments?: boolean | CollectionCase$paymentsArgs<ExtArgs>
    paymentAgreements?: boolean | CollectionCase$paymentAgreementsArgs<ExtArgs>
    penalties?: boolean | CollectionCase$penaltiesArgs<ExtArgs>
    chatRooms?: boolean | CollectionCase$chatRoomsArgs<ExtArgs>
    _count?: boolean | CollectionCaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCase"]>

  export type CollectionCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    issueDate?: boolean
    dueDate?: boolean
    reminder1SentAt?: boolean
    reminder1DueDate?: boolean
    reminder2SentAt?: boolean
    reminder2DueDate?: boolean
    tenantId?: boolean
    debtorId?: boolean
    amountOriginal?: boolean
    amountDue?: boolean
    amountToReceive?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCase"]>

  export type CollectionCaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referenceNumber?: boolean
    issueDate?: boolean
    dueDate?: boolean
    reminder1SentAt?: boolean
    reminder1DueDate?: boolean
    reminder2SentAt?: boolean
    reminder2DueDate?: boolean
    tenantId?: boolean
    debtorId?: boolean
    amountOriginal?: boolean
    amountDue?: boolean
    amountToReceive?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCase"]>

  export type CollectionCaseSelectScalar = {
    id?: boolean
    referenceNumber?: boolean
    issueDate?: boolean
    dueDate?: boolean
    reminder1SentAt?: boolean
    reminder1DueDate?: boolean
    reminder2SentAt?: boolean
    reminder2DueDate?: boolean
    tenantId?: boolean
    debtorId?: boolean
    amountOriginal?: boolean
    amountDue?: boolean
    amountToReceive?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CollectionCaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referenceNumber" | "issueDate" | "dueDate" | "reminder1SentAt" | "reminder1DueDate" | "reminder2SentAt" | "reminder2DueDate" | "tenantId" | "debtorId" | "amountOriginal" | "amountDue" | "amountToReceive" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["collectionCase"]>
  export type CollectionCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    notifications?: boolean | CollectionCase$notificationsArgs<ExtArgs>
    payments?: boolean | CollectionCase$paymentsArgs<ExtArgs>
    paymentAgreements?: boolean | CollectionCase$paymentAgreementsArgs<ExtArgs>
    penalties?: boolean | CollectionCase$penaltiesArgs<ExtArgs>
    chatRooms?: boolean | CollectionCase$chatRoomsArgs<ExtArgs>
    _count?: boolean | CollectionCaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollectionCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CollectionCaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CollectionCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionCase"
    objects: {
      debtor: Prisma.$DebtorPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      paymentAgreements: Prisma.$PaymentAgreementPayload<ExtArgs>[]
      penalties: Prisma.$PenaltyPayload<ExtArgs>[]
      chatRooms: Prisma.$ChatRoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referenceNumber: string | null
      issueDate: Date | null
      dueDate: Date | null
      reminder1SentAt: Date | null
      reminder1DueDate: Date | null
      reminder2SentAt: Date | null
      reminder2DueDate: Date | null
      tenantId: string
      debtorId: string
      amountOriginal: Prisma.Decimal
      amountDue: Prisma.Decimal
      amountToReceive: Prisma.Decimal
      status: $Enums.CollectionStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["collectionCase"]>
    composites: {}
  }

  type CollectionCaseGetPayload<S extends boolean | null | undefined | CollectionCaseDefaultArgs> = $Result.GetResult<Prisma.$CollectionCasePayload, S>

  type CollectionCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionCaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCaseCountAggregateInputType | true
    }

  export interface CollectionCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionCase'], meta: { name: 'CollectionCase' } }
    /**
     * Find zero or one CollectionCase that matches the filter.
     * @param {CollectionCaseFindUniqueArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionCaseFindUniqueArgs>(args: SelectSubset<T, CollectionCaseFindUniqueArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionCase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionCaseFindUniqueOrThrowArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseFindFirstArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionCaseFindFirstArgs>(args?: SelectSubset<T, CollectionCaseFindFirstArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseFindFirstOrThrowArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionCases
     * const collectionCases = await prisma.collectionCase.findMany()
     * 
     * // Get first 10 CollectionCases
     * const collectionCases = await prisma.collectionCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionCaseWithIdOnly = await prisma.collectionCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionCaseFindManyArgs>(args?: SelectSubset<T, CollectionCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionCase.
     * @param {CollectionCaseCreateArgs} args - Arguments to create a CollectionCase.
     * @example
     * // Create one CollectionCase
     * const CollectionCase = await prisma.collectionCase.create({
     *   data: {
     *     // ... data to create a CollectionCase
     *   }
     * })
     * 
     */
    create<T extends CollectionCaseCreateArgs>(args: SelectSubset<T, CollectionCaseCreateArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionCases.
     * @param {CollectionCaseCreateManyArgs} args - Arguments to create many CollectionCases.
     * @example
     * // Create many CollectionCases
     * const collectionCase = await prisma.collectionCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCaseCreateManyArgs>(args?: SelectSubset<T, CollectionCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionCases and returns the data saved in the database.
     * @param {CollectionCaseCreateManyAndReturnArgs} args - Arguments to create many CollectionCases.
     * @example
     * // Create many CollectionCases
     * const collectionCase = await prisma.collectionCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionCases and only return the `id`
     * const collectionCaseWithIdOnly = await prisma.collectionCase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionCase.
     * @param {CollectionCaseDeleteArgs} args - Arguments to delete one CollectionCase.
     * @example
     * // Delete one CollectionCase
     * const CollectionCase = await prisma.collectionCase.delete({
     *   where: {
     *     // ... filter to delete one CollectionCase
     *   }
     * })
     * 
     */
    delete<T extends CollectionCaseDeleteArgs>(args: SelectSubset<T, CollectionCaseDeleteArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionCase.
     * @param {CollectionCaseUpdateArgs} args - Arguments to update one CollectionCase.
     * @example
     * // Update one CollectionCase
     * const collectionCase = await prisma.collectionCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionCaseUpdateArgs>(args: SelectSubset<T, CollectionCaseUpdateArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionCases.
     * @param {CollectionCaseDeleteManyArgs} args - Arguments to filter CollectionCases to delete.
     * @example
     * // Delete a few CollectionCases
     * const { count } = await prisma.collectionCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionCaseDeleteManyArgs>(args?: SelectSubset<T, CollectionCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionCases
     * const collectionCase = await prisma.collectionCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionCaseUpdateManyArgs>(args: SelectSubset<T, CollectionCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCases and returns the data updated in the database.
     * @param {CollectionCaseUpdateManyAndReturnArgs} args - Arguments to update many CollectionCases.
     * @example
     * // Update many CollectionCases
     * const collectionCase = await prisma.collectionCase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionCases and only return the `id`
     * const collectionCaseWithIdOnly = await prisma.collectionCase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionCaseUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionCaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionCase.
     * @param {CollectionCaseUpsertArgs} args - Arguments to update or create a CollectionCase.
     * @example
     * // Update or create a CollectionCase
     * const collectionCase = await prisma.collectionCase.upsert({
     *   create: {
     *     // ... data to create a CollectionCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionCase we want to update
     *   }
     * })
     */
    upsert<T extends CollectionCaseUpsertArgs>(args: SelectSubset<T, CollectionCaseUpsertArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseCountArgs} args - Arguments to filter CollectionCases to count.
     * @example
     * // Count the number of CollectionCases
     * const count = await prisma.collectionCase.count({
     *   where: {
     *     // ... the filter for the CollectionCases we want to count
     *   }
     * })
    **/
    count<T extends CollectionCaseCountArgs>(
      args?: Subset<T, CollectionCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionCaseAggregateArgs>(args: Subset<T, CollectionCaseAggregateArgs>): Prisma.PrismaPromise<GetCollectionCaseAggregateType<T>>

    /**
     * Group by CollectionCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionCaseGroupByArgs['orderBy'] }
        : { orderBy?: CollectionCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionCase model
   */
  readonly fields: CollectionCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    debtor<T extends DebtorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtorDefaultArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends CollectionCase$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends CollectionCase$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentAgreements<T extends CollectionCase$paymentAgreementsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$paymentAgreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    penalties<T extends CollectionCase$penaltiesArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$penaltiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatRooms<T extends CollectionCase$chatRoomsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$chatRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionCase model
   */
  interface CollectionCaseFieldRefs {
    readonly id: FieldRef<"CollectionCase", 'String'>
    readonly referenceNumber: FieldRef<"CollectionCase", 'String'>
    readonly issueDate: FieldRef<"CollectionCase", 'DateTime'>
    readonly dueDate: FieldRef<"CollectionCase", 'DateTime'>
    readonly reminder1SentAt: FieldRef<"CollectionCase", 'DateTime'>
    readonly reminder1DueDate: FieldRef<"CollectionCase", 'DateTime'>
    readonly reminder2SentAt: FieldRef<"CollectionCase", 'DateTime'>
    readonly reminder2DueDate: FieldRef<"CollectionCase", 'DateTime'>
    readonly tenantId: FieldRef<"CollectionCase", 'String'>
    readonly debtorId: FieldRef<"CollectionCase", 'String'>
    readonly amountOriginal: FieldRef<"CollectionCase", 'Decimal'>
    readonly amountDue: FieldRef<"CollectionCase", 'Decimal'>
    readonly amountToReceive: FieldRef<"CollectionCase", 'Decimal'>
    readonly status: FieldRef<"CollectionCase", 'CollectionStatus'>
    readonly createdAt: FieldRef<"CollectionCase", 'DateTime'>
    readonly updatedAt: FieldRef<"CollectionCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionCase findUnique
   */
  export type CollectionCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase findUniqueOrThrow
   */
  export type CollectionCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase findFirst
   */
  export type CollectionCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCases.
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCases.
     */
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * CollectionCase findFirstOrThrow
   */
  export type CollectionCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCases.
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCases.
     */
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * CollectionCase findMany
   */
  export type CollectionCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCases to fetch.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionCases.
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * CollectionCase create
   */
  export type CollectionCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a CollectionCase.
     */
    data: XOR<CollectionCaseCreateInput, CollectionCaseUncheckedCreateInput>
  }

  /**
   * CollectionCase createMany
   */
  export type CollectionCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionCases.
     */
    data: CollectionCaseCreateManyInput | CollectionCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionCase createManyAndReturn
   */
  export type CollectionCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionCases.
     */
    data: CollectionCaseCreateManyInput | CollectionCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCase update
   */
  export type CollectionCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a CollectionCase.
     */
    data: XOR<CollectionCaseUpdateInput, CollectionCaseUncheckedUpdateInput>
    /**
     * Choose, which CollectionCase to update.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase updateMany
   */
  export type CollectionCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionCases.
     */
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCases to update
     */
    where?: CollectionCaseWhereInput
    /**
     * Limit how many CollectionCases to update.
     */
    limit?: number
  }

  /**
   * CollectionCase updateManyAndReturn
   */
  export type CollectionCaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * The data used to update CollectionCases.
     */
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCases to update
     */
    where?: CollectionCaseWhereInput
    /**
     * Limit how many CollectionCases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCase upsert
   */
  export type CollectionCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the CollectionCase to update in case it exists.
     */
    where: CollectionCaseWhereUniqueInput
    /**
     * In case the CollectionCase found by the `where` argument doesn't exist, create a new CollectionCase with this data.
     */
    create: XOR<CollectionCaseCreateInput, CollectionCaseUncheckedCreateInput>
    /**
     * In case the CollectionCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionCaseUpdateInput, CollectionCaseUncheckedUpdateInput>
  }

  /**
   * CollectionCase delete
   */
  export type CollectionCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter which CollectionCase to delete.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase deleteMany
   */
  export type CollectionCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCases to delete
     */
    where?: CollectionCaseWhereInput
    /**
     * Limit how many CollectionCases to delete.
     */
    limit?: number
  }

  /**
   * CollectionCase.notifications
   */
  export type CollectionCase$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * CollectionCase.payments
   */
  export type CollectionCase$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * CollectionCase.paymentAgreements
   */
  export type CollectionCase$paymentAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    where?: PaymentAgreementWhereInput
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    cursor?: PaymentAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentAgreementScalarFieldEnum | PaymentAgreementScalarFieldEnum[]
  }

  /**
   * CollectionCase.penalties
   */
  export type CollectionCase$penaltiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    where?: PenaltyWhereInput
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    cursor?: PenaltyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * CollectionCase.chatRooms
   */
  export type CollectionCase$chatRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    where?: ChatRoomWhereInput
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    cursor?: ChatRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * CollectionCase without action
   */
  export type CollectionCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
  }


  /**
   * Model Penalty
   */

  export type AggregatePenalty = {
    _count: PenaltyCountAggregateOutputType | null
    _avg: PenaltyAvgAggregateOutputType | null
    _sum: PenaltySumAggregateOutputType | null
    _min: PenaltyMinAggregateOutputType | null
    _max: PenaltyMaxAggregateOutputType | null
  }

  export type PenaltyAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PenaltySumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PenaltyMinAggregateOutputType = {
    id: string | null
    collectionCaseId: string | null
    description: string | null
    amount: Decimal | null
    dateApplied: Date | null
    isPaid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PenaltyMaxAggregateOutputType = {
    id: string | null
    collectionCaseId: string | null
    description: string | null
    amount: Decimal | null
    dateApplied: Date | null
    isPaid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PenaltyCountAggregateOutputType = {
    id: number
    collectionCaseId: number
    description: number
    amount: number
    dateApplied: number
    isPaid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PenaltyAvgAggregateInputType = {
    amount?: true
  }

  export type PenaltySumAggregateInputType = {
    amount?: true
  }

  export type PenaltyMinAggregateInputType = {
    id?: true
    collectionCaseId?: true
    description?: true
    amount?: true
    dateApplied?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PenaltyMaxAggregateInputType = {
    id?: true
    collectionCaseId?: true
    description?: true
    amount?: true
    dateApplied?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PenaltyCountAggregateInputType = {
    id?: true
    collectionCaseId?: true
    description?: true
    amount?: true
    dateApplied?: true
    isPaid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PenaltyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Penalty to aggregate.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Penalties
    **/
    _count?: true | PenaltyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PenaltyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PenaltySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PenaltyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PenaltyMaxAggregateInputType
  }

  export type GetPenaltyAggregateType<T extends PenaltyAggregateArgs> = {
        [P in keyof T & keyof AggregatePenalty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePenalty[P]>
      : GetScalarType<T[P], AggregatePenalty[P]>
  }




  export type PenaltyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PenaltyWhereInput
    orderBy?: PenaltyOrderByWithAggregationInput | PenaltyOrderByWithAggregationInput[]
    by: PenaltyScalarFieldEnum[] | PenaltyScalarFieldEnum
    having?: PenaltyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PenaltyCountAggregateInputType | true
    _avg?: PenaltyAvgAggregateInputType
    _sum?: PenaltySumAggregateInputType
    _min?: PenaltyMinAggregateInputType
    _max?: PenaltyMaxAggregateInputType
  }

  export type PenaltyGroupByOutputType = {
    id: string
    collectionCaseId: string
    description: string | null
    amount: Decimal
    dateApplied: Date
    isPaid: boolean
    createdAt: Date
    updatedAt: Date
    _count: PenaltyCountAggregateOutputType | null
    _avg: PenaltyAvgAggregateOutputType | null
    _sum: PenaltySumAggregateOutputType | null
    _min: PenaltyMinAggregateOutputType | null
    _max: PenaltyMaxAggregateOutputType | null
  }

  type GetPenaltyGroupByPayload<T extends PenaltyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PenaltyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PenaltyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PenaltyGroupByOutputType[P]>
            : GetScalarType<T[P], PenaltyGroupByOutputType[P]>
        }
      >
    >


  export type PenaltySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    description?: boolean
    amount?: boolean
    dateApplied?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["penalty"]>

  export type PenaltySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    description?: boolean
    amount?: boolean
    dateApplied?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["penalty"]>

  export type PenaltySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    description?: boolean
    amount?: boolean
    dateApplied?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["penalty"]>

  export type PenaltySelectScalar = {
    id?: boolean
    collectionCaseId?: boolean
    description?: boolean
    amount?: boolean
    dateApplied?: boolean
    isPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PenaltyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collectionCaseId" | "description" | "amount" | "dateApplied" | "isPaid" | "createdAt" | "updatedAt", ExtArgs["result"]["penalty"]>
  export type PenaltyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type PenaltyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type PenaltyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }

  export type $PenaltyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Penalty"
    objects: {
      collectionCase: Prisma.$CollectionCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collectionCaseId: string
      description: string | null
      amount: Prisma.Decimal
      dateApplied: Date
      isPaid: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["penalty"]>
    composites: {}
  }

  type PenaltyGetPayload<S extends boolean | null | undefined | PenaltyDefaultArgs> = $Result.GetResult<Prisma.$PenaltyPayload, S>

  type PenaltyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PenaltyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PenaltyCountAggregateInputType | true
    }

  export interface PenaltyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Penalty'], meta: { name: 'Penalty' } }
    /**
     * Find zero or one Penalty that matches the filter.
     * @param {PenaltyFindUniqueArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PenaltyFindUniqueArgs>(args: SelectSubset<T, PenaltyFindUniqueArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Penalty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PenaltyFindUniqueOrThrowArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PenaltyFindUniqueOrThrowArgs>(args: SelectSubset<T, PenaltyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Penalty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindFirstArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PenaltyFindFirstArgs>(args?: SelectSubset<T, PenaltyFindFirstArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Penalty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindFirstOrThrowArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PenaltyFindFirstOrThrowArgs>(args?: SelectSubset<T, PenaltyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Penalties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Penalties
     * const penalties = await prisma.penalty.findMany()
     * 
     * // Get first 10 Penalties
     * const penalties = await prisma.penalty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const penaltyWithIdOnly = await prisma.penalty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PenaltyFindManyArgs>(args?: SelectSubset<T, PenaltyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Penalty.
     * @param {PenaltyCreateArgs} args - Arguments to create a Penalty.
     * @example
     * // Create one Penalty
     * const Penalty = await prisma.penalty.create({
     *   data: {
     *     // ... data to create a Penalty
     *   }
     * })
     * 
     */
    create<T extends PenaltyCreateArgs>(args: SelectSubset<T, PenaltyCreateArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Penalties.
     * @param {PenaltyCreateManyArgs} args - Arguments to create many Penalties.
     * @example
     * // Create many Penalties
     * const penalty = await prisma.penalty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PenaltyCreateManyArgs>(args?: SelectSubset<T, PenaltyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Penalties and returns the data saved in the database.
     * @param {PenaltyCreateManyAndReturnArgs} args - Arguments to create many Penalties.
     * @example
     * // Create many Penalties
     * const penalty = await prisma.penalty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Penalties and only return the `id`
     * const penaltyWithIdOnly = await prisma.penalty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PenaltyCreateManyAndReturnArgs>(args?: SelectSubset<T, PenaltyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Penalty.
     * @param {PenaltyDeleteArgs} args - Arguments to delete one Penalty.
     * @example
     * // Delete one Penalty
     * const Penalty = await prisma.penalty.delete({
     *   where: {
     *     // ... filter to delete one Penalty
     *   }
     * })
     * 
     */
    delete<T extends PenaltyDeleteArgs>(args: SelectSubset<T, PenaltyDeleteArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Penalty.
     * @param {PenaltyUpdateArgs} args - Arguments to update one Penalty.
     * @example
     * // Update one Penalty
     * const penalty = await prisma.penalty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PenaltyUpdateArgs>(args: SelectSubset<T, PenaltyUpdateArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Penalties.
     * @param {PenaltyDeleteManyArgs} args - Arguments to filter Penalties to delete.
     * @example
     * // Delete a few Penalties
     * const { count } = await prisma.penalty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PenaltyDeleteManyArgs>(args?: SelectSubset<T, PenaltyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Penalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Penalties
     * const penalty = await prisma.penalty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PenaltyUpdateManyArgs>(args: SelectSubset<T, PenaltyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Penalties and returns the data updated in the database.
     * @param {PenaltyUpdateManyAndReturnArgs} args - Arguments to update many Penalties.
     * @example
     * // Update many Penalties
     * const penalty = await prisma.penalty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Penalties and only return the `id`
     * const penaltyWithIdOnly = await prisma.penalty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PenaltyUpdateManyAndReturnArgs>(args: SelectSubset<T, PenaltyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Penalty.
     * @param {PenaltyUpsertArgs} args - Arguments to update or create a Penalty.
     * @example
     * // Update or create a Penalty
     * const penalty = await prisma.penalty.upsert({
     *   create: {
     *     // ... data to create a Penalty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Penalty we want to update
     *   }
     * })
     */
    upsert<T extends PenaltyUpsertArgs>(args: SelectSubset<T, PenaltyUpsertArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Penalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyCountArgs} args - Arguments to filter Penalties to count.
     * @example
     * // Count the number of Penalties
     * const count = await prisma.penalty.count({
     *   where: {
     *     // ... the filter for the Penalties we want to count
     *   }
     * })
    **/
    count<T extends PenaltyCountArgs>(
      args?: Subset<T, PenaltyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PenaltyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Penalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PenaltyAggregateArgs>(args: Subset<T, PenaltyAggregateArgs>): Prisma.PrismaPromise<GetPenaltyAggregateType<T>>

    /**
     * Group by Penalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PenaltyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PenaltyGroupByArgs['orderBy'] }
        : { orderBy?: PenaltyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PenaltyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPenaltyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Penalty model
   */
  readonly fields: PenaltyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Penalty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PenaltyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionCase<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Penalty model
   */
  interface PenaltyFieldRefs {
    readonly id: FieldRef<"Penalty", 'String'>
    readonly collectionCaseId: FieldRef<"Penalty", 'String'>
    readonly description: FieldRef<"Penalty", 'String'>
    readonly amount: FieldRef<"Penalty", 'Decimal'>
    readonly dateApplied: FieldRef<"Penalty", 'DateTime'>
    readonly isPaid: FieldRef<"Penalty", 'Boolean'>
    readonly createdAt: FieldRef<"Penalty", 'DateTime'>
    readonly updatedAt: FieldRef<"Penalty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Penalty findUnique
   */
  export type PenaltyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty findUniqueOrThrow
   */
  export type PenaltyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty findFirst
   */
  export type PenaltyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Penalties.
     */
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty findFirstOrThrow
   */
  export type PenaltyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Penalties.
     */
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty findMany
   */
  export type PenaltyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalties to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty create
   */
  export type PenaltyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The data needed to create a Penalty.
     */
    data: XOR<PenaltyCreateInput, PenaltyUncheckedCreateInput>
  }

  /**
   * Penalty createMany
   */
  export type PenaltyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Penalties.
     */
    data: PenaltyCreateManyInput | PenaltyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Penalty createManyAndReturn
   */
  export type PenaltyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * The data used to create many Penalties.
     */
    data: PenaltyCreateManyInput | PenaltyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Penalty update
   */
  export type PenaltyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The data needed to update a Penalty.
     */
    data: XOR<PenaltyUpdateInput, PenaltyUncheckedUpdateInput>
    /**
     * Choose, which Penalty to update.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty updateMany
   */
  export type PenaltyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Penalties.
     */
    data: XOR<PenaltyUpdateManyMutationInput, PenaltyUncheckedUpdateManyInput>
    /**
     * Filter which Penalties to update
     */
    where?: PenaltyWhereInput
    /**
     * Limit how many Penalties to update.
     */
    limit?: number
  }

  /**
   * Penalty updateManyAndReturn
   */
  export type PenaltyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * The data used to update Penalties.
     */
    data: XOR<PenaltyUpdateManyMutationInput, PenaltyUncheckedUpdateManyInput>
    /**
     * Filter which Penalties to update
     */
    where?: PenaltyWhereInput
    /**
     * Limit how many Penalties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Penalty upsert
   */
  export type PenaltyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The filter to search for the Penalty to update in case it exists.
     */
    where: PenaltyWhereUniqueInput
    /**
     * In case the Penalty found by the `where` argument doesn't exist, create a new Penalty with this data.
     */
    create: XOR<PenaltyCreateInput, PenaltyUncheckedCreateInput>
    /**
     * In case the Penalty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PenaltyUpdateInput, PenaltyUncheckedUpdateInput>
  }

  /**
   * Penalty delete
   */
  export type PenaltyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter which Penalty to delete.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty deleteMany
   */
  export type PenaltyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Penalties to delete
     */
    where?: PenaltyWhereInput
    /**
     * Limit how many Penalties to delete.
     */
    limit?: number
  }

  /**
   * Penalty without action
   */
  export type PenaltyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    collectionCaseId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    sentAt: Date | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    collectionCaseId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    sentAt: Date | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    collectionCaseId: number
    type: number
    title: number
    message: number
    sentAt: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    collectionCaseId?: true
    type?: true
    title?: true
    message?: true
    sentAt?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    collectionCaseId?: true
    type?: true
    title?: true
    message?: true
    sentAt?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    collectionCaseId?: true
    type?: true
    title?: true
    message?: true
    sentAt?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    collectionCaseId: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt: Date
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sentAt?: boolean
    read?: boolean
    createdAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sentAt?: boolean
    read?: boolean
    createdAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sentAt?: boolean
    read?: boolean
    createdAt?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    collectionCaseId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sentAt?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collectionCaseId" | "type" | "title" | "message" | "sentAt" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      collectionCase: Prisma.$CollectionCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collectionCaseId: string
      type: $Enums.NotificationType
      title: string
      message: string
      sentAt: Date
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionCase<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly collectionCaseId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    createdAt: Date | null
    collectionCaseId: string | null
    paymentDate: Date | null
    referenceNumber: string | null
    updatedAt: Date | null
    paymentAgreementId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    createdAt: Date | null
    collectionCaseId: string | null
    paymentDate: Date | null
    referenceNumber: string | null
    updatedAt: Date | null
    paymentAgreementId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    amount: number
    method: number
    createdAt: number
    collectionCaseId: number
    paymentDate: number
    referenceNumber: number
    updatedAt: number
    paymentAgreementId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    amount?: true
    method?: true
    createdAt?: true
    collectionCaseId?: true
    paymentDate?: true
    referenceNumber?: true
    updatedAt?: true
    paymentAgreementId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    amount?: true
    method?: true
    createdAt?: true
    collectionCaseId?: true
    paymentDate?: true
    referenceNumber?: true
    updatedAt?: true
    paymentAgreementId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    amount?: true
    method?: true
    createdAt?: true
    collectionCaseId?: true
    paymentDate?: true
    referenceNumber?: true
    updatedAt?: true
    paymentAgreementId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    amount: Decimal
    method: $Enums.PaymentMethod
    createdAt: Date
    collectionCaseId: string
    paymentDate: Date
    referenceNumber: string | null
    updatedAt: Date
    paymentAgreementId: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    method?: boolean
    createdAt?: boolean
    collectionCaseId?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    updatedAt?: boolean
    paymentAgreementId?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    PaymentAgreement?: boolean | Payment$PaymentAgreementArgs<ExtArgs>
    Installment?: boolean | Payment$InstallmentArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    method?: boolean
    createdAt?: boolean
    collectionCaseId?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    updatedAt?: boolean
    paymentAgreementId?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    PaymentAgreement?: boolean | Payment$PaymentAgreementArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    method?: boolean
    createdAt?: boolean
    collectionCaseId?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    updatedAt?: boolean
    paymentAgreementId?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    PaymentAgreement?: boolean | Payment$PaymentAgreementArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    amount?: boolean
    method?: boolean
    createdAt?: boolean
    collectionCaseId?: boolean
    paymentDate?: boolean
    referenceNumber?: boolean
    updatedAt?: boolean
    paymentAgreementId?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "method" | "createdAt" | "collectionCaseId" | "paymentDate" | "referenceNumber" | "updatedAt" | "paymentAgreementId", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    PaymentAgreement?: boolean | Payment$PaymentAgreementArgs<ExtArgs>
    Installment?: boolean | Payment$InstallmentArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    PaymentAgreement?: boolean | Payment$PaymentAgreementArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    PaymentAgreement?: boolean | Payment$PaymentAgreementArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      collectionCase: Prisma.$CollectionCasePayload<ExtArgs>
      PaymentAgreement: Prisma.$PaymentAgreementPayload<ExtArgs> | null
      Installment: Prisma.$InstallmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: Prisma.Decimal
      method: $Enums.PaymentMethod
      createdAt: Date
      collectionCaseId: string
      paymentDate: Date
      referenceNumber: string | null
      updatedAt: Date
      paymentAgreementId: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionCase<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PaymentAgreement<T extends Payment$PaymentAgreementArgs<ExtArgs> = {}>(args?: Subset<T, Payment$PaymentAgreementArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Installment<T extends Payment$InstallmentArgs<ExtArgs> = {}>(args?: Subset<T, Payment$InstallmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly collectionCaseId: FieldRef<"Payment", 'String'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly referenceNumber: FieldRef<"Payment", 'String'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly paymentAgreementId: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.PaymentAgreement
   */
  export type Payment$PaymentAgreementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    where?: PaymentAgreementWhereInput
  }

  /**
   * Payment.Installment
   */
  export type Payment$InstallmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    where?: InstallmentWhereInput
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    cursor?: InstallmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Debtor
   */

  export type AggregateDebtor = {
    _count: DebtorCountAggregateOutputType | null
    _avg: DebtorAvgAggregateOutputType | null
    _sum: DebtorSumAggregateOutputType | null
    _min: DebtorMinAggregateOutputType | null
    _max: DebtorMaxAggregateOutputType | null
  }

  export type DebtorAvgAggregateOutputType = {
    totalIncome: number | null
  }

  export type DebtorSumAggregateOutputType = {
    totalIncome: number | null
  }

  export type DebtorMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    fullname: string | null
    email: string | null
    phone: string | null
    address: string | null
    personType: $Enums.PersonType | null
    identificationType: $Enums.IdentificationType | null
    identification: string | null
    totalIncome: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtorMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    fullname: string | null
    email: string | null
    phone: string | null
    address: string | null
    personType: $Enums.PersonType | null
    identificationType: $Enums.IdentificationType | null
    identification: string | null
    totalIncome: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtorCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    fullname: number
    email: number
    phone: number
    address: number
    personType: number
    identificationType: number
    identification: number
    totalIncome: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DebtorAvgAggregateInputType = {
    totalIncome?: true
  }

  export type DebtorSumAggregateInputType = {
    totalIncome?: true
  }

  export type DebtorMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    fullname?: true
    email?: true
    phone?: true
    address?: true
    personType?: true
    identificationType?: true
    identification?: true
    totalIncome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtorMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    fullname?: true
    email?: true
    phone?: true
    address?: true
    personType?: true
    identificationType?: true
    identification?: true
    totalIncome?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtorCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    fullname?: true
    email?: true
    phone?: true
    address?: true
    personType?: true
    identificationType?: true
    identification?: true
    totalIncome?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DebtorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debtor to aggregate.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Debtors
    **/
    _count?: true | DebtorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtorMaxAggregateInputType
  }

  export type GetDebtorAggregateType<T extends DebtorAggregateArgs> = {
        [P in keyof T & keyof AggregateDebtor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebtor[P]>
      : GetScalarType<T[P], AggregateDebtor[P]>
  }




  export type DebtorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorWhereInput
    orderBy?: DebtorOrderByWithAggregationInput | DebtorOrderByWithAggregationInput[]
    by: DebtorScalarFieldEnum[] | DebtorScalarFieldEnum
    having?: DebtorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtorCountAggregateInputType | true
    _avg?: DebtorAvgAggregateInputType
    _sum?: DebtorSumAggregateInputType
    _min?: DebtorMinAggregateInputType
    _max?: DebtorMaxAggregateInputType
  }

  export type DebtorGroupByOutputType = {
    id: string
    tenantId: string
    userId: string | null
    fullname: string
    email: string
    phone: string | null
    address: string | null
    personType: $Enums.PersonType
    identificationType: $Enums.IdentificationType | null
    identification: string | null
    totalIncome: number | null
    createdAt: Date
    updatedAt: Date
    _count: DebtorCountAggregateOutputType | null
    _avg: DebtorAvgAggregateOutputType | null
    _sum: DebtorSumAggregateOutputType | null
    _min: DebtorMinAggregateOutputType | null
    _max: DebtorMaxAggregateOutputType | null
  }

  type GetDebtorGroupByPayload<T extends DebtorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtorGroupByOutputType[P]>
            : GetScalarType<T[P], DebtorGroupByOutputType[P]>
        }
      >
    >


  export type DebtorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    personType?: boolean
    identificationType?: boolean
    identification?: boolean
    totalIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collectionCases?: boolean | Debtor$collectionCasesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
    incomes?: boolean | Debtor$incomesArgs<ExtArgs>
    paymentAgreements?: boolean | Debtor$paymentAgreementsArgs<ExtArgs>
    verdicts?: boolean | Debtor$verdictsArgs<ExtArgs>
    _count?: boolean | DebtorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtor"]>

  export type DebtorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    personType?: boolean
    identificationType?: boolean
    identification?: boolean
    totalIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }, ExtArgs["result"]["debtor"]>

  export type DebtorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    personType?: boolean
    identificationType?: boolean
    identification?: boolean
    totalIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }, ExtArgs["result"]["debtor"]>

  export type DebtorSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    personType?: boolean
    identificationType?: boolean
    identification?: boolean
    totalIncome?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DebtorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "fullname" | "email" | "phone" | "address" | "personType" | "identificationType" | "identification" | "totalIncome" | "createdAt" | "updatedAt", ExtArgs["result"]["debtor"]>
  export type DebtorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCases?: boolean | Debtor$collectionCasesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
    incomes?: boolean | Debtor$incomesArgs<ExtArgs>
    paymentAgreements?: boolean | Debtor$paymentAgreementsArgs<ExtArgs>
    verdicts?: boolean | Debtor$verdictsArgs<ExtArgs>
    _count?: boolean | DebtorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DebtorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }
  export type DebtorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }

  export type $DebtorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Debtor"
    objects: {
      collectionCases: Prisma.$CollectionCasePayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      incomes: Prisma.$DebtorIncomePayload<ExtArgs>[]
      paymentAgreements: Prisma.$PaymentAgreementPayload<ExtArgs>[]
      verdicts: Prisma.$VerdictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string | null
      fullname: string
      email: string
      phone: string | null
      address: string | null
      personType: $Enums.PersonType
      identificationType: $Enums.IdentificationType | null
      identification: string | null
      totalIncome: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["debtor"]>
    composites: {}
  }

  type DebtorGetPayload<S extends boolean | null | undefined | DebtorDefaultArgs> = $Result.GetResult<Prisma.$DebtorPayload, S>

  type DebtorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DebtorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DebtorCountAggregateInputType | true
    }

  export interface DebtorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Debtor'], meta: { name: 'Debtor' } }
    /**
     * Find zero or one Debtor that matches the filter.
     * @param {DebtorFindUniqueArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtorFindUniqueArgs>(args: SelectSubset<T, DebtorFindUniqueArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Debtor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DebtorFindUniqueOrThrowArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtorFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debtor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorFindFirstArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtorFindFirstArgs>(args?: SelectSubset<T, DebtorFindFirstArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debtor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorFindFirstOrThrowArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtorFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Debtors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Debtors
     * const debtors = await prisma.debtor.findMany()
     * 
     * // Get first 10 Debtors
     * const debtors = await prisma.debtor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtorWithIdOnly = await prisma.debtor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtorFindManyArgs>(args?: SelectSubset<T, DebtorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Debtor.
     * @param {DebtorCreateArgs} args - Arguments to create a Debtor.
     * @example
     * // Create one Debtor
     * const Debtor = await prisma.debtor.create({
     *   data: {
     *     // ... data to create a Debtor
     *   }
     * })
     * 
     */
    create<T extends DebtorCreateArgs>(args: SelectSubset<T, DebtorCreateArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Debtors.
     * @param {DebtorCreateManyArgs} args - Arguments to create many Debtors.
     * @example
     * // Create many Debtors
     * const debtor = await prisma.debtor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtorCreateManyArgs>(args?: SelectSubset<T, DebtorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Debtors and returns the data saved in the database.
     * @param {DebtorCreateManyAndReturnArgs} args - Arguments to create many Debtors.
     * @example
     * // Create many Debtors
     * const debtor = await prisma.debtor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Debtors and only return the `id`
     * const debtorWithIdOnly = await prisma.debtor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DebtorCreateManyAndReturnArgs>(args?: SelectSubset<T, DebtorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Debtor.
     * @param {DebtorDeleteArgs} args - Arguments to delete one Debtor.
     * @example
     * // Delete one Debtor
     * const Debtor = await prisma.debtor.delete({
     *   where: {
     *     // ... filter to delete one Debtor
     *   }
     * })
     * 
     */
    delete<T extends DebtorDeleteArgs>(args: SelectSubset<T, DebtorDeleteArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Debtor.
     * @param {DebtorUpdateArgs} args - Arguments to update one Debtor.
     * @example
     * // Update one Debtor
     * const debtor = await prisma.debtor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtorUpdateArgs>(args: SelectSubset<T, DebtorUpdateArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Debtors.
     * @param {DebtorDeleteManyArgs} args - Arguments to filter Debtors to delete.
     * @example
     * // Delete a few Debtors
     * const { count } = await prisma.debtor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtorDeleteManyArgs>(args?: SelectSubset<T, DebtorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debtors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Debtors
     * const debtor = await prisma.debtor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtorUpdateManyArgs>(args: SelectSubset<T, DebtorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debtors and returns the data updated in the database.
     * @param {DebtorUpdateManyAndReturnArgs} args - Arguments to update many Debtors.
     * @example
     * // Update many Debtors
     * const debtor = await prisma.debtor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Debtors and only return the `id`
     * const debtorWithIdOnly = await prisma.debtor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DebtorUpdateManyAndReturnArgs>(args: SelectSubset<T, DebtorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Debtor.
     * @param {DebtorUpsertArgs} args - Arguments to update or create a Debtor.
     * @example
     * // Update or create a Debtor
     * const debtor = await prisma.debtor.upsert({
     *   create: {
     *     // ... data to create a Debtor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Debtor we want to update
     *   }
     * })
     */
    upsert<T extends DebtorUpsertArgs>(args: SelectSubset<T, DebtorUpsertArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Debtors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorCountArgs} args - Arguments to filter Debtors to count.
     * @example
     * // Count the number of Debtors
     * const count = await prisma.debtor.count({
     *   where: {
     *     // ... the filter for the Debtors we want to count
     *   }
     * })
    **/
    count<T extends DebtorCountArgs>(
      args?: Subset<T, DebtorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Debtor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtorAggregateArgs>(args: Subset<T, DebtorAggregateArgs>): Prisma.PrismaPromise<GetDebtorAggregateType<T>>

    /**
     * Group by Debtor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtorGroupByArgs['orderBy'] }
        : { orderBy?: DebtorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Debtor model
   */
  readonly fields: DebtorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Debtor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionCases<T extends Debtor$collectionCasesArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$collectionCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Debtor$userArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    incomes<T extends Debtor$incomesArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$incomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentAgreements<T extends Debtor$paymentAgreementsArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$paymentAgreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdicts<T extends Debtor$verdictsArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$verdictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Debtor model
   */
  interface DebtorFieldRefs {
    readonly id: FieldRef<"Debtor", 'String'>
    readonly tenantId: FieldRef<"Debtor", 'String'>
    readonly userId: FieldRef<"Debtor", 'String'>
    readonly fullname: FieldRef<"Debtor", 'String'>
    readonly email: FieldRef<"Debtor", 'String'>
    readonly phone: FieldRef<"Debtor", 'String'>
    readonly address: FieldRef<"Debtor", 'String'>
    readonly personType: FieldRef<"Debtor", 'PersonType'>
    readonly identificationType: FieldRef<"Debtor", 'IdentificationType'>
    readonly identification: FieldRef<"Debtor", 'String'>
    readonly totalIncome: FieldRef<"Debtor", 'Float'>
    readonly createdAt: FieldRef<"Debtor", 'DateTime'>
    readonly updatedAt: FieldRef<"Debtor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Debtor findUnique
   */
  export type DebtorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor findUniqueOrThrow
   */
  export type DebtorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor findFirst
   */
  export type DebtorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debtors.
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debtors.
     */
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Debtor findFirstOrThrow
   */
  export type DebtorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debtors.
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debtors.
     */
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Debtor findMany
   */
  export type DebtorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtors to fetch.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Debtors.
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Debtor create
   */
  export type DebtorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * The data needed to create a Debtor.
     */
    data: XOR<DebtorCreateInput, DebtorUncheckedCreateInput>
  }

  /**
   * Debtor createMany
   */
  export type DebtorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Debtors.
     */
    data: DebtorCreateManyInput | DebtorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Debtor createManyAndReturn
   */
  export type DebtorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * The data used to create many Debtors.
     */
    data: DebtorCreateManyInput | DebtorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Debtor update
   */
  export type DebtorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * The data needed to update a Debtor.
     */
    data: XOR<DebtorUpdateInput, DebtorUncheckedUpdateInput>
    /**
     * Choose, which Debtor to update.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor updateMany
   */
  export type DebtorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Debtors.
     */
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyInput>
    /**
     * Filter which Debtors to update
     */
    where?: DebtorWhereInput
    /**
     * Limit how many Debtors to update.
     */
    limit?: number
  }

  /**
   * Debtor updateManyAndReturn
   */
  export type DebtorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * The data used to update Debtors.
     */
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyInput>
    /**
     * Filter which Debtors to update
     */
    where?: DebtorWhereInput
    /**
     * Limit how many Debtors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Debtor upsert
   */
  export type DebtorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * The filter to search for the Debtor to update in case it exists.
     */
    where: DebtorWhereUniqueInput
    /**
     * In case the Debtor found by the `where` argument doesn't exist, create a new Debtor with this data.
     */
    create: XOR<DebtorCreateInput, DebtorUncheckedCreateInput>
    /**
     * In case the Debtor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtorUpdateInput, DebtorUncheckedUpdateInput>
  }

  /**
   * Debtor delete
   */
  export type DebtorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter which Debtor to delete.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor deleteMany
   */
  export type DebtorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debtors to delete
     */
    where?: DebtorWhereInput
    /**
     * Limit how many Debtors to delete.
     */
    limit?: number
  }

  /**
   * Debtor.collectionCases
   */
  export type Debtor$collectionCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    where?: CollectionCaseWhereInput
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    cursor?: CollectionCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * Debtor.user
   */
  export type Debtor$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Debtor.incomes
   */
  export type Debtor$incomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    where?: DebtorIncomeWhereInput
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    cursor?: DebtorIncomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * Debtor.paymentAgreements
   */
  export type Debtor$paymentAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    where?: PaymentAgreementWhereInput
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    cursor?: PaymentAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentAgreementScalarFieldEnum | PaymentAgreementScalarFieldEnum[]
  }

  /**
   * Debtor.verdicts
   */
  export type Debtor$verdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    cursor?: VerdictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Debtor without action
   */
  export type DebtorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
  }


  /**
   * Model ChatRoom
   */

  export type AggregateChatRoom = {
    _count: ChatRoomCountAggregateOutputType | null
    _min: ChatRoomMinAggregateOutputType | null
    _max: ChatRoomMaxAggregateOutputType | null
  }

  export type ChatRoomMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    collectionCaseId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatRoomMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    collectionCaseId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatRoomCountAggregateOutputType = {
    id: number
    tenantId: number
    collectionCaseId: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatRoomMinAggregateInputType = {
    id?: true
    tenantId?: true
    collectionCaseId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatRoomMaxAggregateInputType = {
    id?: true
    tenantId?: true
    collectionCaseId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatRoomCountAggregateInputType = {
    id?: true
    tenantId?: true
    collectionCaseId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatRoom to aggregate.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatRooms
    **/
    _count?: true | ChatRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatRoomMaxAggregateInputType
  }

  export type GetChatRoomAggregateType<T extends ChatRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateChatRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatRoom[P]>
      : GetScalarType<T[P], AggregateChatRoom[P]>
  }




  export type ChatRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatRoomWhereInput
    orderBy?: ChatRoomOrderByWithAggregationInput | ChatRoomOrderByWithAggregationInput[]
    by: ChatRoomScalarFieldEnum[] | ChatRoomScalarFieldEnum
    having?: ChatRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatRoomCountAggregateInputType | true
    _min?: ChatRoomMinAggregateInputType
    _max?: ChatRoomMaxAggregateInputType
  }

  export type ChatRoomGroupByOutputType = {
    id: string
    tenantId: string
    collectionCaseId: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ChatRoomCountAggregateOutputType | null
    _min: ChatRoomMinAggregateOutputType | null
    _max: ChatRoomMaxAggregateOutputType | null
  }

  type GetChatRoomGroupByPayload<T extends ChatRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatRoomGroupByOutputType[P]>
            : GetScalarType<T[P], ChatRoomGroupByOutputType[P]>
        }
      >
    >


  export type ChatRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    collectionCaseId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    messages?: boolean | ChatRoom$messagesArgs<ExtArgs>
    _count?: boolean | ChatRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatRoom"]>

  export type ChatRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    collectionCaseId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatRoom"]>

  export type ChatRoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    collectionCaseId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatRoom"]>

  export type ChatRoomSelectScalar = {
    id?: boolean
    tenantId?: boolean
    collectionCaseId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "collectionCaseId" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["chatRoom"]>
  export type ChatRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    messages?: boolean | ChatRoom$messagesArgs<ExtArgs>
    _count?: boolean | ChatRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type ChatRoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }

  export type $ChatRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatRoom"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      collectionCase: Prisma.$CollectionCasePayload<ExtArgs>
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      collectionCaseId: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chatRoom"]>
    composites: {}
  }

  type ChatRoomGetPayload<S extends boolean | null | undefined | ChatRoomDefaultArgs> = $Result.GetResult<Prisma.$ChatRoomPayload, S>

  type ChatRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatRoomCountAggregateInputType | true
    }

  export interface ChatRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatRoom'], meta: { name: 'ChatRoom' } }
    /**
     * Find zero or one ChatRoom that matches the filter.
     * @param {ChatRoomFindUniqueArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatRoomFindUniqueArgs>(args: SelectSubset<T, ChatRoomFindUniqueArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatRoomFindUniqueOrThrowArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomFindFirstArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatRoomFindFirstArgs>(args?: SelectSubset<T, ChatRoomFindFirstArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomFindFirstOrThrowArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatRooms
     * const chatRooms = await prisma.chatRoom.findMany()
     * 
     * // Get first 10 ChatRooms
     * const chatRooms = await prisma.chatRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatRoomWithIdOnly = await prisma.chatRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatRoomFindManyArgs>(args?: SelectSubset<T, ChatRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatRoom.
     * @param {ChatRoomCreateArgs} args - Arguments to create a ChatRoom.
     * @example
     * // Create one ChatRoom
     * const ChatRoom = await prisma.chatRoom.create({
     *   data: {
     *     // ... data to create a ChatRoom
     *   }
     * })
     * 
     */
    create<T extends ChatRoomCreateArgs>(args: SelectSubset<T, ChatRoomCreateArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatRooms.
     * @param {ChatRoomCreateManyArgs} args - Arguments to create many ChatRooms.
     * @example
     * // Create many ChatRooms
     * const chatRoom = await prisma.chatRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatRoomCreateManyArgs>(args?: SelectSubset<T, ChatRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatRooms and returns the data saved in the database.
     * @param {ChatRoomCreateManyAndReturnArgs} args - Arguments to create many ChatRooms.
     * @example
     * // Create many ChatRooms
     * const chatRoom = await prisma.chatRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatRooms and only return the `id`
     * const chatRoomWithIdOnly = await prisma.chatRoom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatRoom.
     * @param {ChatRoomDeleteArgs} args - Arguments to delete one ChatRoom.
     * @example
     * // Delete one ChatRoom
     * const ChatRoom = await prisma.chatRoom.delete({
     *   where: {
     *     // ... filter to delete one ChatRoom
     *   }
     * })
     * 
     */
    delete<T extends ChatRoomDeleteArgs>(args: SelectSubset<T, ChatRoomDeleteArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatRoom.
     * @param {ChatRoomUpdateArgs} args - Arguments to update one ChatRoom.
     * @example
     * // Update one ChatRoom
     * const chatRoom = await prisma.chatRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatRoomUpdateArgs>(args: SelectSubset<T, ChatRoomUpdateArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatRooms.
     * @param {ChatRoomDeleteManyArgs} args - Arguments to filter ChatRooms to delete.
     * @example
     * // Delete a few ChatRooms
     * const { count } = await prisma.chatRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatRoomDeleteManyArgs>(args?: SelectSubset<T, ChatRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatRooms
     * const chatRoom = await prisma.chatRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatRoomUpdateManyArgs>(args: SelectSubset<T, ChatRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatRooms and returns the data updated in the database.
     * @param {ChatRoomUpdateManyAndReturnArgs} args - Arguments to update many ChatRooms.
     * @example
     * // Update many ChatRooms
     * const chatRoom = await prisma.chatRoom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatRooms and only return the `id`
     * const chatRoomWithIdOnly = await prisma.chatRoom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatRoomUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatRoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatRoom.
     * @param {ChatRoomUpsertArgs} args - Arguments to update or create a ChatRoom.
     * @example
     * // Update or create a ChatRoom
     * const chatRoom = await prisma.chatRoom.upsert({
     *   create: {
     *     // ... data to create a ChatRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatRoom we want to update
     *   }
     * })
     */
    upsert<T extends ChatRoomUpsertArgs>(args: SelectSubset<T, ChatRoomUpsertArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomCountArgs} args - Arguments to filter ChatRooms to count.
     * @example
     * // Count the number of ChatRooms
     * const count = await prisma.chatRoom.count({
     *   where: {
     *     // ... the filter for the ChatRooms we want to count
     *   }
     * })
    **/
    count<T extends ChatRoomCountArgs>(
      args?: Subset<T, ChatRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatRoomAggregateArgs>(args: Subset<T, ChatRoomAggregateArgs>): Prisma.PrismaPromise<GetChatRoomAggregateType<T>>

    /**
     * Group by ChatRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatRoomGroupByArgs['orderBy'] }
        : { orderBy?: ChatRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatRoom model
   */
  readonly fields: ChatRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    collectionCase<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends ChatRoom$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatRoom$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatRoom model
   */
  interface ChatRoomFieldRefs {
    readonly id: FieldRef<"ChatRoom", 'String'>
    readonly tenantId: FieldRef<"ChatRoom", 'String'>
    readonly collectionCaseId: FieldRef<"ChatRoom", 'String'>
    readonly name: FieldRef<"ChatRoom", 'String'>
    readonly createdAt: FieldRef<"ChatRoom", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatRoom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatRoom findUnique
   */
  export type ChatRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom findUniqueOrThrow
   */
  export type ChatRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom findFirst
   */
  export type ChatRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatRooms.
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatRooms.
     */
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * ChatRoom findFirstOrThrow
   */
  export type ChatRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatRooms.
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatRooms.
     */
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * ChatRoom findMany
   */
  export type ChatRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRooms to fetch.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatRooms.
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * ChatRoom create
   */
  export type ChatRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatRoom.
     */
    data: XOR<ChatRoomCreateInput, ChatRoomUncheckedCreateInput>
  }

  /**
   * ChatRoom createMany
   */
  export type ChatRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatRooms.
     */
    data: ChatRoomCreateManyInput | ChatRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatRoom createManyAndReturn
   */
  export type ChatRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * The data used to create many ChatRooms.
     */
    data: ChatRoomCreateManyInput | ChatRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatRoom update
   */
  export type ChatRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatRoom.
     */
    data: XOR<ChatRoomUpdateInput, ChatRoomUncheckedUpdateInput>
    /**
     * Choose, which ChatRoom to update.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom updateMany
   */
  export type ChatRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatRooms.
     */
    data: XOR<ChatRoomUpdateManyMutationInput, ChatRoomUncheckedUpdateManyInput>
    /**
     * Filter which ChatRooms to update
     */
    where?: ChatRoomWhereInput
    /**
     * Limit how many ChatRooms to update.
     */
    limit?: number
  }

  /**
   * ChatRoom updateManyAndReturn
   */
  export type ChatRoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * The data used to update ChatRooms.
     */
    data: XOR<ChatRoomUpdateManyMutationInput, ChatRoomUncheckedUpdateManyInput>
    /**
     * Filter which ChatRooms to update
     */
    where?: ChatRoomWhereInput
    /**
     * Limit how many ChatRooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatRoom upsert
   */
  export type ChatRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatRoom to update in case it exists.
     */
    where: ChatRoomWhereUniqueInput
    /**
     * In case the ChatRoom found by the `where` argument doesn't exist, create a new ChatRoom with this data.
     */
    create: XOR<ChatRoomCreateInput, ChatRoomUncheckedCreateInput>
    /**
     * In case the ChatRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatRoomUpdateInput, ChatRoomUncheckedUpdateInput>
  }

  /**
   * ChatRoom delete
   */
  export type ChatRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter which ChatRoom to delete.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom deleteMany
   */
  export type ChatRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatRooms to delete
     */
    where?: ChatRoomWhereInput
    /**
     * Limit how many ChatRooms to delete.
     */
    limit?: number
  }

  /**
   * ChatRoom.messages
   */
  export type ChatRoom$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatRoom without action
   */
  export type ChatRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    senderId: string | null
    message: string | null
    fileUrl: string | null
    fileName: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    senderId: string | null
    message: string | null
    fileUrl: string | null
    fileName: string | null
    timestamp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    roomId: number
    senderId: number
    message: number
    fileUrl: number
    fileName: number
    timestamp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    roomId?: true
    senderId?: true
    message?: true
    fileUrl?: true
    fileName?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    roomId?: true
    senderId?: true
    message?: true
    fileUrl?: true
    fileName?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    roomId?: true
    senderId?: true
    message?: true
    fileUrl?: true
    fileName?: true
    timestamp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    roomId: string
    senderId: string
    message: string
    fileUrl: string | null
    fileName: string | null
    timestamp: Date
    createdAt: Date
    updatedAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    senderId?: boolean
    message?: boolean
    fileUrl?: boolean
    fileName?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    senderId?: boolean
    message?: boolean
    fileUrl?: boolean
    fileName?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    senderId?: boolean
    message?: boolean
    fileUrl?: boolean
    fileName?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    roomId?: boolean
    senderId?: boolean
    message?: boolean
    fileUrl?: boolean
    fileName?: boolean
    timestamp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "senderId" | "message" | "fileUrl" | "fileName" | "timestamp" | "createdAt" | "updatedAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      room: Prisma.$ChatRoomPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      senderId: string
      message: string
      fileUrl: string | null
      fileName: string | null
      timestamp: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends ChatRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatRoomDefaultArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly roomId: FieldRef<"ChatMessage", 'String'>
    readonly senderId: FieldRef<"ChatMessage", 'String'>
    readonly message: FieldRef<"ChatMessage", 'String'>
    readonly fileUrl: FieldRef<"ChatMessage", 'String'>
    readonly fileName: FieldRef<"ChatMessage", 'String'>
    readonly timestamp: FieldRef<"ChatMessage", 'DateTime'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model DebtorIncome
   */

  export type AggregateDebtorIncome = {
    _count: DebtorIncomeCountAggregateOutputType | null
    _avg: DebtorIncomeAvgAggregateOutputType | null
    _sum: DebtorIncomeSumAggregateOutputType | null
    _min: DebtorIncomeMinAggregateOutputType | null
    _max: DebtorIncomeMaxAggregateOutputType | null
  }

  export type DebtorIncomeAvgAggregateOutputType = {
    amount: number | null
  }

  export type DebtorIncomeSumAggregateOutputType = {
    amount: number | null
  }

  export type DebtorIncomeMinAggregateOutputType = {
    id: string | null
    debtorId: string | null
    amount: number | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtorIncomeMaxAggregateOutputType = {
    id: string | null
    debtorId: string | null
    amount: number | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DebtorIncomeCountAggregateOutputType = {
    id: number
    debtorId: number
    amount: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DebtorIncomeAvgAggregateInputType = {
    amount?: true
  }

  export type DebtorIncomeSumAggregateInputType = {
    amount?: true
  }

  export type DebtorIncomeMinAggregateInputType = {
    id?: true
    debtorId?: true
    amount?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtorIncomeMaxAggregateInputType = {
    id?: true
    debtorId?: true
    amount?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DebtorIncomeCountAggregateInputType = {
    id?: true
    debtorId?: true
    amount?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DebtorIncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtorIncome to aggregate.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DebtorIncomes
    **/
    _count?: true | DebtorIncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtorIncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtorIncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtorIncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtorIncomeMaxAggregateInputType
  }

  export type GetDebtorIncomeAggregateType<T extends DebtorIncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateDebtorIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebtorIncome[P]>
      : GetScalarType<T[P], AggregateDebtorIncome[P]>
  }




  export type DebtorIncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorIncomeWhereInput
    orderBy?: DebtorIncomeOrderByWithAggregationInput | DebtorIncomeOrderByWithAggregationInput[]
    by: DebtorIncomeScalarFieldEnum[] | DebtorIncomeScalarFieldEnum
    having?: DebtorIncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtorIncomeCountAggregateInputType | true
    _avg?: DebtorIncomeAvgAggregateInputType
    _sum?: DebtorIncomeSumAggregateInputType
    _min?: DebtorIncomeMinAggregateInputType
    _max?: DebtorIncomeMaxAggregateInputType
  }

  export type DebtorIncomeGroupByOutputType = {
    id: string
    debtorId: string
    amount: number
    source: string
    createdAt: Date
    updatedAt: Date
    _count: DebtorIncomeCountAggregateOutputType | null
    _avg: DebtorIncomeAvgAggregateOutputType | null
    _sum: DebtorIncomeSumAggregateOutputType | null
    _min: DebtorIncomeMinAggregateOutputType | null
    _max: DebtorIncomeMaxAggregateOutputType | null
  }

  type GetDebtorIncomeGroupByPayload<T extends DebtorIncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtorIncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtorIncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtorIncomeGroupByOutputType[P]>
            : GetScalarType<T[P], DebtorIncomeGroupByOutputType[P]>
        }
      >
    >


  export type DebtorIncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtorId?: boolean
    amount?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtorIncome"]>

  export type DebtorIncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtorId?: boolean
    amount?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtorIncome"]>

  export type DebtorIncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtorId?: boolean
    amount?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtorIncome"]>

  export type DebtorIncomeSelectScalar = {
    id?: boolean
    debtorId?: boolean
    amount?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DebtorIncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "debtorId" | "amount" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["debtorIncome"]>
  export type DebtorIncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }
  export type DebtorIncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }
  export type DebtorIncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }

  export type $DebtorIncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DebtorIncome"
    objects: {
      debtor: Prisma.$DebtorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      debtorId: string
      amount: number
      source: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["debtorIncome"]>
    composites: {}
  }

  type DebtorIncomeGetPayload<S extends boolean | null | undefined | DebtorIncomeDefaultArgs> = $Result.GetResult<Prisma.$DebtorIncomePayload, S>

  type DebtorIncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DebtorIncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DebtorIncomeCountAggregateInputType | true
    }

  export interface DebtorIncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DebtorIncome'], meta: { name: 'DebtorIncome' } }
    /**
     * Find zero or one DebtorIncome that matches the filter.
     * @param {DebtorIncomeFindUniqueArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtorIncomeFindUniqueArgs>(args: SelectSubset<T, DebtorIncomeFindUniqueArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DebtorIncome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DebtorIncomeFindUniqueOrThrowArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtorIncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtorIncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DebtorIncome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeFindFirstArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtorIncomeFindFirstArgs>(args?: SelectSubset<T, DebtorIncomeFindFirstArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DebtorIncome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeFindFirstOrThrowArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtorIncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtorIncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DebtorIncomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DebtorIncomes
     * const debtorIncomes = await prisma.debtorIncome.findMany()
     * 
     * // Get first 10 DebtorIncomes
     * const debtorIncomes = await prisma.debtorIncome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtorIncomeWithIdOnly = await prisma.debtorIncome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtorIncomeFindManyArgs>(args?: SelectSubset<T, DebtorIncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DebtorIncome.
     * @param {DebtorIncomeCreateArgs} args - Arguments to create a DebtorIncome.
     * @example
     * // Create one DebtorIncome
     * const DebtorIncome = await prisma.debtorIncome.create({
     *   data: {
     *     // ... data to create a DebtorIncome
     *   }
     * })
     * 
     */
    create<T extends DebtorIncomeCreateArgs>(args: SelectSubset<T, DebtorIncomeCreateArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DebtorIncomes.
     * @param {DebtorIncomeCreateManyArgs} args - Arguments to create many DebtorIncomes.
     * @example
     * // Create many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtorIncomeCreateManyArgs>(args?: SelectSubset<T, DebtorIncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DebtorIncomes and returns the data saved in the database.
     * @param {DebtorIncomeCreateManyAndReturnArgs} args - Arguments to create many DebtorIncomes.
     * @example
     * // Create many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DebtorIncomes and only return the `id`
     * const debtorIncomeWithIdOnly = await prisma.debtorIncome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DebtorIncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, DebtorIncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DebtorIncome.
     * @param {DebtorIncomeDeleteArgs} args - Arguments to delete one DebtorIncome.
     * @example
     * // Delete one DebtorIncome
     * const DebtorIncome = await prisma.debtorIncome.delete({
     *   where: {
     *     // ... filter to delete one DebtorIncome
     *   }
     * })
     * 
     */
    delete<T extends DebtorIncomeDeleteArgs>(args: SelectSubset<T, DebtorIncomeDeleteArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DebtorIncome.
     * @param {DebtorIncomeUpdateArgs} args - Arguments to update one DebtorIncome.
     * @example
     * // Update one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtorIncomeUpdateArgs>(args: SelectSubset<T, DebtorIncomeUpdateArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DebtorIncomes.
     * @param {DebtorIncomeDeleteManyArgs} args - Arguments to filter DebtorIncomes to delete.
     * @example
     * // Delete a few DebtorIncomes
     * const { count } = await prisma.debtorIncome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtorIncomeDeleteManyArgs>(args?: SelectSubset<T, DebtorIncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DebtorIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtorIncomeUpdateManyArgs>(args: SelectSubset<T, DebtorIncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DebtorIncomes and returns the data updated in the database.
     * @param {DebtorIncomeUpdateManyAndReturnArgs} args - Arguments to update many DebtorIncomes.
     * @example
     * // Update many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DebtorIncomes and only return the `id`
     * const debtorIncomeWithIdOnly = await prisma.debtorIncome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DebtorIncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, DebtorIncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DebtorIncome.
     * @param {DebtorIncomeUpsertArgs} args - Arguments to update or create a DebtorIncome.
     * @example
     * // Update or create a DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.upsert({
     *   create: {
     *     // ... data to create a DebtorIncome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DebtorIncome we want to update
     *   }
     * })
     */
    upsert<T extends DebtorIncomeUpsertArgs>(args: SelectSubset<T, DebtorIncomeUpsertArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DebtorIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeCountArgs} args - Arguments to filter DebtorIncomes to count.
     * @example
     * // Count the number of DebtorIncomes
     * const count = await prisma.debtorIncome.count({
     *   where: {
     *     // ... the filter for the DebtorIncomes we want to count
     *   }
     * })
    **/
    count<T extends DebtorIncomeCountArgs>(
      args?: Subset<T, DebtorIncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtorIncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DebtorIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtorIncomeAggregateArgs>(args: Subset<T, DebtorIncomeAggregateArgs>): Prisma.PrismaPromise<GetDebtorIncomeAggregateType<T>>

    /**
     * Group by DebtorIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtorIncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtorIncomeGroupByArgs['orderBy'] }
        : { orderBy?: DebtorIncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtorIncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtorIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DebtorIncome model
   */
  readonly fields: DebtorIncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DebtorIncome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtorIncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    debtor<T extends DebtorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtorDefaultArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DebtorIncome model
   */
  interface DebtorIncomeFieldRefs {
    readonly id: FieldRef<"DebtorIncome", 'String'>
    readonly debtorId: FieldRef<"DebtorIncome", 'String'>
    readonly amount: FieldRef<"DebtorIncome", 'Float'>
    readonly source: FieldRef<"DebtorIncome", 'String'>
    readonly createdAt: FieldRef<"DebtorIncome", 'DateTime'>
    readonly updatedAt: FieldRef<"DebtorIncome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DebtorIncome findUnique
   */
  export type DebtorIncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome findUniqueOrThrow
   */
  export type DebtorIncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome findFirst
   */
  export type DebtorIncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtorIncomes.
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtorIncomes.
     */
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * DebtorIncome findFirstOrThrow
   */
  export type DebtorIncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtorIncomes.
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtorIncomes.
     */
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * DebtorIncome findMany
   */
  export type DebtorIncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncomes to fetch.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DebtorIncomes.
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * DebtorIncome create
   */
  export type DebtorIncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a DebtorIncome.
     */
    data: XOR<DebtorIncomeCreateInput, DebtorIncomeUncheckedCreateInput>
  }

  /**
   * DebtorIncome createMany
   */
  export type DebtorIncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DebtorIncomes.
     */
    data: DebtorIncomeCreateManyInput | DebtorIncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DebtorIncome createManyAndReturn
   */
  export type DebtorIncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * The data used to create many DebtorIncomes.
     */
    data: DebtorIncomeCreateManyInput | DebtorIncomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DebtorIncome update
   */
  export type DebtorIncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a DebtorIncome.
     */
    data: XOR<DebtorIncomeUpdateInput, DebtorIncomeUncheckedUpdateInput>
    /**
     * Choose, which DebtorIncome to update.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome updateMany
   */
  export type DebtorIncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DebtorIncomes.
     */
    data: XOR<DebtorIncomeUpdateManyMutationInput, DebtorIncomeUncheckedUpdateManyInput>
    /**
     * Filter which DebtorIncomes to update
     */
    where?: DebtorIncomeWhereInput
    /**
     * Limit how many DebtorIncomes to update.
     */
    limit?: number
  }

  /**
   * DebtorIncome updateManyAndReturn
   */
  export type DebtorIncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * The data used to update DebtorIncomes.
     */
    data: XOR<DebtorIncomeUpdateManyMutationInput, DebtorIncomeUncheckedUpdateManyInput>
    /**
     * Filter which DebtorIncomes to update
     */
    where?: DebtorIncomeWhereInput
    /**
     * Limit how many DebtorIncomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DebtorIncome upsert
   */
  export type DebtorIncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the DebtorIncome to update in case it exists.
     */
    where: DebtorIncomeWhereUniqueInput
    /**
     * In case the DebtorIncome found by the `where` argument doesn't exist, create a new DebtorIncome with this data.
     */
    create: XOR<DebtorIncomeCreateInput, DebtorIncomeUncheckedCreateInput>
    /**
     * In case the DebtorIncome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtorIncomeUpdateInput, DebtorIncomeUncheckedUpdateInput>
  }

  /**
   * DebtorIncome delete
   */
  export type DebtorIncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter which DebtorIncome to delete.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome deleteMany
   */
  export type DebtorIncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtorIncomes to delete
     */
    where?: DebtorIncomeWhereInput
    /**
     * Limit how many DebtorIncomes to delete.
     */
    limit?: number
  }

  /**
   * DebtorIncome without action
   */
  export type DebtorIncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
  }


  /**
   * Model PaymentAgreement
   */

  export type AggregatePaymentAgreement = {
    _count: PaymentAgreementCountAggregateOutputType | null
    _avg: PaymentAgreementAvgAggregateOutputType | null
    _sum: PaymentAgreementSumAggregateOutputType | null
    _min: PaymentAgreementMinAggregateOutputType | null
    _max: PaymentAgreementMaxAggregateOutputType | null
  }

  export type PaymentAgreementAvgAggregateOutputType = {
    totalAmount: Decimal | null
    installmentAmount: Decimal | null
    installmentsCount: number | null
  }

  export type PaymentAgreementSumAggregateOutputType = {
    totalAmount: Decimal | null
    installmentAmount: Decimal | null
    installmentsCount: number | null
  }

  export type PaymentAgreementMinAggregateOutputType = {
    id: string | null
    collectionCaseId: string | null
    totalAmount: Decimal | null
    installmentAmount: Decimal | null
    installmentsCount: number | null
    startDate: Date | null
    status: $Enums.PaymentAgreementStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    debtorId: string | null
  }

  export type PaymentAgreementMaxAggregateOutputType = {
    id: string | null
    collectionCaseId: string | null
    totalAmount: Decimal | null
    installmentAmount: Decimal | null
    installmentsCount: number | null
    startDate: Date | null
    status: $Enums.PaymentAgreementStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    debtorId: string | null
  }

  export type PaymentAgreementCountAggregateOutputType = {
    id: number
    collectionCaseId: number
    totalAmount: number
    installmentAmount: number
    installmentsCount: number
    startDate: number
    status: number
    createdAt: number
    updatedAt: number
    debtorId: number
    _all: number
  }


  export type PaymentAgreementAvgAggregateInputType = {
    totalAmount?: true
    installmentAmount?: true
    installmentsCount?: true
  }

  export type PaymentAgreementSumAggregateInputType = {
    totalAmount?: true
    installmentAmount?: true
    installmentsCount?: true
  }

  export type PaymentAgreementMinAggregateInputType = {
    id?: true
    collectionCaseId?: true
    totalAmount?: true
    installmentAmount?: true
    installmentsCount?: true
    startDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    debtorId?: true
  }

  export type PaymentAgreementMaxAggregateInputType = {
    id?: true
    collectionCaseId?: true
    totalAmount?: true
    installmentAmount?: true
    installmentsCount?: true
    startDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    debtorId?: true
  }

  export type PaymentAgreementCountAggregateInputType = {
    id?: true
    collectionCaseId?: true
    totalAmount?: true
    installmentAmount?: true
    installmentsCount?: true
    startDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    debtorId?: true
    _all?: true
  }

  export type PaymentAgreementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAgreement to aggregate.
     */
    where?: PaymentAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAgreements to fetch.
     */
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentAgreements
    **/
    _count?: true | PaymentAgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAgreementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentAgreementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentAgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentAgreementMaxAggregateInputType
  }

  export type GetPaymentAgreementAggregateType<T extends PaymentAgreementAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentAgreement[P]>
      : GetScalarType<T[P], AggregatePaymentAgreement[P]>
  }




  export type PaymentAgreementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentAgreementWhereInput
    orderBy?: PaymentAgreementOrderByWithAggregationInput | PaymentAgreementOrderByWithAggregationInput[]
    by: PaymentAgreementScalarFieldEnum[] | PaymentAgreementScalarFieldEnum
    having?: PaymentAgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentAgreementCountAggregateInputType | true
    _avg?: PaymentAgreementAvgAggregateInputType
    _sum?: PaymentAgreementSumAggregateInputType
    _min?: PaymentAgreementMinAggregateInputType
    _max?: PaymentAgreementMaxAggregateInputType
  }

  export type PaymentAgreementGroupByOutputType = {
    id: string
    collectionCaseId: string
    totalAmount: Decimal
    installmentAmount: Decimal
    installmentsCount: number
    startDate: Date
    status: $Enums.PaymentAgreementStatus
    createdAt: Date
    updatedAt: Date
    debtorId: string | null
    _count: PaymentAgreementCountAggregateOutputType | null
    _avg: PaymentAgreementAvgAggregateOutputType | null
    _sum: PaymentAgreementSumAggregateOutputType | null
    _min: PaymentAgreementMinAggregateOutputType | null
    _max: PaymentAgreementMaxAggregateOutputType | null
  }

  type GetPaymentAgreementGroupByPayload<T extends PaymentAgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentAgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentAgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentAgreementGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentAgreementGroupByOutputType[P]>
        }
      >
    >


  export type PaymentAgreementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    totalAmount?: boolean
    installmentAmount?: boolean
    installmentsCount?: boolean
    startDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtorId?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    installments?: boolean | PaymentAgreement$installmentsArgs<ExtArgs>
    payments?: boolean | PaymentAgreement$paymentsArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
    _count?: boolean | PaymentAgreementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAgreement"]>

  export type PaymentAgreementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    totalAmount?: boolean
    installmentAmount?: boolean
    installmentsCount?: boolean
    startDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtorId?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAgreement"]>

  export type PaymentAgreementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionCaseId?: boolean
    totalAmount?: boolean
    installmentAmount?: boolean
    installmentsCount?: boolean
    startDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtorId?: boolean
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
  }, ExtArgs["result"]["paymentAgreement"]>

  export type PaymentAgreementSelectScalar = {
    id?: boolean
    collectionCaseId?: boolean
    totalAmount?: boolean
    installmentAmount?: boolean
    installmentsCount?: boolean
    startDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    debtorId?: boolean
  }

  export type PaymentAgreementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collectionCaseId" | "totalAmount" | "installmentAmount" | "installmentsCount" | "startDate" | "status" | "createdAt" | "updatedAt" | "debtorId", ExtArgs["result"]["paymentAgreement"]>
  export type PaymentAgreementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    installments?: boolean | PaymentAgreement$installmentsArgs<ExtArgs>
    payments?: boolean | PaymentAgreement$paymentsArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
    _count?: boolean | PaymentAgreementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentAgreementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
  }
  export type PaymentAgreementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionCase?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    Debtor?: boolean | PaymentAgreement$DebtorArgs<ExtArgs>
  }

  export type $PaymentAgreementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentAgreement"
    objects: {
      collectionCase: Prisma.$CollectionCasePayload<ExtArgs>
      installments: Prisma.$InstallmentPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      Debtor: Prisma.$DebtorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collectionCaseId: string
      totalAmount: Prisma.Decimal
      installmentAmount: Prisma.Decimal
      installmentsCount: number
      startDate: Date
      status: $Enums.PaymentAgreementStatus
      createdAt: Date
      updatedAt: Date
      debtorId: string | null
    }, ExtArgs["result"]["paymentAgreement"]>
    composites: {}
  }

  type PaymentAgreementGetPayload<S extends boolean | null | undefined | PaymentAgreementDefaultArgs> = $Result.GetResult<Prisma.$PaymentAgreementPayload, S>

  type PaymentAgreementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentAgreementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentAgreementCountAggregateInputType | true
    }

  export interface PaymentAgreementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentAgreement'], meta: { name: 'PaymentAgreement' } }
    /**
     * Find zero or one PaymentAgreement that matches the filter.
     * @param {PaymentAgreementFindUniqueArgs} args - Arguments to find a PaymentAgreement
     * @example
     * // Get one PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentAgreementFindUniqueArgs>(args: SelectSubset<T, PaymentAgreementFindUniqueArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentAgreement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentAgreementFindUniqueOrThrowArgs} args - Arguments to find a PaymentAgreement
     * @example
     * // Get one PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentAgreementFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentAgreementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentAgreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementFindFirstArgs} args - Arguments to find a PaymentAgreement
     * @example
     * // Get one PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentAgreementFindFirstArgs>(args?: SelectSubset<T, PaymentAgreementFindFirstArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentAgreement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementFindFirstOrThrowArgs} args - Arguments to find a PaymentAgreement
     * @example
     * // Get one PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentAgreementFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentAgreementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentAgreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentAgreements
     * const paymentAgreements = await prisma.paymentAgreement.findMany()
     * 
     * // Get first 10 PaymentAgreements
     * const paymentAgreements = await prisma.paymentAgreement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentAgreementWithIdOnly = await prisma.paymentAgreement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentAgreementFindManyArgs>(args?: SelectSubset<T, PaymentAgreementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentAgreement.
     * @param {PaymentAgreementCreateArgs} args - Arguments to create a PaymentAgreement.
     * @example
     * // Create one PaymentAgreement
     * const PaymentAgreement = await prisma.paymentAgreement.create({
     *   data: {
     *     // ... data to create a PaymentAgreement
     *   }
     * })
     * 
     */
    create<T extends PaymentAgreementCreateArgs>(args: SelectSubset<T, PaymentAgreementCreateArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentAgreements.
     * @param {PaymentAgreementCreateManyArgs} args - Arguments to create many PaymentAgreements.
     * @example
     * // Create many PaymentAgreements
     * const paymentAgreement = await prisma.paymentAgreement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentAgreementCreateManyArgs>(args?: SelectSubset<T, PaymentAgreementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentAgreements and returns the data saved in the database.
     * @param {PaymentAgreementCreateManyAndReturnArgs} args - Arguments to create many PaymentAgreements.
     * @example
     * // Create many PaymentAgreements
     * const paymentAgreement = await prisma.paymentAgreement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentAgreements and only return the `id`
     * const paymentAgreementWithIdOnly = await prisma.paymentAgreement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentAgreementCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentAgreementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentAgreement.
     * @param {PaymentAgreementDeleteArgs} args - Arguments to delete one PaymentAgreement.
     * @example
     * // Delete one PaymentAgreement
     * const PaymentAgreement = await prisma.paymentAgreement.delete({
     *   where: {
     *     // ... filter to delete one PaymentAgreement
     *   }
     * })
     * 
     */
    delete<T extends PaymentAgreementDeleteArgs>(args: SelectSubset<T, PaymentAgreementDeleteArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentAgreement.
     * @param {PaymentAgreementUpdateArgs} args - Arguments to update one PaymentAgreement.
     * @example
     * // Update one PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentAgreementUpdateArgs>(args: SelectSubset<T, PaymentAgreementUpdateArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentAgreements.
     * @param {PaymentAgreementDeleteManyArgs} args - Arguments to filter PaymentAgreements to delete.
     * @example
     * // Delete a few PaymentAgreements
     * const { count } = await prisma.paymentAgreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentAgreementDeleteManyArgs>(args?: SelectSubset<T, PaymentAgreementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentAgreements
     * const paymentAgreement = await prisma.paymentAgreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentAgreementUpdateManyArgs>(args: SelectSubset<T, PaymentAgreementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentAgreements and returns the data updated in the database.
     * @param {PaymentAgreementUpdateManyAndReturnArgs} args - Arguments to update many PaymentAgreements.
     * @example
     * // Update many PaymentAgreements
     * const paymentAgreement = await prisma.paymentAgreement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentAgreements and only return the `id`
     * const paymentAgreementWithIdOnly = await prisma.paymentAgreement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentAgreementUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentAgreementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentAgreement.
     * @param {PaymentAgreementUpsertArgs} args - Arguments to update or create a PaymentAgreement.
     * @example
     * // Update or create a PaymentAgreement
     * const paymentAgreement = await prisma.paymentAgreement.upsert({
     *   create: {
     *     // ... data to create a PaymentAgreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentAgreement we want to update
     *   }
     * })
     */
    upsert<T extends PaymentAgreementUpsertArgs>(args: SelectSubset<T, PaymentAgreementUpsertArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementCountArgs} args - Arguments to filter PaymentAgreements to count.
     * @example
     * // Count the number of PaymentAgreements
     * const count = await prisma.paymentAgreement.count({
     *   where: {
     *     // ... the filter for the PaymentAgreements we want to count
     *   }
     * })
    **/
    count<T extends PaymentAgreementCountArgs>(
      args?: Subset<T, PaymentAgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentAgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAgreementAggregateArgs>(args: Subset<T, PaymentAgreementAggregateArgs>): Prisma.PrismaPromise<GetPaymentAgreementAggregateType<T>>

    /**
     * Group by PaymentAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentAgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentAgreementGroupByArgs['orderBy'] }
        : { orderBy?: PaymentAgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentAgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentAgreement model
   */
  readonly fields: PaymentAgreementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentAgreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentAgreementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionCase<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    installments<T extends PaymentAgreement$installmentsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentAgreement$installmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends PaymentAgreement$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentAgreement$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Debtor<T extends PaymentAgreement$DebtorArgs<ExtArgs> = {}>(args?: Subset<T, PaymentAgreement$DebtorArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentAgreement model
   */
  interface PaymentAgreementFieldRefs {
    readonly id: FieldRef<"PaymentAgreement", 'String'>
    readonly collectionCaseId: FieldRef<"PaymentAgreement", 'String'>
    readonly totalAmount: FieldRef<"PaymentAgreement", 'Decimal'>
    readonly installmentAmount: FieldRef<"PaymentAgreement", 'Decimal'>
    readonly installmentsCount: FieldRef<"PaymentAgreement", 'Int'>
    readonly startDate: FieldRef<"PaymentAgreement", 'DateTime'>
    readonly status: FieldRef<"PaymentAgreement", 'PaymentAgreementStatus'>
    readonly createdAt: FieldRef<"PaymentAgreement", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentAgreement", 'DateTime'>
    readonly debtorId: FieldRef<"PaymentAgreement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentAgreement findUnique
   */
  export type PaymentAgreementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAgreement to fetch.
     */
    where: PaymentAgreementWhereUniqueInput
  }

  /**
   * PaymentAgreement findUniqueOrThrow
   */
  export type PaymentAgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAgreement to fetch.
     */
    where: PaymentAgreementWhereUniqueInput
  }

  /**
   * PaymentAgreement findFirst
   */
  export type PaymentAgreementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAgreement to fetch.
     */
    where?: PaymentAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAgreements to fetch.
     */
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAgreements.
     */
    cursor?: PaymentAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAgreements.
     */
    distinct?: PaymentAgreementScalarFieldEnum | PaymentAgreementScalarFieldEnum[]
  }

  /**
   * PaymentAgreement findFirstOrThrow
   */
  export type PaymentAgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAgreement to fetch.
     */
    where?: PaymentAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAgreements to fetch.
     */
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentAgreements.
     */
    cursor?: PaymentAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentAgreements.
     */
    distinct?: PaymentAgreementScalarFieldEnum | PaymentAgreementScalarFieldEnum[]
  }

  /**
   * PaymentAgreement findMany
   */
  export type PaymentAgreementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter, which PaymentAgreements to fetch.
     */
    where?: PaymentAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentAgreements to fetch.
     */
    orderBy?: PaymentAgreementOrderByWithRelationInput | PaymentAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentAgreements.
     */
    cursor?: PaymentAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentAgreements.
     */
    skip?: number
    distinct?: PaymentAgreementScalarFieldEnum | PaymentAgreementScalarFieldEnum[]
  }

  /**
   * PaymentAgreement create
   */
  export type PaymentAgreementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentAgreement.
     */
    data: XOR<PaymentAgreementCreateInput, PaymentAgreementUncheckedCreateInput>
  }

  /**
   * PaymentAgreement createMany
   */
  export type PaymentAgreementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentAgreements.
     */
    data: PaymentAgreementCreateManyInput | PaymentAgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentAgreement createManyAndReturn
   */
  export type PaymentAgreementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentAgreements.
     */
    data: PaymentAgreementCreateManyInput | PaymentAgreementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentAgreement update
   */
  export type PaymentAgreementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentAgreement.
     */
    data: XOR<PaymentAgreementUpdateInput, PaymentAgreementUncheckedUpdateInput>
    /**
     * Choose, which PaymentAgreement to update.
     */
    where: PaymentAgreementWhereUniqueInput
  }

  /**
   * PaymentAgreement updateMany
   */
  export type PaymentAgreementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentAgreements.
     */
    data: XOR<PaymentAgreementUpdateManyMutationInput, PaymentAgreementUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAgreements to update
     */
    where?: PaymentAgreementWhereInput
    /**
     * Limit how many PaymentAgreements to update.
     */
    limit?: number
  }

  /**
   * PaymentAgreement updateManyAndReturn
   */
  export type PaymentAgreementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * The data used to update PaymentAgreements.
     */
    data: XOR<PaymentAgreementUpdateManyMutationInput, PaymentAgreementUncheckedUpdateManyInput>
    /**
     * Filter which PaymentAgreements to update
     */
    where?: PaymentAgreementWhereInput
    /**
     * Limit how many PaymentAgreements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentAgreement upsert
   */
  export type PaymentAgreementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentAgreement to update in case it exists.
     */
    where: PaymentAgreementWhereUniqueInput
    /**
     * In case the PaymentAgreement found by the `where` argument doesn't exist, create a new PaymentAgreement with this data.
     */
    create: XOR<PaymentAgreementCreateInput, PaymentAgreementUncheckedCreateInput>
    /**
     * In case the PaymentAgreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentAgreementUpdateInput, PaymentAgreementUncheckedUpdateInput>
  }

  /**
   * PaymentAgreement delete
   */
  export type PaymentAgreementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
    /**
     * Filter which PaymentAgreement to delete.
     */
    where: PaymentAgreementWhereUniqueInput
  }

  /**
   * PaymentAgreement deleteMany
   */
  export type PaymentAgreementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentAgreements to delete
     */
    where?: PaymentAgreementWhereInput
    /**
     * Limit how many PaymentAgreements to delete.
     */
    limit?: number
  }

  /**
   * PaymentAgreement.installments
   */
  export type PaymentAgreement$installmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    where?: InstallmentWhereInput
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    cursor?: InstallmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * PaymentAgreement.payments
   */
  export type PaymentAgreement$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * PaymentAgreement.Debtor
   */
  export type PaymentAgreement$DebtorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    where?: DebtorWhereInput
  }

  /**
   * PaymentAgreement without action
   */
  export type PaymentAgreementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentAgreement
     */
    select?: PaymentAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentAgreement
     */
    omit?: PaymentAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentAgreementInclude<ExtArgs> | null
  }


  /**
   * Model Installment
   */

  export type AggregateInstallment = {
    _count: InstallmentCountAggregateOutputType | null
    _avg: InstallmentAvgAggregateOutputType | null
    _sum: InstallmentSumAggregateOutputType | null
    _min: InstallmentMinAggregateOutputType | null
    _max: InstallmentMaxAggregateOutputType | null
  }

  export type InstallmentAvgAggregateOutputType = {
    number: number | null
    amount: Decimal | null
  }

  export type InstallmentSumAggregateOutputType = {
    number: number | null
    amount: Decimal | null
  }

  export type InstallmentMinAggregateOutputType = {
    id: string | null
    paymentAgreementId: string | null
    number: number | null
    dueDate: Date | null
    amount: Decimal | null
    status: $Enums.InstallmentStatus | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstallmentMaxAggregateOutputType = {
    id: string | null
    paymentAgreementId: string | null
    number: number | null
    dueDate: Date | null
    amount: Decimal | null
    status: $Enums.InstallmentStatus | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstallmentCountAggregateOutputType = {
    id: number
    paymentAgreementId: number
    number: number
    dueDate: number
    amount: number
    status: number
    paymentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstallmentAvgAggregateInputType = {
    number?: true
    amount?: true
  }

  export type InstallmentSumAggregateInputType = {
    number?: true
    amount?: true
  }

  export type InstallmentMinAggregateInputType = {
    id?: true
    paymentAgreementId?: true
    number?: true
    dueDate?: true
    amount?: true
    status?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstallmentMaxAggregateInputType = {
    id?: true
    paymentAgreementId?: true
    number?: true
    dueDate?: true
    amount?: true
    status?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstallmentCountAggregateInputType = {
    id?: true
    paymentAgreementId?: true
    number?: true
    dueDate?: true
    amount?: true
    status?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstallmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Installment to aggregate.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Installments
    **/
    _count?: true | InstallmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstallmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstallmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstallmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstallmentMaxAggregateInputType
  }

  export type GetInstallmentAggregateType<T extends InstallmentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstallment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstallment[P]>
      : GetScalarType<T[P], AggregateInstallment[P]>
  }




  export type InstallmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentWhereInput
    orderBy?: InstallmentOrderByWithAggregationInput | InstallmentOrderByWithAggregationInput[]
    by: InstallmentScalarFieldEnum[] | InstallmentScalarFieldEnum
    having?: InstallmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstallmentCountAggregateInputType | true
    _avg?: InstallmentAvgAggregateInputType
    _sum?: InstallmentSumAggregateInputType
    _min?: InstallmentMinAggregateInputType
    _max?: InstallmentMaxAggregateInputType
  }

  export type InstallmentGroupByOutputType = {
    id: string
    paymentAgreementId: string
    number: number
    dueDate: Date
    amount: Decimal
    status: $Enums.InstallmentStatus
    paymentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: InstallmentCountAggregateOutputType | null
    _avg: InstallmentAvgAggregateOutputType | null
    _sum: InstallmentSumAggregateOutputType | null
    _min: InstallmentMinAggregateOutputType | null
    _max: InstallmentMaxAggregateOutputType | null
  }

  type GetInstallmentGroupByPayload<T extends InstallmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstallmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstallmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstallmentGroupByOutputType[P]>
            : GetScalarType<T[P], InstallmentGroupByOutputType[P]>
        }
      >
    >


  export type InstallmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentAgreementId?: boolean
    number?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentAgreement?: boolean | PaymentAgreementDefaultArgs<ExtArgs>
    payment?: boolean | Installment$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["installment"]>

  export type InstallmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentAgreementId?: boolean
    number?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentAgreement?: boolean | PaymentAgreementDefaultArgs<ExtArgs>
    payment?: boolean | Installment$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["installment"]>

  export type InstallmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentAgreementId?: boolean
    number?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentAgreement?: boolean | PaymentAgreementDefaultArgs<ExtArgs>
    payment?: boolean | Installment$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["installment"]>

  export type InstallmentSelectScalar = {
    id?: boolean
    paymentAgreementId?: boolean
    number?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstallmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentAgreementId" | "number" | "dueDate" | "amount" | "status" | "paymentId" | "createdAt" | "updatedAt", ExtArgs["result"]["installment"]>
  export type InstallmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentAgreement?: boolean | PaymentAgreementDefaultArgs<ExtArgs>
    payment?: boolean | Installment$paymentArgs<ExtArgs>
  }
  export type InstallmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentAgreement?: boolean | PaymentAgreementDefaultArgs<ExtArgs>
    payment?: boolean | Installment$paymentArgs<ExtArgs>
  }
  export type InstallmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentAgreement?: boolean | PaymentAgreementDefaultArgs<ExtArgs>
    payment?: boolean | Installment$paymentArgs<ExtArgs>
  }

  export type $InstallmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Installment"
    objects: {
      paymentAgreement: Prisma.$PaymentAgreementPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentAgreementId: string
      number: number
      dueDate: Date
      amount: Prisma.Decimal
      status: $Enums.InstallmentStatus
      paymentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["installment"]>
    composites: {}
  }

  type InstallmentGetPayload<S extends boolean | null | undefined | InstallmentDefaultArgs> = $Result.GetResult<Prisma.$InstallmentPayload, S>

  type InstallmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstallmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstallmentCountAggregateInputType | true
    }

  export interface InstallmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Installment'], meta: { name: 'Installment' } }
    /**
     * Find zero or one Installment that matches the filter.
     * @param {InstallmentFindUniqueArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstallmentFindUniqueArgs>(args: SelectSubset<T, InstallmentFindUniqueArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Installment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstallmentFindUniqueOrThrowArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstallmentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstallmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Installment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindFirstArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstallmentFindFirstArgs>(args?: SelectSubset<T, InstallmentFindFirstArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Installment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindFirstOrThrowArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstallmentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstallmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Installments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Installments
     * const installments = await prisma.installment.findMany()
     * 
     * // Get first 10 Installments
     * const installments = await prisma.installment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const installmentWithIdOnly = await prisma.installment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstallmentFindManyArgs>(args?: SelectSubset<T, InstallmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Installment.
     * @param {InstallmentCreateArgs} args - Arguments to create a Installment.
     * @example
     * // Create one Installment
     * const Installment = await prisma.installment.create({
     *   data: {
     *     // ... data to create a Installment
     *   }
     * })
     * 
     */
    create<T extends InstallmentCreateArgs>(args: SelectSubset<T, InstallmentCreateArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Installments.
     * @param {InstallmentCreateManyArgs} args - Arguments to create many Installments.
     * @example
     * // Create many Installments
     * const installment = await prisma.installment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstallmentCreateManyArgs>(args?: SelectSubset<T, InstallmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Installments and returns the data saved in the database.
     * @param {InstallmentCreateManyAndReturnArgs} args - Arguments to create many Installments.
     * @example
     * // Create many Installments
     * const installment = await prisma.installment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Installments and only return the `id`
     * const installmentWithIdOnly = await prisma.installment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstallmentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstallmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Installment.
     * @param {InstallmentDeleteArgs} args - Arguments to delete one Installment.
     * @example
     * // Delete one Installment
     * const Installment = await prisma.installment.delete({
     *   where: {
     *     // ... filter to delete one Installment
     *   }
     * })
     * 
     */
    delete<T extends InstallmentDeleteArgs>(args: SelectSubset<T, InstallmentDeleteArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Installment.
     * @param {InstallmentUpdateArgs} args - Arguments to update one Installment.
     * @example
     * // Update one Installment
     * const installment = await prisma.installment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstallmentUpdateArgs>(args: SelectSubset<T, InstallmentUpdateArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Installments.
     * @param {InstallmentDeleteManyArgs} args - Arguments to filter Installments to delete.
     * @example
     * // Delete a few Installments
     * const { count } = await prisma.installment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstallmentDeleteManyArgs>(args?: SelectSubset<T, InstallmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Installments
     * const installment = await prisma.installment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstallmentUpdateManyArgs>(args: SelectSubset<T, InstallmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Installments and returns the data updated in the database.
     * @param {InstallmentUpdateManyAndReturnArgs} args - Arguments to update many Installments.
     * @example
     * // Update many Installments
     * const installment = await prisma.installment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Installments and only return the `id`
     * const installmentWithIdOnly = await prisma.installment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstallmentUpdateManyAndReturnArgs>(args: SelectSubset<T, InstallmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Installment.
     * @param {InstallmentUpsertArgs} args - Arguments to update or create a Installment.
     * @example
     * // Update or create a Installment
     * const installment = await prisma.installment.upsert({
     *   create: {
     *     // ... data to create a Installment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Installment we want to update
     *   }
     * })
     */
    upsert<T extends InstallmentUpsertArgs>(args: SelectSubset<T, InstallmentUpsertArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentCountArgs} args - Arguments to filter Installments to count.
     * @example
     * // Count the number of Installments
     * const count = await prisma.installment.count({
     *   where: {
     *     // ... the filter for the Installments we want to count
     *   }
     * })
    **/
    count<T extends InstallmentCountArgs>(
      args?: Subset<T, InstallmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstallmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Installment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstallmentAggregateArgs>(args: Subset<T, InstallmentAggregateArgs>): Prisma.PrismaPromise<GetInstallmentAggregateType<T>>

    /**
     * Group by Installment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstallmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstallmentGroupByArgs['orderBy'] }
        : { orderBy?: InstallmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstallmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstallmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Installment model
   */
  readonly fields: InstallmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Installment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstallmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paymentAgreement<T extends PaymentAgreementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentAgreementDefaultArgs<ExtArgs>>): Prisma__PaymentAgreementClient<$Result.GetResult<Prisma.$PaymentAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment<T extends Installment$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Installment$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Installment model
   */
  interface InstallmentFieldRefs {
    readonly id: FieldRef<"Installment", 'String'>
    readonly paymentAgreementId: FieldRef<"Installment", 'String'>
    readonly number: FieldRef<"Installment", 'Int'>
    readonly dueDate: FieldRef<"Installment", 'DateTime'>
    readonly amount: FieldRef<"Installment", 'Decimal'>
    readonly status: FieldRef<"Installment", 'InstallmentStatus'>
    readonly paymentId: FieldRef<"Installment", 'String'>
    readonly createdAt: FieldRef<"Installment", 'DateTime'>
    readonly updatedAt: FieldRef<"Installment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Installment findUnique
   */
  export type InstallmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment findUniqueOrThrow
   */
  export type InstallmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment findFirst
   */
  export type InstallmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Installments.
     */
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment findFirstOrThrow
   */
  export type InstallmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Installments.
     */
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment findMany
   */
  export type InstallmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installments to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment create
   */
  export type InstallmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Installment.
     */
    data: XOR<InstallmentCreateInput, InstallmentUncheckedCreateInput>
  }

  /**
   * Installment createMany
   */
  export type InstallmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Installments.
     */
    data: InstallmentCreateManyInput | InstallmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Installment createManyAndReturn
   */
  export type InstallmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * The data used to create many Installments.
     */
    data: InstallmentCreateManyInput | InstallmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Installment update
   */
  export type InstallmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Installment.
     */
    data: XOR<InstallmentUpdateInput, InstallmentUncheckedUpdateInput>
    /**
     * Choose, which Installment to update.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment updateMany
   */
  export type InstallmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Installments.
     */
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyInput>
    /**
     * Filter which Installments to update
     */
    where?: InstallmentWhereInput
    /**
     * Limit how many Installments to update.
     */
    limit?: number
  }

  /**
   * Installment updateManyAndReturn
   */
  export type InstallmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * The data used to update Installments.
     */
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyInput>
    /**
     * Filter which Installments to update
     */
    where?: InstallmentWhereInput
    /**
     * Limit how many Installments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Installment upsert
   */
  export type InstallmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Installment to update in case it exists.
     */
    where: InstallmentWhereUniqueInput
    /**
     * In case the Installment found by the `where` argument doesn't exist, create a new Installment with this data.
     */
    create: XOR<InstallmentCreateInput, InstallmentUncheckedCreateInput>
    /**
     * In case the Installment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstallmentUpdateInput, InstallmentUncheckedUpdateInput>
  }

  /**
   * Installment delete
   */
  export type InstallmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter which Installment to delete.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment deleteMany
   */
  export type InstallmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Installments to delete
     */
    where?: InstallmentWhereInput
    /**
     * Limit how many Installments to delete.
     */
    limit?: number
  }

  /**
   * Installment.payment
   */
  export type Installment$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Installment without action
   */
  export type InstallmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Installment
     */
    omit?: InstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subdomain: 'subdomain',
    contactEmail: 'contactEmail',
    countryCode: 'countryCode',
    address: 'address',
    city: 'city',
    logoUrl: 'logoUrl',
    numberOfEmployees: 'numberOfEmployees',
    phone: 'phone',
    website: 'website',
    planId: 'planId',
    planStatus: 'planStatus',
    planExpiresAt: 'planExpiresAt',
    termsAccepted: 'termsAccepted',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const TenantRegistryScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    kvk: 'kvk',
    crib: 'crib',
    taxId: 'taxId',
    vatNumber: 'vatNumber',
    legalName: 'legalName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantRegistryScalarFieldEnum = (typeof TenantRegistryScalarFieldEnum)[keyof typeof TenantRegistryScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    fullname: 'fullname',
    phone: 'phone',
    tenantId: 'tenantId',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ParameterScalarFieldEnum: {
    id: 'id',
    porcCobranza: 'porcCobranza',
    porcAbb: 'porcAbb',
    diasPlazoEmpresaAanmaning: 'diasPlazoEmpresaAanmaning',
    diasPlazoConsumidorAanmaning: 'diasPlazoConsumidorAanmaning',
    diasPlazoEmpresaSommatie: 'diasPlazoEmpresaSommatie',
    diasPlazoConsumidorSommatie: 'diasPlazoConsumidorSommatie',
    precioEmpresaPequena: 'precioEmpresaPequena',
    contribucionEmpresaPequenaPfc: 'contribucionEmpresaPequenaPfc',
    precioEmpresaGrande: 'precioEmpresaGrande',
    contribucionEmpresaGrandePfc: 'contribucionEmpresaGrandePfc',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    multaAanmaningEmpresa: 'multaAanmaningEmpresa',
    multaAanmaningNatural: 'multaAanmaningNatural',
    multaSommatieEmpresa: 'multaSommatieEmpresa',
    multaSommatieNatural: 'multaSommatieNatural',
    limiteDiasReaccionEmpresa: 'limiteDiasReaccionEmpresa',
    multaNoReaccionEmpresa: 'multaNoReaccionEmpresa',
    multaNoReaccionNatural: 'multaNoReaccionNatural',
    multaAcuerdoPagoEmpresa: 'multaAcuerdoPagoEmpresa',
    multaAcuerdoPagoNatural: 'multaAcuerdoPagoNatural',
    invoiceNumberLength: 'invoiceNumberLength',
    invoicePrefix: 'invoicePrefix',
    invoiceSecuence: 'invoiceSecuence',
    bankAccount: 'bankAccount',
    bankName: 'bankName'
  };

  export type ParameterScalarFieldEnum = (typeof ParameterScalarFieldEnum)[keyof typeof ParameterScalarFieldEnum]


  export const VerdictScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    creditorName: 'creditorName',
    debtorId: 'debtorId',
    registrationNumber: 'registrationNumber',
    sentenceAmount: 'sentenceAmount',
    sentenceDate: 'sentenceDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    procesalCost: 'procesalCost',
    tenantId: 'tenantId',
    notes: 'notes',
    bailiffId: 'bailiffId'
  };

  export type VerdictScalarFieldEnum = (typeof VerdictScalarFieldEnum)[keyof typeof VerdictScalarFieldEnum]


  export const VerdictInterestScalarFieldEnum: {
    id: 'id',
    interestType: 'interestType',
    baseAmount: 'baseAmount',
    calculatedInterest: 'calculatedInterest',
    calculationStart: 'calculationStart',
    calculationEnd: 'calculationEnd',
    totalInterest: 'totalInterest',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    verdictId: 'verdictId'
  };

  export type VerdictInterestScalarFieldEnum = (typeof VerdictInterestScalarFieldEnum)[keyof typeof VerdictInterestScalarFieldEnum]


  export const VerdictInterestDetailsScalarFieldEnum: {
    id: 'id',
    period: 'period',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    days: 'days',
    annualRate: 'annualRate',
    proportionalRate: 'proportionalRate',
    baseAmount: 'baseAmount',
    interest: 'interest',
    total: 'total',
    verdictInterestId: 'verdictInterestId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerdictInterestDetailsScalarFieldEnum = (typeof VerdictInterestDetailsScalarFieldEnum)[keyof typeof VerdictInterestDetailsScalarFieldEnum]


  export const VerdictEmbargoScalarFieldEnum: {
    id: 'id',
    verdictId: 'verdictId',
    companyName: 'companyName',
    companyPhone: 'companyPhone',
    companyEmail: 'companyEmail',
    companyAddress: 'companyAddress',
    embargoType: 'embargoType',
    embargoDate: 'embargoDate',
    embargoAmount: 'embargoAmount',
    totalAmount: 'totalAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerdictEmbargoScalarFieldEnum = (typeof VerdictEmbargoScalarFieldEnum)[keyof typeof VerdictEmbargoScalarFieldEnum]


  export const VerdictBailiffServicesScalarFieldEnum: {
    id: 'id',
    verdictId: 'verdictId',
    serviceType: 'serviceType',
    serviceCost: 'serviceCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerdictBailiffServicesScalarFieldEnum = (typeof VerdictBailiffServicesScalarFieldEnum)[keyof typeof VerdictBailiffServicesScalarFieldEnum]


  export const VerdictAttachmentScalarFieldEnum: {
    id: 'id',
    verdictId: 'verdictId',
    filePath: 'filePath',
    fileSize: 'fileSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fileName: 'fileName'
  };

  export type VerdictAttachmentScalarFieldEnum = (typeof VerdictAttachmentScalarFieldEnum)[keyof typeof VerdictAttachmentScalarFieldEnum]


  export const InterestTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    calculationType: 'calculationType'
  };

  export type InterestTypeScalarFieldEnum = (typeof InterestTypeScalarFieldEnum)[keyof typeof InterestTypeScalarFieldEnum]


  export const InterestDetailScalarFieldEnum: {
    id: 'id',
    date: 'date',
    rate: 'rate',
    interestTypeId: 'interestTypeId'
  };

  export type InterestDetailScalarFieldEnum = (typeof InterestDetailScalarFieldEnum)[keyof typeof InterestDetailScalarFieldEnum]


  export const BillingInvoiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    invoiceNumber: 'invoiceNumber',
    amount: 'amount',
    currency: 'currency',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillingInvoiceScalarFieldEnum = (typeof BillingInvoiceScalarFieldEnum)[keyof typeof BillingInvoiceScalarFieldEnum]


  export const BillingInvoiceDetailScalarFieldEnum: {
    id: 'id',
    itemDescription: 'itemDescription',
    itemQuantity: 'itemQuantity',
    itemUnitPrice: 'itemUnitPrice',
    itemTotalPrice: 'itemTotalPrice',
    itemTaxRate: 'itemTaxRate',
    itemTaxAmount: 'itemTaxAmount',
    itemTotalWithTax: 'itemTotalWithTax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    billingInvoiceId: 'billingInvoiceId'
  };

  export type BillingInvoiceDetailScalarFieldEnum = (typeof BillingInvoiceDetailScalarFieldEnum)[keyof typeof BillingInvoiceDetailScalarFieldEnum]


  export const BillingPaymentScalarFieldEnum: {
    id: 'id',
    paymentDate: 'paymentDate',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    transactionId: 'transactionId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    billingInvoiceId: 'billingInvoiceId'
  };

  export type BillingPaymentScalarFieldEnum = (typeof BillingPaymentScalarFieldEnum)[keyof typeof BillingPaymentScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    description: 'description',
    durationDays: 'durationDays',
    isActive: 'isActive'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const CollectionCaseScalarFieldEnum: {
    id: 'id',
    referenceNumber: 'referenceNumber',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    reminder1SentAt: 'reminder1SentAt',
    reminder1DueDate: 'reminder1DueDate',
    reminder2SentAt: 'reminder2SentAt',
    reminder2DueDate: 'reminder2DueDate',
    tenantId: 'tenantId',
    debtorId: 'debtorId',
    amountOriginal: 'amountOriginal',
    amountDue: 'amountDue',
    amountToReceive: 'amountToReceive',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollectionCaseScalarFieldEnum = (typeof CollectionCaseScalarFieldEnum)[keyof typeof CollectionCaseScalarFieldEnum]


  export const PenaltyScalarFieldEnum: {
    id: 'id',
    collectionCaseId: 'collectionCaseId',
    description: 'description',
    amount: 'amount',
    dateApplied: 'dateApplied',
    isPaid: 'isPaid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PenaltyScalarFieldEnum = (typeof PenaltyScalarFieldEnum)[keyof typeof PenaltyScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    collectionCaseId: 'collectionCaseId',
    type: 'type',
    title: 'title',
    message: 'message',
    sentAt: 'sentAt',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    method: 'method',
    createdAt: 'createdAt',
    collectionCaseId: 'collectionCaseId',
    paymentDate: 'paymentDate',
    referenceNumber: 'referenceNumber',
    updatedAt: 'updatedAt',
    paymentAgreementId: 'paymentAgreementId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const DebtorScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    fullname: 'fullname',
    email: 'email',
    phone: 'phone',
    address: 'address',
    personType: 'personType',
    identificationType: 'identificationType',
    identification: 'identification',
    totalIncome: 'totalIncome',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DebtorScalarFieldEnum = (typeof DebtorScalarFieldEnum)[keyof typeof DebtorScalarFieldEnum]


  export const ChatRoomScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    collectionCaseId: 'collectionCaseId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatRoomScalarFieldEnum = (typeof ChatRoomScalarFieldEnum)[keyof typeof ChatRoomScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    senderId: 'senderId',
    message: 'message',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    timestamp: 'timestamp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const DebtorIncomeScalarFieldEnum: {
    id: 'id',
    debtorId: 'debtorId',
    amount: 'amount',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DebtorIncomeScalarFieldEnum = (typeof DebtorIncomeScalarFieldEnum)[keyof typeof DebtorIncomeScalarFieldEnum]


  export const PaymentAgreementScalarFieldEnum: {
    id: 'id',
    collectionCaseId: 'collectionCaseId',
    totalAmount: 'totalAmount',
    installmentAmount: 'installmentAmount',
    installmentsCount: 'installmentsCount',
    startDate: 'startDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    debtorId: 'debtorId'
  };

  export type PaymentAgreementScalarFieldEnum = (typeof PaymentAgreementScalarFieldEnum)[keyof typeof PaymentAgreementScalarFieldEnum]


  export const InstallmentScalarFieldEnum: {
    id: 'id',
    paymentAgreementId: 'paymentAgreementId',
    number: 'number',
    dueDate: 'dueDate',
    amount: 'amount',
    status: 'status',
    paymentId: 'paymentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstallmentScalarFieldEnum = (typeof InstallmentScalarFieldEnum)[keyof typeof InstallmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'roleEnum'
   */
  export type EnumroleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'roleEnum'>
    


  /**
   * Reference to a field of type 'roleEnum[]'
   */
  export type ListEnumroleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'roleEnum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'VerdictStatus'
   */
  export type EnumVerdictStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerdictStatus'>
    


  /**
   * Reference to a field of type 'VerdictStatus[]'
   */
  export type ListEnumVerdictStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerdictStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'CalculationTypeEnum'
   */
  export type EnumCalculationTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalculationTypeEnum'>
    


  /**
   * Reference to a field of type 'CalculationTypeEnum[]'
   */
  export type ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalculationTypeEnum[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'CollectionStatus'
   */
  export type EnumCollectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CollectionStatus'>
    


  /**
   * Reference to a field of type 'CollectionStatus[]'
   */
  export type ListEnumCollectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CollectionStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PersonType'
   */
  export type EnumPersonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonType'>
    


  /**
   * Reference to a field of type 'PersonType[]'
   */
  export type ListEnumPersonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonType[]'>
    


  /**
   * Reference to a field of type 'IdentificationType'
   */
  export type EnumIdentificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentificationType'>
    


  /**
   * Reference to a field of type 'IdentificationType[]'
   */
  export type ListEnumIdentificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentificationType[]'>
    


  /**
   * Reference to a field of type 'PaymentAgreementStatus'
   */
  export type EnumPaymentAgreementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentAgreementStatus'>
    


  /**
   * Reference to a field of type 'PaymentAgreementStatus[]'
   */
  export type ListEnumPaymentAgreementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentAgreementStatus[]'>
    


  /**
   * Reference to a field of type 'InstallmentStatus'
   */
  export type EnumInstallmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstallmentStatus'>
    


  /**
   * Reference to a field of type 'InstallmentStatus[]'
   */
  export type ListEnumInstallmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstallmentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    subdomain?: StringFilter<"Tenant"> | string
    contactEmail?: StringFilter<"Tenant"> | string
    countryCode?: StringFilter<"Tenant"> | string
    address?: StringNullableFilter<"Tenant"> | string | null
    city?: StringNullableFilter<"Tenant"> | string | null
    logoUrl?: StringNullableFilter<"Tenant"> | string | null
    numberOfEmployees?: IntNullableFilter<"Tenant"> | number | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    website?: StringNullableFilter<"Tenant"> | string | null
    planId?: StringNullableFilter<"Tenant"> | string | null
    planStatus?: StringFilter<"Tenant"> | string
    planExpiresAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    termsAccepted?: BoolFilter<"Tenant"> | boolean
    isActive?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    plan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
    billingInvoice?: BillingInvoiceListRelationFilter
    collectionCases?: CollectionCaseListRelationFilter
    debtors?: DebtorListRelationFilter
    registry?: XOR<TenantRegistryNullableScalarRelationFilter, TenantRegistryWhereInput> | null
    verdicts?: VerdictListRelationFilter
    users?: UserListRelationFilter
    chatRooms?: ChatRoomListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    contactEmail?: SortOrder
    countryCode?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    numberOfEmployees?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    planStatus?: SortOrder
    planExpiresAt?: SortOrderInput | SortOrder
    termsAccepted?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
    billingInvoice?: BillingInvoiceOrderByRelationAggregateInput
    collectionCases?: CollectionCaseOrderByRelationAggregateInput
    debtors?: DebtorOrderByRelationAggregateInput
    registry?: TenantRegistryOrderByWithRelationInput
    verdicts?: VerdictOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    chatRooms?: ChatRoomOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subdomain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    contactEmail?: StringFilter<"Tenant"> | string
    countryCode?: StringFilter<"Tenant"> | string
    address?: StringNullableFilter<"Tenant"> | string | null
    city?: StringNullableFilter<"Tenant"> | string | null
    logoUrl?: StringNullableFilter<"Tenant"> | string | null
    numberOfEmployees?: IntNullableFilter<"Tenant"> | number | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    website?: StringNullableFilter<"Tenant"> | string | null
    planId?: StringNullableFilter<"Tenant"> | string | null
    planStatus?: StringFilter<"Tenant"> | string
    planExpiresAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    termsAccepted?: BoolFilter<"Tenant"> | boolean
    isActive?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    plan?: XOR<PlanNullableScalarRelationFilter, PlanWhereInput> | null
    billingInvoice?: BillingInvoiceListRelationFilter
    collectionCases?: CollectionCaseListRelationFilter
    debtors?: DebtorListRelationFilter
    registry?: XOR<TenantRegistryNullableScalarRelationFilter, TenantRegistryWhereInput> | null
    verdicts?: VerdictListRelationFilter
    users?: UserListRelationFilter
    chatRooms?: ChatRoomListRelationFilter
  }, "id" | "subdomain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    contactEmail?: SortOrder
    countryCode?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    numberOfEmployees?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    planStatus?: SortOrder
    planExpiresAt?: SortOrderInput | SortOrder
    termsAccepted?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    subdomain?: StringWithAggregatesFilter<"Tenant"> | string
    contactEmail?: StringWithAggregatesFilter<"Tenant"> | string
    countryCode?: StringWithAggregatesFilter<"Tenant"> | string
    address?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    city?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    numberOfEmployees?: IntNullableWithAggregatesFilter<"Tenant"> | number | null
    phone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    website?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    planId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    planStatus?: StringWithAggregatesFilter<"Tenant"> | string
    planExpiresAt?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    termsAccepted?: BoolWithAggregatesFilter<"Tenant"> | boolean
    isActive?: BoolWithAggregatesFilter<"Tenant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type TenantRegistryWhereInput = {
    AND?: TenantRegistryWhereInput | TenantRegistryWhereInput[]
    OR?: TenantRegistryWhereInput[]
    NOT?: TenantRegistryWhereInput | TenantRegistryWhereInput[]
    id?: StringFilter<"TenantRegistry"> | string
    tenantId?: StringFilter<"TenantRegistry"> | string
    kvk?: StringNullableFilter<"TenantRegistry"> | string | null
    crib?: StringNullableFilter<"TenantRegistry"> | string | null
    taxId?: StringNullableFilter<"TenantRegistry"> | string | null
    vatNumber?: StringNullableFilter<"TenantRegistry"> | string | null
    legalName?: StringNullableFilter<"TenantRegistry"> | string | null
    createdAt?: DateTimeFilter<"TenantRegistry"> | Date | string
    updatedAt?: DateTimeFilter<"TenantRegistry"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantRegistryOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kvk?: SortOrderInput | SortOrder
    crib?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    legalName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantRegistryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: TenantRegistryWhereInput | TenantRegistryWhereInput[]
    OR?: TenantRegistryWhereInput[]
    NOT?: TenantRegistryWhereInput | TenantRegistryWhereInput[]
    kvk?: StringNullableFilter<"TenantRegistry"> | string | null
    crib?: StringNullableFilter<"TenantRegistry"> | string | null
    taxId?: StringNullableFilter<"TenantRegistry"> | string | null
    vatNumber?: StringNullableFilter<"TenantRegistry"> | string | null
    legalName?: StringNullableFilter<"TenantRegistry"> | string | null
    createdAt?: DateTimeFilter<"TenantRegistry"> | Date | string
    updatedAt?: DateTimeFilter<"TenantRegistry"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type TenantRegistryOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kvk?: SortOrderInput | SortOrder
    crib?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    vatNumber?: SortOrderInput | SortOrder
    legalName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantRegistryCountOrderByAggregateInput
    _max?: TenantRegistryMaxOrderByAggregateInput
    _min?: TenantRegistryMinOrderByAggregateInput
  }

  export type TenantRegistryScalarWhereWithAggregatesInput = {
    AND?: TenantRegistryScalarWhereWithAggregatesInput | TenantRegistryScalarWhereWithAggregatesInput[]
    OR?: TenantRegistryScalarWhereWithAggregatesInput[]
    NOT?: TenantRegistryScalarWhereWithAggregatesInput | TenantRegistryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantRegistry"> | string
    tenantId?: StringWithAggregatesFilter<"TenantRegistry"> | string
    kvk?: StringNullableWithAggregatesFilter<"TenantRegistry"> | string | null
    crib?: StringNullableWithAggregatesFilter<"TenantRegistry"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"TenantRegistry"> | string | null
    vatNumber?: StringNullableWithAggregatesFilter<"TenantRegistry"> | string | null
    legalName?: StringNullableWithAggregatesFilter<"TenantRegistry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantRegistry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantRegistry"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    fullname?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    tenantId?: StringFilter<"User"> | string
    role?: EnumroleEnumFilter<"User"> | $Enums.roleEnum
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    debtors?: DebtorListRelationFilter
    verdictBailiffs?: VerdictListRelationFilter
    messages?: ChatMessageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    debtors?: DebtorOrderByRelationAggregateInput
    verdictBailiffs?: VerdictOrderByRelationAggregateInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    fullname?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    tenantId?: StringFilter<"User"> | string
    role?: EnumroleEnumFilter<"User"> | $Enums.roleEnum
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    debtors?: DebtorListRelationFilter
    verdictBailiffs?: VerdictListRelationFilter
    messages?: ChatMessageListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullname?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    tenantId?: StringWithAggregatesFilter<"User"> | string
    role?: EnumroleEnumWithAggregatesFilter<"User"> | $Enums.roleEnum
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ParameterWhereInput = {
    AND?: ParameterWhereInput | ParameterWhereInput[]
    OR?: ParameterWhereInput[]
    NOT?: ParameterWhereInput | ParameterWhereInput[]
    id?: StringFilter<"Parameter"> | string
    porcCobranza?: FloatFilter<"Parameter"> | number
    porcAbb?: FloatFilter<"Parameter"> | number
    diasPlazoEmpresaAanmaning?: IntFilter<"Parameter"> | number
    diasPlazoConsumidorAanmaning?: IntFilter<"Parameter"> | number
    diasPlazoEmpresaSommatie?: IntFilter<"Parameter"> | number
    diasPlazoConsumidorSommatie?: IntFilter<"Parameter"> | number
    precioEmpresaPequena?: FloatFilter<"Parameter"> | number
    contribucionEmpresaPequenaPfc?: FloatFilter<"Parameter"> | number
    precioEmpresaGrande?: FloatFilter<"Parameter"> | number
    contribucionEmpresaGrandePfc?: FloatFilter<"Parameter"> | number
    createdAt?: DateTimeFilter<"Parameter"> | Date | string
    updatedAt?: DateTimeFilter<"Parameter"> | Date | string
    multaAanmaningEmpresa?: FloatFilter<"Parameter"> | number
    multaAanmaningNatural?: FloatFilter<"Parameter"> | number
    multaSommatieEmpresa?: FloatFilter<"Parameter"> | number
    multaSommatieNatural?: FloatFilter<"Parameter"> | number
    limiteDiasReaccionEmpresa?: IntFilter<"Parameter"> | number
    multaNoReaccionEmpresa?: FloatFilter<"Parameter"> | number
    multaNoReaccionNatural?: FloatFilter<"Parameter"> | number
    multaAcuerdoPagoEmpresa?: FloatFilter<"Parameter"> | number
    multaAcuerdoPagoNatural?: FloatFilter<"Parameter"> | number
    invoiceNumberLength?: IntFilter<"Parameter"> | number
    invoicePrefix?: StringFilter<"Parameter"> | string
    invoiceSecuence?: IntFilter<"Parameter"> | number
    bankAccount?: StringFilter<"Parameter"> | string
    bankName?: StringFilter<"Parameter"> | string
  }

  export type ParameterOrderByWithRelationInput = {
    id?: SortOrder
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoicePrefix?: SortOrder
    invoiceSecuence?: SortOrder
    bankAccount?: SortOrder
    bankName?: SortOrder
  }

  export type ParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParameterWhereInput | ParameterWhereInput[]
    OR?: ParameterWhereInput[]
    NOT?: ParameterWhereInput | ParameterWhereInput[]
    porcCobranza?: FloatFilter<"Parameter"> | number
    porcAbb?: FloatFilter<"Parameter"> | number
    diasPlazoEmpresaAanmaning?: IntFilter<"Parameter"> | number
    diasPlazoConsumidorAanmaning?: IntFilter<"Parameter"> | number
    diasPlazoEmpresaSommatie?: IntFilter<"Parameter"> | number
    diasPlazoConsumidorSommatie?: IntFilter<"Parameter"> | number
    precioEmpresaPequena?: FloatFilter<"Parameter"> | number
    contribucionEmpresaPequenaPfc?: FloatFilter<"Parameter"> | number
    precioEmpresaGrande?: FloatFilter<"Parameter"> | number
    contribucionEmpresaGrandePfc?: FloatFilter<"Parameter"> | number
    createdAt?: DateTimeFilter<"Parameter"> | Date | string
    updatedAt?: DateTimeFilter<"Parameter"> | Date | string
    multaAanmaningEmpresa?: FloatFilter<"Parameter"> | number
    multaAanmaningNatural?: FloatFilter<"Parameter"> | number
    multaSommatieEmpresa?: FloatFilter<"Parameter"> | number
    multaSommatieNatural?: FloatFilter<"Parameter"> | number
    limiteDiasReaccionEmpresa?: IntFilter<"Parameter"> | number
    multaNoReaccionEmpresa?: FloatFilter<"Parameter"> | number
    multaNoReaccionNatural?: FloatFilter<"Parameter"> | number
    multaAcuerdoPagoEmpresa?: FloatFilter<"Parameter"> | number
    multaAcuerdoPagoNatural?: FloatFilter<"Parameter"> | number
    invoiceNumberLength?: IntFilter<"Parameter"> | number
    invoicePrefix?: StringFilter<"Parameter"> | string
    invoiceSecuence?: IntFilter<"Parameter"> | number
    bankAccount?: StringFilter<"Parameter"> | string
    bankName?: StringFilter<"Parameter"> | string
  }, "id">

  export type ParameterOrderByWithAggregationInput = {
    id?: SortOrder
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoicePrefix?: SortOrder
    invoiceSecuence?: SortOrder
    bankAccount?: SortOrder
    bankName?: SortOrder
    _count?: ParameterCountOrderByAggregateInput
    _avg?: ParameterAvgOrderByAggregateInput
    _max?: ParameterMaxOrderByAggregateInput
    _min?: ParameterMinOrderByAggregateInput
    _sum?: ParameterSumOrderByAggregateInput
  }

  export type ParameterScalarWhereWithAggregatesInput = {
    AND?: ParameterScalarWhereWithAggregatesInput | ParameterScalarWhereWithAggregatesInput[]
    OR?: ParameterScalarWhereWithAggregatesInput[]
    NOT?: ParameterScalarWhereWithAggregatesInput | ParameterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parameter"> | string
    porcCobranza?: FloatWithAggregatesFilter<"Parameter"> | number
    porcAbb?: FloatWithAggregatesFilter<"Parameter"> | number
    diasPlazoEmpresaAanmaning?: IntWithAggregatesFilter<"Parameter"> | number
    diasPlazoConsumidorAanmaning?: IntWithAggregatesFilter<"Parameter"> | number
    diasPlazoEmpresaSommatie?: IntWithAggregatesFilter<"Parameter"> | number
    diasPlazoConsumidorSommatie?: IntWithAggregatesFilter<"Parameter"> | number
    precioEmpresaPequena?: FloatWithAggregatesFilter<"Parameter"> | number
    contribucionEmpresaPequenaPfc?: FloatWithAggregatesFilter<"Parameter"> | number
    precioEmpresaGrande?: FloatWithAggregatesFilter<"Parameter"> | number
    contribucionEmpresaGrandePfc?: FloatWithAggregatesFilter<"Parameter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Parameter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parameter"> | Date | string
    multaAanmaningEmpresa?: FloatWithAggregatesFilter<"Parameter"> | number
    multaAanmaningNatural?: FloatWithAggregatesFilter<"Parameter"> | number
    multaSommatieEmpresa?: FloatWithAggregatesFilter<"Parameter"> | number
    multaSommatieNatural?: FloatWithAggregatesFilter<"Parameter"> | number
    limiteDiasReaccionEmpresa?: IntWithAggregatesFilter<"Parameter"> | number
    multaNoReaccionEmpresa?: FloatWithAggregatesFilter<"Parameter"> | number
    multaNoReaccionNatural?: FloatWithAggregatesFilter<"Parameter"> | number
    multaAcuerdoPagoEmpresa?: FloatWithAggregatesFilter<"Parameter"> | number
    multaAcuerdoPagoNatural?: FloatWithAggregatesFilter<"Parameter"> | number
    invoiceNumberLength?: IntWithAggregatesFilter<"Parameter"> | number
    invoicePrefix?: StringWithAggregatesFilter<"Parameter"> | string
    invoiceSecuence?: IntWithAggregatesFilter<"Parameter"> | number
    bankAccount?: StringWithAggregatesFilter<"Parameter"> | string
    bankName?: StringWithAggregatesFilter<"Parameter"> | string
  }

  export type VerdictWhereInput = {
    AND?: VerdictWhereInput | VerdictWhereInput[]
    OR?: VerdictWhereInput[]
    NOT?: VerdictWhereInput | VerdictWhereInput[]
    id?: StringFilter<"Verdict"> | string
    invoiceNumber?: StringFilter<"Verdict"> | string
    creditorName?: StringFilter<"Verdict"> | string
    debtorId?: StringFilter<"Verdict"> | string
    registrationNumber?: StringFilter<"Verdict"> | string
    sentenceAmount?: FloatFilter<"Verdict"> | number
    sentenceDate?: DateTimeFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusFilter<"Verdict"> | $Enums.VerdictStatus
    createdAt?: DateTimeFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeFilter<"Verdict"> | Date | string
    procesalCost?: FloatNullableFilter<"Verdict"> | number | null
    tenantId?: StringFilter<"Verdict"> | string
    notes?: StringNullableFilter<"Verdict"> | string | null
    bailiffId?: StringNullableFilter<"Verdict"> | string | null
    bailiff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    attachments?: VerdictAttachmentListRelationFilter
    bailiffServices?: VerdictBailiffServicesListRelationFilter
    verdictEmbargo?: VerdictEmbargoListRelationFilter
    verdictInterest?: VerdictInterestListRelationFilter
  }

  export type VerdictOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    creditorName?: SortOrder
    debtorId?: SortOrder
    registrationNumber?: SortOrder
    sentenceAmount?: SortOrder
    sentenceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procesalCost?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    notes?: SortOrderInput | SortOrder
    bailiffId?: SortOrderInput | SortOrder
    bailiff?: UserOrderByWithRelationInput
    debtor?: DebtorOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    attachments?: VerdictAttachmentOrderByRelationAggregateInput
    bailiffServices?: VerdictBailiffServicesOrderByRelationAggregateInput
    verdictEmbargo?: VerdictEmbargoOrderByRelationAggregateInput
    verdictInterest?: VerdictInterestOrderByRelationAggregateInput
  }

  export type VerdictWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictWhereInput | VerdictWhereInput[]
    OR?: VerdictWhereInput[]
    NOT?: VerdictWhereInput | VerdictWhereInput[]
    invoiceNumber?: StringFilter<"Verdict"> | string
    creditorName?: StringFilter<"Verdict"> | string
    debtorId?: StringFilter<"Verdict"> | string
    registrationNumber?: StringFilter<"Verdict"> | string
    sentenceAmount?: FloatFilter<"Verdict"> | number
    sentenceDate?: DateTimeFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusFilter<"Verdict"> | $Enums.VerdictStatus
    createdAt?: DateTimeFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeFilter<"Verdict"> | Date | string
    procesalCost?: FloatNullableFilter<"Verdict"> | number | null
    tenantId?: StringFilter<"Verdict"> | string
    notes?: StringNullableFilter<"Verdict"> | string | null
    bailiffId?: StringNullableFilter<"Verdict"> | string | null
    bailiff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    attachments?: VerdictAttachmentListRelationFilter
    bailiffServices?: VerdictBailiffServicesListRelationFilter
    verdictEmbargo?: VerdictEmbargoListRelationFilter
    verdictInterest?: VerdictInterestListRelationFilter
  }, "id">

  export type VerdictOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    creditorName?: SortOrder
    debtorId?: SortOrder
    registrationNumber?: SortOrder
    sentenceAmount?: SortOrder
    sentenceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procesalCost?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    notes?: SortOrderInput | SortOrder
    bailiffId?: SortOrderInput | SortOrder
    _count?: VerdictCountOrderByAggregateInput
    _avg?: VerdictAvgOrderByAggregateInput
    _max?: VerdictMaxOrderByAggregateInput
    _min?: VerdictMinOrderByAggregateInput
    _sum?: VerdictSumOrderByAggregateInput
  }

  export type VerdictScalarWhereWithAggregatesInput = {
    AND?: VerdictScalarWhereWithAggregatesInput | VerdictScalarWhereWithAggregatesInput[]
    OR?: VerdictScalarWhereWithAggregatesInput[]
    NOT?: VerdictScalarWhereWithAggregatesInput | VerdictScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verdict"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Verdict"> | string
    creditorName?: StringWithAggregatesFilter<"Verdict"> | string
    debtorId?: StringWithAggregatesFilter<"Verdict"> | string
    registrationNumber?: StringWithAggregatesFilter<"Verdict"> | string
    sentenceAmount?: FloatWithAggregatesFilter<"Verdict"> | number
    sentenceDate?: DateTimeWithAggregatesFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusWithAggregatesFilter<"Verdict"> | $Enums.VerdictStatus
    createdAt?: DateTimeWithAggregatesFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verdict"> | Date | string
    procesalCost?: FloatNullableWithAggregatesFilter<"Verdict"> | number | null
    tenantId?: StringWithAggregatesFilter<"Verdict"> | string
    notes?: StringNullableWithAggregatesFilter<"Verdict"> | string | null
    bailiffId?: StringNullableWithAggregatesFilter<"Verdict"> | string | null
  }

  export type VerdictInterestWhereInput = {
    AND?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    OR?: VerdictInterestWhereInput[]
    NOT?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    id?: StringFilter<"VerdictInterest"> | string
    interestType?: IntFilter<"VerdictInterest"> | number
    baseAmount?: FloatFilter<"VerdictInterest"> | number
    calculatedInterest?: FloatNullableFilter<"VerdictInterest"> | number | null
    calculationStart?: DateTimeFilter<"VerdictInterest"> | Date | string
    calculationEnd?: DateTimeFilter<"VerdictInterest"> | Date | string
    totalInterest?: FloatFilter<"VerdictInterest"> | number
    createdAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    verdictId?: StringNullableFilter<"VerdictInterest"> | string | null
    verdict?: XOR<VerdictNullableScalarRelationFilter, VerdictWhereInput> | null
    details?: VerdictInterestDetailsListRelationFilter
  }

  export type VerdictInterestOrderByWithRelationInput = {
    id?: SortOrder
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrderInput | SortOrder
    calculationStart?: SortOrder
    calculationEnd?: SortOrder
    totalInterest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictId?: SortOrderInput | SortOrder
    verdict?: VerdictOrderByWithRelationInput
    details?: VerdictInterestDetailsOrderByRelationAggregateInput
  }

  export type VerdictInterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    OR?: VerdictInterestWhereInput[]
    NOT?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    interestType?: IntFilter<"VerdictInterest"> | number
    baseAmount?: FloatFilter<"VerdictInterest"> | number
    calculatedInterest?: FloatNullableFilter<"VerdictInterest"> | number | null
    calculationStart?: DateTimeFilter<"VerdictInterest"> | Date | string
    calculationEnd?: DateTimeFilter<"VerdictInterest"> | Date | string
    totalInterest?: FloatFilter<"VerdictInterest"> | number
    createdAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    verdictId?: StringNullableFilter<"VerdictInterest"> | string | null
    verdict?: XOR<VerdictNullableScalarRelationFilter, VerdictWhereInput> | null
    details?: VerdictInterestDetailsListRelationFilter
  }, "id">

  export type VerdictInterestOrderByWithAggregationInput = {
    id?: SortOrder
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrderInput | SortOrder
    calculationStart?: SortOrder
    calculationEnd?: SortOrder
    totalInterest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictId?: SortOrderInput | SortOrder
    _count?: VerdictInterestCountOrderByAggregateInput
    _avg?: VerdictInterestAvgOrderByAggregateInput
    _max?: VerdictInterestMaxOrderByAggregateInput
    _min?: VerdictInterestMinOrderByAggregateInput
    _sum?: VerdictInterestSumOrderByAggregateInput
  }

  export type VerdictInterestScalarWhereWithAggregatesInput = {
    AND?: VerdictInterestScalarWhereWithAggregatesInput | VerdictInterestScalarWhereWithAggregatesInput[]
    OR?: VerdictInterestScalarWhereWithAggregatesInput[]
    NOT?: VerdictInterestScalarWhereWithAggregatesInput | VerdictInterestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictInterest"> | string
    interestType?: IntWithAggregatesFilter<"VerdictInterest"> | number
    baseAmount?: FloatWithAggregatesFilter<"VerdictInterest"> | number
    calculatedInterest?: FloatNullableWithAggregatesFilter<"VerdictInterest"> | number | null
    calculationStart?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    calculationEnd?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    totalInterest?: FloatWithAggregatesFilter<"VerdictInterest"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    verdictId?: StringNullableWithAggregatesFilter<"VerdictInterest"> | string | null
  }

  export type VerdictInterestDetailsWhereInput = {
    AND?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    OR?: VerdictInterestDetailsWhereInput[]
    NOT?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    id?: StringFilter<"VerdictInterestDetails"> | string
    period?: StringFilter<"VerdictInterestDetails"> | string
    periodStart?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    periodEnd?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    days?: IntFilter<"VerdictInterestDetails"> | number
    annualRate?: FloatFilter<"VerdictInterestDetails"> | number
    proportionalRate?: FloatFilter<"VerdictInterestDetails"> | number
    baseAmount?: FloatFilter<"VerdictInterestDetails"> | number
    interest?: FloatFilter<"VerdictInterestDetails"> | number
    total?: FloatFilter<"VerdictInterestDetails"> | number
    verdictInterestId?: StringFilter<"VerdictInterestDetails"> | string
    createdAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    verdictInterest?: XOR<VerdictInterestScalarRelationFilter, VerdictInterestWhereInput>
  }

  export type VerdictInterestDetailsOrderByWithRelationInput = {
    id?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdictInterestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictInterest?: VerdictInterestOrderByWithRelationInput
  }

  export type VerdictInterestDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    OR?: VerdictInterestDetailsWhereInput[]
    NOT?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    period?: StringFilter<"VerdictInterestDetails"> | string
    periodStart?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    periodEnd?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    days?: IntFilter<"VerdictInterestDetails"> | number
    annualRate?: FloatFilter<"VerdictInterestDetails"> | number
    proportionalRate?: FloatFilter<"VerdictInterestDetails"> | number
    baseAmount?: FloatFilter<"VerdictInterestDetails"> | number
    interest?: FloatFilter<"VerdictInterestDetails"> | number
    total?: FloatFilter<"VerdictInterestDetails"> | number
    verdictInterestId?: StringFilter<"VerdictInterestDetails"> | string
    createdAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    verdictInterest?: XOR<VerdictInterestScalarRelationFilter, VerdictInterestWhereInput>
  }, "id">

  export type VerdictInterestDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdictInterestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerdictInterestDetailsCountOrderByAggregateInput
    _avg?: VerdictInterestDetailsAvgOrderByAggregateInput
    _max?: VerdictInterestDetailsMaxOrderByAggregateInput
    _min?: VerdictInterestDetailsMinOrderByAggregateInput
    _sum?: VerdictInterestDetailsSumOrderByAggregateInput
  }

  export type VerdictInterestDetailsScalarWhereWithAggregatesInput = {
    AND?: VerdictInterestDetailsScalarWhereWithAggregatesInput | VerdictInterestDetailsScalarWhereWithAggregatesInput[]
    OR?: VerdictInterestDetailsScalarWhereWithAggregatesInput[]
    NOT?: VerdictInterestDetailsScalarWhereWithAggregatesInput | VerdictInterestDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictInterestDetails"> | string
    period?: StringWithAggregatesFilter<"VerdictInterestDetails"> | string
    periodStart?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
    days?: IntWithAggregatesFilter<"VerdictInterestDetails"> | number
    annualRate?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    proportionalRate?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    baseAmount?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    interest?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    total?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    verdictInterestId?: StringWithAggregatesFilter<"VerdictInterestDetails"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
  }

  export type VerdictEmbargoWhereInput = {
    AND?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    OR?: VerdictEmbargoWhereInput[]
    NOT?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    id?: StringFilter<"VerdictEmbargo"> | string
    verdictId?: StringFilter<"VerdictEmbargo"> | string
    companyName?: StringFilter<"VerdictEmbargo"> | string
    companyPhone?: StringFilter<"VerdictEmbargo"> | string
    companyEmail?: StringFilter<"VerdictEmbargo"> | string
    companyAddress?: StringFilter<"VerdictEmbargo"> | string
    embargoType?: StringFilter<"VerdictEmbargo"> | string
    embargoDate?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    embargoAmount?: FloatFilter<"VerdictEmbargo"> | number
    totalAmount?: FloatFilter<"VerdictEmbargo"> | number
    createdAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }

  export type VerdictEmbargoOrderByWithRelationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    companyName?: SortOrder
    companyPhone?: SortOrder
    companyEmail?: SortOrder
    companyAddress?: SortOrder
    embargoType?: SortOrder
    embargoDate?: SortOrder
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdict?: VerdictOrderByWithRelationInput
  }

  export type VerdictEmbargoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    OR?: VerdictEmbargoWhereInput[]
    NOT?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    verdictId?: StringFilter<"VerdictEmbargo"> | string
    companyName?: StringFilter<"VerdictEmbargo"> | string
    companyPhone?: StringFilter<"VerdictEmbargo"> | string
    companyEmail?: StringFilter<"VerdictEmbargo"> | string
    companyAddress?: StringFilter<"VerdictEmbargo"> | string
    embargoType?: StringFilter<"VerdictEmbargo"> | string
    embargoDate?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    embargoAmount?: FloatFilter<"VerdictEmbargo"> | number
    totalAmount?: FloatFilter<"VerdictEmbargo"> | number
    createdAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }, "id">

  export type VerdictEmbargoOrderByWithAggregationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    companyName?: SortOrder
    companyPhone?: SortOrder
    companyEmail?: SortOrder
    companyAddress?: SortOrder
    embargoType?: SortOrder
    embargoDate?: SortOrder
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerdictEmbargoCountOrderByAggregateInput
    _avg?: VerdictEmbargoAvgOrderByAggregateInput
    _max?: VerdictEmbargoMaxOrderByAggregateInput
    _min?: VerdictEmbargoMinOrderByAggregateInput
    _sum?: VerdictEmbargoSumOrderByAggregateInput
  }

  export type VerdictEmbargoScalarWhereWithAggregatesInput = {
    AND?: VerdictEmbargoScalarWhereWithAggregatesInput | VerdictEmbargoScalarWhereWithAggregatesInput[]
    OR?: VerdictEmbargoScalarWhereWithAggregatesInput[]
    NOT?: VerdictEmbargoScalarWhereWithAggregatesInput | VerdictEmbargoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    verdictId?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    companyName?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    companyPhone?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    companyEmail?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    companyAddress?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    embargoType?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    embargoDate?: DateTimeWithAggregatesFilter<"VerdictEmbargo"> | Date | string
    embargoAmount?: FloatWithAggregatesFilter<"VerdictEmbargo"> | number
    totalAmount?: FloatWithAggregatesFilter<"VerdictEmbargo"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VerdictEmbargo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerdictEmbargo"> | Date | string
  }

  export type VerdictBailiffServicesWhereInput = {
    AND?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    OR?: VerdictBailiffServicesWhereInput[]
    NOT?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    id?: StringFilter<"VerdictBailiffServices"> | string
    verdictId?: StringFilter<"VerdictBailiffServices"> | string
    serviceType?: StringFilter<"VerdictBailiffServices"> | string
    serviceCost?: FloatFilter<"VerdictBailiffServices"> | number
    createdAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }

  export type VerdictBailiffServicesOrderByWithRelationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    serviceType?: SortOrder
    serviceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdict?: VerdictOrderByWithRelationInput
  }

  export type VerdictBailiffServicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    OR?: VerdictBailiffServicesWhereInput[]
    NOT?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    verdictId?: StringFilter<"VerdictBailiffServices"> | string
    serviceType?: StringFilter<"VerdictBailiffServices"> | string
    serviceCost?: FloatFilter<"VerdictBailiffServices"> | number
    createdAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }, "id">

  export type VerdictBailiffServicesOrderByWithAggregationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    serviceType?: SortOrder
    serviceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerdictBailiffServicesCountOrderByAggregateInput
    _avg?: VerdictBailiffServicesAvgOrderByAggregateInput
    _max?: VerdictBailiffServicesMaxOrderByAggregateInput
    _min?: VerdictBailiffServicesMinOrderByAggregateInput
    _sum?: VerdictBailiffServicesSumOrderByAggregateInput
  }

  export type VerdictBailiffServicesScalarWhereWithAggregatesInput = {
    AND?: VerdictBailiffServicesScalarWhereWithAggregatesInput | VerdictBailiffServicesScalarWhereWithAggregatesInput[]
    OR?: VerdictBailiffServicesScalarWhereWithAggregatesInput[]
    NOT?: VerdictBailiffServicesScalarWhereWithAggregatesInput | VerdictBailiffServicesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictBailiffServices"> | string
    verdictId?: StringWithAggregatesFilter<"VerdictBailiffServices"> | string
    serviceType?: StringWithAggregatesFilter<"VerdictBailiffServices"> | string
    serviceCost?: FloatWithAggregatesFilter<"VerdictBailiffServices"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VerdictBailiffServices"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerdictBailiffServices"> | Date | string
  }

  export type VerdictAttachmentWhereInput = {
    AND?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    OR?: VerdictAttachmentWhereInput[]
    NOT?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    id?: StringFilter<"VerdictAttachment"> | string
    verdictId?: StringFilter<"VerdictAttachment"> | string
    filePath?: StringFilter<"VerdictAttachment"> | string
    fileSize?: BigIntFilter<"VerdictAttachment"> | bigint | number
    createdAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    fileName?: StringFilter<"VerdictAttachment"> | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }

  export type VerdictAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
    verdict?: VerdictOrderByWithRelationInput
  }

  export type VerdictAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    OR?: VerdictAttachmentWhereInput[]
    NOT?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    verdictId?: StringFilter<"VerdictAttachment"> | string
    filePath?: StringFilter<"VerdictAttachment"> | string
    fileSize?: BigIntFilter<"VerdictAttachment"> | bigint | number
    createdAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    fileName?: StringFilter<"VerdictAttachment"> | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }, "id">

  export type VerdictAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    verdictId?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
    _count?: VerdictAttachmentCountOrderByAggregateInput
    _avg?: VerdictAttachmentAvgOrderByAggregateInput
    _max?: VerdictAttachmentMaxOrderByAggregateInput
    _min?: VerdictAttachmentMinOrderByAggregateInput
    _sum?: VerdictAttachmentSumOrderByAggregateInput
  }

  export type VerdictAttachmentScalarWhereWithAggregatesInput = {
    AND?: VerdictAttachmentScalarWhereWithAggregatesInput | VerdictAttachmentScalarWhereWithAggregatesInput[]
    OR?: VerdictAttachmentScalarWhereWithAggregatesInput[]
    NOT?: VerdictAttachmentScalarWhereWithAggregatesInput | VerdictAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictAttachment"> | string
    verdictId?: StringWithAggregatesFilter<"VerdictAttachment"> | string
    filePath?: StringWithAggregatesFilter<"VerdictAttachment"> | string
    fileSize?: BigIntWithAggregatesFilter<"VerdictAttachment"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"VerdictAttachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VerdictAttachment"> | Date | string
    fileName?: StringWithAggregatesFilter<"VerdictAttachment"> | string
  }

  export type InterestTypeWhereInput = {
    AND?: InterestTypeWhereInput | InterestTypeWhereInput[]
    OR?: InterestTypeWhereInput[]
    NOT?: InterestTypeWhereInput | InterestTypeWhereInput[]
    id?: IntFilter<"InterestType"> | number
    name?: StringFilter<"InterestType"> | string
    calculationType?: EnumCalculationTypeEnumFilter<"InterestType"> | $Enums.CalculationTypeEnum
    details?: InterestDetailListRelationFilter
  }

  export type InterestTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    calculationType?: SortOrder
    details?: InterestDetailOrderByRelationAggregateInput
  }

  export type InterestTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InterestTypeWhereInput | InterestTypeWhereInput[]
    OR?: InterestTypeWhereInput[]
    NOT?: InterestTypeWhereInput | InterestTypeWhereInput[]
    name?: StringFilter<"InterestType"> | string
    calculationType?: EnumCalculationTypeEnumFilter<"InterestType"> | $Enums.CalculationTypeEnum
    details?: InterestDetailListRelationFilter
  }, "id">

  export type InterestTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    calculationType?: SortOrder
    _count?: InterestTypeCountOrderByAggregateInput
    _avg?: InterestTypeAvgOrderByAggregateInput
    _max?: InterestTypeMaxOrderByAggregateInput
    _min?: InterestTypeMinOrderByAggregateInput
    _sum?: InterestTypeSumOrderByAggregateInput
  }

  export type InterestTypeScalarWhereWithAggregatesInput = {
    AND?: InterestTypeScalarWhereWithAggregatesInput | InterestTypeScalarWhereWithAggregatesInput[]
    OR?: InterestTypeScalarWhereWithAggregatesInput[]
    NOT?: InterestTypeScalarWhereWithAggregatesInput | InterestTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InterestType"> | number
    name?: StringWithAggregatesFilter<"InterestType"> | string
    calculationType?: EnumCalculationTypeEnumWithAggregatesFilter<"InterestType"> | $Enums.CalculationTypeEnum
  }

  export type InterestDetailWhereInput = {
    AND?: InterestDetailWhereInput | InterestDetailWhereInput[]
    OR?: InterestDetailWhereInput[]
    NOT?: InterestDetailWhereInput | InterestDetailWhereInput[]
    id?: IntFilter<"InterestDetail"> | number
    date?: StringFilter<"InterestDetail"> | string
    rate?: FloatFilter<"InterestDetail"> | number
    interestTypeId?: IntFilter<"InterestDetail"> | number
    interestType?: XOR<InterestTypeScalarRelationFilter, InterestTypeWhereInput>
  }

  export type InterestDetailOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
    interestType?: InterestTypeOrderByWithRelationInput
  }

  export type InterestDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InterestDetailWhereInput | InterestDetailWhereInput[]
    OR?: InterestDetailWhereInput[]
    NOT?: InterestDetailWhereInput | InterestDetailWhereInput[]
    date?: StringFilter<"InterestDetail"> | string
    rate?: FloatFilter<"InterestDetail"> | number
    interestTypeId?: IntFilter<"InterestDetail"> | number
    interestType?: XOR<InterestTypeScalarRelationFilter, InterestTypeWhereInput>
  }, "id">

  export type InterestDetailOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
    _count?: InterestDetailCountOrderByAggregateInput
    _avg?: InterestDetailAvgOrderByAggregateInput
    _max?: InterestDetailMaxOrderByAggregateInput
    _min?: InterestDetailMinOrderByAggregateInput
    _sum?: InterestDetailSumOrderByAggregateInput
  }

  export type InterestDetailScalarWhereWithAggregatesInput = {
    AND?: InterestDetailScalarWhereWithAggregatesInput | InterestDetailScalarWhereWithAggregatesInput[]
    OR?: InterestDetailScalarWhereWithAggregatesInput[]
    NOT?: InterestDetailScalarWhereWithAggregatesInput | InterestDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InterestDetail"> | number
    date?: StringWithAggregatesFilter<"InterestDetail"> | string
    rate?: FloatWithAggregatesFilter<"InterestDetail"> | number
    interestTypeId?: IntWithAggregatesFilter<"InterestDetail"> | number
  }

  export type BillingInvoiceWhereInput = {
    AND?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    OR?: BillingInvoiceWhereInput[]
    NOT?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    id?: StringFilter<"BillingInvoice"> | string
    tenantId?: StringFilter<"BillingInvoice"> | string
    invoiceNumber?: StringFilter<"BillingInvoice"> | string
    amount?: FloatFilter<"BillingInvoice"> | number
    currency?: StringFilter<"BillingInvoice"> | string
    issueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    dueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    description?: StringNullableFilter<"BillingInvoice"> | string | null
    status?: StringFilter<"BillingInvoice"> | string
    createdAt?: DateTimeFilter<"BillingInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoice"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    details?: BillingInvoiceDetailListRelationFilter
    payments?: BillingPaymentListRelationFilter
  }

  export type BillingInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    details?: BillingInvoiceDetailOrderByRelationAggregateInput
    payments?: BillingPaymentOrderByRelationAggregateInput
  }

  export type BillingInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    OR?: BillingInvoiceWhereInput[]
    NOT?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    tenantId?: StringFilter<"BillingInvoice"> | string
    amount?: FloatFilter<"BillingInvoice"> | number
    currency?: StringFilter<"BillingInvoice"> | string
    issueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    dueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    description?: StringNullableFilter<"BillingInvoice"> | string | null
    status?: StringFilter<"BillingInvoice"> | string
    createdAt?: DateTimeFilter<"BillingInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoice"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    details?: BillingInvoiceDetailListRelationFilter
    payments?: BillingPaymentListRelationFilter
  }, "id" | "invoiceNumber">

  export type BillingInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillingInvoiceCountOrderByAggregateInput
    _avg?: BillingInvoiceAvgOrderByAggregateInput
    _max?: BillingInvoiceMaxOrderByAggregateInput
    _min?: BillingInvoiceMinOrderByAggregateInput
    _sum?: BillingInvoiceSumOrderByAggregateInput
  }

  export type BillingInvoiceScalarWhereWithAggregatesInput = {
    AND?: BillingInvoiceScalarWhereWithAggregatesInput | BillingInvoiceScalarWhereWithAggregatesInput[]
    OR?: BillingInvoiceScalarWhereWithAggregatesInput[]
    NOT?: BillingInvoiceScalarWhereWithAggregatesInput | BillingInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingInvoice"> | string
    tenantId?: StringWithAggregatesFilter<"BillingInvoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"BillingInvoice"> | string
    amount?: FloatWithAggregatesFilter<"BillingInvoice"> | number
    currency?: StringWithAggregatesFilter<"BillingInvoice"> | string
    issueDate?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
    description?: StringNullableWithAggregatesFilter<"BillingInvoice"> | string | null
    status?: StringWithAggregatesFilter<"BillingInvoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
  }

  export type BillingInvoiceDetailWhereInput = {
    AND?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    OR?: BillingInvoiceDetailWhereInput[]
    NOT?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    id?: StringFilter<"BillingInvoiceDetail"> | string
    itemDescription?: StringFilter<"BillingInvoiceDetail"> | string
    itemQuantity?: IntFilter<"BillingInvoiceDetail"> | number
    itemUnitPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxRate?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxAmount?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalWithTax?: FloatFilter<"BillingInvoiceDetail"> | number
    createdAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingInvoiceDetail"> | string | null
    billingInvoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }

  export type BillingInvoiceDetailOrderByWithRelationInput = {
    id?: SortOrder
    itemDescription?: SortOrder
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrderInput | SortOrder
    billingInvoice?: BillingInvoiceOrderByWithRelationInput
  }

  export type BillingInvoiceDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    OR?: BillingInvoiceDetailWhereInput[]
    NOT?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    itemDescription?: StringFilter<"BillingInvoiceDetail"> | string
    itemQuantity?: IntFilter<"BillingInvoiceDetail"> | number
    itemUnitPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxRate?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxAmount?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalWithTax?: FloatFilter<"BillingInvoiceDetail"> | number
    createdAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingInvoiceDetail"> | string | null
    billingInvoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }, "id">

  export type BillingInvoiceDetailOrderByWithAggregationInput = {
    id?: SortOrder
    itemDescription?: SortOrder
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrderInput | SortOrder
    _count?: BillingInvoiceDetailCountOrderByAggregateInput
    _avg?: BillingInvoiceDetailAvgOrderByAggregateInput
    _max?: BillingInvoiceDetailMaxOrderByAggregateInput
    _min?: BillingInvoiceDetailMinOrderByAggregateInput
    _sum?: BillingInvoiceDetailSumOrderByAggregateInput
  }

  export type BillingInvoiceDetailScalarWhereWithAggregatesInput = {
    AND?: BillingInvoiceDetailScalarWhereWithAggregatesInput | BillingInvoiceDetailScalarWhereWithAggregatesInput[]
    OR?: BillingInvoiceDetailScalarWhereWithAggregatesInput[]
    NOT?: BillingInvoiceDetailScalarWhereWithAggregatesInput | BillingInvoiceDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingInvoiceDetail"> | string
    itemDescription?: StringWithAggregatesFilter<"BillingInvoiceDetail"> | string
    itemQuantity?: IntWithAggregatesFilter<"BillingInvoiceDetail"> | number
    itemUnitPrice?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    itemTotalPrice?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    itemTaxRate?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    itemTaxAmount?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    itemTotalWithTax?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BillingInvoiceDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingInvoiceDetail"> | Date | string
    billingInvoiceId?: StringNullableWithAggregatesFilter<"BillingInvoiceDetail"> | string | null
  }

  export type BillingPaymentWhereInput = {
    AND?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    OR?: BillingPaymentWhereInput[]
    NOT?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    id?: StringFilter<"BillingPayment"> | string
    paymentDate?: DateTimeFilter<"BillingPayment"> | Date | string
    amount?: FloatFilter<"BillingPayment"> | number
    paymentMethod?: StringFilter<"BillingPayment"> | string
    transactionId?: StringNullableFilter<"BillingPayment"> | string | null
    status?: StringFilter<"BillingPayment"> | string
    createdAt?: DateTimeFilter<"BillingPayment"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPayment"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingPayment"> | string | null
    BillingInvoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }

  export type BillingPaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrderInput | SortOrder
    BillingInvoice?: BillingInvoiceOrderByWithRelationInput
  }

  export type BillingPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    OR?: BillingPaymentWhereInput[]
    NOT?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    paymentDate?: DateTimeFilter<"BillingPayment"> | Date | string
    amount?: FloatFilter<"BillingPayment"> | number
    paymentMethod?: StringFilter<"BillingPayment"> | string
    transactionId?: StringNullableFilter<"BillingPayment"> | string | null
    status?: StringFilter<"BillingPayment"> | string
    createdAt?: DateTimeFilter<"BillingPayment"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPayment"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingPayment"> | string | null
    BillingInvoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }, "id">

  export type BillingPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrderInput | SortOrder
    _count?: BillingPaymentCountOrderByAggregateInput
    _avg?: BillingPaymentAvgOrderByAggregateInput
    _max?: BillingPaymentMaxOrderByAggregateInput
    _min?: BillingPaymentMinOrderByAggregateInput
    _sum?: BillingPaymentSumOrderByAggregateInput
  }

  export type BillingPaymentScalarWhereWithAggregatesInput = {
    AND?: BillingPaymentScalarWhereWithAggregatesInput | BillingPaymentScalarWhereWithAggregatesInput[]
    OR?: BillingPaymentScalarWhereWithAggregatesInput[]
    NOT?: BillingPaymentScalarWhereWithAggregatesInput | BillingPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingPayment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"BillingPayment"> | Date | string
    amount?: FloatWithAggregatesFilter<"BillingPayment"> | number
    paymentMethod?: StringWithAggregatesFilter<"BillingPayment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"BillingPayment"> | string | null
    status?: StringWithAggregatesFilter<"BillingPayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BillingPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillingPayment"> | Date | string
    billingInvoiceId?: StringNullableWithAggregatesFilter<"BillingPayment"> | string | null
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    price?: FloatFilter<"Plan"> | number
    description?: StringNullableFilter<"Plan"> | string | null
    durationDays?: IntFilter<"Plan"> | number
    isActive?: BoolFilter<"Plan"> | boolean
    tenants?: TenantListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    durationDays?: SortOrder
    isActive?: SortOrder
    tenants?: TenantOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    price?: FloatFilter<"Plan"> | number
    description?: StringNullableFilter<"Plan"> | string | null
    durationDays?: IntFilter<"Plan"> | number
    isActive?: BoolFilter<"Plan"> | boolean
    tenants?: TenantListRelationFilter
  }, "id" | "name">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    durationDays?: SortOrder
    isActive?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    price?: FloatWithAggregatesFilter<"Plan"> | number
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    durationDays?: IntWithAggregatesFilter<"Plan"> | number
    isActive?: BoolWithAggregatesFilter<"Plan"> | boolean
  }

  export type CollectionCaseWhereInput = {
    AND?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    OR?: CollectionCaseWhereInput[]
    NOT?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    id?: StringFilter<"CollectionCase"> | string
    referenceNumber?: StringNullableFilter<"CollectionCase"> | string | null
    issueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1SentAt?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1DueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2SentAt?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2DueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    tenantId?: StringFilter<"CollectionCase"> | string
    debtorId?: StringFilter<"CollectionCase"> | string
    amountOriginal?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFilter<"CollectionCase"> | $Enums.CollectionStatus
    createdAt?: DateTimeFilter<"CollectionCase"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionCase"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    paymentAgreements?: PaymentAgreementListRelationFilter
    penalties?: PenaltyListRelationFilter
    chatRooms?: ChatRoomListRelationFilter
  }

  export type CollectionCaseOrderByWithRelationInput = {
    id?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    reminder1SentAt?: SortOrderInput | SortOrder
    reminder1DueDate?: SortOrderInput | SortOrder
    reminder2SentAt?: SortOrderInput | SortOrder
    reminder2DueDate?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    debtorId?: SortOrder
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    debtor?: DebtorOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    paymentAgreements?: PaymentAgreementOrderByRelationAggregateInput
    penalties?: PenaltyOrderByRelationAggregateInput
    chatRooms?: ChatRoomOrderByRelationAggregateInput
  }

  export type CollectionCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    OR?: CollectionCaseWhereInput[]
    NOT?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    referenceNumber?: StringNullableFilter<"CollectionCase"> | string | null
    issueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1SentAt?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1DueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2SentAt?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2DueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    tenantId?: StringFilter<"CollectionCase"> | string
    debtorId?: StringFilter<"CollectionCase"> | string
    amountOriginal?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFilter<"CollectionCase"> | $Enums.CollectionStatus
    createdAt?: DateTimeFilter<"CollectionCase"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionCase"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    notifications?: NotificationListRelationFilter
    payments?: PaymentListRelationFilter
    paymentAgreements?: PaymentAgreementListRelationFilter
    penalties?: PenaltyListRelationFilter
    chatRooms?: ChatRoomListRelationFilter
  }, "id">

  export type CollectionCaseOrderByWithAggregationInput = {
    id?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    reminder1SentAt?: SortOrderInput | SortOrder
    reminder1DueDate?: SortOrderInput | SortOrder
    reminder2SentAt?: SortOrderInput | SortOrder
    reminder2DueDate?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    debtorId?: SortOrder
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CollectionCaseCountOrderByAggregateInput
    _avg?: CollectionCaseAvgOrderByAggregateInput
    _max?: CollectionCaseMaxOrderByAggregateInput
    _min?: CollectionCaseMinOrderByAggregateInput
    _sum?: CollectionCaseSumOrderByAggregateInput
  }

  export type CollectionCaseScalarWhereWithAggregatesInput = {
    AND?: CollectionCaseScalarWhereWithAggregatesInput | CollectionCaseScalarWhereWithAggregatesInput[]
    OR?: CollectionCaseScalarWhereWithAggregatesInput[]
    NOT?: CollectionCaseScalarWhereWithAggregatesInput | CollectionCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionCase"> | string
    referenceNumber?: StringNullableWithAggregatesFilter<"CollectionCase"> | string | null
    issueDate?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    reminder1SentAt?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    reminder1DueDate?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    reminder2SentAt?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    reminder2DueDate?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    tenantId?: StringWithAggregatesFilter<"CollectionCase"> | string
    debtorId?: StringWithAggregatesFilter<"CollectionCase"> | string
    amountOriginal?: DecimalWithAggregatesFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalWithAggregatesFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalWithAggregatesFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusWithAggregatesFilter<"CollectionCase"> | $Enums.CollectionStatus
    createdAt?: DateTimeWithAggregatesFilter<"CollectionCase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CollectionCase"> | Date | string
  }

  export type PenaltyWhereInput = {
    AND?: PenaltyWhereInput | PenaltyWhereInput[]
    OR?: PenaltyWhereInput[]
    NOT?: PenaltyWhereInput | PenaltyWhereInput[]
    id?: StringFilter<"Penalty"> | string
    collectionCaseId?: StringFilter<"Penalty"> | string
    description?: StringNullableFilter<"Penalty"> | string | null
    amount?: DecimalFilter<"Penalty"> | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFilter<"Penalty"> | Date | string
    isPaid?: BoolFilter<"Penalty"> | boolean
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
    updatedAt?: DateTimeFilter<"Penalty"> | Date | string
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }

  export type PenaltyOrderByWithRelationInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    dateApplied?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collectionCase?: CollectionCaseOrderByWithRelationInput
  }

  export type PenaltyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PenaltyWhereInput | PenaltyWhereInput[]
    OR?: PenaltyWhereInput[]
    NOT?: PenaltyWhereInput | PenaltyWhereInput[]
    collectionCaseId?: StringFilter<"Penalty"> | string
    description?: StringNullableFilter<"Penalty"> | string | null
    amount?: DecimalFilter<"Penalty"> | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFilter<"Penalty"> | Date | string
    isPaid?: BoolFilter<"Penalty"> | boolean
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
    updatedAt?: DateTimeFilter<"Penalty"> | Date | string
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }, "id">

  export type PenaltyOrderByWithAggregationInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    dateApplied?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PenaltyCountOrderByAggregateInput
    _avg?: PenaltyAvgOrderByAggregateInput
    _max?: PenaltyMaxOrderByAggregateInput
    _min?: PenaltyMinOrderByAggregateInput
    _sum?: PenaltySumOrderByAggregateInput
  }

  export type PenaltyScalarWhereWithAggregatesInput = {
    AND?: PenaltyScalarWhereWithAggregatesInput | PenaltyScalarWhereWithAggregatesInput[]
    OR?: PenaltyScalarWhereWithAggregatesInput[]
    NOT?: PenaltyScalarWhereWithAggregatesInput | PenaltyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Penalty"> | string
    collectionCaseId?: StringWithAggregatesFilter<"Penalty"> | string
    description?: StringNullableWithAggregatesFilter<"Penalty"> | string | null
    amount?: DecimalWithAggregatesFilter<"Penalty"> | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeWithAggregatesFilter<"Penalty"> | Date | string
    isPaid?: BoolWithAggregatesFilter<"Penalty"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Penalty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Penalty"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    collectionCaseId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    sentAt?: DateTimeFilter<"Notification"> | Date | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    collectionCase?: CollectionCaseOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    collectionCaseId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    sentAt?: DateTimeFilter<"Notification"> | Date | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    collectionCaseId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    sentAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    collectionCaseId?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    paymentAgreementId?: StringNullableFilter<"Payment"> | string | null
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    PaymentAgreement?: XOR<PaymentAgreementNullableScalarRelationFilter, PaymentAgreementWhereInput> | null
    Installment?: InstallmentListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    collectionCaseId?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    paymentAgreementId?: SortOrderInput | SortOrder
    collectionCase?: CollectionCaseOrderByWithRelationInput
    PaymentAgreement?: PaymentAgreementOrderByWithRelationInput
    Installment?: InstallmentOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    collectionCaseId?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    paymentAgreementId?: StringNullableFilter<"Payment"> | string | null
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    PaymentAgreement?: XOR<PaymentAgreementNullableScalarRelationFilter, PaymentAgreementWhereInput> | null
    Installment?: InstallmentListRelationFilter
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    collectionCaseId?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    paymentAgreementId?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    collectionCaseId?: StringWithAggregatesFilter<"Payment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    paymentAgreementId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type DebtorWhereInput = {
    AND?: DebtorWhereInput | DebtorWhereInput[]
    OR?: DebtorWhereInput[]
    NOT?: DebtorWhereInput | DebtorWhereInput[]
    id?: StringFilter<"Debtor"> | string
    tenantId?: StringFilter<"Debtor"> | string
    userId?: StringNullableFilter<"Debtor"> | string | null
    fullname?: StringFilter<"Debtor"> | string
    email?: StringFilter<"Debtor"> | string
    phone?: StringNullableFilter<"Debtor"> | string | null
    address?: StringNullableFilter<"Debtor"> | string | null
    personType?: EnumPersonTypeFilter<"Debtor"> | $Enums.PersonType
    identificationType?: EnumIdentificationTypeNullableFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableFilter<"Debtor"> | string | null
    totalIncome?: FloatNullableFilter<"Debtor"> | number | null
    createdAt?: DateTimeFilter<"Debtor"> | Date | string
    updatedAt?: DateTimeFilter<"Debtor"> | Date | string
    collectionCases?: CollectionCaseListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    incomes?: DebtorIncomeListRelationFilter
    paymentAgreements?: PaymentAgreementListRelationFilter
    verdicts?: VerdictListRelationFilter
  }

  export type DebtorOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    personType?: SortOrder
    identificationType?: SortOrderInput | SortOrder
    identification?: SortOrderInput | SortOrder
    totalIncome?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collectionCases?: CollectionCaseOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    incomes?: DebtorIncomeOrderByRelationAggregateInput
    paymentAgreements?: PaymentAgreementOrderByRelationAggregateInput
    verdicts?: VerdictOrderByRelationAggregateInput
  }

  export type DebtorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_email?: DebtorTenantIdEmailCompoundUniqueInput
    tenantId_identification?: DebtorTenantIdIdentificationCompoundUniqueInput
    AND?: DebtorWhereInput | DebtorWhereInput[]
    OR?: DebtorWhereInput[]
    NOT?: DebtorWhereInput | DebtorWhereInput[]
    tenantId?: StringFilter<"Debtor"> | string
    userId?: StringNullableFilter<"Debtor"> | string | null
    fullname?: StringFilter<"Debtor"> | string
    email?: StringFilter<"Debtor"> | string
    phone?: StringNullableFilter<"Debtor"> | string | null
    address?: StringNullableFilter<"Debtor"> | string | null
    personType?: EnumPersonTypeFilter<"Debtor"> | $Enums.PersonType
    identificationType?: EnumIdentificationTypeNullableFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableFilter<"Debtor"> | string | null
    totalIncome?: FloatNullableFilter<"Debtor"> | number | null
    createdAt?: DateTimeFilter<"Debtor"> | Date | string
    updatedAt?: DateTimeFilter<"Debtor"> | Date | string
    collectionCases?: CollectionCaseListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    incomes?: DebtorIncomeListRelationFilter
    paymentAgreements?: PaymentAgreementListRelationFilter
    verdicts?: VerdictListRelationFilter
  }, "id" | "tenantId_email" | "tenantId_identification">

  export type DebtorOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    personType?: SortOrder
    identificationType?: SortOrderInput | SortOrder
    identification?: SortOrderInput | SortOrder
    totalIncome?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DebtorCountOrderByAggregateInput
    _avg?: DebtorAvgOrderByAggregateInput
    _max?: DebtorMaxOrderByAggregateInput
    _min?: DebtorMinOrderByAggregateInput
    _sum?: DebtorSumOrderByAggregateInput
  }

  export type DebtorScalarWhereWithAggregatesInput = {
    AND?: DebtorScalarWhereWithAggregatesInput | DebtorScalarWhereWithAggregatesInput[]
    OR?: DebtorScalarWhereWithAggregatesInput[]
    NOT?: DebtorScalarWhereWithAggregatesInput | DebtorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Debtor"> | string
    tenantId?: StringWithAggregatesFilter<"Debtor"> | string
    userId?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    fullname?: StringWithAggregatesFilter<"Debtor"> | string
    email?: StringWithAggregatesFilter<"Debtor"> | string
    phone?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    address?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    personType?: EnumPersonTypeWithAggregatesFilter<"Debtor"> | $Enums.PersonType
    identificationType?: EnumIdentificationTypeNullableWithAggregatesFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    totalIncome?: FloatNullableWithAggregatesFilter<"Debtor"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Debtor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Debtor"> | Date | string
  }

  export type ChatRoomWhereInput = {
    AND?: ChatRoomWhereInput | ChatRoomWhereInput[]
    OR?: ChatRoomWhereInput[]
    NOT?: ChatRoomWhereInput | ChatRoomWhereInput[]
    id?: StringFilter<"ChatRoom"> | string
    tenantId?: StringFilter<"ChatRoom"> | string
    collectionCaseId?: StringFilter<"ChatRoom"> | string
    name?: StringFilter<"ChatRoom"> | string
    createdAt?: DateTimeFilter<"ChatRoom"> | Date | string
    updatedAt?: DateTimeFilter<"ChatRoom"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    messages?: ChatMessageListRelationFilter
  }

  export type ChatRoomOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    collectionCaseId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    collectionCase?: CollectionCaseOrderByWithRelationInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type ChatRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatRoomWhereInput | ChatRoomWhereInput[]
    OR?: ChatRoomWhereInput[]
    NOT?: ChatRoomWhereInput | ChatRoomWhereInput[]
    tenantId?: StringFilter<"ChatRoom"> | string
    collectionCaseId?: StringFilter<"ChatRoom"> | string
    name?: StringFilter<"ChatRoom"> | string
    createdAt?: DateTimeFilter<"ChatRoom"> | Date | string
    updatedAt?: DateTimeFilter<"ChatRoom"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    messages?: ChatMessageListRelationFilter
  }, "id">

  export type ChatRoomOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    collectionCaseId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatRoomCountOrderByAggregateInput
    _max?: ChatRoomMaxOrderByAggregateInput
    _min?: ChatRoomMinOrderByAggregateInput
  }

  export type ChatRoomScalarWhereWithAggregatesInput = {
    AND?: ChatRoomScalarWhereWithAggregatesInput | ChatRoomScalarWhereWithAggregatesInput[]
    OR?: ChatRoomScalarWhereWithAggregatesInput[]
    NOT?: ChatRoomScalarWhereWithAggregatesInput | ChatRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatRoom"> | string
    tenantId?: StringWithAggregatesFilter<"ChatRoom"> | string
    collectionCaseId?: StringWithAggregatesFilter<"ChatRoom"> | string
    name?: StringWithAggregatesFilter<"ChatRoom"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatRoom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatRoom"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    roomId?: StringFilter<"ChatMessage"> | string
    senderId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    fileUrl?: StringNullableFilter<"ChatMessage"> | string | null
    fileName?: StringNullableFilter<"ChatMessage"> | string | null
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMessage"> | Date | string
    room?: XOR<ChatRoomScalarRelationFilter, ChatRoomWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    room?: ChatRoomOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    roomId?: StringFilter<"ChatMessage"> | string
    senderId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    fileUrl?: StringNullableFilter<"ChatMessage"> | string | null
    fileName?: StringNullableFilter<"ChatMessage"> | string | null
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMessage"> | Date | string
    room?: XOR<ChatRoomScalarRelationFilter, ChatRoomWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    roomId?: StringWithAggregatesFilter<"ChatMessage"> | string
    senderId?: StringWithAggregatesFilter<"ChatMessage"> | string
    message?: StringWithAggregatesFilter<"ChatMessage"> | string
    fileUrl?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    fileName?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type DebtorIncomeWhereInput = {
    AND?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    OR?: DebtorIncomeWhereInput[]
    NOT?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    id?: StringFilter<"DebtorIncome"> | string
    debtorId?: StringFilter<"DebtorIncome"> | string
    amount?: FloatFilter<"DebtorIncome"> | number
    source?: StringFilter<"DebtorIncome"> | string
    createdAt?: DateTimeFilter<"DebtorIncome"> | Date | string
    updatedAt?: DateTimeFilter<"DebtorIncome"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
  }

  export type DebtorIncomeOrderByWithRelationInput = {
    id?: SortOrder
    debtorId?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    debtor?: DebtorOrderByWithRelationInput
  }

  export type DebtorIncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    OR?: DebtorIncomeWhereInput[]
    NOT?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    debtorId?: StringFilter<"DebtorIncome"> | string
    amount?: FloatFilter<"DebtorIncome"> | number
    source?: StringFilter<"DebtorIncome"> | string
    createdAt?: DateTimeFilter<"DebtorIncome"> | Date | string
    updatedAt?: DateTimeFilter<"DebtorIncome"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
  }, "id">

  export type DebtorIncomeOrderByWithAggregationInput = {
    id?: SortOrder
    debtorId?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DebtorIncomeCountOrderByAggregateInput
    _avg?: DebtorIncomeAvgOrderByAggregateInput
    _max?: DebtorIncomeMaxOrderByAggregateInput
    _min?: DebtorIncomeMinOrderByAggregateInput
    _sum?: DebtorIncomeSumOrderByAggregateInput
  }

  export type DebtorIncomeScalarWhereWithAggregatesInput = {
    AND?: DebtorIncomeScalarWhereWithAggregatesInput | DebtorIncomeScalarWhereWithAggregatesInput[]
    OR?: DebtorIncomeScalarWhereWithAggregatesInput[]
    NOT?: DebtorIncomeScalarWhereWithAggregatesInput | DebtorIncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DebtorIncome"> | string
    debtorId?: StringWithAggregatesFilter<"DebtorIncome"> | string
    amount?: FloatWithAggregatesFilter<"DebtorIncome"> | number
    source?: StringWithAggregatesFilter<"DebtorIncome"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DebtorIncome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DebtorIncome"> | Date | string
  }

  export type PaymentAgreementWhereInput = {
    AND?: PaymentAgreementWhereInput | PaymentAgreementWhereInput[]
    OR?: PaymentAgreementWhereInput[]
    NOT?: PaymentAgreementWhereInput | PaymentAgreementWhereInput[]
    id?: StringFilter<"PaymentAgreement"> | string
    collectionCaseId?: StringFilter<"PaymentAgreement"> | string
    totalAmount?: DecimalFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFilter<"PaymentAgreement"> | number
    startDate?: DateTimeFilter<"PaymentAgreement"> | Date | string
    status?: EnumPaymentAgreementStatusFilter<"PaymentAgreement"> | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    debtorId?: StringNullableFilter<"PaymentAgreement"> | string | null
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    installments?: InstallmentListRelationFilter
    payments?: PaymentListRelationFilter
    Debtor?: XOR<DebtorNullableScalarRelationFilter, DebtorWhereInput> | null
  }

  export type PaymentAgreementOrderByWithRelationInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    totalAmount?: SortOrder
    installmentAmount?: SortOrder
    installmentsCount?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    debtorId?: SortOrderInput | SortOrder
    collectionCase?: CollectionCaseOrderByWithRelationInput
    installments?: InstallmentOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    Debtor?: DebtorOrderByWithRelationInput
  }

  export type PaymentAgreementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    collectionCaseId?: string
    AND?: PaymentAgreementWhereInput | PaymentAgreementWhereInput[]
    OR?: PaymentAgreementWhereInput[]
    NOT?: PaymentAgreementWhereInput | PaymentAgreementWhereInput[]
    totalAmount?: DecimalFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFilter<"PaymentAgreement"> | number
    startDate?: DateTimeFilter<"PaymentAgreement"> | Date | string
    status?: EnumPaymentAgreementStatusFilter<"PaymentAgreement"> | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    debtorId?: StringNullableFilter<"PaymentAgreement"> | string | null
    collectionCase?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    installments?: InstallmentListRelationFilter
    payments?: PaymentListRelationFilter
    Debtor?: XOR<DebtorNullableScalarRelationFilter, DebtorWhereInput> | null
  }, "id" | "collectionCaseId">

  export type PaymentAgreementOrderByWithAggregationInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    totalAmount?: SortOrder
    installmentAmount?: SortOrder
    installmentsCount?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    debtorId?: SortOrderInput | SortOrder
    _count?: PaymentAgreementCountOrderByAggregateInput
    _avg?: PaymentAgreementAvgOrderByAggregateInput
    _max?: PaymentAgreementMaxOrderByAggregateInput
    _min?: PaymentAgreementMinOrderByAggregateInput
    _sum?: PaymentAgreementSumOrderByAggregateInput
  }

  export type PaymentAgreementScalarWhereWithAggregatesInput = {
    AND?: PaymentAgreementScalarWhereWithAggregatesInput | PaymentAgreementScalarWhereWithAggregatesInput[]
    OR?: PaymentAgreementScalarWhereWithAggregatesInput[]
    NOT?: PaymentAgreementScalarWhereWithAggregatesInput | PaymentAgreementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentAgreement"> | string
    collectionCaseId?: StringWithAggregatesFilter<"PaymentAgreement"> | string
    totalAmount?: DecimalWithAggregatesFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalWithAggregatesFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntWithAggregatesFilter<"PaymentAgreement"> | number
    startDate?: DateTimeWithAggregatesFilter<"PaymentAgreement"> | Date | string
    status?: EnumPaymentAgreementStatusWithAggregatesFilter<"PaymentAgreement"> | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeWithAggregatesFilter<"PaymentAgreement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentAgreement"> | Date | string
    debtorId?: StringNullableWithAggregatesFilter<"PaymentAgreement"> | string | null
  }

  export type InstallmentWhereInput = {
    AND?: InstallmentWhereInput | InstallmentWhereInput[]
    OR?: InstallmentWhereInput[]
    NOT?: InstallmentWhereInput | InstallmentWhereInput[]
    id?: StringFilter<"Installment"> | string
    paymentAgreementId?: StringFilter<"Installment"> | string
    number?: IntFilter<"Installment"> | number
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    amount?: DecimalFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFilter<"Installment"> | $Enums.InstallmentStatus
    paymentId?: StringNullableFilter<"Installment"> | string | null
    createdAt?: DateTimeFilter<"Installment"> | Date | string
    updatedAt?: DateTimeFilter<"Installment"> | Date | string
    paymentAgreement?: XOR<PaymentAgreementScalarRelationFilter, PaymentAgreementWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }

  export type InstallmentOrderByWithRelationInput = {
    id?: SortOrder
    paymentAgreementId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentAgreement?: PaymentAgreementOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
  }

  export type InstallmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstallmentWhereInput | InstallmentWhereInput[]
    OR?: InstallmentWhereInput[]
    NOT?: InstallmentWhereInput | InstallmentWhereInput[]
    paymentAgreementId?: StringFilter<"Installment"> | string
    number?: IntFilter<"Installment"> | number
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    amount?: DecimalFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFilter<"Installment"> | $Enums.InstallmentStatus
    paymentId?: StringNullableFilter<"Installment"> | string | null
    createdAt?: DateTimeFilter<"Installment"> | Date | string
    updatedAt?: DateTimeFilter<"Installment"> | Date | string
    paymentAgreement?: XOR<PaymentAgreementScalarRelationFilter, PaymentAgreementWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }, "id">

  export type InstallmentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentAgreementId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstallmentCountOrderByAggregateInput
    _avg?: InstallmentAvgOrderByAggregateInput
    _max?: InstallmentMaxOrderByAggregateInput
    _min?: InstallmentMinOrderByAggregateInput
    _sum?: InstallmentSumOrderByAggregateInput
  }

  export type InstallmentScalarWhereWithAggregatesInput = {
    AND?: InstallmentScalarWhereWithAggregatesInput | InstallmentScalarWhereWithAggregatesInput[]
    OR?: InstallmentScalarWhereWithAggregatesInput[]
    NOT?: InstallmentScalarWhereWithAggregatesInput | InstallmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Installment"> | string
    paymentAgreementId?: StringWithAggregatesFilter<"Installment"> | string
    number?: IntWithAggregatesFilter<"Installment"> | number
    dueDate?: DateTimeWithAggregatesFilter<"Installment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusWithAggregatesFilter<"Installment"> | $Enums.InstallmentStatus
    paymentId?: StringNullableWithAggregatesFilter<"Installment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Installment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Installment"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutTenantsInput
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planId?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutTenantsNestedInput
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planId?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantRegistryCreateInput = {
    id?: string
    kvk?: string | null
    crib?: string | null
    taxId?: string | null
    vatNumber?: string | null
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutRegistryInput
  }

  export type TenantRegistryUncheckedCreateInput = {
    id?: string
    tenantId: string
    kvk?: string | null
    crib?: string | null
    taxId?: string | null
    vatNumber?: string | null
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantRegistryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutRegistryNestedInput
  }

  export type TenantRegistryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantRegistryCreateManyInput = {
    id?: string
    tenantId: string
    kvk?: string | null
    crib?: string | null
    taxId?: string | null
    vatNumber?: string | null
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantRegistryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantRegistryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    debtors?: DebtorCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    tenantId: string
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    tenantId: string
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParameterCreateInput = {
    id?: string
    porcCobranza?: number
    porcAbb?: number
    diasPlazoEmpresaAanmaning?: number
    diasPlazoConsumidorAanmaning?: number
    diasPlazoEmpresaSommatie?: number
    diasPlazoConsumidorSommatie?: number
    precioEmpresaPequena?: number
    contribucionEmpresaPequenaPfc?: number
    precioEmpresaGrande?: number
    contribucionEmpresaGrandePfc?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    multaAanmaningEmpresa?: number
    multaAanmaningNatural?: number
    multaSommatieEmpresa?: number
    multaSommatieNatural?: number
    limiteDiasReaccionEmpresa?: number
    multaNoReaccionEmpresa?: number
    multaNoReaccionNatural?: number
    multaAcuerdoPagoEmpresa?: number
    multaAcuerdoPagoNatural?: number
    invoiceNumberLength?: number
    invoicePrefix?: string
    invoiceSecuence?: number
    bankAccount?: string
    bankName?: string
  }

  export type ParameterUncheckedCreateInput = {
    id?: string
    porcCobranza?: number
    porcAbb?: number
    diasPlazoEmpresaAanmaning?: number
    diasPlazoConsumidorAanmaning?: number
    diasPlazoEmpresaSommatie?: number
    diasPlazoConsumidorSommatie?: number
    precioEmpresaPequena?: number
    contribucionEmpresaPequenaPfc?: number
    precioEmpresaGrande?: number
    contribucionEmpresaGrandePfc?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    multaAanmaningEmpresa?: number
    multaAanmaningNatural?: number
    multaSommatieEmpresa?: number
    multaSommatieNatural?: number
    limiteDiasReaccionEmpresa?: number
    multaNoReaccionEmpresa?: number
    multaNoReaccionNatural?: number
    multaAcuerdoPagoEmpresa?: number
    multaAcuerdoPagoNatural?: number
    invoiceNumberLength?: number
    invoicePrefix?: string
    invoiceSecuence?: number
    bankAccount?: string
    bankName?: string
  }

  export type ParameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    porcCobranza?: FloatFieldUpdateOperationsInput | number
    porcAbb?: FloatFieldUpdateOperationsInput | number
    diasPlazoEmpresaAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoEmpresaSommatie?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorSommatie?: IntFieldUpdateOperationsInput | number
    precioEmpresaPequena?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaPequenaPfc?: FloatFieldUpdateOperationsInput | number
    precioEmpresaGrande?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaGrandePfc?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multaAanmaningEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAanmaningNatural?: FloatFieldUpdateOperationsInput | number
    multaSommatieEmpresa?: FloatFieldUpdateOperationsInput | number
    multaSommatieNatural?: FloatFieldUpdateOperationsInput | number
    limiteDiasReaccionEmpresa?: IntFieldUpdateOperationsInput | number
    multaNoReaccionEmpresa?: FloatFieldUpdateOperationsInput | number
    multaNoReaccionNatural?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoNatural?: FloatFieldUpdateOperationsInput | number
    invoiceNumberLength?: IntFieldUpdateOperationsInput | number
    invoicePrefix?: StringFieldUpdateOperationsInput | string
    invoiceSecuence?: IntFieldUpdateOperationsInput | number
    bankAccount?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type ParameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    porcCobranza?: FloatFieldUpdateOperationsInput | number
    porcAbb?: FloatFieldUpdateOperationsInput | number
    diasPlazoEmpresaAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoEmpresaSommatie?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorSommatie?: IntFieldUpdateOperationsInput | number
    precioEmpresaPequena?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaPequenaPfc?: FloatFieldUpdateOperationsInput | number
    precioEmpresaGrande?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaGrandePfc?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multaAanmaningEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAanmaningNatural?: FloatFieldUpdateOperationsInput | number
    multaSommatieEmpresa?: FloatFieldUpdateOperationsInput | number
    multaSommatieNatural?: FloatFieldUpdateOperationsInput | number
    limiteDiasReaccionEmpresa?: IntFieldUpdateOperationsInput | number
    multaNoReaccionEmpresa?: FloatFieldUpdateOperationsInput | number
    multaNoReaccionNatural?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoNatural?: FloatFieldUpdateOperationsInput | number
    invoiceNumberLength?: IntFieldUpdateOperationsInput | number
    invoicePrefix?: StringFieldUpdateOperationsInput | string
    invoiceSecuence?: IntFieldUpdateOperationsInput | number
    bankAccount?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type ParameterCreateManyInput = {
    id?: string
    porcCobranza?: number
    porcAbb?: number
    diasPlazoEmpresaAanmaning?: number
    diasPlazoConsumidorAanmaning?: number
    diasPlazoEmpresaSommatie?: number
    diasPlazoConsumidorSommatie?: number
    precioEmpresaPequena?: number
    contribucionEmpresaPequenaPfc?: number
    precioEmpresaGrande?: number
    contribucionEmpresaGrandePfc?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    multaAanmaningEmpresa?: number
    multaAanmaningNatural?: number
    multaSommatieEmpresa?: number
    multaSommatieNatural?: number
    limiteDiasReaccionEmpresa?: number
    multaNoReaccionEmpresa?: number
    multaNoReaccionNatural?: number
    multaAcuerdoPagoEmpresa?: number
    multaAcuerdoPagoNatural?: number
    invoiceNumberLength?: number
    invoicePrefix?: string
    invoiceSecuence?: number
    bankAccount?: string
    bankName?: string
  }

  export type ParameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    porcCobranza?: FloatFieldUpdateOperationsInput | number
    porcAbb?: FloatFieldUpdateOperationsInput | number
    diasPlazoEmpresaAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoEmpresaSommatie?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorSommatie?: IntFieldUpdateOperationsInput | number
    precioEmpresaPequena?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaPequenaPfc?: FloatFieldUpdateOperationsInput | number
    precioEmpresaGrande?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaGrandePfc?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multaAanmaningEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAanmaningNatural?: FloatFieldUpdateOperationsInput | number
    multaSommatieEmpresa?: FloatFieldUpdateOperationsInput | number
    multaSommatieNatural?: FloatFieldUpdateOperationsInput | number
    limiteDiasReaccionEmpresa?: IntFieldUpdateOperationsInput | number
    multaNoReaccionEmpresa?: FloatFieldUpdateOperationsInput | number
    multaNoReaccionNatural?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoNatural?: FloatFieldUpdateOperationsInput | number
    invoiceNumberLength?: IntFieldUpdateOperationsInput | number
    invoicePrefix?: StringFieldUpdateOperationsInput | string
    invoiceSecuence?: IntFieldUpdateOperationsInput | number
    bankAccount?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type ParameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    porcCobranza?: FloatFieldUpdateOperationsInput | number
    porcAbb?: FloatFieldUpdateOperationsInput | number
    diasPlazoEmpresaAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorAanmaning?: IntFieldUpdateOperationsInput | number
    diasPlazoEmpresaSommatie?: IntFieldUpdateOperationsInput | number
    diasPlazoConsumidorSommatie?: IntFieldUpdateOperationsInput | number
    precioEmpresaPequena?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaPequenaPfc?: FloatFieldUpdateOperationsInput | number
    precioEmpresaGrande?: FloatFieldUpdateOperationsInput | number
    contribucionEmpresaGrandePfc?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    multaAanmaningEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAanmaningNatural?: FloatFieldUpdateOperationsInput | number
    multaSommatieEmpresa?: FloatFieldUpdateOperationsInput | number
    multaSommatieNatural?: FloatFieldUpdateOperationsInput | number
    limiteDiasReaccionEmpresa?: IntFieldUpdateOperationsInput | number
    multaNoReaccionEmpresa?: FloatFieldUpdateOperationsInput | number
    multaNoReaccionNatural?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoEmpresa?: FloatFieldUpdateOperationsInput | number
    multaAcuerdoPagoNatural?: FloatFieldUpdateOperationsInput | number
    invoiceNumberLength?: IntFieldUpdateOperationsInput | number
    invoicePrefix?: StringFieldUpdateOperationsInput | string
    invoiceSecuence?: IntFieldUpdateOperationsInput | number
    bankAccount?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictCreateInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictCreateManyInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
  }

  export type VerdictUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictInterestCreateInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdict?: VerdictCreateNestedOneWithoutVerdictInterestInput
    details?: VerdictInterestDetailsCreateNestedManyWithoutVerdictInterestInput
  }

  export type VerdictInterestUncheckedCreateInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdictId?: string | null
    details?: VerdictInterestDetailsUncheckedCreateNestedManyWithoutVerdictInterestInput
  }

  export type VerdictInterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneWithoutVerdictInterestNestedInput
    details?: VerdictInterestDetailsUpdateManyWithoutVerdictInterestNestedInput
  }

  export type VerdictInterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdictId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: VerdictInterestDetailsUncheckedUpdateManyWithoutVerdictInterestNestedInput
  }

  export type VerdictInterestCreateManyInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdictId?: string | null
  }

  export type VerdictInterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdictId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictInterestDetailsCreateInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdictInterest: VerdictInterestCreateNestedOneWithoutDetailsInput
  }

  export type VerdictInterestDetailsUncheckedCreateInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    verdictInterestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdictInterest?: VerdictInterestUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type VerdictInterestDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    verdictInterestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsCreateManyInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    verdictInterestId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    verdictInterestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoCreateInput = {
    id?: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdict: VerdictCreateNestedOneWithoutVerdictEmbargoInput
  }

  export type VerdictEmbargoUncheckedCreateInput = {
    id?: string
    verdictId: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictEmbargoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneRequiredWithoutVerdictEmbargoNestedInput
  }

  export type VerdictEmbargoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoCreateManyInput = {
    id?: string
    verdictId: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictEmbargoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesCreateInput = {
    id?: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdict: VerdictCreateNestedOneWithoutBailiffServicesInput
  }

  export type VerdictBailiffServicesUncheckedCreateInput = {
    id?: string
    verdictId: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictBailiffServicesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneRequiredWithoutBailiffServicesNestedInput
  }

  export type VerdictBailiffServicesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesCreateManyInput = {
    id?: string
    verdictId: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictBailiffServicesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictAttachmentCreateInput = {
    id?: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
    verdict: VerdictCreateNestedOneWithoutAttachmentsInput
  }

  export type VerdictAttachmentUncheckedCreateInput = {
    id?: string
    verdictId: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
  }

  export type VerdictAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
    verdict?: VerdictUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type VerdictAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentCreateManyInput = {
    id?: string
    verdictId: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
  }

  export type VerdictAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdictId?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type InterestTypeCreateInput = {
    name: string
    calculationType: $Enums.CalculationTypeEnum
    details?: InterestDetailCreateNestedManyWithoutInterestTypeInput
  }

  export type InterestTypeUncheckedCreateInput = {
    id?: number
    name: string
    calculationType: $Enums.CalculationTypeEnum
    details?: InterestDetailUncheckedCreateNestedManyWithoutInterestTypeInput
  }

  export type InterestTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
    details?: InterestDetailUpdateManyWithoutInterestTypeNestedInput
  }

  export type InterestTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
    details?: InterestDetailUncheckedUpdateManyWithoutInterestTypeNestedInput
  }

  export type InterestTypeCreateManyInput = {
    id?: number
    name: string
    calculationType: $Enums.CalculationTypeEnum
  }

  export type InterestTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type InterestTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type InterestDetailCreateInput = {
    date: string
    rate: number
    interestType: InterestTypeCreateNestedOneWithoutDetailsInput
  }

  export type InterestDetailUncheckedCreateInput = {
    id?: number
    date: string
    rate: number
    interestTypeId: number
  }

  export type InterestDetailUpdateInput = {
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    interestType?: InterestTypeUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type InterestDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    interestTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type InterestDetailCreateManyInput = {
    id?: number
    date: string
    rate: number
    interestTypeId: number
  }

  export type InterestDetailUpdateManyMutationInput = {
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type InterestDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    interestTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type BillingInvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBillingInvoiceInput
    details?: BillingInvoiceDetailCreateNestedManyWithoutBillingInvoiceInput
    payments?: BillingPaymentCreateNestedManyWithoutBillingInvoiceInput
  }

  export type BillingInvoiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BillingInvoiceDetailUncheckedCreateNestedManyWithoutBillingInvoiceInput
    payments?: BillingPaymentUncheckedCreateNestedManyWithoutBillingInvoiceInput
  }

  export type BillingInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBillingInvoiceNestedInput
    details?: BillingInvoiceDetailUpdateManyWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUpdateManyWithoutBillingInvoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceNestedInput
  }

  export type BillingInvoiceCreateManyInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailCreateInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoice?: BillingInvoiceCreateNestedOneWithoutDetailsInput
  }

  export type BillingInvoiceDetailUncheckedCreateInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoiceId?: string | null
  }

  export type BillingInvoiceDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoice?: BillingInvoiceUpdateOneWithoutDetailsNestedInput
  }

  export type BillingInvoiceDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingInvoiceDetailCreateManyInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoiceId?: string | null
  }

  export type BillingInvoiceDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingPaymentCreateInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    BillingInvoice?: BillingInvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type BillingPaymentUncheckedCreateInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoiceId?: string | null
  }

  export type BillingPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BillingInvoice?: BillingInvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type BillingPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingPaymentCreateManyInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoiceId?: string | null
  }

  export type BillingPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    price: number
    description?: string | null
    durationDays: number
    isActive?: boolean
    tenants?: TenantCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    description?: string | null
    durationDays: number
    isActive?: boolean
    tenants?: TenantUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenants?: TenantUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenants?: TenantUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    price: number
    description?: string | null
    durationDays: number
    isActive?: boolean
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CollectionCaseCreateInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseCreateManyInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyCreateInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutPenaltiesInput
  }

  export type PenaltyUncheckedCreateInput = {
    id?: string
    collectionCaseId: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PenaltyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutPenaltiesNestedInput
  }

  export type PenaltyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyCreateManyInput = {
    id?: string
    collectionCaseId: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PenaltyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    collectionCaseId: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    collectionCaseId: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutPaymentsInput
    PaymentAgreement?: PaymentAgreementCreateNestedOneWithoutPaymentsInput
    Installment?: InstallmentCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    collectionCaseId: string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
    paymentAgreementId?: string | null
    Installment?: InstallmentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutPaymentsNestedInput
    PaymentAgreement?: PaymentAgreementUpdateOneWithoutPaymentsNestedInput
    Installment?: InstallmentUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAgreementId?: NullableStringFieldUpdateOperationsInput | string | null
    Installment?: InstallmentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    collectionCaseId: string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
    paymentAgreementId?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAgreementId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DebtorCreateInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorCreateManyInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatRoomCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutChatRoomsInput
    collectionCase: CollectionCaseCreateNestedOneWithoutChatRoomsInput
    messages?: ChatMessageCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomUncheckedCreateInput = {
    id?: string
    tenantId: string
    collectionCaseId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutChatRoomsNestedInput
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutChatRoomsNestedInput
    messages?: ChatMessageUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomCreateManyInput = {
    id?: string
    tenantId: string
    collectionCaseId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    message: string
    fileUrl?: string | null
    fileName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    room: ChatRoomCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    roomId: string
    senderId: string
    message: string
    fileUrl?: string | null
    fileName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: ChatRoomUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    roomId: string
    senderId: string
    message: string
    fileUrl?: string | null
    fileName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeCreateInput = {
    id?: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutIncomesInput
  }

  export type DebtorIncomeUncheckedCreateInput = {
    id?: string
    debtorId: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorIncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutIncomesNestedInput
  }

  export type DebtorIncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeCreateManyInput = {
    id?: string
    debtorId: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorIncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAgreementCreateInput = {
    id?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutPaymentAgreementsInput
    installments?: InstallmentCreateNestedManyWithoutPaymentAgreementInput
    payments?: PaymentCreateNestedManyWithoutPaymentAgreementInput
    Debtor?: DebtorCreateNestedOneWithoutPaymentAgreementsInput
  }

  export type PaymentAgreementUncheckedCreateInput = {
    id?: string
    collectionCaseId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtorId?: string | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutPaymentAgreementInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPaymentAgreementInput
  }

  export type PaymentAgreementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutPaymentAgreementsNestedInput
    installments?: InstallmentUpdateManyWithoutPaymentAgreementNestedInput
    payments?: PaymentUpdateManyWithoutPaymentAgreementNestedInput
    Debtor?: DebtorUpdateOneWithoutPaymentAgreementsNestedInput
  }

  export type PaymentAgreementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    installments?: InstallmentUncheckedUpdateManyWithoutPaymentAgreementNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPaymentAgreementNestedInput
  }

  export type PaymentAgreementCreateManyInput = {
    id?: string
    collectionCaseId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtorId?: string | null
  }

  export type PaymentAgreementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAgreementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstallmentCreateInput = {
    id?: string
    number: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAgreement: PaymentAgreementCreateNestedOneWithoutInstallmentsInput
    payment?: PaymentCreateNestedOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedCreateInput = {
    id?: string
    paymentAgreementId: string
    number: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAgreement?: PaymentAgreementUpdateOneRequiredWithoutInstallmentsNestedInput
    payment?: PaymentUpdateOneWithoutInstallmentNestedInput
  }

  export type InstallmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentAgreementId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallmentCreateManyInput = {
    id?: string
    paymentAgreementId: string
    number: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentAgreementId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PlanNullableScalarRelationFilter = {
    is?: PlanWhereInput | null
    isNot?: PlanWhereInput | null
  }

  export type BillingInvoiceListRelationFilter = {
    every?: BillingInvoiceWhereInput
    some?: BillingInvoiceWhereInput
    none?: BillingInvoiceWhereInput
  }

  export type CollectionCaseListRelationFilter = {
    every?: CollectionCaseWhereInput
    some?: CollectionCaseWhereInput
    none?: CollectionCaseWhereInput
  }

  export type DebtorListRelationFilter = {
    every?: DebtorWhereInput
    some?: DebtorWhereInput
    none?: DebtorWhereInput
  }

  export type TenantRegistryNullableScalarRelationFilter = {
    is?: TenantRegistryWhereInput | null
    isNot?: TenantRegistryWhereInput | null
  }

  export type VerdictListRelationFilter = {
    every?: VerdictWhereInput
    some?: VerdictWhereInput
    none?: VerdictWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ChatRoomListRelationFilter = {
    every?: ChatRoomWhereInput
    some?: ChatRoomWhereInput
    none?: ChatRoomWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BillingInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    contactEmail?: SortOrder
    countryCode?: SortOrder
    address?: SortOrder
    city?: SortOrder
    logoUrl?: SortOrder
    numberOfEmployees?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    planId?: SortOrder
    planStatus?: SortOrder
    planExpiresAt?: SortOrder
    termsAccepted?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    numberOfEmployees?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    contactEmail?: SortOrder
    countryCode?: SortOrder
    address?: SortOrder
    city?: SortOrder
    logoUrl?: SortOrder
    numberOfEmployees?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    planId?: SortOrder
    planStatus?: SortOrder
    planExpiresAt?: SortOrder
    termsAccepted?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    contactEmail?: SortOrder
    countryCode?: SortOrder
    address?: SortOrder
    city?: SortOrder
    logoUrl?: SortOrder
    numberOfEmployees?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    planId?: SortOrder
    planStatus?: SortOrder
    planExpiresAt?: SortOrder
    termsAccepted?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    numberOfEmployees?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type TenantRegistryCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kvk?: SortOrder
    crib?: SortOrder
    taxId?: SortOrder
    vatNumber?: SortOrder
    legalName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantRegistryMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kvk?: SortOrder
    crib?: SortOrder
    taxId?: SortOrder
    vatNumber?: SortOrder
    legalName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantRegistryMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    kvk?: SortOrder
    crib?: SortOrder
    taxId?: SortOrder
    vatNumber?: SortOrder
    legalName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumroleEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumFilter<$PrismaModel> | $Enums.roleEnum
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullname?: SortOrder
    phone?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullname?: SortOrder
    phone?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullname?: SortOrder
    phone?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumroleEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumWithAggregatesFilter<$PrismaModel> | $Enums.roleEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleEnumFilter<$PrismaModel>
    _max?: NestedEnumroleEnumFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ParameterCountOrderByAggregateInput = {
    id?: SortOrder
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoicePrefix?: SortOrder
    invoiceSecuence?: SortOrder
    bankAccount?: SortOrder
    bankName?: SortOrder
  }

  export type ParameterAvgOrderByAggregateInput = {
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoiceSecuence?: SortOrder
  }

  export type ParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoicePrefix?: SortOrder
    invoiceSecuence?: SortOrder
    bankAccount?: SortOrder
    bankName?: SortOrder
  }

  export type ParameterMinOrderByAggregateInput = {
    id?: SortOrder
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoicePrefix?: SortOrder
    invoiceSecuence?: SortOrder
    bankAccount?: SortOrder
    bankName?: SortOrder
  }

  export type ParameterSumOrderByAggregateInput = {
    porcCobranza?: SortOrder
    porcAbb?: SortOrder
    diasPlazoEmpresaAanmaning?: SortOrder
    diasPlazoConsumidorAanmaning?: SortOrder
    diasPlazoEmpresaSommatie?: SortOrder
    diasPlazoConsumidorSommatie?: SortOrder
    precioEmpresaPequena?: SortOrder
    contribucionEmpresaPequenaPfc?: SortOrder
    precioEmpresaGrande?: SortOrder
    contribucionEmpresaGrandePfc?: SortOrder
    multaAanmaningEmpresa?: SortOrder
    multaAanmaningNatural?: SortOrder
    multaSommatieEmpresa?: SortOrder
    multaSommatieNatural?: SortOrder
    limiteDiasReaccionEmpresa?: SortOrder
    multaNoReaccionEmpresa?: SortOrder
    multaNoReaccionNatural?: SortOrder
    multaAcuerdoPagoEmpresa?: SortOrder
    multaAcuerdoPagoNatural?: SortOrder
    invoiceNumberLength?: SortOrder
    invoiceSecuence?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumVerdictStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusFilter<$PrismaModel> | $Enums.VerdictStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DebtorScalarRelationFilter = {
    is?: DebtorWhereInput
    isNot?: DebtorWhereInput
  }

  export type VerdictAttachmentListRelationFilter = {
    every?: VerdictAttachmentWhereInput
    some?: VerdictAttachmentWhereInput
    none?: VerdictAttachmentWhereInput
  }

  export type VerdictBailiffServicesListRelationFilter = {
    every?: VerdictBailiffServicesWhereInput
    some?: VerdictBailiffServicesWhereInput
    none?: VerdictBailiffServicesWhereInput
  }

  export type VerdictEmbargoListRelationFilter = {
    every?: VerdictEmbargoWhereInput
    some?: VerdictEmbargoWhereInput
    none?: VerdictEmbargoWhereInput
  }

  export type VerdictInterestListRelationFilter = {
    every?: VerdictInterestWhereInput
    some?: VerdictInterestWhereInput
    none?: VerdictInterestWhereInput
  }

  export type VerdictAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictBailiffServicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictEmbargoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    creditorName?: SortOrder
    debtorId?: SortOrder
    registrationNumber?: SortOrder
    sentenceAmount?: SortOrder
    sentenceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procesalCost?: SortOrder
    tenantId?: SortOrder
    notes?: SortOrder
    bailiffId?: SortOrder
  }

  export type VerdictAvgOrderByAggregateInput = {
    sentenceAmount?: SortOrder
    procesalCost?: SortOrder
  }

  export type VerdictMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    creditorName?: SortOrder
    debtorId?: SortOrder
    registrationNumber?: SortOrder
    sentenceAmount?: SortOrder
    sentenceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procesalCost?: SortOrder
    tenantId?: SortOrder
    notes?: SortOrder
    bailiffId?: SortOrder
  }

  export type VerdictMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    creditorName?: SortOrder
    debtorId?: SortOrder
    registrationNumber?: SortOrder
    sentenceAmount?: SortOrder
    sentenceDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    procesalCost?: SortOrder
    tenantId?: SortOrder
    notes?: SortOrder
    bailiffId?: SortOrder
  }

  export type VerdictSumOrderByAggregateInput = {
    sentenceAmount?: SortOrder
    procesalCost?: SortOrder
  }

  export type EnumVerdictStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerdictStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerdictStatusFilter<$PrismaModel>
    _max?: NestedEnumVerdictStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type VerdictNullableScalarRelationFilter = {
    is?: VerdictWhereInput | null
    isNot?: VerdictWhereInput | null
  }

  export type VerdictInterestDetailsListRelationFilter = {
    every?: VerdictInterestDetailsWhereInput
    some?: VerdictInterestDetailsWhereInput
    none?: VerdictInterestDetailsWhereInput
  }

  export type VerdictInterestDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictInterestCountOrderByAggregateInput = {
    id?: SortOrder
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrder
    calculationStart?: SortOrder
    calculationEnd?: SortOrder
    totalInterest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictId?: SortOrder
  }

  export type VerdictInterestAvgOrderByAggregateInput = {
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrder
    totalInterest?: SortOrder
  }

  export type VerdictInterestMaxOrderByAggregateInput = {
    id?: SortOrder
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrder
    calculationStart?: SortOrder
    calculationEnd?: SortOrder
    totalInterest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictId?: SortOrder
  }

  export type VerdictInterestMinOrderByAggregateInput = {
    id?: SortOrder
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrder
    calculationStart?: SortOrder
    calculationEnd?: SortOrder
    totalInterest?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verdictId?: SortOrder
  }

  export type VerdictInterestSumOrderByAggregateInput = {
    interestType?: SortOrder
    baseAmount?: SortOrder
    calculatedInterest?: SortOrder
    totalInterest?: SortOrder
  }

  export type VerdictInterestScalarRelationFilter = {
    is?: VerdictInterestWhereInput
    isNot?: VerdictInterestWhereInput
  }

  export type VerdictInterestDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdictInterestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictInterestDetailsAvgOrderByAggregateInput = {
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
  }

  export type VerdictInterestDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdictInterestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictInterestDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdictInterestId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictInterestDetailsSumOrderByAggregateInput = {
    days?: SortOrder
    annualRate?: SortOrder
    proportionalRate?: SortOrder
    baseAmount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
  }

  export type VerdictScalarRelationFilter = {
    is?: VerdictWhereInput
    isNot?: VerdictWhereInput
  }

  export type VerdictEmbargoCountOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    companyName?: SortOrder
    companyPhone?: SortOrder
    companyEmail?: SortOrder
    companyAddress?: SortOrder
    embargoType?: SortOrder
    embargoDate?: SortOrder
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictEmbargoAvgOrderByAggregateInput = {
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type VerdictEmbargoMaxOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    companyName?: SortOrder
    companyPhone?: SortOrder
    companyEmail?: SortOrder
    companyAddress?: SortOrder
    embargoType?: SortOrder
    embargoDate?: SortOrder
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictEmbargoMinOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    companyName?: SortOrder
    companyPhone?: SortOrder
    companyEmail?: SortOrder
    companyAddress?: SortOrder
    embargoType?: SortOrder
    embargoDate?: SortOrder
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictEmbargoSumOrderByAggregateInput = {
    embargoAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type VerdictBailiffServicesCountOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    serviceType?: SortOrder
    serviceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictBailiffServicesAvgOrderByAggregateInput = {
    serviceCost?: SortOrder
  }

  export type VerdictBailiffServicesMaxOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    serviceType?: SortOrder
    serviceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictBailiffServicesMinOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    serviceType?: SortOrder
    serviceCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerdictBailiffServicesSumOrderByAggregateInput = {
    serviceCost?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type VerdictAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
  }

  export type VerdictAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type VerdictAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
  }

  export type VerdictAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    verdictId?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fileName?: SortOrder
  }

  export type VerdictAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumCalculationTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumFilter<$PrismaModel> | $Enums.CalculationTypeEnum
  }

  export type InterestDetailListRelationFilter = {
    every?: InterestDetailWhereInput
    some?: InterestDetailWhereInput
    none?: InterestDetailWhereInput
  }

  export type InterestDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterestTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calculationType?: SortOrder
  }

  export type InterestTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InterestTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calculationType?: SortOrder
  }

  export type InterestTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calculationType?: SortOrder
  }

  export type InterestTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.CalculationTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
  }

  export type InterestTypeScalarRelationFilter = {
    is?: InterestTypeWhereInput
    isNot?: InterestTypeWhereInput
  }

  export type InterestDetailCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
  }

  export type InterestDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
  }

  export type InterestDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
  }

  export type InterestDetailMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
  }

  export type InterestDetailSumOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    interestTypeId?: SortOrder
  }

  export type BillingInvoiceDetailListRelationFilter = {
    every?: BillingInvoiceDetailWhereInput
    some?: BillingInvoiceDetailWhereInput
    none?: BillingInvoiceDetailWhereInput
  }

  export type BillingPaymentListRelationFilter = {
    every?: BillingPaymentWhereInput
    some?: BillingPaymentWhereInput
    none?: BillingPaymentWhereInput
  }

  export type BillingInvoiceDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingInvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillingInvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingInvoiceNullableScalarRelationFilter = {
    is?: BillingInvoiceWhereInput | null
    isNot?: BillingInvoiceWhereInput | null
  }

  export type BillingInvoiceDetailCountOrderByAggregateInput = {
    id?: SortOrder
    itemDescription?: SortOrder
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingInvoiceDetailAvgOrderByAggregateInput = {
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
  }

  export type BillingInvoiceDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    itemDescription?: SortOrder
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingInvoiceDetailMinOrderByAggregateInput = {
    id?: SortOrder
    itemDescription?: SortOrder
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingInvoiceDetailSumOrderByAggregateInput = {
    itemQuantity?: SortOrder
    itemUnitPrice?: SortOrder
    itemTotalPrice?: SortOrder
    itemTaxRate?: SortOrder
    itemTaxAmount?: SortOrder
    itemTotalWithTax?: SortOrder
  }

  export type BillingPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentDate?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    transactionId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    billingInvoiceId?: SortOrder
  }

  export type BillingPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TenantListRelationFilter = {
    every?: TenantWhereInput
    some?: TenantWhereInput
    none?: TenantWhereInput
  }

  export type TenantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    durationDays?: SortOrder
    isActive?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    price?: SortOrder
    durationDays?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    durationDays?: SortOrder
    isActive?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    durationDays?: SortOrder
    isActive?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    price?: SortOrder
    durationDays?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumCollectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionStatus | EnumCollectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionStatusFilter<$PrismaModel> | $Enums.CollectionStatus
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentAgreementListRelationFilter = {
    every?: PaymentAgreementWhereInput
    some?: PaymentAgreementWhereInput
    none?: PaymentAgreementWhereInput
  }

  export type PenaltyListRelationFilter = {
    every?: PenaltyWhereInput
    some?: PenaltyWhereInput
    none?: PenaltyWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentAgreementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PenaltyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCaseCountOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    reminder1SentAt?: SortOrder
    reminder1DueDate?: SortOrder
    reminder2SentAt?: SortOrder
    reminder2DueDate?: SortOrder
    tenantId?: SortOrder
    debtorId?: SortOrder
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionCaseAvgOrderByAggregateInput = {
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
  }

  export type CollectionCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    reminder1SentAt?: SortOrder
    reminder1DueDate?: SortOrder
    reminder2SentAt?: SortOrder
    reminder2DueDate?: SortOrder
    tenantId?: SortOrder
    debtorId?: SortOrder
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionCaseMinOrderByAggregateInput = {
    id?: SortOrder
    referenceNumber?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    reminder1SentAt?: SortOrder
    reminder1DueDate?: SortOrder
    reminder2SentAt?: SortOrder
    reminder2DueDate?: SortOrder
    tenantId?: SortOrder
    debtorId?: SortOrder
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionCaseSumOrderByAggregateInput = {
    amountOriginal?: SortOrder
    amountDue?: SortOrder
    amountToReceive?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumCollectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionStatus | EnumCollectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CollectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCollectionStatusFilter<$PrismaModel>
    _max?: NestedEnumCollectionStatusFilter<$PrismaModel>
  }

  export type CollectionCaseScalarRelationFilter = {
    is?: CollectionCaseWhereInput
    isNot?: CollectionCaseWhereInput
  }

  export type PenaltyCountOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    dateApplied?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PenaltyAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PenaltyMaxOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    dateApplied?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PenaltyMinOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    dateApplied?: SortOrder
    isPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PenaltySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type PaymentAgreementNullableScalarRelationFilter = {
    is?: PaymentAgreementWhereInput | null
    isNot?: PaymentAgreementWhereInput | null
  }

  export type InstallmentListRelationFilter = {
    every?: InstallmentWhereInput
    some?: InstallmentWhereInput
    none?: InstallmentWhereInput
  }

  export type InstallmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    collectionCaseId?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrder
    updatedAt?: SortOrder
    paymentAgreementId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    collectionCaseId?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrder
    updatedAt?: SortOrder
    paymentAgreementId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    collectionCaseId?: SortOrder
    paymentDate?: SortOrder
    referenceNumber?: SortOrder
    updatedAt?: SortOrder
    paymentAgreementId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPersonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeFilter<$PrismaModel> | $Enums.PersonType
  }

  export type EnumIdentificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel> | $Enums.IdentificationType | null
  }

  export type DebtorIncomeListRelationFilter = {
    every?: DebtorIncomeWhereInput
    some?: DebtorIncomeWhereInput
    none?: DebtorIncomeWhereInput
  }

  export type DebtorIncomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtorTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type DebtorTenantIdIdentificationCompoundUniqueInput = {
    tenantId: string
    identification: string
  }

  export type DebtorCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    personType?: SortOrder
    identificationType?: SortOrder
    identification?: SortOrder
    totalIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorAvgOrderByAggregateInput = {
    totalIncome?: SortOrder
  }

  export type DebtorMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    personType?: SortOrder
    identificationType?: SortOrder
    identification?: SortOrder
    totalIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    personType?: SortOrder
    identificationType?: SortOrder
    identification?: SortOrder
    totalIncome?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorSumOrderByAggregateInput = {
    totalIncome?: SortOrder
  }

  export type EnumPersonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel> | $Enums.PersonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonTypeFilter<$PrismaModel>
    _max?: NestedEnumPersonTypeFilter<$PrismaModel>
  }

  export type EnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.IdentificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
  }

  export type ChatRoomCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    collectionCaseId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    collectionCaseId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatRoomMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    collectionCaseId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatRoomScalarRelationFilter = {
    is?: ChatRoomWhereInput
    isNot?: ChatRoomWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorIncomeCountOrderByAggregateInput = {
    id?: SortOrder
    debtorId?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorIncomeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DebtorIncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    debtorId?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorIncomeMinOrderByAggregateInput = {
    id?: SortOrder
    debtorId?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DebtorIncomeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentAgreementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentAgreementStatus | EnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentAgreementStatus[] | ListEnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentAgreementStatus[] | ListEnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentAgreementStatusFilter<$PrismaModel> | $Enums.PaymentAgreementStatus
  }

  export type DebtorNullableScalarRelationFilter = {
    is?: DebtorWhereInput | null
    isNot?: DebtorWhereInput | null
  }

  export type PaymentAgreementCountOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    totalAmount?: SortOrder
    installmentAmount?: SortOrder
    installmentsCount?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    debtorId?: SortOrder
  }

  export type PaymentAgreementAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    installmentAmount?: SortOrder
    installmentsCount?: SortOrder
  }

  export type PaymentAgreementMaxOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    totalAmount?: SortOrder
    installmentAmount?: SortOrder
    installmentsCount?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    debtorId?: SortOrder
  }

  export type PaymentAgreementMinOrderByAggregateInput = {
    id?: SortOrder
    collectionCaseId?: SortOrder
    totalAmount?: SortOrder
    installmentAmount?: SortOrder
    installmentsCount?: SortOrder
    startDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    debtorId?: SortOrder
  }

  export type PaymentAgreementSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    installmentAmount?: SortOrder
    installmentsCount?: SortOrder
  }

  export type EnumPaymentAgreementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentAgreementStatus | EnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentAgreementStatus[] | ListEnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentAgreementStatus[] | ListEnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentAgreementStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentAgreementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentAgreementStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentAgreementStatusFilter<$PrismaModel>
  }

  export type EnumInstallmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusFilter<$PrismaModel> | $Enums.InstallmentStatus
  }

  export type PaymentAgreementScalarRelationFilter = {
    is?: PaymentAgreementWhereInput
    isNot?: PaymentAgreementWhereInput
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type InstallmentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentAgreementId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallmentAvgOrderByAggregateInput = {
    number?: SortOrder
    amount?: SortOrder
  }

  export type InstallmentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentAgreementId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallmentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentAgreementId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallmentSumOrderByAggregateInput = {
    number?: SortOrder
    amount?: SortOrder
  }

  export type EnumInstallmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstallmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstallmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInstallmentStatusFilter<$PrismaModel>
  }

  export type PlanCreateNestedOneWithoutTenantsInput = {
    create?: XOR<PlanCreateWithoutTenantsInput, PlanUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutTenantsInput
    connect?: PlanWhereUniqueInput
  }

  export type BillingInvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
  }

  export type CollectionCaseCreateNestedManyWithoutTenantInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type DebtorCreateNestedManyWithoutTenantInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type TenantRegistryCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantRegistryCreateOrConnectWithoutTenantInput
    connect?: TenantRegistryWhereUniqueInput
  }

  export type VerdictCreateNestedManyWithoutTenantInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ChatRoomCreateNestedManyWithoutTenantInput = {
    create?: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput> | ChatRoomCreateWithoutTenantInput[] | ChatRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutTenantInput | ChatRoomCreateOrConnectWithoutTenantInput[]
    createMany?: ChatRoomCreateManyTenantInputEnvelope
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
  }

  export type BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
  }

  export type CollectionCaseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type DebtorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type TenantRegistryUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantRegistryCreateOrConnectWithoutTenantInput
    connect?: TenantRegistryWhereUniqueInput
  }

  export type VerdictUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ChatRoomUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput> | ChatRoomCreateWithoutTenantInput[] | ChatRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutTenantInput | ChatRoomCreateOrConnectWithoutTenantInput[]
    createMany?: ChatRoomCreateManyTenantInputEnvelope
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PlanUpdateOneWithoutTenantsNestedInput = {
    create?: XOR<PlanCreateWithoutTenantsInput, PlanUncheckedCreateWithoutTenantsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutTenantsInput
    upsert?: PlanUpsertWithoutTenantsInput
    disconnect?: PlanWhereInput | boolean
    delete?: PlanWhereInput | boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutTenantsInput, PlanUpdateWithoutTenantsInput>, PlanUncheckedUpdateWithoutTenantsInput>
  }

  export type BillingInvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput | BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    set?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    disconnect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    delete?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    update?: BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput | BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BillingInvoiceUpdateManyWithWhereWithoutTenantInput | BillingInvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
  }

  export type CollectionCaseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutTenantInput | CollectionCaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutTenantInput | CollectionCaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutTenantInput | CollectionCaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type DebtorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutTenantInput | DebtorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutTenantInput | DebtorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutTenantInput | DebtorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type TenantRegistryUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantRegistryCreateOrConnectWithoutTenantInput
    upsert?: TenantRegistryUpsertWithoutTenantInput
    disconnect?: TenantRegistryWhereInput | boolean
    delete?: TenantRegistryWhereInput | boolean
    connect?: TenantRegistryWhereUniqueInput
    update?: XOR<XOR<TenantRegistryUpdateToOneWithWhereWithoutTenantInput, TenantRegistryUpdateWithoutTenantInput>, TenantRegistryUncheckedUpdateWithoutTenantInput>
  }

  export type VerdictUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutTenantInput | VerdictUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutTenantInput | VerdictUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutTenantInput | VerdictUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ChatRoomUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput> | ChatRoomCreateWithoutTenantInput[] | ChatRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutTenantInput | ChatRoomCreateOrConnectWithoutTenantInput[]
    upsert?: ChatRoomUpsertWithWhereUniqueWithoutTenantInput | ChatRoomUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ChatRoomCreateManyTenantInputEnvelope
    set?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    disconnect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    delete?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    update?: ChatRoomUpdateWithWhereUniqueWithoutTenantInput | ChatRoomUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ChatRoomUpdateManyWithWhereWithoutTenantInput | ChatRoomUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
  }

  export type BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput | BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    set?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    disconnect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    delete?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    update?: BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput | BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BillingInvoiceUpdateManyWithWhereWithoutTenantInput | BillingInvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
  }

  export type CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutTenantInput | CollectionCaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutTenantInput | CollectionCaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutTenantInput | CollectionCaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type DebtorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutTenantInput | DebtorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutTenantInput | DebtorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutTenantInput | DebtorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantRegistryCreateOrConnectWithoutTenantInput
    upsert?: TenantRegistryUpsertWithoutTenantInput
    disconnect?: TenantRegistryWhereInput | boolean
    delete?: TenantRegistryWhereInput | boolean
    connect?: TenantRegistryWhereUniqueInput
    update?: XOR<XOR<TenantRegistryUpdateToOneWithWhereWithoutTenantInput, TenantRegistryUpdateWithoutTenantInput>, TenantRegistryUncheckedUpdateWithoutTenantInput>
  }

  export type VerdictUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutTenantInput | VerdictUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutTenantInput | VerdictUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutTenantInput | VerdictUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ChatRoomUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput> | ChatRoomCreateWithoutTenantInput[] | ChatRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutTenantInput | ChatRoomCreateOrConnectWithoutTenantInput[]
    upsert?: ChatRoomUpsertWithWhereUniqueWithoutTenantInput | ChatRoomUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ChatRoomCreateManyTenantInputEnvelope
    set?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    disconnect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    delete?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    update?: ChatRoomUpdateWithWhereUniqueWithoutTenantInput | ChatRoomUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ChatRoomUpdateManyWithWhereWithoutTenantInput | ChatRoomUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutRegistryInput = {
    create?: XOR<TenantCreateWithoutRegistryInput, TenantUncheckedCreateWithoutRegistryInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRegistryInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutRegistryNestedInput = {
    create?: XOR<TenantCreateWithoutRegistryInput, TenantUncheckedCreateWithoutRegistryInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRegistryInput
    upsert?: TenantUpsertWithoutRegistryInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRegistryInput, TenantUpdateWithoutRegistryInput>, TenantUncheckedUpdateWithoutRegistryInput>
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type DebtorCreateNestedManyWithoutUserInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type VerdictCreateNestedManyWithoutBailiffInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type DebtorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type VerdictUncheckedCreateNestedManyWithoutBailiffInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type EnumroleEnumFieldUpdateOperationsInput = {
    set?: $Enums.roleEnum
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type DebtorUpdateManyWithoutUserNestedInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutUserInput | DebtorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutUserInput | DebtorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutUserInput | DebtorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type VerdictUpdateManyWithoutBailiffNestedInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutBailiffInput | VerdictUpsertWithWhereUniqueWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutBailiffInput | VerdictUpdateWithWhereUniqueWithoutBailiffInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutBailiffInput | VerdictUpdateManyWithWhereWithoutBailiffInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type DebtorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutUserInput | DebtorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutUserInput | DebtorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutUserInput | DebtorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type VerdictUncheckedUpdateManyWithoutBailiffNestedInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutBailiffInput | VerdictUpsertWithWhereUniqueWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutBailiffInput | VerdictUpdateWithWhereUniqueWithoutBailiffInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutBailiffInput | VerdictUpdateManyWithWhereWithoutBailiffInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutVerdictBailiffsInput = {
    create?: XOR<UserCreateWithoutVerdictBailiffsInput, UserUncheckedCreateWithoutVerdictBailiffsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerdictBailiffsInput
    connect?: UserWhereUniqueInput
  }

  export type DebtorCreateNestedOneWithoutVerdictsInput = {
    create?: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutVerdictsInput
    connect?: DebtorWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutVerdictsInput = {
    create?: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVerdictsInput
    connect?: TenantWhereUniqueInput
  }

  export type VerdictAttachmentCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
  }

  export type VerdictBailiffServicesCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
  }

  export type VerdictEmbargoCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
  }

  export type VerdictInterestCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
  }

  export type VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
  }

  export type VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
  }

  export type VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
  }

  export type VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
  }

  export type EnumVerdictStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerdictStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutVerdictBailiffsNestedInput = {
    create?: XOR<UserCreateWithoutVerdictBailiffsInput, UserUncheckedCreateWithoutVerdictBailiffsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerdictBailiffsInput
    upsert?: UserUpsertWithoutVerdictBailiffsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerdictBailiffsInput, UserUpdateWithoutVerdictBailiffsInput>, UserUncheckedUpdateWithoutVerdictBailiffsInput>
  }

  export type DebtorUpdateOneRequiredWithoutVerdictsNestedInput = {
    create?: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutVerdictsInput
    upsert?: DebtorUpsertWithoutVerdictsInput
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutVerdictsInput, DebtorUpdateWithoutVerdictsInput>, DebtorUncheckedUpdateWithoutVerdictsInput>
  }

  export type TenantUpdateOneRequiredWithoutVerdictsNestedInput = {
    create?: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVerdictsInput
    upsert?: TenantUpsertWithoutVerdictsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVerdictsInput, TenantUpdateWithoutVerdictsInput>, TenantUncheckedUpdateWithoutVerdictsInput>
  }

  export type VerdictAttachmentUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    set?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    disconnect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    delete?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    update?: VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput | VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
  }

  export type VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    set?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    disconnect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    delete?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    update?: VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput | VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
  }

  export type VerdictEmbargoUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    set?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    disconnect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    delete?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    update?: VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput | VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
  }

  export type VerdictInterestUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput | VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    set?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    disconnect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    delete?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    update?: VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput | VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictInterestUpdateManyWithWhereWithoutVerdictInput | VerdictInterestUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
  }

  export type VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    set?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    disconnect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    delete?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    update?: VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput | VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
  }

  export type VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    set?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    disconnect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    delete?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    update?: VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput | VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
  }

  export type VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    set?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    disconnect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    delete?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    update?: VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput | VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
  }

  export type VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput | VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    set?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    disconnect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    delete?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    update?: VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput | VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictInterestUpdateManyWithWhereWithoutVerdictInput | VerdictInterestUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
  }

  export type VerdictCreateNestedOneWithoutVerdictInterestInput = {
    create?: XOR<VerdictCreateWithoutVerdictInterestInput, VerdictUncheckedCreateWithoutVerdictInterestInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdictInterestInput
    connect?: VerdictWhereUniqueInput
  }

  export type VerdictInterestDetailsCreateNestedManyWithoutVerdictInterestInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput> | VerdictInterestDetailsCreateWithoutVerdictInterestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdictInterestInputEnvelope
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
  }

  export type VerdictInterestDetailsUncheckedCreateNestedManyWithoutVerdictInterestInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput> | VerdictInterestDetailsCreateWithoutVerdictInterestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdictInterestInputEnvelope
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
  }

  export type VerdictUpdateOneWithoutVerdictInterestNestedInput = {
    create?: XOR<VerdictCreateWithoutVerdictInterestInput, VerdictUncheckedCreateWithoutVerdictInterestInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdictInterestInput
    upsert?: VerdictUpsertWithoutVerdictInterestInput
    disconnect?: VerdictWhereInput | boolean
    delete?: VerdictWhereInput | boolean
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutVerdictInterestInput, VerdictUpdateWithoutVerdictInterestInput>, VerdictUncheckedUpdateWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsUpdateManyWithoutVerdictInterestNestedInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput> | VerdictInterestDetailsCreateWithoutVerdictInterestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput[]
    upsert?: VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdictInterestInput | VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdictInterestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdictInterestInputEnvelope
    set?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    disconnect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    delete?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    update?: VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdictInterestInput | VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdictInterestInput[]
    updateMany?: VerdictInterestDetailsUpdateManyWithWhereWithoutVerdictInterestInput | VerdictInterestDetailsUpdateManyWithWhereWithoutVerdictInterestInput[]
    deleteMany?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
  }

  export type VerdictInterestDetailsUncheckedUpdateManyWithoutVerdictInterestNestedInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput> | VerdictInterestDetailsCreateWithoutVerdictInterestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput[]
    upsert?: VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdictInterestInput | VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdictInterestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdictInterestInputEnvelope
    set?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    disconnect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    delete?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    update?: VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdictInterestInput | VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdictInterestInput[]
    updateMany?: VerdictInterestDetailsUpdateManyWithWhereWithoutVerdictInterestInput | VerdictInterestDetailsUpdateManyWithWhereWithoutVerdictInterestInput[]
    deleteMany?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
  }

  export type VerdictInterestCreateNestedOneWithoutDetailsInput = {
    create?: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutDetailsInput
    connect?: VerdictInterestWhereUniqueInput
  }

  export type VerdictInterestUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutDetailsInput
    upsert?: VerdictInterestUpsertWithoutDetailsInput
    connect?: VerdictInterestWhereUniqueInput
    update?: XOR<XOR<VerdictInterestUpdateToOneWithWhereWithoutDetailsInput, VerdictInterestUpdateWithoutDetailsInput>, VerdictInterestUncheckedUpdateWithoutDetailsInput>
  }

  export type VerdictCreateNestedOneWithoutVerdictEmbargoInput = {
    create?: XOR<VerdictCreateWithoutVerdictEmbargoInput, VerdictUncheckedCreateWithoutVerdictEmbargoInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdictEmbargoInput
    connect?: VerdictWhereUniqueInput
  }

  export type VerdictUpdateOneRequiredWithoutVerdictEmbargoNestedInput = {
    create?: XOR<VerdictCreateWithoutVerdictEmbargoInput, VerdictUncheckedCreateWithoutVerdictEmbargoInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdictEmbargoInput
    upsert?: VerdictUpsertWithoutVerdictEmbargoInput
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutVerdictEmbargoInput, VerdictUpdateWithoutVerdictEmbargoInput>, VerdictUncheckedUpdateWithoutVerdictEmbargoInput>
  }

  export type VerdictCreateNestedOneWithoutBailiffServicesInput = {
    create?: XOR<VerdictCreateWithoutBailiffServicesInput, VerdictUncheckedCreateWithoutBailiffServicesInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffServicesInput
    connect?: VerdictWhereUniqueInput
  }

  export type VerdictUpdateOneRequiredWithoutBailiffServicesNestedInput = {
    create?: XOR<VerdictCreateWithoutBailiffServicesInput, VerdictUncheckedCreateWithoutBailiffServicesInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffServicesInput
    upsert?: VerdictUpsertWithoutBailiffServicesInput
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutBailiffServicesInput, VerdictUpdateWithoutBailiffServicesInput>, VerdictUncheckedUpdateWithoutBailiffServicesInput>
  }

  export type VerdictCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutAttachmentsInput
    connect?: VerdictWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type VerdictUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutAttachmentsInput
    upsert?: VerdictUpsertWithoutAttachmentsInput
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutAttachmentsInput, VerdictUpdateWithoutAttachmentsInput>, VerdictUncheckedUpdateWithoutAttachmentsInput>
  }

  export type InterestDetailCreateNestedManyWithoutInterestTypeInput = {
    create?: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput> | InterestDetailCreateWithoutInterestTypeInput[] | InterestDetailUncheckedCreateWithoutInterestTypeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterestTypeInput | InterestDetailCreateOrConnectWithoutInterestTypeInput[]
    createMany?: InterestDetailCreateManyInterestTypeInputEnvelope
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
  }

  export type InterestDetailUncheckedCreateNestedManyWithoutInterestTypeInput = {
    create?: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput> | InterestDetailCreateWithoutInterestTypeInput[] | InterestDetailUncheckedCreateWithoutInterestTypeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterestTypeInput | InterestDetailCreateOrConnectWithoutInterestTypeInput[]
    createMany?: InterestDetailCreateManyInterestTypeInputEnvelope
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
  }

  export type EnumCalculationTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.CalculationTypeEnum
  }

  export type InterestDetailUpdateManyWithoutInterestTypeNestedInput = {
    create?: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput> | InterestDetailCreateWithoutInterestTypeInput[] | InterestDetailUncheckedCreateWithoutInterestTypeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterestTypeInput | InterestDetailCreateOrConnectWithoutInterestTypeInput[]
    upsert?: InterestDetailUpsertWithWhereUniqueWithoutInterestTypeInput | InterestDetailUpsertWithWhereUniqueWithoutInterestTypeInput[]
    createMany?: InterestDetailCreateManyInterestTypeInputEnvelope
    set?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    disconnect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    delete?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    update?: InterestDetailUpdateWithWhereUniqueWithoutInterestTypeInput | InterestDetailUpdateWithWhereUniqueWithoutInterestTypeInput[]
    updateMany?: InterestDetailUpdateManyWithWhereWithoutInterestTypeInput | InterestDetailUpdateManyWithWhereWithoutInterestTypeInput[]
    deleteMany?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
  }

  export type InterestDetailUncheckedUpdateManyWithoutInterestTypeNestedInput = {
    create?: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput> | InterestDetailCreateWithoutInterestTypeInput[] | InterestDetailUncheckedCreateWithoutInterestTypeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterestTypeInput | InterestDetailCreateOrConnectWithoutInterestTypeInput[]
    upsert?: InterestDetailUpsertWithWhereUniqueWithoutInterestTypeInput | InterestDetailUpsertWithWhereUniqueWithoutInterestTypeInput[]
    createMany?: InterestDetailCreateManyInterestTypeInputEnvelope
    set?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    disconnect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    delete?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    update?: InterestDetailUpdateWithWhereUniqueWithoutInterestTypeInput | InterestDetailUpdateWithWhereUniqueWithoutInterestTypeInput[]
    updateMany?: InterestDetailUpdateManyWithWhereWithoutInterestTypeInput | InterestDetailUpdateManyWithWhereWithoutInterestTypeInput[]
    deleteMany?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
  }

  export type InterestTypeCreateNestedOneWithoutDetailsInput = {
    create?: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: InterestTypeCreateOrConnectWithoutDetailsInput
    connect?: InterestTypeWhereUniqueInput
  }

  export type InterestTypeUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: InterestTypeCreateOrConnectWithoutDetailsInput
    upsert?: InterestTypeUpsertWithoutDetailsInput
    connect?: InterestTypeWhereUniqueInput
    update?: XOR<XOR<InterestTypeUpdateToOneWithWhereWithoutDetailsInput, InterestTypeUpdateWithoutDetailsInput>, InterestTypeUncheckedUpdateWithoutDetailsInput>
  }

  export type TenantCreateNestedOneWithoutBillingInvoiceInput = {
    create?: XOR<TenantCreateWithoutBillingInvoiceInput, TenantUncheckedCreateWithoutBillingInvoiceInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBillingInvoiceInput
    connect?: TenantWhereUniqueInput
  }

  export type BillingInvoiceDetailCreateNestedManyWithoutBillingInvoiceInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput> | BillingInvoiceDetailCreateWithoutBillingInvoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBillingInvoiceInputEnvelope
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
  }

  export type BillingPaymentCreateNestedManyWithoutBillingInvoiceInput = {
    create?: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput> | BillingPaymentCreateWithoutBillingInvoiceInput[] | BillingPaymentUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBillingInvoiceInput | BillingPaymentCreateOrConnectWithoutBillingInvoiceInput[]
    createMany?: BillingPaymentCreateManyBillingInvoiceInputEnvelope
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
  }

  export type BillingInvoiceDetailUncheckedCreateNestedManyWithoutBillingInvoiceInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput> | BillingInvoiceDetailCreateWithoutBillingInvoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBillingInvoiceInputEnvelope
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
  }

  export type BillingPaymentUncheckedCreateNestedManyWithoutBillingInvoiceInput = {
    create?: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput> | BillingPaymentCreateWithoutBillingInvoiceInput[] | BillingPaymentUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBillingInvoiceInput | BillingPaymentCreateOrConnectWithoutBillingInvoiceInput[]
    createMany?: BillingPaymentCreateManyBillingInvoiceInputEnvelope
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutBillingInvoiceNestedInput = {
    create?: XOR<TenantCreateWithoutBillingInvoiceInput, TenantUncheckedCreateWithoutBillingInvoiceInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBillingInvoiceInput
    upsert?: TenantUpsertWithoutBillingInvoiceInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBillingInvoiceInput, TenantUpdateWithoutBillingInvoiceInput>, TenantUncheckedUpdateWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailUpdateManyWithoutBillingInvoiceNestedInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput> | BillingInvoiceDetailCreateWithoutBillingInvoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput[]
    upsert?: BillingInvoiceDetailUpsertWithWhereUniqueWithoutBillingInvoiceInput | BillingInvoiceDetailUpsertWithWhereUniqueWithoutBillingInvoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBillingInvoiceInputEnvelope
    set?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    disconnect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    delete?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    update?: BillingInvoiceDetailUpdateWithWhereUniqueWithoutBillingInvoiceInput | BillingInvoiceDetailUpdateWithWhereUniqueWithoutBillingInvoiceInput[]
    updateMany?: BillingInvoiceDetailUpdateManyWithWhereWithoutBillingInvoiceInput | BillingInvoiceDetailUpdateManyWithWhereWithoutBillingInvoiceInput[]
    deleteMany?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
  }

  export type BillingPaymentUpdateManyWithoutBillingInvoiceNestedInput = {
    create?: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput> | BillingPaymentCreateWithoutBillingInvoiceInput[] | BillingPaymentUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBillingInvoiceInput | BillingPaymentCreateOrConnectWithoutBillingInvoiceInput[]
    upsert?: BillingPaymentUpsertWithWhereUniqueWithoutBillingInvoiceInput | BillingPaymentUpsertWithWhereUniqueWithoutBillingInvoiceInput[]
    createMany?: BillingPaymentCreateManyBillingInvoiceInputEnvelope
    set?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    disconnect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    delete?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    update?: BillingPaymentUpdateWithWhereUniqueWithoutBillingInvoiceInput | BillingPaymentUpdateWithWhereUniqueWithoutBillingInvoiceInput[]
    updateMany?: BillingPaymentUpdateManyWithWhereWithoutBillingInvoiceInput | BillingPaymentUpdateManyWithWhereWithoutBillingInvoiceInput[]
    deleteMany?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
  }

  export type BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceNestedInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput> | BillingInvoiceDetailCreateWithoutBillingInvoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput[]
    upsert?: BillingInvoiceDetailUpsertWithWhereUniqueWithoutBillingInvoiceInput | BillingInvoiceDetailUpsertWithWhereUniqueWithoutBillingInvoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBillingInvoiceInputEnvelope
    set?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    disconnect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    delete?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    update?: BillingInvoiceDetailUpdateWithWhereUniqueWithoutBillingInvoiceInput | BillingInvoiceDetailUpdateWithWhereUniqueWithoutBillingInvoiceInput[]
    updateMany?: BillingInvoiceDetailUpdateManyWithWhereWithoutBillingInvoiceInput | BillingInvoiceDetailUpdateManyWithWhereWithoutBillingInvoiceInput[]
    deleteMany?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
  }

  export type BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceNestedInput = {
    create?: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput> | BillingPaymentCreateWithoutBillingInvoiceInput[] | BillingPaymentUncheckedCreateWithoutBillingInvoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBillingInvoiceInput | BillingPaymentCreateOrConnectWithoutBillingInvoiceInput[]
    upsert?: BillingPaymentUpsertWithWhereUniqueWithoutBillingInvoiceInput | BillingPaymentUpsertWithWhereUniqueWithoutBillingInvoiceInput[]
    createMany?: BillingPaymentCreateManyBillingInvoiceInputEnvelope
    set?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    disconnect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    delete?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    update?: BillingPaymentUpdateWithWhereUniqueWithoutBillingInvoiceInput | BillingPaymentUpdateWithWhereUniqueWithoutBillingInvoiceInput[]
    updateMany?: BillingPaymentUpdateManyWithWhereWithoutBillingInvoiceInput | BillingPaymentUpdateManyWithWhereWithoutBillingInvoiceInput[]
    deleteMany?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
  }

  export type BillingInvoiceCreateNestedOneWithoutDetailsInput = {
    create?: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutDetailsInput
    connect?: BillingInvoiceWhereUniqueInput
  }

  export type BillingInvoiceUpdateOneWithoutDetailsNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutDetailsInput
    upsert?: BillingInvoiceUpsertWithoutDetailsInput
    disconnect?: BillingInvoiceWhereInput | boolean
    delete?: BillingInvoiceWhereInput | boolean
    connect?: BillingInvoiceWhereUniqueInput
    update?: XOR<XOR<BillingInvoiceUpdateToOneWithWhereWithoutDetailsInput, BillingInvoiceUpdateWithoutDetailsInput>, BillingInvoiceUncheckedUpdateWithoutDetailsInput>
  }

  export type BillingInvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutPaymentsInput
    connect?: BillingInvoiceWhereUniqueInput
  }

  export type BillingInvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: BillingInvoiceUpsertWithoutPaymentsInput
    disconnect?: BillingInvoiceWhereInput | boolean
    delete?: BillingInvoiceWhereInput | boolean
    connect?: BillingInvoiceWhereUniqueInput
    update?: XOR<XOR<BillingInvoiceUpdateToOneWithWhereWithoutPaymentsInput, BillingInvoiceUpdateWithoutPaymentsInput>, BillingInvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantCreateNestedManyWithoutPlanInput = {
    create?: XOR<TenantCreateWithoutPlanInput, TenantUncheckedCreateWithoutPlanInput> | TenantCreateWithoutPlanInput[] | TenantUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutPlanInput | TenantCreateOrConnectWithoutPlanInput[]
    createMany?: TenantCreateManyPlanInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type TenantUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<TenantCreateWithoutPlanInput, TenantUncheckedCreateWithoutPlanInput> | TenantCreateWithoutPlanInput[] | TenantUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutPlanInput | TenantCreateOrConnectWithoutPlanInput[]
    createMany?: TenantCreateManyPlanInputEnvelope
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
  }

  export type TenantUpdateManyWithoutPlanNestedInput = {
    create?: XOR<TenantCreateWithoutPlanInput, TenantUncheckedCreateWithoutPlanInput> | TenantCreateWithoutPlanInput[] | TenantUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutPlanInput | TenantCreateOrConnectWithoutPlanInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutPlanInput | TenantUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: TenantCreateManyPlanInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutPlanInput | TenantUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutPlanInput | TenantUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type TenantUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<TenantCreateWithoutPlanInput, TenantUncheckedCreateWithoutPlanInput> | TenantCreateWithoutPlanInput[] | TenantUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: TenantCreateOrConnectWithoutPlanInput | TenantCreateOrConnectWithoutPlanInput[]
    upsert?: TenantUpsertWithWhereUniqueWithoutPlanInput | TenantUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: TenantCreateManyPlanInputEnvelope
    set?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    disconnect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    delete?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    connect?: TenantWhereUniqueInput | TenantWhereUniqueInput[]
    update?: TenantUpdateWithWhereUniqueWithoutPlanInput | TenantUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: TenantUpdateManyWithWhereWithoutPlanInput | TenantUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: TenantScalarWhereInput | TenantScalarWhereInput[]
  }

  export type DebtorCreateNestedOneWithoutCollectionCasesInput = {
    create?: XOR<DebtorCreateWithoutCollectionCasesInput, DebtorUncheckedCreateWithoutCollectionCasesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutCollectionCasesInput
    connect?: DebtorWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutCollectionCasesInput = {
    create?: XOR<TenantCreateWithoutCollectionCasesInput, TenantUncheckedCreateWithoutCollectionCasesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCollectionCasesInput
    connect?: TenantWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput> | NotificationCreateWithoutCollectionCaseInput[] | NotificationUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCollectionCaseInput | NotificationCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: NotificationCreateManyCollectionCaseInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput> | PaymentCreateWithoutCollectionCaseInput[] | PaymentUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectionCaseInput | PaymentCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PaymentCreateManyCollectionCaseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentAgreementCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput> | PaymentAgreementCreateWithoutCollectionCaseInput[] | PaymentAgreementUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutCollectionCaseInput | PaymentAgreementCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PaymentAgreementCreateManyCollectionCaseInputEnvelope
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
  }

  export type PenaltyCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput> | PenaltyCreateWithoutCollectionCaseInput[] | PenaltyUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutCollectionCaseInput | PenaltyCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PenaltyCreateManyCollectionCaseInputEnvelope
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
  }

  export type ChatRoomCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<ChatRoomCreateWithoutCollectionCaseInput, ChatRoomUncheckedCreateWithoutCollectionCaseInput> | ChatRoomCreateWithoutCollectionCaseInput[] | ChatRoomUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutCollectionCaseInput | ChatRoomCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: ChatRoomCreateManyCollectionCaseInputEnvelope
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput> | NotificationCreateWithoutCollectionCaseInput[] | NotificationUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCollectionCaseInput | NotificationCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: NotificationCreateManyCollectionCaseInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput> | PaymentCreateWithoutCollectionCaseInput[] | PaymentUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectionCaseInput | PaymentCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PaymentCreateManyCollectionCaseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput> | PaymentAgreementCreateWithoutCollectionCaseInput[] | PaymentAgreementUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutCollectionCaseInput | PaymentAgreementCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PaymentAgreementCreateManyCollectionCaseInputEnvelope
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
  }

  export type PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput> | PenaltyCreateWithoutCollectionCaseInput[] | PenaltyUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutCollectionCaseInput | PenaltyCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: PenaltyCreateManyCollectionCaseInputEnvelope
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
  }

  export type ChatRoomUncheckedCreateNestedManyWithoutCollectionCaseInput = {
    create?: XOR<ChatRoomCreateWithoutCollectionCaseInput, ChatRoomUncheckedCreateWithoutCollectionCaseInput> | ChatRoomCreateWithoutCollectionCaseInput[] | ChatRoomUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutCollectionCaseInput | ChatRoomCreateOrConnectWithoutCollectionCaseInput[]
    createMany?: ChatRoomCreateManyCollectionCaseInputEnvelope
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumCollectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.CollectionStatus
  }

  export type DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput = {
    create?: XOR<DebtorCreateWithoutCollectionCasesInput, DebtorUncheckedCreateWithoutCollectionCasesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutCollectionCasesInput
    upsert?: DebtorUpsertWithoutCollectionCasesInput
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutCollectionCasesInput, DebtorUpdateWithoutCollectionCasesInput>, DebtorUncheckedUpdateWithoutCollectionCasesInput>
  }

  export type TenantUpdateOneRequiredWithoutCollectionCasesNestedInput = {
    create?: XOR<TenantCreateWithoutCollectionCasesInput, TenantUncheckedCreateWithoutCollectionCasesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCollectionCasesInput
    upsert?: TenantUpsertWithoutCollectionCasesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCollectionCasesInput, TenantUpdateWithoutCollectionCasesInput>, TenantUncheckedUpdateWithoutCollectionCasesInput>
  }

  export type NotificationUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput> | NotificationCreateWithoutCollectionCaseInput[] | NotificationUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCollectionCaseInput | NotificationCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCollectionCaseInput | NotificationUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: NotificationCreateManyCollectionCaseInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCollectionCaseInput | NotificationUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCollectionCaseInput | NotificationUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput> | PaymentCreateWithoutCollectionCaseInput[] | PaymentUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectionCaseInput | PaymentCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCollectionCaseInput | PaymentUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PaymentCreateManyCollectionCaseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCollectionCaseInput | PaymentUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCollectionCaseInput | PaymentUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput> | PaymentAgreementCreateWithoutCollectionCaseInput[] | PaymentAgreementUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutCollectionCaseInput | PaymentAgreementCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PaymentAgreementUpsertWithWhereUniqueWithoutCollectionCaseInput | PaymentAgreementUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PaymentAgreementCreateManyCollectionCaseInputEnvelope
    set?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    disconnect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    delete?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    update?: PaymentAgreementUpdateWithWhereUniqueWithoutCollectionCaseInput | PaymentAgreementUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PaymentAgreementUpdateManyWithWhereWithoutCollectionCaseInput | PaymentAgreementUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
  }

  export type PenaltyUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput> | PenaltyCreateWithoutCollectionCaseInput[] | PenaltyUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutCollectionCaseInput | PenaltyCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PenaltyUpsertWithWhereUniqueWithoutCollectionCaseInput | PenaltyUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PenaltyCreateManyCollectionCaseInputEnvelope
    set?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    disconnect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    delete?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    update?: PenaltyUpdateWithWhereUniqueWithoutCollectionCaseInput | PenaltyUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PenaltyUpdateManyWithWhereWithoutCollectionCaseInput | PenaltyUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
  }

  export type ChatRoomUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<ChatRoomCreateWithoutCollectionCaseInput, ChatRoomUncheckedCreateWithoutCollectionCaseInput> | ChatRoomCreateWithoutCollectionCaseInput[] | ChatRoomUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutCollectionCaseInput | ChatRoomCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: ChatRoomUpsertWithWhereUniqueWithoutCollectionCaseInput | ChatRoomUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: ChatRoomCreateManyCollectionCaseInputEnvelope
    set?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    disconnect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    delete?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    update?: ChatRoomUpdateWithWhereUniqueWithoutCollectionCaseInput | ChatRoomUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: ChatRoomUpdateManyWithWhereWithoutCollectionCaseInput | ChatRoomUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput> | NotificationCreateWithoutCollectionCaseInput[] | NotificationUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCollectionCaseInput | NotificationCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCollectionCaseInput | NotificationUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: NotificationCreateManyCollectionCaseInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCollectionCaseInput | NotificationUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCollectionCaseInput | NotificationUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput> | PaymentCreateWithoutCollectionCaseInput[] | PaymentUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectionCaseInput | PaymentCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCollectionCaseInput | PaymentUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PaymentCreateManyCollectionCaseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCollectionCaseInput | PaymentUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCollectionCaseInput | PaymentUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput> | PaymentAgreementCreateWithoutCollectionCaseInput[] | PaymentAgreementUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutCollectionCaseInput | PaymentAgreementCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PaymentAgreementUpsertWithWhereUniqueWithoutCollectionCaseInput | PaymentAgreementUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PaymentAgreementCreateManyCollectionCaseInputEnvelope
    set?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    disconnect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    delete?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    update?: PaymentAgreementUpdateWithWhereUniqueWithoutCollectionCaseInput | PaymentAgreementUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PaymentAgreementUpdateManyWithWhereWithoutCollectionCaseInput | PaymentAgreementUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
  }

  export type PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput> | PenaltyCreateWithoutCollectionCaseInput[] | PenaltyUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutCollectionCaseInput | PenaltyCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: PenaltyUpsertWithWhereUniqueWithoutCollectionCaseInput | PenaltyUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: PenaltyCreateManyCollectionCaseInputEnvelope
    set?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    disconnect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    delete?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    update?: PenaltyUpdateWithWhereUniqueWithoutCollectionCaseInput | PenaltyUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: PenaltyUpdateManyWithWhereWithoutCollectionCaseInput | PenaltyUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
  }

  export type ChatRoomUncheckedUpdateManyWithoutCollectionCaseNestedInput = {
    create?: XOR<ChatRoomCreateWithoutCollectionCaseInput, ChatRoomUncheckedCreateWithoutCollectionCaseInput> | ChatRoomCreateWithoutCollectionCaseInput[] | ChatRoomUncheckedCreateWithoutCollectionCaseInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutCollectionCaseInput | ChatRoomCreateOrConnectWithoutCollectionCaseInput[]
    upsert?: ChatRoomUpsertWithWhereUniqueWithoutCollectionCaseInput | ChatRoomUpsertWithWhereUniqueWithoutCollectionCaseInput[]
    createMany?: ChatRoomCreateManyCollectionCaseInputEnvelope
    set?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    disconnect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    delete?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    update?: ChatRoomUpdateWithWhereUniqueWithoutCollectionCaseInput | ChatRoomUpdateWithWhereUniqueWithoutCollectionCaseInput[]
    updateMany?: ChatRoomUpdateManyWithWhereWithoutCollectionCaseInput | ChatRoomUpdateManyWithWhereWithoutCollectionCaseInput[]
    deleteMany?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
  }

  export type CollectionCaseCreateNestedOneWithoutPenaltiesInput = {
    create?: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPenaltiesInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type CollectionCaseUpdateOneRequiredWithoutPenaltiesNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPenaltiesInput
    upsert?: CollectionCaseUpsertWithoutPenaltiesInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutPenaltiesInput, CollectionCaseUpdateWithoutPenaltiesInput>, CollectionCaseUncheckedUpdateWithoutPenaltiesInput>
  }

  export type CollectionCaseCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutNotificationsInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type CollectionCaseUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutNotificationsInput
    upsert?: CollectionCaseUpsertWithoutNotificationsInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutNotificationsInput, CollectionCaseUpdateWithoutNotificationsInput>, CollectionCaseUncheckedUpdateWithoutNotificationsInput>
  }

  export type CollectionCaseCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPaymentsInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type PaymentAgreementCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PaymentAgreementCreateWithoutPaymentsInput, PaymentAgreementUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutPaymentsInput
    connect?: PaymentAgreementWhereUniqueInput
  }

  export type InstallmentCreateNestedManyWithoutPaymentInput = {
    create?: XOR<InstallmentCreateWithoutPaymentInput, InstallmentUncheckedCreateWithoutPaymentInput> | InstallmentCreateWithoutPaymentInput[] | InstallmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutPaymentInput | InstallmentCreateOrConnectWithoutPaymentInput[]
    createMany?: InstallmentCreateManyPaymentInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type InstallmentUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<InstallmentCreateWithoutPaymentInput, InstallmentUncheckedCreateWithoutPaymentInput> | InstallmentCreateWithoutPaymentInput[] | InstallmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutPaymentInput | InstallmentCreateOrConnectWithoutPaymentInput[]
    createMany?: InstallmentCreateManyPaymentInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type CollectionCaseUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPaymentsInput
    upsert?: CollectionCaseUpsertWithoutPaymentsInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutPaymentsInput, CollectionCaseUpdateWithoutPaymentsInput>, CollectionCaseUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentAgreementUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<PaymentAgreementCreateWithoutPaymentsInput, PaymentAgreementUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutPaymentsInput
    upsert?: PaymentAgreementUpsertWithoutPaymentsInput
    disconnect?: PaymentAgreementWhereInput | boolean
    delete?: PaymentAgreementWhereInput | boolean
    connect?: PaymentAgreementWhereUniqueInput
    update?: XOR<XOR<PaymentAgreementUpdateToOneWithWhereWithoutPaymentsInput, PaymentAgreementUpdateWithoutPaymentsInput>, PaymentAgreementUncheckedUpdateWithoutPaymentsInput>
  }

  export type InstallmentUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<InstallmentCreateWithoutPaymentInput, InstallmentUncheckedCreateWithoutPaymentInput> | InstallmentCreateWithoutPaymentInput[] | InstallmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutPaymentInput | InstallmentCreateOrConnectWithoutPaymentInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutPaymentInput | InstallmentUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: InstallmentCreateManyPaymentInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutPaymentInput | InstallmentUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutPaymentInput | InstallmentUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type InstallmentUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<InstallmentCreateWithoutPaymentInput, InstallmentUncheckedCreateWithoutPaymentInput> | InstallmentCreateWithoutPaymentInput[] | InstallmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutPaymentInput | InstallmentCreateOrConnectWithoutPaymentInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutPaymentInput | InstallmentUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: InstallmentCreateManyPaymentInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutPaymentInput | InstallmentUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutPaymentInput | InstallmentUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type CollectionCaseCreateNestedManyWithoutDebtorInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutDebtorsInput = {
    create?: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDebtorsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDebtorsInput = {
    create?: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtorsInput
    connect?: UserWhereUniqueInput
  }

  export type DebtorIncomeCreateNestedManyWithoutDebtorInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
  }

  export type PaymentAgreementCreateNestedManyWithoutDebtorInput = {
    create?: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput> | PaymentAgreementCreateWithoutDebtorInput[] | PaymentAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutDebtorInput | PaymentAgreementCreateOrConnectWithoutDebtorInput[]
    createMany?: PaymentAgreementCreateManyDebtorInputEnvelope
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
  }

  export type VerdictCreateNestedManyWithoutDebtorInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
  }

  export type PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput> | PaymentAgreementCreateWithoutDebtorInput[] | PaymentAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutDebtorInput | PaymentAgreementCreateOrConnectWithoutDebtorInput[]
    createMany?: PaymentAgreementCreateManyDebtorInputEnvelope
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
  }

  export type VerdictUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type EnumPersonTypeFieldUpdateOperationsInput = {
    set?: $Enums.PersonType
  }

  export type NullableEnumIdentificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.IdentificationType | null
  }

  export type CollectionCaseUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput | CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput | CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutDebtorInput | CollectionCaseUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutDebtorsNestedInput = {
    create?: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDebtorsInput
    upsert?: TenantUpsertWithoutDebtorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDebtorsInput, TenantUpdateWithoutDebtorsInput>, TenantUncheckedUpdateWithoutDebtorsInput>
  }

  export type UserUpdateOneWithoutDebtorsNestedInput = {
    create?: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtorsInput
    upsert?: UserUpsertWithoutDebtorsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDebtorsInput, UserUpdateWithoutDebtorsInput>, UserUncheckedUpdateWithoutDebtorsInput>
  }

  export type DebtorIncomeUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    upsert?: DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    set?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    disconnect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    delete?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    update?: DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: DebtorIncomeUpdateManyWithWhereWithoutDebtorInput | DebtorIncomeUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
  }

  export type PaymentAgreementUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput> | PaymentAgreementCreateWithoutDebtorInput[] | PaymentAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutDebtorInput | PaymentAgreementCreateOrConnectWithoutDebtorInput[]
    upsert?: PaymentAgreementUpsertWithWhereUniqueWithoutDebtorInput | PaymentAgreementUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: PaymentAgreementCreateManyDebtorInputEnvelope
    set?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    disconnect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    delete?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    update?: PaymentAgreementUpdateWithWhereUniqueWithoutDebtorInput | PaymentAgreementUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: PaymentAgreementUpdateManyWithWhereWithoutDebtorInput | PaymentAgreementUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
  }

  export type VerdictUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutDebtorInput | VerdictUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutDebtorInput | VerdictUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutDebtorInput | VerdictUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput | CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput | CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutDebtorInput | CollectionCaseUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    upsert?: DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    set?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    disconnect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    delete?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    update?: DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: DebtorIncomeUpdateManyWithWhereWithoutDebtorInput | DebtorIncomeUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
  }

  export type PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput> | PaymentAgreementCreateWithoutDebtorInput[] | PaymentAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutDebtorInput | PaymentAgreementCreateOrConnectWithoutDebtorInput[]
    upsert?: PaymentAgreementUpsertWithWhereUniqueWithoutDebtorInput | PaymentAgreementUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: PaymentAgreementCreateManyDebtorInputEnvelope
    set?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    disconnect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    delete?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    connect?: PaymentAgreementWhereUniqueInput | PaymentAgreementWhereUniqueInput[]
    update?: PaymentAgreementUpdateWithWhereUniqueWithoutDebtorInput | PaymentAgreementUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: PaymentAgreementUpdateManyWithWhereWithoutDebtorInput | PaymentAgreementUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
  }

  export type VerdictUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutDebtorInput | VerdictUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutDebtorInput | VerdictUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutDebtorInput | VerdictUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutChatRoomsInput = {
    create?: XOR<TenantCreateWithoutChatRoomsInput, TenantUncheckedCreateWithoutChatRoomsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutChatRoomsInput
    connect?: TenantWhereUniqueInput
  }

  export type CollectionCaseCreateNestedOneWithoutChatRoomsInput = {
    create?: XOR<CollectionCaseCreateWithoutChatRoomsInput, CollectionCaseUncheckedCreateWithoutChatRoomsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutChatRoomsInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutRoomInput = {
    create?: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput> | ChatMessageCreateWithoutRoomInput[] | ChatMessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRoomInput | ChatMessageCreateOrConnectWithoutRoomInput[]
    createMany?: ChatMessageCreateManyRoomInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput> | ChatMessageCreateWithoutRoomInput[] | ChatMessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRoomInput | ChatMessageCreateOrConnectWithoutRoomInput[]
    createMany?: ChatMessageCreateManyRoomInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutChatRoomsNestedInput = {
    create?: XOR<TenantCreateWithoutChatRoomsInput, TenantUncheckedCreateWithoutChatRoomsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutChatRoomsInput
    upsert?: TenantUpsertWithoutChatRoomsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutChatRoomsInput, TenantUpdateWithoutChatRoomsInput>, TenantUncheckedUpdateWithoutChatRoomsInput>
  }

  export type CollectionCaseUpdateOneRequiredWithoutChatRoomsNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutChatRoomsInput, CollectionCaseUncheckedCreateWithoutChatRoomsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutChatRoomsInput
    upsert?: CollectionCaseUpsertWithoutChatRoomsInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutChatRoomsInput, CollectionCaseUpdateWithoutChatRoomsInput>, CollectionCaseUncheckedUpdateWithoutChatRoomsInput>
  }

  export type ChatMessageUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput> | ChatMessageCreateWithoutRoomInput[] | ChatMessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRoomInput | ChatMessageCreateOrConnectWithoutRoomInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutRoomInput | ChatMessageUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ChatMessageCreateManyRoomInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutRoomInput | ChatMessageUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutRoomInput | ChatMessageUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput> | ChatMessageCreateWithoutRoomInput[] | ChatMessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRoomInput | ChatMessageCreateOrConnectWithoutRoomInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutRoomInput | ChatMessageUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ChatMessageCreateManyRoomInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutRoomInput | ChatMessageUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutRoomInput | ChatMessageUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatRoomCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatRoomCreateOrConnectWithoutMessagesInput
    connect?: ChatRoomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ChatRoomUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatRoomCreateOrConnectWithoutMessagesInput
    upsert?: ChatRoomUpsertWithoutMessagesInput
    connect?: ChatRoomWhereUniqueInput
    update?: XOR<XOR<ChatRoomUpdateToOneWithWhereWithoutMessagesInput, ChatRoomUpdateWithoutMessagesInput>, ChatRoomUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type DebtorCreateNestedOneWithoutIncomesInput = {
    create?: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutIncomesInput
    connect?: DebtorWhereUniqueInput
  }

  export type DebtorUpdateOneRequiredWithoutIncomesNestedInput = {
    create?: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutIncomesInput
    upsert?: DebtorUpsertWithoutIncomesInput
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutIncomesInput, DebtorUpdateWithoutIncomesInput>, DebtorUncheckedUpdateWithoutIncomesInput>
  }

  export type CollectionCaseCreateNestedOneWithoutPaymentAgreementsInput = {
    create?: XOR<CollectionCaseCreateWithoutPaymentAgreementsInput, CollectionCaseUncheckedCreateWithoutPaymentAgreementsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPaymentAgreementsInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type InstallmentCreateNestedManyWithoutPaymentAgreementInput = {
    create?: XOR<InstallmentCreateWithoutPaymentAgreementInput, InstallmentUncheckedCreateWithoutPaymentAgreementInput> | InstallmentCreateWithoutPaymentAgreementInput[] | InstallmentUncheckedCreateWithoutPaymentAgreementInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutPaymentAgreementInput | InstallmentCreateOrConnectWithoutPaymentAgreementInput[]
    createMany?: InstallmentCreateManyPaymentAgreementInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutPaymentAgreementInput = {
    create?: XOR<PaymentCreateWithoutPaymentAgreementInput, PaymentUncheckedCreateWithoutPaymentAgreementInput> | PaymentCreateWithoutPaymentAgreementInput[] | PaymentUncheckedCreateWithoutPaymentAgreementInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentAgreementInput | PaymentCreateOrConnectWithoutPaymentAgreementInput[]
    createMany?: PaymentCreateManyPaymentAgreementInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DebtorCreateNestedOneWithoutPaymentAgreementsInput = {
    create?: XOR<DebtorCreateWithoutPaymentAgreementsInput, DebtorUncheckedCreateWithoutPaymentAgreementsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutPaymentAgreementsInput
    connect?: DebtorWhereUniqueInput
  }

  export type InstallmentUncheckedCreateNestedManyWithoutPaymentAgreementInput = {
    create?: XOR<InstallmentCreateWithoutPaymentAgreementInput, InstallmentUncheckedCreateWithoutPaymentAgreementInput> | InstallmentCreateWithoutPaymentAgreementInput[] | InstallmentUncheckedCreateWithoutPaymentAgreementInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutPaymentAgreementInput | InstallmentCreateOrConnectWithoutPaymentAgreementInput[]
    createMany?: InstallmentCreateManyPaymentAgreementInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPaymentAgreementInput = {
    create?: XOR<PaymentCreateWithoutPaymentAgreementInput, PaymentUncheckedCreateWithoutPaymentAgreementInput> | PaymentCreateWithoutPaymentAgreementInput[] | PaymentUncheckedCreateWithoutPaymentAgreementInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentAgreementInput | PaymentCreateOrConnectWithoutPaymentAgreementInput[]
    createMany?: PaymentCreateManyPaymentAgreementInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumPaymentAgreementStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentAgreementStatus
  }

  export type CollectionCaseUpdateOneRequiredWithoutPaymentAgreementsNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutPaymentAgreementsInput, CollectionCaseUncheckedCreateWithoutPaymentAgreementsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPaymentAgreementsInput
    upsert?: CollectionCaseUpsertWithoutPaymentAgreementsInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutPaymentAgreementsInput, CollectionCaseUpdateWithoutPaymentAgreementsInput>, CollectionCaseUncheckedUpdateWithoutPaymentAgreementsInput>
  }

  export type InstallmentUpdateManyWithoutPaymentAgreementNestedInput = {
    create?: XOR<InstallmentCreateWithoutPaymentAgreementInput, InstallmentUncheckedCreateWithoutPaymentAgreementInput> | InstallmentCreateWithoutPaymentAgreementInput[] | InstallmentUncheckedCreateWithoutPaymentAgreementInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutPaymentAgreementInput | InstallmentCreateOrConnectWithoutPaymentAgreementInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutPaymentAgreementInput | InstallmentUpsertWithWhereUniqueWithoutPaymentAgreementInput[]
    createMany?: InstallmentCreateManyPaymentAgreementInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutPaymentAgreementInput | InstallmentUpdateWithWhereUniqueWithoutPaymentAgreementInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutPaymentAgreementInput | InstallmentUpdateManyWithWhereWithoutPaymentAgreementInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutPaymentAgreementNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentAgreementInput, PaymentUncheckedCreateWithoutPaymentAgreementInput> | PaymentCreateWithoutPaymentAgreementInput[] | PaymentUncheckedCreateWithoutPaymentAgreementInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentAgreementInput | PaymentCreateOrConnectWithoutPaymentAgreementInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaymentAgreementInput | PaymentUpsertWithWhereUniqueWithoutPaymentAgreementInput[]
    createMany?: PaymentCreateManyPaymentAgreementInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaymentAgreementInput | PaymentUpdateWithWhereUniqueWithoutPaymentAgreementInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaymentAgreementInput | PaymentUpdateManyWithWhereWithoutPaymentAgreementInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DebtorUpdateOneWithoutPaymentAgreementsNestedInput = {
    create?: XOR<DebtorCreateWithoutPaymentAgreementsInput, DebtorUncheckedCreateWithoutPaymentAgreementsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutPaymentAgreementsInput
    upsert?: DebtorUpsertWithoutPaymentAgreementsInput
    disconnect?: DebtorWhereInput | boolean
    delete?: DebtorWhereInput | boolean
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutPaymentAgreementsInput, DebtorUpdateWithoutPaymentAgreementsInput>, DebtorUncheckedUpdateWithoutPaymentAgreementsInput>
  }

  export type InstallmentUncheckedUpdateManyWithoutPaymentAgreementNestedInput = {
    create?: XOR<InstallmentCreateWithoutPaymentAgreementInput, InstallmentUncheckedCreateWithoutPaymentAgreementInput> | InstallmentCreateWithoutPaymentAgreementInput[] | InstallmentUncheckedCreateWithoutPaymentAgreementInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutPaymentAgreementInput | InstallmentCreateOrConnectWithoutPaymentAgreementInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutPaymentAgreementInput | InstallmentUpsertWithWhereUniqueWithoutPaymentAgreementInput[]
    createMany?: InstallmentCreateManyPaymentAgreementInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutPaymentAgreementInput | InstallmentUpdateWithWhereUniqueWithoutPaymentAgreementInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutPaymentAgreementInput | InstallmentUpdateManyWithWhereWithoutPaymentAgreementInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentAgreementNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentAgreementInput, PaymentUncheckedCreateWithoutPaymentAgreementInput> | PaymentCreateWithoutPaymentAgreementInput[] | PaymentUncheckedCreateWithoutPaymentAgreementInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentAgreementInput | PaymentCreateOrConnectWithoutPaymentAgreementInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaymentAgreementInput | PaymentUpsertWithWhereUniqueWithoutPaymentAgreementInput[]
    createMany?: PaymentCreateManyPaymentAgreementInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaymentAgreementInput | PaymentUpdateWithWhereUniqueWithoutPaymentAgreementInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaymentAgreementInput | PaymentUpdateManyWithWhereWithoutPaymentAgreementInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentAgreementCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<PaymentAgreementCreateWithoutInstallmentsInput, PaymentAgreementUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutInstallmentsInput
    connect?: PaymentAgreementWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutInstallmentInput = {
    create?: XOR<PaymentCreateWithoutInstallmentInput, PaymentUncheckedCreateWithoutInstallmentInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutInstallmentInput
    connect?: PaymentWhereUniqueInput
  }

  export type EnumInstallmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.InstallmentStatus
  }

  export type PaymentAgreementUpdateOneRequiredWithoutInstallmentsNestedInput = {
    create?: XOR<PaymentAgreementCreateWithoutInstallmentsInput, PaymentAgreementUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: PaymentAgreementCreateOrConnectWithoutInstallmentsInput
    upsert?: PaymentAgreementUpsertWithoutInstallmentsInput
    connect?: PaymentAgreementWhereUniqueInput
    update?: XOR<XOR<PaymentAgreementUpdateToOneWithWhereWithoutInstallmentsInput, PaymentAgreementUpdateWithoutInstallmentsInput>, PaymentAgreementUncheckedUpdateWithoutInstallmentsInput>
  }

  export type PaymentUpdateOneWithoutInstallmentNestedInput = {
    create?: XOR<PaymentCreateWithoutInstallmentInput, PaymentUncheckedCreateWithoutInstallmentInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutInstallmentInput
    upsert?: PaymentUpsertWithoutInstallmentInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutInstallmentInput, PaymentUpdateWithoutInstallmentInput>, PaymentUncheckedUpdateWithoutInstallmentInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumroleEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumFilter<$PrismaModel> | $Enums.roleEnum
  }

  export type NestedEnumroleEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumWithAggregatesFilter<$PrismaModel> | $Enums.roleEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleEnumFilter<$PrismaModel>
    _max?: NestedEnumroleEnumFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumVerdictStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusFilter<$PrismaModel> | $Enums.VerdictStatus
  }

  export type NestedEnumVerdictStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerdictStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerdictStatusFilter<$PrismaModel>
    _max?: NestedEnumVerdictStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumCalculationTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumFilter<$PrismaModel> | $Enums.CalculationTypeEnum
  }

  export type NestedEnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.CalculationTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumCollectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionStatus | EnumCollectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionStatusFilter<$PrismaModel> | $Enums.CollectionStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumCollectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionStatus | EnumCollectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionStatus[] | ListEnumCollectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CollectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCollectionStatusFilter<$PrismaModel>
    _max?: NestedEnumCollectionStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPersonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeFilter<$PrismaModel> | $Enums.PersonType
  }

  export type NestedEnumIdentificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel> | $Enums.IdentificationType | null
  }

  export type NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel> | $Enums.PersonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonTypeFilter<$PrismaModel>
    _max?: NestedEnumPersonTypeFilter<$PrismaModel>
  }

  export type NestedEnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.IdentificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentAgreementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentAgreementStatus | EnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentAgreementStatus[] | ListEnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentAgreementStatus[] | ListEnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentAgreementStatusFilter<$PrismaModel> | $Enums.PaymentAgreementStatus
  }

  export type NestedEnumPaymentAgreementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentAgreementStatus | EnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentAgreementStatus[] | ListEnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentAgreementStatus[] | ListEnumPaymentAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentAgreementStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentAgreementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentAgreementStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentAgreementStatusFilter<$PrismaModel>
  }

  export type NestedEnumInstallmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusFilter<$PrismaModel> | $Enums.InstallmentStatus
  }

  export type NestedEnumInstallmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstallmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstallmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInstallmentStatusFilter<$PrismaModel>
  }

  export type PlanCreateWithoutTenantsInput = {
    id?: string
    name: string
    price: number
    description?: string | null
    durationDays: number
    isActive?: boolean
  }

  export type PlanUncheckedCreateWithoutTenantsInput = {
    id?: string
    name: string
    price: number
    description?: string | null
    durationDays: number
    isActive?: boolean
  }

  export type PlanCreateOrConnectWithoutTenantsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutTenantsInput, PlanUncheckedCreateWithoutTenantsInput>
  }

  export type BillingInvoiceCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BillingInvoiceDetailCreateNestedManyWithoutBillingInvoiceInput
    payments?: BillingPaymentCreateNestedManyWithoutBillingInvoiceInput
  }

  export type BillingInvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BillingInvoiceDetailUncheckedCreateNestedManyWithoutBillingInvoiceInput
    payments?: BillingPaymentUncheckedCreateNestedManyWithoutBillingInvoiceInput
  }

  export type BillingInvoiceCreateOrConnectWithoutTenantInput = {
    where: BillingInvoiceWhereUniqueInput
    create: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput>
  }

  export type BillingInvoiceCreateManyTenantInputEnvelope = {
    data: BillingInvoiceCreateManyTenantInput | BillingInvoiceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCaseCreateWithoutTenantInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutTenantInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutTenantInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput>
  }

  export type CollectionCaseCreateManyTenantInputEnvelope = {
    data: CollectionCaseCreateManyTenantInput | CollectionCaseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DebtorCreateWithoutTenantInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutTenantInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput>
  }

  export type DebtorCreateManyTenantInputEnvelope = {
    data: DebtorCreateManyTenantInput | DebtorCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantRegistryCreateWithoutTenantInput = {
    id?: string
    kvk?: string | null
    crib?: string | null
    taxId?: string | null
    vatNumber?: string | null
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantRegistryUncheckedCreateWithoutTenantInput = {
    id?: string
    kvk?: string | null
    crib?: string | null
    taxId?: string | null
    vatNumber?: string | null
    legalName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantRegistryCreateOrConnectWithoutTenantInput = {
    where: TenantRegistryWhereUniqueInput
    create: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
  }

  export type VerdictCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutTenantInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput>
  }

  export type VerdictCreateManyTenantInputEnvelope = {
    data: VerdictCreateManyTenantInput | VerdictCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ChatRoomCreateWithoutTenantInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutChatRoomsInput
    messages?: ChatMessageCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomUncheckedCreateWithoutTenantInput = {
    id?: string
    collectionCaseId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomCreateOrConnectWithoutTenantInput = {
    where: ChatRoomWhereUniqueInput
    create: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput>
  }

  export type ChatRoomCreateManyTenantInputEnvelope = {
    data: ChatRoomCreateManyTenantInput | ChatRoomCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PlanUpsertWithoutTenantsInput = {
    update: XOR<PlanUpdateWithoutTenantsInput, PlanUncheckedUpdateWithoutTenantsInput>
    create: XOR<PlanCreateWithoutTenantsInput, PlanUncheckedCreateWithoutTenantsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutTenantsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutTenantsInput, PlanUncheckedUpdateWithoutTenantsInput>
  }

  export type PlanUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlanUncheckedUpdateWithoutTenantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    durationDays?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: BillingInvoiceWhereUniqueInput
    update: XOR<BillingInvoiceUpdateWithoutTenantInput, BillingInvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput>
  }

  export type BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: BillingInvoiceWhereUniqueInput
    data: XOR<BillingInvoiceUpdateWithoutTenantInput, BillingInvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type BillingInvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: BillingInvoiceScalarWhereInput
    data: XOR<BillingInvoiceUpdateManyMutationInput, BillingInvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type BillingInvoiceScalarWhereInput = {
    AND?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
    OR?: BillingInvoiceScalarWhereInput[]
    NOT?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
    id?: StringFilter<"BillingInvoice"> | string
    tenantId?: StringFilter<"BillingInvoice"> | string
    invoiceNumber?: StringFilter<"BillingInvoice"> | string
    amount?: FloatFilter<"BillingInvoice"> | number
    currency?: StringFilter<"BillingInvoice"> | string
    issueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    dueDate?: DateTimeFilter<"BillingInvoice"> | Date | string
    description?: StringNullableFilter<"BillingInvoice"> | string | null
    status?: StringFilter<"BillingInvoice"> | string
    createdAt?: DateTimeFilter<"BillingInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoice"> | Date | string
  }

  export type CollectionCaseUpsertWithWhereUniqueWithoutTenantInput = {
    where: CollectionCaseWhereUniqueInput
    update: XOR<CollectionCaseUpdateWithoutTenantInput, CollectionCaseUncheckedUpdateWithoutTenantInput>
    create: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput>
  }

  export type CollectionCaseUpdateWithWhereUniqueWithoutTenantInput = {
    where: CollectionCaseWhereUniqueInput
    data: XOR<CollectionCaseUpdateWithoutTenantInput, CollectionCaseUncheckedUpdateWithoutTenantInput>
  }

  export type CollectionCaseUpdateManyWithWhereWithoutTenantInput = {
    where: CollectionCaseScalarWhereInput
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyWithoutTenantInput>
  }

  export type CollectionCaseScalarWhereInput = {
    AND?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
    OR?: CollectionCaseScalarWhereInput[]
    NOT?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
    id?: StringFilter<"CollectionCase"> | string
    referenceNumber?: StringNullableFilter<"CollectionCase"> | string | null
    issueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    dueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1SentAt?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1DueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2SentAt?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2DueDate?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    tenantId?: StringFilter<"CollectionCase"> | string
    debtorId?: StringFilter<"CollectionCase"> | string
    amountOriginal?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFilter<"CollectionCase"> | $Enums.CollectionStatus
    createdAt?: DateTimeFilter<"CollectionCase"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionCase"> | Date | string
  }

  export type DebtorUpsertWithWhereUniqueWithoutTenantInput = {
    where: DebtorWhereUniqueInput
    update: XOR<DebtorUpdateWithoutTenantInput, DebtorUncheckedUpdateWithoutTenantInput>
    create: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput>
  }

  export type DebtorUpdateWithWhereUniqueWithoutTenantInput = {
    where: DebtorWhereUniqueInput
    data: XOR<DebtorUpdateWithoutTenantInput, DebtorUncheckedUpdateWithoutTenantInput>
  }

  export type DebtorUpdateManyWithWhereWithoutTenantInput = {
    where: DebtorScalarWhereInput
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyWithoutTenantInput>
  }

  export type DebtorScalarWhereInput = {
    AND?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
    OR?: DebtorScalarWhereInput[]
    NOT?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
    id?: StringFilter<"Debtor"> | string
    tenantId?: StringFilter<"Debtor"> | string
    userId?: StringNullableFilter<"Debtor"> | string | null
    fullname?: StringFilter<"Debtor"> | string
    email?: StringFilter<"Debtor"> | string
    phone?: StringNullableFilter<"Debtor"> | string | null
    address?: StringNullableFilter<"Debtor"> | string | null
    personType?: EnumPersonTypeFilter<"Debtor"> | $Enums.PersonType
    identificationType?: EnumIdentificationTypeNullableFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableFilter<"Debtor"> | string | null
    totalIncome?: FloatNullableFilter<"Debtor"> | number | null
    createdAt?: DateTimeFilter<"Debtor"> | Date | string
    updatedAt?: DateTimeFilter<"Debtor"> | Date | string
  }

  export type TenantRegistryUpsertWithoutTenantInput = {
    update: XOR<TenantRegistryUpdateWithoutTenantInput, TenantRegistryUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantRegistryCreateWithoutTenantInput, TenantRegistryUncheckedCreateWithoutTenantInput>
    where?: TenantRegistryWhereInput
  }

  export type TenantRegistryUpdateToOneWithWhereWithoutTenantInput = {
    where?: TenantRegistryWhereInput
    data: XOR<TenantRegistryUpdateWithoutTenantInput, TenantRegistryUncheckedUpdateWithoutTenantInput>
  }

  export type TenantRegistryUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantRegistryUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    crib?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    vatNumber?: NullableStringFieldUpdateOperationsInput | string | null
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUpsertWithWhereUniqueWithoutTenantInput = {
    where: VerdictWhereUniqueInput
    update: XOR<VerdictUpdateWithoutTenantInput, VerdictUncheckedUpdateWithoutTenantInput>
    create: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput>
  }

  export type VerdictUpdateWithWhereUniqueWithoutTenantInput = {
    where: VerdictWhereUniqueInput
    data: XOR<VerdictUpdateWithoutTenantInput, VerdictUncheckedUpdateWithoutTenantInput>
  }

  export type VerdictUpdateManyWithWhereWithoutTenantInput = {
    where: VerdictScalarWhereInput
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyWithoutTenantInput>
  }

  export type VerdictScalarWhereInput = {
    AND?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
    OR?: VerdictScalarWhereInput[]
    NOT?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
    id?: StringFilter<"Verdict"> | string
    invoiceNumber?: StringFilter<"Verdict"> | string
    creditorName?: StringFilter<"Verdict"> | string
    debtorId?: StringFilter<"Verdict"> | string
    registrationNumber?: StringFilter<"Verdict"> | string
    sentenceAmount?: FloatFilter<"Verdict"> | number
    sentenceDate?: DateTimeFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusFilter<"Verdict"> | $Enums.VerdictStatus
    createdAt?: DateTimeFilter<"Verdict"> | Date | string
    updatedAt?: DateTimeFilter<"Verdict"> | Date | string
    procesalCost?: FloatNullableFilter<"Verdict"> | number | null
    tenantId?: StringFilter<"Verdict"> | string
    notes?: StringNullableFilter<"Verdict"> | string | null
    bailiffId?: StringNullableFilter<"Verdict"> | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    fullname?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    tenantId?: StringFilter<"User"> | string
    role?: EnumroleEnumFilter<"User"> | $Enums.roleEnum
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ChatRoomUpsertWithWhereUniqueWithoutTenantInput = {
    where: ChatRoomWhereUniqueInput
    update: XOR<ChatRoomUpdateWithoutTenantInput, ChatRoomUncheckedUpdateWithoutTenantInput>
    create: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput>
  }

  export type ChatRoomUpdateWithWhereUniqueWithoutTenantInput = {
    where: ChatRoomWhereUniqueInput
    data: XOR<ChatRoomUpdateWithoutTenantInput, ChatRoomUncheckedUpdateWithoutTenantInput>
  }

  export type ChatRoomUpdateManyWithWhereWithoutTenantInput = {
    where: ChatRoomScalarWhereInput
    data: XOR<ChatRoomUpdateManyMutationInput, ChatRoomUncheckedUpdateManyWithoutTenantInput>
  }

  export type ChatRoomScalarWhereInput = {
    AND?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
    OR?: ChatRoomScalarWhereInput[]
    NOT?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
    id?: StringFilter<"ChatRoom"> | string
    tenantId?: StringFilter<"ChatRoom"> | string
    collectionCaseId?: StringFilter<"ChatRoom"> | string
    name?: StringFilter<"ChatRoom"> | string
    createdAt?: DateTimeFilter<"ChatRoom"> | Date | string
    updatedAt?: DateTimeFilter<"ChatRoom"> | Date | string
  }

  export type TenantCreateWithoutRegistryInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutTenantsInput
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRegistryInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planId?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRegistryInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRegistryInput, TenantUncheckedCreateWithoutRegistryInput>
  }

  export type TenantUpsertWithoutRegistryInput = {
    update: XOR<TenantUpdateWithoutRegistryInput, TenantUncheckedUpdateWithoutRegistryInput>
    create: XOR<TenantCreateWithoutRegistryInput, TenantUncheckedCreateWithoutRegistryInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRegistryInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRegistryInput, TenantUncheckedUpdateWithoutRegistryInput>
  }

  export type TenantUpdateWithoutRegistryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutTenantsNestedInput
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRegistryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutTenantsInput
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planId?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type DebtorCreateWithoutUserInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutUserInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput>
  }

  export type DebtorCreateManyUserInputEnvelope = {
    data: DebtorCreateManyUserInput | DebtorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VerdictCreateWithoutBailiffInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutBailiffInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutBailiffInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput>
  }

  export type VerdictCreateManyBailiffInputEnvelope = {
    data: VerdictCreateManyBailiffInput | VerdictCreateManyBailiffInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutSenderInput = {
    id?: string
    message: string
    fileUrl?: string | null
    fileName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    room: ChatRoomCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    roomId: string
    message: string
    fileUrl?: string | null
    fileName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageCreateManySenderInputEnvelope = {
    data: ChatMessageCreateManySenderInput | ChatMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutTenantsNestedInput
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DebtorUpsertWithWhereUniqueWithoutUserInput = {
    where: DebtorWhereUniqueInput
    update: XOR<DebtorUpdateWithoutUserInput, DebtorUncheckedUpdateWithoutUserInput>
    create: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput>
  }

  export type DebtorUpdateWithWhereUniqueWithoutUserInput = {
    where: DebtorWhereUniqueInput
    data: XOR<DebtorUpdateWithoutUserInput, DebtorUncheckedUpdateWithoutUserInput>
  }

  export type DebtorUpdateManyWithWhereWithoutUserInput = {
    where: DebtorScalarWhereInput
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyWithoutUserInput>
  }

  export type VerdictUpsertWithWhereUniqueWithoutBailiffInput = {
    where: VerdictWhereUniqueInput
    update: XOR<VerdictUpdateWithoutBailiffInput, VerdictUncheckedUpdateWithoutBailiffInput>
    create: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput>
  }

  export type VerdictUpdateWithWhereUniqueWithoutBailiffInput = {
    where: VerdictWhereUniqueInput
    data: XOR<VerdictUpdateWithoutBailiffInput, VerdictUncheckedUpdateWithoutBailiffInput>
  }

  export type VerdictUpdateManyWithWhereWithoutBailiffInput = {
    where: VerdictScalarWhereInput
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyWithoutBailiffInput>
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    roomId?: StringFilter<"ChatMessage"> | string
    senderId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    fileUrl?: StringNullableFilter<"ChatMessage"> | string | null
    fileName?: StringNullableFilter<"ChatMessage"> | string | null
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type UserCreateWithoutVerdictBailiffsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    debtors?: DebtorCreateNestedManyWithoutUserInput
    messages?: ChatMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutVerdictBailiffsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    tenantId: string
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutVerdictBailiffsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerdictBailiffsInput, UserUncheckedCreateWithoutVerdictBailiffsInput>
  }

  export type DebtorCreateWithoutVerdictsInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutVerdictsInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutVerdictsInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
  }

  export type TenantCreateWithoutVerdictsInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutTenantsInput
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVerdictsInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planId?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVerdictsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
  }

  export type VerdictAttachmentCreateWithoutVerdictInput = {
    id?: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
  }

  export type VerdictAttachmentUncheckedCreateWithoutVerdictInput = {
    id?: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
  }

  export type VerdictAttachmentCreateOrConnectWithoutVerdictInput = {
    where: VerdictAttachmentWhereUniqueInput
    create: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictAttachmentCreateManyVerdictInputEnvelope = {
    data: VerdictAttachmentCreateManyVerdictInput | VerdictAttachmentCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type VerdictBailiffServicesCreateWithoutVerdictInput = {
    id?: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictBailiffServicesUncheckedCreateWithoutVerdictInput = {
    id?: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictBailiffServicesCreateOrConnectWithoutVerdictInput = {
    where: VerdictBailiffServicesWhereUniqueInput
    create: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictBailiffServicesCreateManyVerdictInputEnvelope = {
    data: VerdictBailiffServicesCreateManyVerdictInput | VerdictBailiffServicesCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type VerdictEmbargoCreateWithoutVerdictInput = {
    id?: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictEmbargoUncheckedCreateWithoutVerdictInput = {
    id?: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictEmbargoCreateOrConnectWithoutVerdictInput = {
    where: VerdictEmbargoWhereUniqueInput
    create: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictEmbargoCreateManyVerdictInputEnvelope = {
    data: VerdictEmbargoCreateManyVerdictInput | VerdictEmbargoCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type VerdictInterestCreateWithoutVerdictInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: VerdictInterestDetailsCreateNestedManyWithoutVerdictInterestInput
  }

  export type VerdictInterestUncheckedCreateWithoutVerdictInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: VerdictInterestDetailsUncheckedCreateNestedManyWithoutVerdictInterestInput
  }

  export type VerdictInterestCreateOrConnectWithoutVerdictInput = {
    where: VerdictInterestWhereUniqueInput
    create: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictInterestCreateManyVerdictInputEnvelope = {
    data: VerdictInterestCreateManyVerdictInput | VerdictInterestCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutVerdictBailiffsInput = {
    update: XOR<UserUpdateWithoutVerdictBailiffsInput, UserUncheckedUpdateWithoutVerdictBailiffsInput>
    create: XOR<UserCreateWithoutVerdictBailiffsInput, UserUncheckedCreateWithoutVerdictBailiffsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerdictBailiffsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerdictBailiffsInput, UserUncheckedUpdateWithoutVerdictBailiffsInput>
  }

  export type UserUpdateWithoutVerdictBailiffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    messages?: ChatMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutVerdictBailiffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    messages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type DebtorUpsertWithoutVerdictsInput = {
    update: XOR<DebtorUpdateWithoutVerdictsInput, DebtorUncheckedUpdateWithoutVerdictsInput>
    create: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutVerdictsInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutVerdictsInput, DebtorUncheckedUpdateWithoutVerdictsInput>
  }

  export type DebtorUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type TenantUpsertWithoutVerdictsInput = {
    update: XOR<TenantUpdateWithoutVerdictsInput, TenantUncheckedUpdateWithoutVerdictsInput>
    create: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVerdictsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVerdictsInput, TenantUncheckedUpdateWithoutVerdictsInput>
  }

  export type TenantUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutTenantsNestedInput
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictAttachmentWhereUniqueInput
    update: XOR<VerdictAttachmentUpdateWithoutVerdictInput, VerdictAttachmentUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictAttachmentWhereUniqueInput
    data: XOR<VerdictAttachmentUpdateWithoutVerdictInput, VerdictAttachmentUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictAttachmentScalarWhereInput
    data: XOR<VerdictAttachmentUpdateManyMutationInput, VerdictAttachmentUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictAttachmentScalarWhereInput = {
    AND?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
    OR?: VerdictAttachmentScalarWhereInput[]
    NOT?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
    id?: StringFilter<"VerdictAttachment"> | string
    verdictId?: StringFilter<"VerdictAttachment"> | string
    filePath?: StringFilter<"VerdictAttachment"> | string
    fileSize?: BigIntFilter<"VerdictAttachment"> | bigint | number
    createdAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictAttachment"> | Date | string
    fileName?: StringFilter<"VerdictAttachment"> | string
  }

  export type VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictBailiffServicesWhereUniqueInput
    update: XOR<VerdictBailiffServicesUpdateWithoutVerdictInput, VerdictBailiffServicesUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictBailiffServicesWhereUniqueInput
    data: XOR<VerdictBailiffServicesUpdateWithoutVerdictInput, VerdictBailiffServicesUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictBailiffServicesScalarWhereInput
    data: XOR<VerdictBailiffServicesUpdateManyMutationInput, VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictBailiffServicesScalarWhereInput = {
    AND?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
    OR?: VerdictBailiffServicesScalarWhereInput[]
    NOT?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
    id?: StringFilter<"VerdictBailiffServices"> | string
    verdictId?: StringFilter<"VerdictBailiffServices"> | string
    serviceType?: StringFilter<"VerdictBailiffServices"> | string
    serviceCost?: FloatFilter<"VerdictBailiffServices"> | number
    createdAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
  }

  export type VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictEmbargoWhereUniqueInput
    update: XOR<VerdictEmbargoUpdateWithoutVerdictInput, VerdictEmbargoUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictEmbargoWhereUniqueInput
    data: XOR<VerdictEmbargoUpdateWithoutVerdictInput, VerdictEmbargoUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictEmbargoScalarWhereInput
    data: XOR<VerdictEmbargoUpdateManyMutationInput, VerdictEmbargoUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictEmbargoScalarWhereInput = {
    AND?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
    OR?: VerdictEmbargoScalarWhereInput[]
    NOT?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
    id?: StringFilter<"VerdictEmbargo"> | string
    verdictId?: StringFilter<"VerdictEmbargo"> | string
    companyName?: StringFilter<"VerdictEmbargo"> | string
    companyPhone?: StringFilter<"VerdictEmbargo"> | string
    companyEmail?: StringFilter<"VerdictEmbargo"> | string
    companyAddress?: StringFilter<"VerdictEmbargo"> | string
    embargoType?: StringFilter<"VerdictEmbargo"> | string
    embargoDate?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    embargoAmount?: FloatFilter<"VerdictEmbargo"> | number
    totalAmount?: FloatFilter<"VerdictEmbargo"> | number
    createdAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictEmbargo"> | Date | string
  }

  export type VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictInterestWhereUniqueInput
    update: XOR<VerdictInterestUpdateWithoutVerdictInput, VerdictInterestUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictInterestWhereUniqueInput
    data: XOR<VerdictInterestUpdateWithoutVerdictInput, VerdictInterestUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictInterestUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictInterestScalarWhereInput
    data: XOR<VerdictInterestUpdateManyMutationInput, VerdictInterestUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictInterestScalarWhereInput = {
    AND?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
    OR?: VerdictInterestScalarWhereInput[]
    NOT?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
    id?: StringFilter<"VerdictInterest"> | string
    interestType?: IntFilter<"VerdictInterest"> | number
    baseAmount?: FloatFilter<"VerdictInterest"> | number
    calculatedInterest?: FloatNullableFilter<"VerdictInterest"> | number | null
    calculationStart?: DateTimeFilter<"VerdictInterest"> | Date | string
    calculationEnd?: DateTimeFilter<"VerdictInterest"> | Date | string
    totalInterest?: FloatFilter<"VerdictInterest"> | number
    createdAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterest"> | Date | string
    verdictId?: StringNullableFilter<"VerdictInterest"> | string | null
  }

  export type VerdictCreateWithoutVerdictInterestInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutVerdictInterestInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutVerdictInterestInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutVerdictInterestInput, VerdictUncheckedCreateWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsCreateWithoutVerdictInterestInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestDetailsCreateOrConnectWithoutVerdictInterestInput = {
    where: VerdictInterestDetailsWhereUniqueInput
    create: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsCreateManyVerdictInterestInputEnvelope = {
    data: VerdictInterestDetailsCreateManyVerdictInterestInput | VerdictInterestDetailsCreateManyVerdictInterestInput[]
    skipDuplicates?: boolean
  }

  export type VerdictUpsertWithoutVerdictInterestInput = {
    update: XOR<VerdictUpdateWithoutVerdictInterestInput, VerdictUncheckedUpdateWithoutVerdictInterestInput>
    create: XOR<VerdictCreateWithoutVerdictInterestInput, VerdictUncheckedCreateWithoutVerdictInterestInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutVerdictInterestInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutVerdictInterestInput, VerdictUncheckedUpdateWithoutVerdictInterestInput>
  }

  export type VerdictUpdateWithoutVerdictInterestInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutVerdictInterestInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdictInterestInput = {
    where: VerdictInterestDetailsWhereUniqueInput
    update: XOR<VerdictInterestDetailsUpdateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedUpdateWithoutVerdictInterestInput>
    create: XOR<VerdictInterestDetailsCreateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdictInterestInput = {
    where: VerdictInterestDetailsWhereUniqueInput
    data: XOR<VerdictInterestDetailsUpdateWithoutVerdictInterestInput, VerdictInterestDetailsUncheckedUpdateWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsUpdateManyWithWhereWithoutVerdictInterestInput = {
    where: VerdictInterestDetailsScalarWhereInput
    data: XOR<VerdictInterestDetailsUpdateManyMutationInput, VerdictInterestDetailsUncheckedUpdateManyWithoutVerdictInterestInput>
  }

  export type VerdictInterestDetailsScalarWhereInput = {
    AND?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
    OR?: VerdictInterestDetailsScalarWhereInput[]
    NOT?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
    id?: StringFilter<"VerdictInterestDetails"> | string
    period?: StringFilter<"VerdictInterestDetails"> | string
    periodStart?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    periodEnd?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    days?: IntFilter<"VerdictInterestDetails"> | number
    annualRate?: FloatFilter<"VerdictInterestDetails"> | number
    proportionalRate?: FloatFilter<"VerdictInterestDetails"> | number
    baseAmount?: FloatFilter<"VerdictInterestDetails"> | number
    interest?: FloatFilter<"VerdictInterestDetails"> | number
    total?: FloatFilter<"VerdictInterestDetails"> | number
    verdictInterestId?: StringFilter<"VerdictInterestDetails"> | string
    createdAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    updatedAt?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
  }

  export type VerdictInterestCreateWithoutDetailsInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdict?: VerdictCreateNestedOneWithoutVerdictInterestInput
  }

  export type VerdictInterestUncheckedCreateWithoutDetailsInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verdictId?: string | null
  }

  export type VerdictInterestCreateOrConnectWithoutDetailsInput = {
    where: VerdictInterestWhereUniqueInput
    create: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
  }

  export type VerdictInterestUpsertWithoutDetailsInput = {
    update: XOR<VerdictInterestUpdateWithoutDetailsInput, VerdictInterestUncheckedUpdateWithoutDetailsInput>
    create: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
    where?: VerdictInterestWhereInput
  }

  export type VerdictInterestUpdateToOneWithWhereWithoutDetailsInput = {
    where?: VerdictInterestWhereInput
    data: XOR<VerdictInterestUpdateWithoutDetailsInput, VerdictInterestUncheckedUpdateWithoutDetailsInput>
  }

  export type VerdictInterestUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneWithoutVerdictInterestNestedInput
  }

  export type VerdictInterestUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdictId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictCreateWithoutVerdictEmbargoInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutVerdictEmbargoInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutVerdictEmbargoInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutVerdictEmbargoInput, VerdictUncheckedCreateWithoutVerdictEmbargoInput>
  }

  export type VerdictUpsertWithoutVerdictEmbargoInput = {
    update: XOR<VerdictUpdateWithoutVerdictEmbargoInput, VerdictUncheckedUpdateWithoutVerdictEmbargoInput>
    create: XOR<VerdictCreateWithoutVerdictEmbargoInput, VerdictUncheckedCreateWithoutVerdictEmbargoInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutVerdictEmbargoInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutVerdictEmbargoInput, VerdictUncheckedUpdateWithoutVerdictEmbargoInput>
  }

  export type VerdictUpdateWithoutVerdictEmbargoInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutVerdictEmbargoInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictCreateWithoutBailiffServicesInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutBailiffServicesInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutBailiffServicesInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutBailiffServicesInput, VerdictUncheckedCreateWithoutBailiffServicesInput>
  }

  export type VerdictUpsertWithoutBailiffServicesInput = {
    update: XOR<VerdictUpdateWithoutBailiffServicesInput, VerdictUncheckedUpdateWithoutBailiffServicesInput>
    create: XOR<VerdictCreateWithoutBailiffServicesInput, VerdictUncheckedCreateWithoutBailiffServicesInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutBailiffServicesInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutBailiffServicesInput, VerdictUncheckedUpdateWithoutBailiffServicesInput>
  }

  export type VerdictUpdateWithoutBailiffServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutBailiffServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictCreateWithoutAttachmentsInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutAttachmentsInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
  }

  export type VerdictUpsertWithoutAttachmentsInput = {
    update: XOR<VerdictUpdateWithoutAttachmentsInput, VerdictUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutAttachmentsInput, VerdictUncheckedUpdateWithoutAttachmentsInput>
  }

  export type VerdictUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type InterestDetailCreateWithoutInterestTypeInput = {
    date: string
    rate: number
  }

  export type InterestDetailUncheckedCreateWithoutInterestTypeInput = {
    id?: number
    date: string
    rate: number
  }

  export type InterestDetailCreateOrConnectWithoutInterestTypeInput = {
    where: InterestDetailWhereUniqueInput
    create: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput>
  }

  export type InterestDetailCreateManyInterestTypeInputEnvelope = {
    data: InterestDetailCreateManyInterestTypeInput | InterestDetailCreateManyInterestTypeInput[]
    skipDuplicates?: boolean
  }

  export type InterestDetailUpsertWithWhereUniqueWithoutInterestTypeInput = {
    where: InterestDetailWhereUniqueInput
    update: XOR<InterestDetailUpdateWithoutInterestTypeInput, InterestDetailUncheckedUpdateWithoutInterestTypeInput>
    create: XOR<InterestDetailCreateWithoutInterestTypeInput, InterestDetailUncheckedCreateWithoutInterestTypeInput>
  }

  export type InterestDetailUpdateWithWhereUniqueWithoutInterestTypeInput = {
    where: InterestDetailWhereUniqueInput
    data: XOR<InterestDetailUpdateWithoutInterestTypeInput, InterestDetailUncheckedUpdateWithoutInterestTypeInput>
  }

  export type InterestDetailUpdateManyWithWhereWithoutInterestTypeInput = {
    where: InterestDetailScalarWhereInput
    data: XOR<InterestDetailUpdateManyMutationInput, InterestDetailUncheckedUpdateManyWithoutInterestTypeInput>
  }

  export type InterestDetailScalarWhereInput = {
    AND?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
    OR?: InterestDetailScalarWhereInput[]
    NOT?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
    id?: IntFilter<"InterestDetail"> | number
    date?: StringFilter<"InterestDetail"> | string
    rate?: FloatFilter<"InterestDetail"> | number
    interestTypeId?: IntFilter<"InterestDetail"> | number
  }

  export type InterestTypeCreateWithoutDetailsInput = {
    name: string
    calculationType: $Enums.CalculationTypeEnum
  }

  export type InterestTypeUncheckedCreateWithoutDetailsInput = {
    id?: number
    name: string
    calculationType: $Enums.CalculationTypeEnum
  }

  export type InterestTypeCreateOrConnectWithoutDetailsInput = {
    where: InterestTypeWhereUniqueInput
    create: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
  }

  export type InterestTypeUpsertWithoutDetailsInput = {
    update: XOR<InterestTypeUpdateWithoutDetailsInput, InterestTypeUncheckedUpdateWithoutDetailsInput>
    create: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
    where?: InterestTypeWhereInput
  }

  export type InterestTypeUpdateToOneWithWhereWithoutDetailsInput = {
    where?: InterestTypeWhereInput
    data: XOR<InterestTypeUpdateWithoutDetailsInput, InterestTypeUncheckedUpdateWithoutDetailsInput>
  }

  export type InterestTypeUpdateWithoutDetailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type InterestTypeUncheckedUpdateWithoutDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calculationType?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type TenantCreateWithoutBillingInvoiceInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutTenantsInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBillingInvoiceInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planId?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBillingInvoiceInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBillingInvoiceInput, TenantUncheckedCreateWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailCreateWithoutBillingInvoiceInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingInvoiceDetailCreateOrConnectWithoutBillingInvoiceInput = {
    where: BillingInvoiceDetailWhereUniqueInput
    create: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailCreateManyBillingInvoiceInputEnvelope = {
    data: BillingInvoiceDetailCreateManyBillingInvoiceInput | BillingInvoiceDetailCreateManyBillingInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type BillingPaymentCreateWithoutBillingInvoiceInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPaymentUncheckedCreateWithoutBillingInvoiceInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPaymentCreateOrConnectWithoutBillingInvoiceInput = {
    where: BillingPaymentWhereUniqueInput
    create: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput>
  }

  export type BillingPaymentCreateManyBillingInvoiceInputEnvelope = {
    data: BillingPaymentCreateManyBillingInvoiceInput | BillingPaymentCreateManyBillingInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutBillingInvoiceInput = {
    update: XOR<TenantUpdateWithoutBillingInvoiceInput, TenantUncheckedUpdateWithoutBillingInvoiceInput>
    create: XOR<TenantCreateWithoutBillingInvoiceInput, TenantUncheckedCreateWithoutBillingInvoiceInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBillingInvoiceInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBillingInvoiceInput, TenantUncheckedUpdateWithoutBillingInvoiceInput>
  }

  export type TenantUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutTenantsNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BillingInvoiceDetailUpsertWithWhereUniqueWithoutBillingInvoiceInput = {
    where: BillingInvoiceDetailWhereUniqueInput
    update: XOR<BillingInvoiceDetailUpdateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedUpdateWithoutBillingInvoiceInput>
    create: XOR<BillingInvoiceDetailCreateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailUpdateWithWhereUniqueWithoutBillingInvoiceInput = {
    where: BillingInvoiceDetailWhereUniqueInput
    data: XOR<BillingInvoiceDetailUpdateWithoutBillingInvoiceInput, BillingInvoiceDetailUncheckedUpdateWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailUpdateManyWithWhereWithoutBillingInvoiceInput = {
    where: BillingInvoiceDetailScalarWhereInput
    data: XOR<BillingInvoiceDetailUpdateManyMutationInput, BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceInput>
  }

  export type BillingInvoiceDetailScalarWhereInput = {
    AND?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
    OR?: BillingInvoiceDetailScalarWhereInput[]
    NOT?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
    id?: StringFilter<"BillingInvoiceDetail"> | string
    itemDescription?: StringFilter<"BillingInvoiceDetail"> | string
    itemQuantity?: IntFilter<"BillingInvoiceDetail"> | number
    itemUnitPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalPrice?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxRate?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTaxAmount?: FloatFilter<"BillingInvoiceDetail"> | number
    itemTotalWithTax?: FloatFilter<"BillingInvoiceDetail"> | number
    createdAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingInvoiceDetail"> | string | null
  }

  export type BillingPaymentUpsertWithWhereUniqueWithoutBillingInvoiceInput = {
    where: BillingPaymentWhereUniqueInput
    update: XOR<BillingPaymentUpdateWithoutBillingInvoiceInput, BillingPaymentUncheckedUpdateWithoutBillingInvoiceInput>
    create: XOR<BillingPaymentCreateWithoutBillingInvoiceInput, BillingPaymentUncheckedCreateWithoutBillingInvoiceInput>
  }

  export type BillingPaymentUpdateWithWhereUniqueWithoutBillingInvoiceInput = {
    where: BillingPaymentWhereUniqueInput
    data: XOR<BillingPaymentUpdateWithoutBillingInvoiceInput, BillingPaymentUncheckedUpdateWithoutBillingInvoiceInput>
  }

  export type BillingPaymentUpdateManyWithWhereWithoutBillingInvoiceInput = {
    where: BillingPaymentScalarWhereInput
    data: XOR<BillingPaymentUpdateManyMutationInput, BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceInput>
  }

  export type BillingPaymentScalarWhereInput = {
    AND?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
    OR?: BillingPaymentScalarWhereInput[]
    NOT?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
    id?: StringFilter<"BillingPayment"> | string
    paymentDate?: DateTimeFilter<"BillingPayment"> | Date | string
    amount?: FloatFilter<"BillingPayment"> | number
    paymentMethod?: StringFilter<"BillingPayment"> | string
    transactionId?: StringNullableFilter<"BillingPayment"> | string | null
    status?: StringFilter<"BillingPayment"> | string
    createdAt?: DateTimeFilter<"BillingPayment"> | Date | string
    updatedAt?: DateTimeFilter<"BillingPayment"> | Date | string
    billingInvoiceId?: StringNullableFilter<"BillingPayment"> | string | null
  }

  export type BillingInvoiceCreateWithoutDetailsInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBillingInvoiceInput
    payments?: BillingPaymentCreateNestedManyWithoutBillingInvoiceInput
  }

  export type BillingInvoiceUncheckedCreateWithoutDetailsInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: BillingPaymentUncheckedCreateNestedManyWithoutBillingInvoiceInput
  }

  export type BillingInvoiceCreateOrConnectWithoutDetailsInput = {
    where: BillingInvoiceWhereUniqueInput
    create: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
  }

  export type BillingInvoiceUpsertWithoutDetailsInput = {
    update: XOR<BillingInvoiceUpdateWithoutDetailsInput, BillingInvoiceUncheckedUpdateWithoutDetailsInput>
    create: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
    where?: BillingInvoiceWhereInput
  }

  export type BillingInvoiceUpdateToOneWithWhereWithoutDetailsInput = {
    where?: BillingInvoiceWhereInput
    data: XOR<BillingInvoiceUpdateWithoutDetailsInput, BillingInvoiceUncheckedUpdateWithoutDetailsInput>
  }

  export type BillingInvoiceUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUpdateManyWithoutBillingInvoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceNestedInput
  }

  export type BillingInvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBillingInvoiceInput
    details?: BillingInvoiceDetailCreateNestedManyWithoutBillingInvoiceInput
  }

  export type BillingInvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BillingInvoiceDetailUncheckedCreateNestedManyWithoutBillingInvoiceInput
  }

  export type BillingInvoiceCreateOrConnectWithoutPaymentsInput = {
    where: BillingInvoiceWhereUniqueInput
    create: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type BillingInvoiceUpsertWithoutPaymentsInput = {
    update: XOR<BillingInvoiceUpdateWithoutPaymentsInput, BillingInvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
    where?: BillingInvoiceWhereInput
  }

  export type BillingInvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BillingInvoiceWhereInput
    data: XOR<BillingInvoiceUpdateWithoutPaymentsInput, BillingInvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type BillingInvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBillingInvoiceNestedInput
    details?: BillingInvoiceDetailUpdateManyWithoutBillingInvoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceNestedInput
  }

  export type TenantCreateWithoutPlanInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPlanInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPlanInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPlanInput, TenantUncheckedCreateWithoutPlanInput>
  }

  export type TenantCreateManyPlanInputEnvelope = {
    data: TenantCreateManyPlanInput | TenantCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithWhereUniqueWithoutPlanInput = {
    where: TenantWhereUniqueInput
    update: XOR<TenantUpdateWithoutPlanInput, TenantUncheckedUpdateWithoutPlanInput>
    create: XOR<TenantCreateWithoutPlanInput, TenantUncheckedCreateWithoutPlanInput>
  }

  export type TenantUpdateWithWhereUniqueWithoutPlanInput = {
    where: TenantWhereUniqueInput
    data: XOR<TenantUpdateWithoutPlanInput, TenantUncheckedUpdateWithoutPlanInput>
  }

  export type TenantUpdateManyWithWhereWithoutPlanInput = {
    where: TenantScalarWhereInput
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyWithoutPlanInput>
  }

  export type TenantScalarWhereInput = {
    AND?: TenantScalarWhereInput | TenantScalarWhereInput[]
    OR?: TenantScalarWhereInput[]
    NOT?: TenantScalarWhereInput | TenantScalarWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    subdomain?: StringFilter<"Tenant"> | string
    contactEmail?: StringFilter<"Tenant"> | string
    countryCode?: StringFilter<"Tenant"> | string
    address?: StringNullableFilter<"Tenant"> | string | null
    city?: StringNullableFilter<"Tenant"> | string | null
    logoUrl?: StringNullableFilter<"Tenant"> | string | null
    numberOfEmployees?: IntNullableFilter<"Tenant"> | number | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    website?: StringNullableFilter<"Tenant"> | string | null
    planId?: StringNullableFilter<"Tenant"> | string | null
    planStatus?: StringFilter<"Tenant"> | string
    planExpiresAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    termsAccepted?: BoolFilter<"Tenant"> | boolean
    isActive?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
  }

  export type DebtorCreateWithoutCollectionCasesInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutCollectionCasesInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutCollectionCasesInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutCollectionCasesInput, DebtorUncheckedCreateWithoutCollectionCasesInput>
  }

  export type TenantCreateWithoutCollectionCasesInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutTenantsInput
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCollectionCasesInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planId?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCollectionCasesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCollectionCasesInput, TenantUncheckedCreateWithoutCollectionCasesInput>
  }

  export type NotificationCreateWithoutCollectionCaseInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutCollectionCaseInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutCollectionCaseInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput>
  }

  export type NotificationCreateManyCollectionCaseInputEnvelope = {
    data: NotificationCreateManyCollectionCaseInput | NotificationCreateManyCollectionCaseInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCollectionCaseInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
    PaymentAgreement?: PaymentAgreementCreateNestedOneWithoutPaymentsInput
    Installment?: InstallmentCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutCollectionCaseInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
    paymentAgreementId?: string | null
    Installment?: InstallmentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutCollectionCaseInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PaymentCreateManyCollectionCaseInputEnvelope = {
    data: PaymentCreateManyCollectionCaseInput | PaymentCreateManyCollectionCaseInput[]
    skipDuplicates?: boolean
  }

  export type PaymentAgreementCreateWithoutCollectionCaseInput = {
    id?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    installments?: InstallmentCreateNestedManyWithoutPaymentAgreementInput
    payments?: PaymentCreateNestedManyWithoutPaymentAgreementInput
    Debtor?: DebtorCreateNestedOneWithoutPaymentAgreementsInput
  }

  export type PaymentAgreementUncheckedCreateWithoutCollectionCaseInput = {
    id?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtorId?: string | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutPaymentAgreementInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPaymentAgreementInput
  }

  export type PaymentAgreementCreateOrConnectWithoutCollectionCaseInput = {
    where: PaymentAgreementWhereUniqueInput
    create: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PaymentAgreementCreateManyCollectionCaseInputEnvelope = {
    data: PaymentAgreementCreateManyCollectionCaseInput | PaymentAgreementCreateManyCollectionCaseInput[]
    skipDuplicates?: boolean
  }

  export type PenaltyCreateWithoutCollectionCaseInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PenaltyUncheckedCreateWithoutCollectionCaseInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PenaltyCreateOrConnectWithoutCollectionCaseInput = {
    where: PenaltyWhereUniqueInput
    create: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PenaltyCreateManyCollectionCaseInputEnvelope = {
    data: PenaltyCreateManyCollectionCaseInput | PenaltyCreateManyCollectionCaseInput[]
    skipDuplicates?: boolean
  }

  export type ChatRoomCreateWithoutCollectionCaseInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutChatRoomsInput
    messages?: ChatMessageCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomUncheckedCreateWithoutCollectionCaseInput = {
    id?: string
    tenantId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomCreateOrConnectWithoutCollectionCaseInput = {
    where: ChatRoomWhereUniqueInput
    create: XOR<ChatRoomCreateWithoutCollectionCaseInput, ChatRoomUncheckedCreateWithoutCollectionCaseInput>
  }

  export type ChatRoomCreateManyCollectionCaseInputEnvelope = {
    data: ChatRoomCreateManyCollectionCaseInput | ChatRoomCreateManyCollectionCaseInput[]
    skipDuplicates?: boolean
  }

  export type DebtorUpsertWithoutCollectionCasesInput = {
    update: XOR<DebtorUpdateWithoutCollectionCasesInput, DebtorUncheckedUpdateWithoutCollectionCasesInput>
    create: XOR<DebtorCreateWithoutCollectionCasesInput, DebtorUncheckedCreateWithoutCollectionCasesInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutCollectionCasesInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutCollectionCasesInput, DebtorUncheckedUpdateWithoutCollectionCasesInput>
  }

  export type DebtorUpdateWithoutCollectionCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutCollectionCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type TenantUpsertWithoutCollectionCasesInput = {
    update: XOR<TenantUpdateWithoutCollectionCasesInput, TenantUncheckedUpdateWithoutCollectionCasesInput>
    create: XOR<TenantCreateWithoutCollectionCasesInput, TenantUncheckedCreateWithoutCollectionCasesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCollectionCasesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCollectionCasesInput, TenantUncheckedUpdateWithoutCollectionCasesInput>
  }

  export type TenantUpdateWithoutCollectionCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutTenantsNestedInput
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCollectionCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutCollectionCaseInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCollectionCaseInput, NotificationUncheckedUpdateWithoutCollectionCaseInput>
    create: XOR<NotificationCreateWithoutCollectionCaseInput, NotificationUncheckedCreateWithoutCollectionCaseInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCollectionCaseInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCollectionCaseInput, NotificationUncheckedUpdateWithoutCollectionCaseInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCollectionCaseInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutCollectionCaseInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    collectionCaseId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    sentAt?: DateTimeFilter<"Notification"> | Date | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutCollectionCaseInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCollectionCaseInput, PaymentUncheckedUpdateWithoutCollectionCaseInput>
    create: XOR<PaymentCreateWithoutCollectionCaseInput, PaymentUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCollectionCaseInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCollectionCaseInput, PaymentUncheckedUpdateWithoutCollectionCaseInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCollectionCaseInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCollectionCaseInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    collectionCaseId?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    paymentAgreementId?: StringNullableFilter<"Payment"> | string | null
  }

  export type PaymentAgreementUpsertWithWhereUniqueWithoutCollectionCaseInput = {
    where: PaymentAgreementWhereUniqueInput
    update: XOR<PaymentAgreementUpdateWithoutCollectionCaseInput, PaymentAgreementUncheckedUpdateWithoutCollectionCaseInput>
    create: XOR<PaymentAgreementCreateWithoutCollectionCaseInput, PaymentAgreementUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PaymentAgreementUpdateWithWhereUniqueWithoutCollectionCaseInput = {
    where: PaymentAgreementWhereUniqueInput
    data: XOR<PaymentAgreementUpdateWithoutCollectionCaseInput, PaymentAgreementUncheckedUpdateWithoutCollectionCaseInput>
  }

  export type PaymentAgreementUpdateManyWithWhereWithoutCollectionCaseInput = {
    where: PaymentAgreementScalarWhereInput
    data: XOR<PaymentAgreementUpdateManyMutationInput, PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseInput>
  }

  export type PaymentAgreementScalarWhereInput = {
    AND?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
    OR?: PaymentAgreementScalarWhereInput[]
    NOT?: PaymentAgreementScalarWhereInput | PaymentAgreementScalarWhereInput[]
    id?: StringFilter<"PaymentAgreement"> | string
    collectionCaseId?: StringFilter<"PaymentAgreement"> | string
    totalAmount?: DecimalFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFilter<"PaymentAgreement"> | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFilter<"PaymentAgreement"> | number
    startDate?: DateTimeFilter<"PaymentAgreement"> | Date | string
    status?: EnumPaymentAgreementStatusFilter<"PaymentAgreement"> | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentAgreement"> | Date | string
    debtorId?: StringNullableFilter<"PaymentAgreement"> | string | null
  }

  export type PenaltyUpsertWithWhereUniqueWithoutCollectionCaseInput = {
    where: PenaltyWhereUniqueInput
    update: XOR<PenaltyUpdateWithoutCollectionCaseInput, PenaltyUncheckedUpdateWithoutCollectionCaseInput>
    create: XOR<PenaltyCreateWithoutCollectionCaseInput, PenaltyUncheckedCreateWithoutCollectionCaseInput>
  }

  export type PenaltyUpdateWithWhereUniqueWithoutCollectionCaseInput = {
    where: PenaltyWhereUniqueInput
    data: XOR<PenaltyUpdateWithoutCollectionCaseInput, PenaltyUncheckedUpdateWithoutCollectionCaseInput>
  }

  export type PenaltyUpdateManyWithWhereWithoutCollectionCaseInput = {
    where: PenaltyScalarWhereInput
    data: XOR<PenaltyUpdateManyMutationInput, PenaltyUncheckedUpdateManyWithoutCollectionCaseInput>
  }

  export type PenaltyScalarWhereInput = {
    AND?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
    OR?: PenaltyScalarWhereInput[]
    NOT?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
    id?: StringFilter<"Penalty"> | string
    collectionCaseId?: StringFilter<"Penalty"> | string
    description?: StringNullableFilter<"Penalty"> | string | null
    amount?: DecimalFilter<"Penalty"> | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFilter<"Penalty"> | Date | string
    isPaid?: BoolFilter<"Penalty"> | boolean
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
    updatedAt?: DateTimeFilter<"Penalty"> | Date | string
  }

  export type ChatRoomUpsertWithWhereUniqueWithoutCollectionCaseInput = {
    where: ChatRoomWhereUniqueInput
    update: XOR<ChatRoomUpdateWithoutCollectionCaseInput, ChatRoomUncheckedUpdateWithoutCollectionCaseInput>
    create: XOR<ChatRoomCreateWithoutCollectionCaseInput, ChatRoomUncheckedCreateWithoutCollectionCaseInput>
  }

  export type ChatRoomUpdateWithWhereUniqueWithoutCollectionCaseInput = {
    where: ChatRoomWhereUniqueInput
    data: XOR<ChatRoomUpdateWithoutCollectionCaseInput, ChatRoomUncheckedUpdateWithoutCollectionCaseInput>
  }

  export type ChatRoomUpdateManyWithWhereWithoutCollectionCaseInput = {
    where: ChatRoomScalarWhereInput
    data: XOR<ChatRoomUpdateManyMutationInput, ChatRoomUncheckedUpdateManyWithoutCollectionCaseInput>
  }

  export type CollectionCaseCreateWithoutPenaltiesInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutPenaltiesInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutPenaltiesInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
  }

  export type CollectionCaseUpsertWithoutPenaltiesInput = {
    update: XOR<CollectionCaseUpdateWithoutPenaltiesInput, CollectionCaseUncheckedUpdateWithoutPenaltiesInput>
    create: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutPenaltiesInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutPenaltiesInput, CollectionCaseUncheckedUpdateWithoutPenaltiesInput>
  }

  export type CollectionCaseUpdateWithoutPenaltiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutPenaltiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseCreateWithoutNotificationsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutNotificationsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutNotificationsInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
  }

  export type CollectionCaseUpsertWithoutNotificationsInput = {
    update: XOR<CollectionCaseUpdateWithoutNotificationsInput, CollectionCaseUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutNotificationsInput, CollectionCaseUncheckedUpdateWithoutNotificationsInput>
  }

  export type CollectionCaseUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseCreateWithoutPaymentsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutPaymentsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutPaymentsInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentAgreementCreateWithoutPaymentsInput = {
    id?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutPaymentAgreementsInput
    installments?: InstallmentCreateNestedManyWithoutPaymentAgreementInput
    Debtor?: DebtorCreateNestedOneWithoutPaymentAgreementsInput
  }

  export type PaymentAgreementUncheckedCreateWithoutPaymentsInput = {
    id?: string
    collectionCaseId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtorId?: string | null
    installments?: InstallmentUncheckedCreateNestedManyWithoutPaymentAgreementInput
  }

  export type PaymentAgreementCreateOrConnectWithoutPaymentsInput = {
    where: PaymentAgreementWhereUniqueInput
    create: XOR<PaymentAgreementCreateWithoutPaymentsInput, PaymentAgreementUncheckedCreateWithoutPaymentsInput>
  }

  export type InstallmentCreateWithoutPaymentInput = {
    id?: string
    number: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentAgreement: PaymentAgreementCreateNestedOneWithoutInstallmentsInput
  }

  export type InstallmentUncheckedCreateWithoutPaymentInput = {
    id?: string
    paymentAgreementId: string
    number: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallmentCreateOrConnectWithoutPaymentInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutPaymentInput, InstallmentUncheckedCreateWithoutPaymentInput>
  }

  export type InstallmentCreateManyPaymentInputEnvelope = {
    data: InstallmentCreateManyPaymentInput | InstallmentCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCaseUpsertWithoutPaymentsInput = {
    update: XOR<CollectionCaseUpdateWithoutPaymentsInput, CollectionCaseUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutPaymentsInput, CollectionCaseUncheckedUpdateWithoutPaymentsInput>
  }

  export type CollectionCaseUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type PaymentAgreementUpsertWithoutPaymentsInput = {
    update: XOR<PaymentAgreementUpdateWithoutPaymentsInput, PaymentAgreementUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PaymentAgreementCreateWithoutPaymentsInput, PaymentAgreementUncheckedCreateWithoutPaymentsInput>
    where?: PaymentAgreementWhereInput
  }

  export type PaymentAgreementUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PaymentAgreementWhereInput
    data: XOR<PaymentAgreementUpdateWithoutPaymentsInput, PaymentAgreementUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentAgreementUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutPaymentAgreementsNestedInput
    installments?: InstallmentUpdateManyWithoutPaymentAgreementNestedInput
    Debtor?: DebtorUpdateOneWithoutPaymentAgreementsNestedInput
  }

  export type PaymentAgreementUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    installments?: InstallmentUncheckedUpdateManyWithoutPaymentAgreementNestedInput
  }

  export type InstallmentUpsertWithWhereUniqueWithoutPaymentInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutPaymentInput, InstallmentUncheckedUpdateWithoutPaymentInput>
    create: XOR<InstallmentCreateWithoutPaymentInput, InstallmentUncheckedCreateWithoutPaymentInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutPaymentInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutPaymentInput, InstallmentUncheckedUpdateWithoutPaymentInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutPaymentInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type InstallmentScalarWhereInput = {
    AND?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
    OR?: InstallmentScalarWhereInput[]
    NOT?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
    id?: StringFilter<"Installment"> | string
    paymentAgreementId?: StringFilter<"Installment"> | string
    number?: IntFilter<"Installment"> | number
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    amount?: DecimalFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFilter<"Installment"> | $Enums.InstallmentStatus
    paymentId?: StringNullableFilter<"Installment"> | string | null
    createdAt?: DateTimeFilter<"Installment"> | Date | string
    updatedAt?: DateTimeFilter<"Installment"> | Date | string
  }

  export type CollectionCaseCreateWithoutDebtorInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutDebtorInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    tenantId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutDebtorInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput>
  }

  export type CollectionCaseCreateManyDebtorInputEnvelope = {
    data: CollectionCaseCreateManyDebtorInput | CollectionCaseCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutDebtorsInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutTenantsInput
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDebtorsInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planId?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDebtorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
  }

  export type UserCreateWithoutDebtorsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    verdictBailiffs?: VerdictCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutDebtorsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    tenantId: string
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    verdictBailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutDebtorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
  }

  export type DebtorIncomeCreateWithoutDebtorInput = {
    id?: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorIncomeUncheckedCreateWithoutDebtorInput = {
    id?: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorIncomeCreateOrConnectWithoutDebtorInput = {
    where: DebtorIncomeWhereUniqueInput
    create: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput>
  }

  export type DebtorIncomeCreateManyDebtorInputEnvelope = {
    data: DebtorIncomeCreateManyDebtorInput | DebtorIncomeCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type PaymentAgreementCreateWithoutDebtorInput = {
    id?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutPaymentAgreementsInput
    installments?: InstallmentCreateNestedManyWithoutPaymentAgreementInput
    payments?: PaymentCreateNestedManyWithoutPaymentAgreementInput
  }

  export type PaymentAgreementUncheckedCreateWithoutDebtorInput = {
    id?: string
    collectionCaseId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    installments?: InstallmentUncheckedCreateNestedManyWithoutPaymentAgreementInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPaymentAgreementInput
  }

  export type PaymentAgreementCreateOrConnectWithoutDebtorInput = {
    where: PaymentAgreementWhereUniqueInput
    create: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput>
  }

  export type PaymentAgreementCreateManyDebtorInputEnvelope = {
    data: PaymentAgreementCreateManyDebtorInput | PaymentAgreementCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type VerdictCreateWithoutDebtorInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdictBailiffsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutDebtorInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiffServices?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdictEmbargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdictInterest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutDebtorInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput>
  }

  export type VerdictCreateManyDebtorInputEnvelope = {
    data: VerdictCreateManyDebtorInput | VerdictCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput = {
    where: CollectionCaseWhereUniqueInput
    update: XOR<CollectionCaseUpdateWithoutDebtorInput, CollectionCaseUncheckedUpdateWithoutDebtorInput>
    create: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput>
  }

  export type CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput = {
    where: CollectionCaseWhereUniqueInput
    data: XOR<CollectionCaseUpdateWithoutDebtorInput, CollectionCaseUncheckedUpdateWithoutDebtorInput>
  }

  export type CollectionCaseUpdateManyWithWhereWithoutDebtorInput = {
    where: CollectionCaseScalarWhereInput
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyWithoutDebtorInput>
  }

  export type TenantUpsertWithoutDebtorsInput = {
    update: XOR<TenantUpdateWithoutDebtorsInput, TenantUncheckedUpdateWithoutDebtorsInput>
    create: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDebtorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDebtorsInput, TenantUncheckedUpdateWithoutDebtorsInput>
  }

  export type TenantUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutTenantsNestedInput
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutDebtorsInput = {
    update: XOR<UserUpdateWithoutDebtorsInput, UserUncheckedUpdateWithoutDebtorsInput>
    create: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDebtorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDebtorsInput, UserUncheckedUpdateWithoutDebtorsInput>
  }

  export type UserUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    verdictBailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verdictBailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput = {
    where: DebtorIncomeWhereUniqueInput
    update: XOR<DebtorIncomeUpdateWithoutDebtorInput, DebtorIncomeUncheckedUpdateWithoutDebtorInput>
    create: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput>
  }

  export type DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput = {
    where: DebtorIncomeWhereUniqueInput
    data: XOR<DebtorIncomeUpdateWithoutDebtorInput, DebtorIncomeUncheckedUpdateWithoutDebtorInput>
  }

  export type DebtorIncomeUpdateManyWithWhereWithoutDebtorInput = {
    where: DebtorIncomeScalarWhereInput
    data: XOR<DebtorIncomeUpdateManyMutationInput, DebtorIncomeUncheckedUpdateManyWithoutDebtorInput>
  }

  export type DebtorIncomeScalarWhereInput = {
    AND?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
    OR?: DebtorIncomeScalarWhereInput[]
    NOT?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
    id?: StringFilter<"DebtorIncome"> | string
    debtorId?: StringFilter<"DebtorIncome"> | string
    amount?: FloatFilter<"DebtorIncome"> | number
    source?: StringFilter<"DebtorIncome"> | string
    createdAt?: DateTimeFilter<"DebtorIncome"> | Date | string
    updatedAt?: DateTimeFilter<"DebtorIncome"> | Date | string
  }

  export type PaymentAgreementUpsertWithWhereUniqueWithoutDebtorInput = {
    where: PaymentAgreementWhereUniqueInput
    update: XOR<PaymentAgreementUpdateWithoutDebtorInput, PaymentAgreementUncheckedUpdateWithoutDebtorInput>
    create: XOR<PaymentAgreementCreateWithoutDebtorInput, PaymentAgreementUncheckedCreateWithoutDebtorInput>
  }

  export type PaymentAgreementUpdateWithWhereUniqueWithoutDebtorInput = {
    where: PaymentAgreementWhereUniqueInput
    data: XOR<PaymentAgreementUpdateWithoutDebtorInput, PaymentAgreementUncheckedUpdateWithoutDebtorInput>
  }

  export type PaymentAgreementUpdateManyWithWhereWithoutDebtorInput = {
    where: PaymentAgreementScalarWhereInput
    data: XOR<PaymentAgreementUpdateManyMutationInput, PaymentAgreementUncheckedUpdateManyWithoutDebtorInput>
  }

  export type VerdictUpsertWithWhereUniqueWithoutDebtorInput = {
    where: VerdictWhereUniqueInput
    update: XOR<VerdictUpdateWithoutDebtorInput, VerdictUncheckedUpdateWithoutDebtorInput>
    create: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput>
  }

  export type VerdictUpdateWithWhereUniqueWithoutDebtorInput = {
    where: VerdictWhereUniqueInput
    data: XOR<VerdictUpdateWithoutDebtorInput, VerdictUncheckedUpdateWithoutDebtorInput>
  }

  export type VerdictUpdateManyWithWhereWithoutDebtorInput = {
    where: VerdictScalarWhereInput
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyWithoutDebtorInput>
  }

  export type TenantCreateWithoutChatRoomsInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutTenantsInput
    billingInvoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryCreateNestedOneWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutChatRoomsInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planId?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    billingInvoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    registry?: TenantRegistryUncheckedCreateNestedOneWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutChatRoomsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutChatRoomsInput, TenantUncheckedCreateWithoutChatRoomsInput>
  }

  export type CollectionCaseCreateWithoutChatRoomsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutChatRoomsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutChatRoomsInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutChatRoomsInput, CollectionCaseUncheckedCreateWithoutChatRoomsInput>
  }

  export type ChatMessageCreateWithoutRoomInput = {
    id?: string
    message: string
    fileUrl?: string | null
    fileName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutRoomInput = {
    id?: string
    senderId: string
    message: string
    fileUrl?: string | null
    fileName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutRoomInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput>
  }

  export type ChatMessageCreateManyRoomInputEnvelope = {
    data: ChatMessageCreateManyRoomInput | ChatMessageCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutChatRoomsInput = {
    update: XOR<TenantUpdateWithoutChatRoomsInput, TenantUncheckedUpdateWithoutChatRoomsInput>
    create: XOR<TenantCreateWithoutChatRoomsInput, TenantUncheckedCreateWithoutChatRoomsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutChatRoomsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutChatRoomsInput, TenantUncheckedUpdateWithoutChatRoomsInput>
  }

  export type TenantUpdateWithoutChatRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutTenantsNestedInput
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutChatRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CollectionCaseUpsertWithoutChatRoomsInput = {
    update: XOR<CollectionCaseUpdateWithoutChatRoomsInput, CollectionCaseUncheckedUpdateWithoutChatRoomsInput>
    create: XOR<CollectionCaseCreateWithoutChatRoomsInput, CollectionCaseUncheckedCreateWithoutChatRoomsInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutChatRoomsInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutChatRoomsInput, CollectionCaseUncheckedUpdateWithoutChatRoomsInput>
  }

  export type CollectionCaseUpdateWithoutChatRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutChatRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutRoomInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutRoomInput, ChatMessageUncheckedUpdateWithoutRoomInput>
    create: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutRoomInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutRoomInput, ChatMessageUncheckedUpdateWithoutRoomInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutRoomInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutRoomInput>
  }

  export type ChatRoomCreateWithoutMessagesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutChatRoomsInput
    collectionCase: CollectionCaseCreateNestedOneWithoutChatRoomsInput
  }

  export type ChatRoomUncheckedCreateWithoutMessagesInput = {
    id?: string
    tenantId: string
    collectionCaseId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatRoomCreateOrConnectWithoutMessagesInput = {
    where: ChatRoomWhereUniqueInput
    create: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    debtors?: DebtorCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictCreateNestedManyWithoutBailiffInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    tenantId: string
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    verdictBailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ChatRoomUpsertWithoutMessagesInput = {
    update: XOR<ChatRoomUpdateWithoutMessagesInput, ChatRoomUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
    where?: ChatRoomWhereInput
  }

  export type ChatRoomUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatRoomWhereInput
    data: XOR<ChatRoomUpdateWithoutMessagesInput, ChatRoomUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatRoomUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutChatRoomsNestedInput
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutChatRoomsNestedInput
  }

  export type ChatRoomUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
  }

  export type DebtorCreateWithoutIncomesInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    paymentAgreements?: PaymentAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutIncomesInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    paymentAgreements?: PaymentAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutIncomesInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
  }

  export type DebtorUpsertWithoutIncomesInput = {
    update: XOR<DebtorUpdateWithoutIncomesInput, DebtorUncheckedUpdateWithoutIncomesInput>
    create: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutIncomesInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutIncomesInput, DebtorUncheckedUpdateWithoutIncomesInput>
  }

  export type DebtorUpdateWithoutIncomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutIncomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type CollectionCaseCreateWithoutPaymentAgreementsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollectionCasesInput
    tenant: TenantCreateNestedOneWithoutCollectionCasesInput
    notifications?: NotificationCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseUncheckedCreateWithoutPaymentAgreementsInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    tenantId: string
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutCollectionCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutCollectionCaseInput
    penalties?: PenaltyUncheckedCreateNestedManyWithoutCollectionCaseInput
    chatRooms?: ChatRoomUncheckedCreateNestedManyWithoutCollectionCaseInput
  }

  export type CollectionCaseCreateOrConnectWithoutPaymentAgreementsInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutPaymentAgreementsInput, CollectionCaseUncheckedCreateWithoutPaymentAgreementsInput>
  }

  export type InstallmentCreateWithoutPaymentAgreementInput = {
    id?: string
    number: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentCreateNestedOneWithoutInstallmentInput
  }

  export type InstallmentUncheckedCreateWithoutPaymentAgreementInput = {
    id?: string
    number: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallmentCreateOrConnectWithoutPaymentAgreementInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutPaymentAgreementInput, InstallmentUncheckedCreateWithoutPaymentAgreementInput>
  }

  export type InstallmentCreateManyPaymentAgreementInputEnvelope = {
    data: InstallmentCreateManyPaymentAgreementInput | InstallmentCreateManyPaymentAgreementInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutPaymentAgreementInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutPaymentsInput
    Installment?: InstallmentCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutPaymentAgreementInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    collectionCaseId: string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
    Installment?: InstallmentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutPaymentAgreementInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPaymentAgreementInput, PaymentUncheckedCreateWithoutPaymentAgreementInput>
  }

  export type PaymentCreateManyPaymentAgreementInputEnvelope = {
    data: PaymentCreateManyPaymentAgreementInput | PaymentCreateManyPaymentAgreementInput[]
    skipDuplicates?: boolean
  }

  export type DebtorCreateWithoutPaymentAgreementsInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutPaymentAgreementsInput = {
    id?: string
    tenantId: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutPaymentAgreementsInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutPaymentAgreementsInput, DebtorUncheckedCreateWithoutPaymentAgreementsInput>
  }

  export type CollectionCaseUpsertWithoutPaymentAgreementsInput = {
    update: XOR<CollectionCaseUpdateWithoutPaymentAgreementsInput, CollectionCaseUncheckedUpdateWithoutPaymentAgreementsInput>
    create: XOR<CollectionCaseCreateWithoutPaymentAgreementsInput, CollectionCaseUncheckedCreateWithoutPaymentAgreementsInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutPaymentAgreementsInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutPaymentAgreementsInput, CollectionCaseUncheckedUpdateWithoutPaymentAgreementsInput>
  }

  export type CollectionCaseUpdateWithoutPaymentAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutPaymentAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type InstallmentUpsertWithWhereUniqueWithoutPaymentAgreementInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutPaymentAgreementInput, InstallmentUncheckedUpdateWithoutPaymentAgreementInput>
    create: XOR<InstallmentCreateWithoutPaymentAgreementInput, InstallmentUncheckedCreateWithoutPaymentAgreementInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutPaymentAgreementInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutPaymentAgreementInput, InstallmentUncheckedUpdateWithoutPaymentAgreementInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutPaymentAgreementInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutPaymentAgreementInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutPaymentAgreementInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPaymentAgreementInput, PaymentUncheckedUpdateWithoutPaymentAgreementInput>
    create: XOR<PaymentCreateWithoutPaymentAgreementInput, PaymentUncheckedCreateWithoutPaymentAgreementInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPaymentAgreementInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPaymentAgreementInput, PaymentUncheckedUpdateWithoutPaymentAgreementInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPaymentAgreementInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentAgreementInput>
  }

  export type DebtorUpsertWithoutPaymentAgreementsInput = {
    update: XOR<DebtorUpdateWithoutPaymentAgreementsInput, DebtorUncheckedUpdateWithoutPaymentAgreementsInput>
    create: XOR<DebtorCreateWithoutPaymentAgreementsInput, DebtorUncheckedCreateWithoutPaymentAgreementsInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutPaymentAgreementsInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutPaymentAgreementsInput, DebtorUncheckedUpdateWithoutPaymentAgreementsInput>
  }

  export type DebtorUpdateWithoutPaymentAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutPaymentAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type PaymentAgreementCreateWithoutInstallmentsInput = {
    id?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutPaymentAgreementsInput
    payments?: PaymentCreateNestedManyWithoutPaymentAgreementInput
    Debtor?: DebtorCreateNestedOneWithoutPaymentAgreementsInput
  }

  export type PaymentAgreementUncheckedCreateWithoutInstallmentsInput = {
    id?: string
    collectionCaseId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtorId?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutPaymentAgreementInput
  }

  export type PaymentAgreementCreateOrConnectWithoutInstallmentsInput = {
    where: PaymentAgreementWhereUniqueInput
    create: XOR<PaymentAgreementCreateWithoutInstallmentsInput, PaymentAgreementUncheckedCreateWithoutInstallmentsInput>
  }

  export type PaymentCreateWithoutInstallmentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
    collectionCase: CollectionCaseCreateNestedOneWithoutPaymentsInput
    PaymentAgreement?: PaymentAgreementCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInstallmentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    collectionCaseId: string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
    paymentAgreementId?: string | null
  }

  export type PaymentCreateOrConnectWithoutInstallmentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInstallmentInput, PaymentUncheckedCreateWithoutInstallmentInput>
  }

  export type PaymentAgreementUpsertWithoutInstallmentsInput = {
    update: XOR<PaymentAgreementUpdateWithoutInstallmentsInput, PaymentAgreementUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<PaymentAgreementCreateWithoutInstallmentsInput, PaymentAgreementUncheckedCreateWithoutInstallmentsInput>
    where?: PaymentAgreementWhereInput
  }

  export type PaymentAgreementUpdateToOneWithWhereWithoutInstallmentsInput = {
    where?: PaymentAgreementWhereInput
    data: XOR<PaymentAgreementUpdateWithoutInstallmentsInput, PaymentAgreementUncheckedUpdateWithoutInstallmentsInput>
  }

  export type PaymentAgreementUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutPaymentAgreementsNestedInput
    payments?: PaymentUpdateManyWithoutPaymentAgreementNestedInput
    Debtor?: DebtorUpdateOneWithoutPaymentAgreementsNestedInput
  }

  export type PaymentAgreementUncheckedUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutPaymentAgreementNestedInput
  }

  export type PaymentUpsertWithoutInstallmentInput = {
    update: XOR<PaymentUpdateWithoutInstallmentInput, PaymentUncheckedUpdateWithoutInstallmentInput>
    create: XOR<PaymentCreateWithoutInstallmentInput, PaymentUncheckedCreateWithoutInstallmentInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutInstallmentInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutInstallmentInput, PaymentUncheckedUpdateWithoutInstallmentInput>
  }

  export type PaymentUpdateWithoutInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutPaymentsNestedInput
    PaymentAgreement?: PaymentAgreementUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAgreementId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingInvoiceCreateManyTenantInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    issueDate: Date | string
    dueDate: Date | string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionCaseCreateManyTenantInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    debtorId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorCreateManyTenantInput = {
    id?: string
    userId?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictCreateManyTenantInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    notes?: string | null
    bailiffId?: string | null
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatRoomCreateManyTenantInput = {
    id?: string
    collectionCaseId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingInvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUpdateManyWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUpdateManyWithoutBillingInvoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceNestedInput
    payments?: BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debtorId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    verdictBailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatRoomUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutChatRoomsNestedInput
    messages?: ChatMessageUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorCreateManyUserInput = {
    id?: string
    tenantId: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    personType?: $Enums.PersonType
    identificationType?: $Enums.IdentificationType | null
    identification?: string | null
    totalIncome?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictCreateManyBailiffInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    debtorId: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
  }

  export type ChatMessageCreateManySenderInput = {
    id?: string
    roomId: string
    message: string
    fileUrl?: string | null
    fileName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    personType?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identificationType?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    totalIncome?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUpdateWithoutBailiffInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutBailiffInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateManyWithoutBailiffInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    debtorId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: ChatRoomUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictAttachmentCreateManyVerdictInput = {
    id?: string
    filePath: string
    fileSize: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    fileName: string
  }

  export type VerdictBailiffServicesCreateManyVerdictInput = {
    id?: string
    serviceType: string
    serviceCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictEmbargoCreateManyVerdictInput = {
    id?: string
    companyName: string
    companyPhone: string
    companyEmail: string
    companyAddress: string
    embargoType: string
    embargoDate: Date | string
    embargoAmount: number
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestCreateManyVerdictInput = {
    id?: string
    interestType: number
    baseAmount: number
    calculatedInterest?: number | null
    calculationStart: Date | string
    calculationEnd: Date | string
    totalInterest: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictAttachmentUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fileName?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictBailiffServicesUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceType?: StringFieldUpdateOperationsInput | string
    serviceCost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyAddress?: StringFieldUpdateOperationsInput | string
    embargoType?: StringFieldUpdateOperationsInput | string
    embargoDate?: DateTimeFieldUpdateOperationsInput | Date | string
    embargoAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: VerdictInterestDetailsUpdateManyWithoutVerdictInterestNestedInput
  }

  export type VerdictInterestUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: VerdictInterestDetailsUncheckedUpdateManyWithoutVerdictInterestNestedInput
  }

  export type VerdictInterestUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    interestType?: IntFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    calculatedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInterest?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsCreateManyVerdictInterestInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    days: number
    annualRate: number
    proportionalRate: number
    baseAmount: number
    interest: number
    total: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictInterestDetailsUpdateWithoutVerdictInterestInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsUncheckedUpdateWithoutVerdictInterestInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsUncheckedUpdateManyWithoutVerdictInterestInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annualRate?: FloatFieldUpdateOperationsInput | number
    proportionalRate?: FloatFieldUpdateOperationsInput | number
    baseAmount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestDetailCreateManyInterestTypeInput = {
    id?: number
    date: string
    rate: number
  }

  export type InterestDetailUpdateWithoutInterestTypeInput = {
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type InterestDetailUncheckedUpdateWithoutInterestTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type InterestDetailUncheckedUpdateManyWithoutInterestTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type BillingInvoiceDetailCreateManyBillingInvoiceInput = {
    id?: string
    itemDescription: string
    itemQuantity: number
    itemUnitPrice: number
    itemTotalPrice: number
    itemTaxRate: number
    itemTaxAmount: number
    itemTotalWithTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingPaymentCreateManyBillingInvoiceInput = {
    id?: string
    paymentDate: Date | string
    amount: number
    paymentMethod: string
    transactionId?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillingInvoiceDetailUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailUncheckedUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailUncheckedUpdateManyWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemDescription?: StringFieldUpdateOperationsInput | string
    itemQuantity?: IntFieldUpdateOperationsInput | number
    itemUnitPrice?: FloatFieldUpdateOperationsInput | number
    itemTotalPrice?: FloatFieldUpdateOperationsInput | number
    itemTaxRate?: FloatFieldUpdateOperationsInput | number
    itemTaxAmount?: FloatFieldUpdateOperationsInput | number
    itemTotalWithTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUncheckedUpdateWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUncheckedUpdateManyWithoutBillingInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateManyPlanInput = {
    id?: string
    name: string
    subdomain: string
    contactEmail: string
    countryCode: string
    address?: string | null
    city?: string | null
    logoUrl?: string | null
    numberOfEmployees?: number | null
    phone?: string | null
    website?: string | null
    planStatus?: string
    planExpiresAt?: Date | string | null
    termsAccepted?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    billingInvoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collectionCases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    registry?: TenantRegistryUncheckedUpdateOneWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfEmployees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    planStatus?: StringFieldUpdateOperationsInput | string
    planExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyCollectionCaseInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sentAt?: Date | string
    read?: boolean
    createdAt?: Date | string
  }

  export type PaymentCreateManyCollectionCaseInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
    paymentAgreementId?: string | null
  }

  export type PaymentAgreementCreateManyCollectionCaseInput = {
    id?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    debtorId?: string | null
  }

  export type PenaltyCreateManyCollectionCaseInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    dateApplied?: Date | string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatRoomCreateManyCollectionCaseInput = {
    id?: string
    tenantId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentAgreement?: PaymentAgreementUpdateOneWithoutPaymentsNestedInput
    Installment?: InstallmentUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAgreementId?: NullableStringFieldUpdateOperationsInput | string | null
    Installment?: InstallmentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAgreementId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentAgreementUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: InstallmentUpdateManyWithoutPaymentAgreementNestedInput
    payments?: PaymentUpdateManyWithoutPaymentAgreementNestedInput
    Debtor?: DebtorUpdateOneWithoutPaymentAgreementsNestedInput
  }

  export type PaymentAgreementUncheckedUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
    installments?: InstallmentUncheckedUpdateManyWithoutPaymentAgreementNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPaymentAgreementNestedInput
  }

  export type PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    debtorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PenaltyUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateManyWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dateApplied?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatRoomUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutChatRoomsNestedInput
    messages?: ChatMessageUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateManyWithoutCollectionCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallmentCreateManyPaymentInput = {
    id?: string
    paymentAgreementId: string
    number: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallmentUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentAgreement?: PaymentAgreementUpdateOneRequiredWithoutInstallmentsNestedInput
  }

  export type InstallmentUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentAgreementId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallmentUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentAgreementId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseCreateManyDebtorInput = {
    id?: string
    referenceNumber?: string | null
    issueDate?: Date | string | null
    dueDate?: Date | string | null
    reminder1SentAt?: Date | string | null
    reminder1DueDate?: Date | string | null
    reminder2SentAt?: Date | string | null
    reminder2DueDate?: Date | string | null
    tenantId: string
    amountOriginal: Decimal | DecimalJsLike | number | string
    amountDue: Decimal | DecimalJsLike | number | string
    amountToReceive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DebtorIncomeCreateManyDebtorInput = {
    id?: string
    amount: number
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentAgreementCreateManyDebtorInput = {
    id?: string
    collectionCaseId: string
    totalAmount: Decimal | DecimalJsLike | number | string
    installmentAmount: Decimal | DecimalJsLike | number | string
    installmentsCount: number
    startDate: Date | string
    status?: $Enums.PaymentAgreementStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerdictCreateManyDebtorInput = {
    id?: string
    invoiceNumber: string
    creditorName: string
    registrationNumber: string
    sentenceAmount: number
    sentenceDate: Date | string
    status?: $Enums.VerdictStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    procesalCost?: number | null
    tenantId: string
    notes?: string | null
    bailiffId?: string | null
  }

  export type CollectionCaseUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCollectionCasesNestedInput
    notifications?: NotificationUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutCollectionCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutCollectionCaseNestedInput
    paymentAgreements?: PaymentAgreementUncheckedUpdateManyWithoutCollectionCaseNestedInput
    penalties?: PenaltyUncheckedUpdateManyWithoutCollectionCaseNestedInput
    chatRooms?: ChatRoomUncheckedUpdateManyWithoutCollectionCaseNestedInput
  }

  export type CollectionCaseUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2SentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2DueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    amountOriginal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountDue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountToReceive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionStatusFieldUpdateOperationsInput | $Enums.CollectionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentAgreementUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutPaymentAgreementsNestedInput
    installments?: InstallmentUpdateManyWithoutPaymentAgreementNestedInput
    payments?: PaymentUpdateManyWithoutPaymentAgreementNestedInput
  }

  export type PaymentAgreementUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: InstallmentUncheckedUpdateManyWithoutPaymentAgreementNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPaymentAgreementNestedInput
  }

  export type PaymentAgreementUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentsCount?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPaymentAgreementStatusFieldUpdateOperationsInput | $Enums.PaymentAgreementStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdictBailiffsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiffServices?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdictEmbargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdictInterest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    creditorName?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    sentenceAmount?: FloatFieldUpdateOperationsInput | number
    sentenceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    procesalCost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenantId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatMessageCreateManyRoomInput = {
    id?: string
    senderId: string
    message: string
    fileUrl?: string | null
    fileName?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatMessageUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallmentCreateManyPaymentAgreementInput = {
    id?: string
    number: number
    dueDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyPaymentAgreementInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    createdAt?: Date | string
    collectionCaseId: string
    paymentDate: Date | string
    referenceNumber?: string | null
    updatedAt?: Date | string
  }

  export type InstallmentUpdateWithoutPaymentAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneWithoutInstallmentNestedInput
  }

  export type InstallmentUncheckedUpdateWithoutPaymentAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallmentUncheckedUpdateManyWithoutPaymentAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutPaymentAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCase?: CollectionCaseUpdateOneRequiredWithoutPaymentsNestedInput
    Installment?: InstallmentUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPaymentAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Installment?: InstallmentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionCaseId?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}