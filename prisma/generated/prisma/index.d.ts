
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Parameter
 * 
 */
export type Parameter = $Result.DefaultSelection<Prisma.$ParameterPayload>
/**
 * Model Verdict
 * 
 */
export type Verdict = $Result.DefaultSelection<Prisma.$VerdictPayload>
/**
 * Model VerdictInterest
 * 
 */
export type VerdictInterest = $Result.DefaultSelection<Prisma.$VerdictInterestPayload>
/**
 * Model VerdictInterestDetails
 * 
 */
export type VerdictInterestDetails = $Result.DefaultSelection<Prisma.$VerdictInterestDetailsPayload>
/**
 * Model VerdictEmbargo
 * 
 */
export type VerdictEmbargo = $Result.DefaultSelection<Prisma.$VerdictEmbargoPayload>
/**
 * Model VerdictBailiffServices
 * 
 */
export type VerdictBailiffServices = $Result.DefaultSelection<Prisma.$VerdictBailiffServicesPayload>
/**
 * Model VerdictAttachment
 * 
 */
export type VerdictAttachment = $Result.DefaultSelection<Prisma.$VerdictAttachmentPayload>
/**
 * Model InterestType
 * 
 */
export type InterestType = $Result.DefaultSelection<Prisma.$InterestTypePayload>
/**
 * Model InterestDetail
 * 
 */
export type InterestDetail = $Result.DefaultSelection<Prisma.$InterestDetailPayload>
/**
 * Model BillingInvoice
 * 
 */
export type BillingInvoice = $Result.DefaultSelection<Prisma.$BillingInvoicePayload>
/**
 * Model BillingInvoiceDetail
 * 
 */
export type BillingInvoiceDetail = $Result.DefaultSelection<Prisma.$BillingInvoiceDetailPayload>
/**
 * Model BillingPayment
 * 
 */
export type BillingPayment = $Result.DefaultSelection<Prisma.$BillingPaymentPayload>
/**
 * Model CollectionCase
 * 
 */
export type CollectionCase = $Result.DefaultSelection<Prisma.$CollectionCasePayload>
/**
 * Model CollectionCasePenalty
 * 
 */
export type CollectionCasePenalty = $Result.DefaultSelection<Prisma.$CollectionCasePenaltyPayload>
/**
 * Model CollectionCaseNotification
 * 
 */
export type CollectionCaseNotification = $Result.DefaultSelection<Prisma.$CollectionCaseNotificationPayload>
/**
 * Model CollectionCasePayment
 * 
 */
export type CollectionCasePayment = $Result.DefaultSelection<Prisma.$CollectionCasePaymentPayload>
/**
 * Model Debtor
 * 
 */
export type Debtor = $Result.DefaultSelection<Prisma.$DebtorPayload>
/**
 * Model ChatRoom
 * 
 */
export type ChatRoom = $Result.DefaultSelection<Prisma.$ChatRoomPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model DebtorIncome
 * 
 */
export type DebtorIncome = $Result.DefaultSelection<Prisma.$DebtorIncomePayload>
/**
 * Model CollectionCaseAgreement
 * 
 */
export type CollectionCaseAgreement = $Result.DefaultSelection<Prisma.$CollectionCaseAgreementPayload>
/**
 * Model CollectionCaseAgreementInstallment
 * 
 */
export type CollectionCaseAgreementInstallment = $Result.DefaultSelection<Prisma.$CollectionCaseAgreementInstallmentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InstallmentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE'
};

export type InstallmentStatus = (typeof InstallmentStatus)[keyof typeof InstallmentStatus]


export const AgreementStatus: {
  PENDING: 'PENDING',
  IN_NEGOTIATION: 'IN_NEGOTIATION',
  COUNTEROFFER: 'COUNTEROFFER',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED',
  CLOSED: 'CLOSED'
};

export type AgreementStatus = (typeof AgreementStatus)[keyof typeof AgreementStatus]


export const CalculationTypeEnum: {
  FIXED: 'FIXED',
  VARIABLE: 'VARIABLE'
};

export type CalculationTypeEnum = (typeof CalculationTypeEnum)[keyof typeof CalculationTypeEnum]


export const VerdictStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type VerdictStatus = (typeof VerdictStatus)[keyof typeof VerdictStatus]


export const NotificationType: {
  AANMANING: 'AANMANING',
  SOMMATIE: 'SOMMATIE',
  INGEBREKESTELLING: 'INGEBREKESTELLING',
  BLOKKADE: 'BLOKKADE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const IdentificationType: {
  DNI: 'DNI',
  PASSPORT: 'PASSPORT',
  NIE: 'NIE',
  CIF: 'CIF',
  KVK: 'KVK',
  OTHER: 'OTHER'
};

export type IdentificationType = (typeof IdentificationType)[keyof typeof IdentificationType]


export const roleEnum: {
  PLATFORM_OWNER: 'PLATFORM_OWNER',
  TENANT_ADMIN: 'TENANT_ADMIN',
  AGENT: 'AGENT',
  DEBTOR: 'DEBTOR',
  BAILIFF: 'BAILIFF'
};

export type roleEnum = (typeof roleEnum)[keyof typeof roleEnum]


export const PaymentMethod: {
  TRANSFER: 'TRANSFER',
  CREDIT_CARD: 'CREDIT_CARD'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const CollectionCaseStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type CollectionCaseStatus = (typeof CollectionCaseStatus)[keyof typeof CollectionCaseStatus]


export const PersonType: {
  INDIVIDUAL: 'INDIVIDUAL',
  COMPANY: 'COMPANY'
};

export type PersonType = (typeof PersonType)[keyof typeof PersonType]

}

export type InstallmentStatus = $Enums.InstallmentStatus

export const InstallmentStatus: typeof $Enums.InstallmentStatus

export type AgreementStatus = $Enums.AgreementStatus

export const AgreementStatus: typeof $Enums.AgreementStatus

export type CalculationTypeEnum = $Enums.CalculationTypeEnum

export const CalculationTypeEnum: typeof $Enums.CalculationTypeEnum

export type VerdictStatus = $Enums.VerdictStatus

export const VerdictStatus: typeof $Enums.VerdictStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type IdentificationType = $Enums.IdentificationType

export const IdentificationType: typeof $Enums.IdentificationType

export type roleEnum = $Enums.roleEnum

export const roleEnum: typeof $Enums.roleEnum

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type CollectionCaseStatus = $Enums.CollectionCaseStatus

export const CollectionCaseStatus: typeof $Enums.CollectionCaseStatus

export type PersonType = $Enums.PersonType

export const PersonType: typeof $Enums.PersonType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parameter`: Exposes CRUD operations for the **Parameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parameters
    * const parameters = await prisma.parameter.findMany()
    * ```
    */
  get parameter(): Prisma.ParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdict`: Exposes CRUD operations for the **Verdict** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verdicts
    * const verdicts = await prisma.verdict.findMany()
    * ```
    */
  get verdict(): Prisma.VerdictDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictInterest`: Exposes CRUD operations for the **VerdictInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictInterests
    * const verdictInterests = await prisma.verdictInterest.findMany()
    * ```
    */
  get verdictInterest(): Prisma.VerdictInterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictInterestDetails`: Exposes CRUD operations for the **VerdictInterestDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictInterestDetails
    * const verdictInterestDetails = await prisma.verdictInterestDetails.findMany()
    * ```
    */
  get verdictInterestDetails(): Prisma.VerdictInterestDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictEmbargo`: Exposes CRUD operations for the **VerdictEmbargo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictEmbargos
    * const verdictEmbargos = await prisma.verdictEmbargo.findMany()
    * ```
    */
  get verdictEmbargo(): Prisma.VerdictEmbargoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictBailiffServices`: Exposes CRUD operations for the **VerdictBailiffServices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictBailiffServices
    * const verdictBailiffServices = await prisma.verdictBailiffServices.findMany()
    * ```
    */
  get verdictBailiffServices(): Prisma.VerdictBailiffServicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verdictAttachment`: Exposes CRUD operations for the **VerdictAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerdictAttachments
    * const verdictAttachments = await prisma.verdictAttachment.findMany()
    * ```
    */
  get verdictAttachment(): Prisma.VerdictAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interestType`: Exposes CRUD operations for the **InterestType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterestTypes
    * const interestTypes = await prisma.interestType.findMany()
    * ```
    */
  get interestType(): Prisma.InterestTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interestDetail`: Exposes CRUD operations for the **InterestDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterestDetails
    * const interestDetails = await prisma.interestDetail.findMany()
    * ```
    */
  get interestDetail(): Prisma.InterestDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingInvoice`: Exposes CRUD operations for the **BillingInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingInvoices
    * const billingInvoices = await prisma.billingInvoice.findMany()
    * ```
    */
  get billingInvoice(): Prisma.BillingInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingInvoiceDetail`: Exposes CRUD operations for the **BillingInvoiceDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingInvoiceDetails
    * const billingInvoiceDetails = await prisma.billingInvoiceDetail.findMany()
    * ```
    */
  get billingInvoiceDetail(): Prisma.BillingInvoiceDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billingPayment`: Exposes CRUD operations for the **BillingPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingPayments
    * const billingPayments = await prisma.billingPayment.findMany()
    * ```
    */
  get billingPayment(): Prisma.BillingPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionCase`: Exposes CRUD operations for the **CollectionCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionCases
    * const collectionCases = await prisma.collectionCase.findMany()
    * ```
    */
  get collectionCase(): Prisma.CollectionCaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionCasePenalty`: Exposes CRUD operations for the **CollectionCasePenalty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionCasePenalties
    * const collectionCasePenalties = await prisma.collectionCasePenalty.findMany()
    * ```
    */
  get collectionCasePenalty(): Prisma.CollectionCasePenaltyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionCaseNotification`: Exposes CRUD operations for the **CollectionCaseNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionCaseNotifications
    * const collectionCaseNotifications = await prisma.collectionCaseNotification.findMany()
    * ```
    */
  get collectionCaseNotification(): Prisma.CollectionCaseNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionCasePayment`: Exposes CRUD operations for the **CollectionCasePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionCasePayments
    * const collectionCasePayments = await prisma.collectionCasePayment.findMany()
    * ```
    */
  get collectionCasePayment(): Prisma.CollectionCasePaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debtor`: Exposes CRUD operations for the **Debtor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Debtors
    * const debtors = await prisma.debtor.findMany()
    * ```
    */
  get debtor(): Prisma.DebtorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatRoom`: Exposes CRUD operations for the **ChatRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatRooms
    * const chatRooms = await prisma.chatRoom.findMany()
    * ```
    */
  get chatRoom(): Prisma.ChatRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.debtorIncome`: Exposes CRUD operations for the **DebtorIncome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DebtorIncomes
    * const debtorIncomes = await prisma.debtorIncome.findMany()
    * ```
    */
  get debtorIncome(): Prisma.DebtorIncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionCaseAgreement`: Exposes CRUD operations for the **CollectionCaseAgreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionCaseAgreements
    * const collectionCaseAgreements = await prisma.collectionCaseAgreement.findMany()
    * ```
    */
  get collectionCaseAgreement(): Prisma.CollectionCaseAgreementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionCaseAgreementInstallment`: Exposes CRUD operations for the **CollectionCaseAgreementInstallment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionCaseAgreementInstallments
    * const collectionCaseAgreementInstallments = await prisma.collectionCaseAgreementInstallment.findMany()
    * ```
    */
  get collectionCaseAgreementInstallment(): Prisma.CollectionCaseAgreementInstallmentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Parameter: 'Parameter',
    Verdict: 'Verdict',
    VerdictInterest: 'VerdictInterest',
    VerdictInterestDetails: 'VerdictInterestDetails',
    VerdictEmbargo: 'VerdictEmbargo',
    VerdictBailiffServices: 'VerdictBailiffServices',
    VerdictAttachment: 'VerdictAttachment',
    InterestType: 'InterestType',
    InterestDetail: 'InterestDetail',
    BillingInvoice: 'BillingInvoice',
    BillingInvoiceDetail: 'BillingInvoiceDetail',
    BillingPayment: 'BillingPayment',
    CollectionCase: 'CollectionCase',
    CollectionCasePenalty: 'CollectionCasePenalty',
    CollectionCaseNotification: 'CollectionCaseNotification',
    CollectionCasePayment: 'CollectionCasePayment',
    Debtor: 'Debtor',
    ChatRoom: 'ChatRoom',
    ChatMessage: 'ChatMessage',
    DebtorIncome: 'DebtorIncome',
    CollectionCaseAgreement: 'CollectionCaseAgreement',
    CollectionCaseAgreementInstallment: 'CollectionCaseAgreementInstallment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "user" | "parameter" | "verdict" | "verdictInterest" | "verdictInterestDetails" | "verdictEmbargo" | "verdictBailiffServices" | "verdictAttachment" | "interestType" | "interestDetail" | "billingInvoice" | "billingInvoiceDetail" | "billingPayment" | "collectionCase" | "collectionCasePenalty" | "collectionCaseNotification" | "collectionCasePayment" | "debtor" | "chatRoom" | "chatMessage" | "debtorIncome" | "collectionCaseAgreement" | "collectionCaseAgreementInstallment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Parameter: {
        payload: Prisma.$ParameterPayload<ExtArgs>
        fields: Prisma.ParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          findFirst: {
            args: Prisma.ParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          findMany: {
            args: Prisma.ParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>[]
          }
          create: {
            args: Prisma.ParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          createMany: {
            args: Prisma.ParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>[]
          }
          delete: {
            args: Prisma.ParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          update: {
            args: Prisma.ParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          deleteMany: {
            args: Prisma.ParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>[]
          }
          upsert: {
            args: Prisma.ParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParameterPayload>
          }
          aggregate: {
            args: Prisma.ParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParameter>
          }
          groupBy: {
            args: Prisma.ParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParameterCountArgs<ExtArgs>
            result: $Utils.Optional<ParameterCountAggregateOutputType> | number
          }
        }
      }
      Verdict: {
        payload: Prisma.$VerdictPayload<ExtArgs>
        fields: Prisma.VerdictFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          findFirst: {
            args: Prisma.VerdictFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          findMany: {
            args: Prisma.VerdictFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          create: {
            args: Prisma.VerdictCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          createMany: {
            args: Prisma.VerdictCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          delete: {
            args: Prisma.VerdictDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          update: {
            args: Prisma.VerdictUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          deleteMany: {
            args: Prisma.VerdictDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>[]
          }
          upsert: {
            args: Prisma.VerdictUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictPayload>
          }
          aggregate: {
            args: Prisma.VerdictAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdict>
          }
          groupBy: {
            args: Prisma.VerdictGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictCountAggregateOutputType> | number
          }
        }
      }
      VerdictInterest: {
        payload: Prisma.$VerdictInterestPayload<ExtArgs>
        fields: Prisma.VerdictInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          findFirst: {
            args: Prisma.VerdictInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          findMany: {
            args: Prisma.VerdictInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>[]
          }
          create: {
            args: Prisma.VerdictInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          createMany: {
            args: Prisma.VerdictInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>[]
          }
          delete: {
            args: Prisma.VerdictInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          update: {
            args: Prisma.VerdictInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          deleteMany: {
            args: Prisma.VerdictInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictInterestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>[]
          }
          upsert: {
            args: Prisma.VerdictInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestPayload>
          }
          aggregate: {
            args: Prisma.VerdictInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictInterest>
          }
          groupBy: {
            args: Prisma.VerdictInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictInterestCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestCountAggregateOutputType> | number
          }
        }
      }
      VerdictInterestDetails: {
        payload: Prisma.$VerdictInterestDetailsPayload<ExtArgs>
        fields: Prisma.VerdictInterestDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictInterestDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictInterestDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          findFirst: {
            args: Prisma.VerdictInterestDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictInterestDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          findMany: {
            args: Prisma.VerdictInterestDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>[]
          }
          create: {
            args: Prisma.VerdictInterestDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          createMany: {
            args: Prisma.VerdictInterestDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictInterestDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>[]
          }
          delete: {
            args: Prisma.VerdictInterestDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          update: {
            args: Prisma.VerdictInterestDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          deleteMany: {
            args: Prisma.VerdictInterestDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictInterestDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictInterestDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>[]
          }
          upsert: {
            args: Prisma.VerdictInterestDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictInterestDetailsPayload>
          }
          aggregate: {
            args: Prisma.VerdictInterestDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictInterestDetails>
          }
          groupBy: {
            args: Prisma.VerdictInterestDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictInterestDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictInterestDetailsCountAggregateOutputType> | number
          }
        }
      }
      VerdictEmbargo: {
        payload: Prisma.$VerdictEmbargoPayload<ExtArgs>
        fields: Prisma.VerdictEmbargoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictEmbargoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictEmbargoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          findFirst: {
            args: Prisma.VerdictEmbargoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictEmbargoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          findMany: {
            args: Prisma.VerdictEmbargoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>[]
          }
          create: {
            args: Prisma.VerdictEmbargoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          createMany: {
            args: Prisma.VerdictEmbargoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictEmbargoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>[]
          }
          delete: {
            args: Prisma.VerdictEmbargoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          update: {
            args: Prisma.VerdictEmbargoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          deleteMany: {
            args: Prisma.VerdictEmbargoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictEmbargoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictEmbargoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>[]
          }
          upsert: {
            args: Prisma.VerdictEmbargoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictEmbargoPayload>
          }
          aggregate: {
            args: Prisma.VerdictEmbargoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictEmbargo>
          }
          groupBy: {
            args: Prisma.VerdictEmbargoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictEmbargoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictEmbargoCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictEmbargoCountAggregateOutputType> | number
          }
        }
      }
      VerdictBailiffServices: {
        payload: Prisma.$VerdictBailiffServicesPayload<ExtArgs>
        fields: Prisma.VerdictBailiffServicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictBailiffServicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictBailiffServicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          findFirst: {
            args: Prisma.VerdictBailiffServicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictBailiffServicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          findMany: {
            args: Prisma.VerdictBailiffServicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>[]
          }
          create: {
            args: Prisma.VerdictBailiffServicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          createMany: {
            args: Prisma.VerdictBailiffServicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictBailiffServicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>[]
          }
          delete: {
            args: Prisma.VerdictBailiffServicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          update: {
            args: Prisma.VerdictBailiffServicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          deleteMany: {
            args: Prisma.VerdictBailiffServicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictBailiffServicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictBailiffServicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>[]
          }
          upsert: {
            args: Prisma.VerdictBailiffServicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictBailiffServicesPayload>
          }
          aggregate: {
            args: Prisma.VerdictBailiffServicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictBailiffServices>
          }
          groupBy: {
            args: Prisma.VerdictBailiffServicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictBailiffServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictBailiffServicesCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictBailiffServicesCountAggregateOutputType> | number
          }
        }
      }
      VerdictAttachment: {
        payload: Prisma.$VerdictAttachmentPayload<ExtArgs>
        fields: Prisma.VerdictAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerdictAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerdictAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          findFirst: {
            args: Prisma.VerdictAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerdictAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          findMany: {
            args: Prisma.VerdictAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>[]
          }
          create: {
            args: Prisma.VerdictAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          createMany: {
            args: Prisma.VerdictAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerdictAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>[]
          }
          delete: {
            args: Prisma.VerdictAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          update: {
            args: Prisma.VerdictAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.VerdictAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerdictAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerdictAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.VerdictAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerdictAttachmentPayload>
          }
          aggregate: {
            args: Prisma.VerdictAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerdictAttachment>
          }
          groupBy: {
            args: Prisma.VerdictAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerdictAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerdictAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<VerdictAttachmentCountAggregateOutputType> | number
          }
        }
      }
      InterestType: {
        payload: Prisma.$InterestTypePayload<ExtArgs>
        fields: Prisma.InterestTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          findFirst: {
            args: Prisma.InterestTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          findMany: {
            args: Prisma.InterestTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>[]
          }
          create: {
            args: Prisma.InterestTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          createMany: {
            args: Prisma.InterestTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>[]
          }
          delete: {
            args: Prisma.InterestTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          update: {
            args: Prisma.InterestTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          deleteMany: {
            args: Prisma.InterestTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterestTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>[]
          }
          upsert: {
            args: Prisma.InterestTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestTypePayload>
          }
          aggregate: {
            args: Prisma.InterestTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterestType>
          }
          groupBy: {
            args: Prisma.InterestTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestTypeCountArgs<ExtArgs>
            result: $Utils.Optional<InterestTypeCountAggregateOutputType> | number
          }
        }
      }
      InterestDetail: {
        payload: Prisma.$InterestDetailPayload<ExtArgs>
        fields: Prisma.InterestDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          findFirst: {
            args: Prisma.InterestDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          findMany: {
            args: Prisma.InterestDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>[]
          }
          create: {
            args: Prisma.InterestDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          createMany: {
            args: Prisma.InterestDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>[]
          }
          delete: {
            args: Prisma.InterestDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          update: {
            args: Prisma.InterestDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          deleteMany: {
            args: Prisma.InterestDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterestDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>[]
          }
          upsert: {
            args: Prisma.InterestDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestDetailPayload>
          }
          aggregate: {
            args: Prisma.InterestDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterestDetail>
          }
          groupBy: {
            args: Prisma.InterestDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestDetailCountArgs<ExtArgs>
            result: $Utils.Optional<InterestDetailCountAggregateOutputType> | number
          }
        }
      }
      BillingInvoice: {
        payload: Prisma.$BillingInvoicePayload<ExtArgs>
        fields: Prisma.BillingInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          findFirst: {
            args: Prisma.BillingInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          findMany: {
            args: Prisma.BillingInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>[]
          }
          create: {
            args: Prisma.BillingInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          createMany: {
            args: Prisma.BillingInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>[]
          }
          delete: {
            args: Prisma.BillingInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          update: {
            args: Prisma.BillingInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          deleteMany: {
            args: Prisma.BillingInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>[]
          }
          upsert: {
            args: Prisma.BillingInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoicePayload>
          }
          aggregate: {
            args: Prisma.BillingInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingInvoice>
          }
          groupBy: {
            args: Prisma.BillingInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceCountAggregateOutputType> | number
          }
        }
      }
      BillingInvoiceDetail: {
        payload: Prisma.$BillingInvoiceDetailPayload<ExtArgs>
        fields: Prisma.BillingInvoiceDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingInvoiceDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingInvoiceDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          findFirst: {
            args: Prisma.BillingInvoiceDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingInvoiceDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          findMany: {
            args: Prisma.BillingInvoiceDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>[]
          }
          create: {
            args: Prisma.BillingInvoiceDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          createMany: {
            args: Prisma.BillingInvoiceDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingInvoiceDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>[]
          }
          delete: {
            args: Prisma.BillingInvoiceDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          update: {
            args: Prisma.BillingInvoiceDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          deleteMany: {
            args: Prisma.BillingInvoiceDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingInvoiceDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingInvoiceDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>[]
          }
          upsert: {
            args: Prisma.BillingInvoiceDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingInvoiceDetailPayload>
          }
          aggregate: {
            args: Prisma.BillingInvoiceDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingInvoiceDetail>
          }
          groupBy: {
            args: Prisma.BillingInvoiceDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingInvoiceDetailCountArgs<ExtArgs>
            result: $Utils.Optional<BillingInvoiceDetailCountAggregateOutputType> | number
          }
        }
      }
      BillingPayment: {
        payload: Prisma.$BillingPaymentPayload<ExtArgs>
        fields: Prisma.BillingPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          findFirst: {
            args: Prisma.BillingPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          findMany: {
            args: Prisma.BillingPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>[]
          }
          create: {
            args: Prisma.BillingPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          createMany: {
            args: Prisma.BillingPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillingPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>[]
          }
          delete: {
            args: Prisma.BillingPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          update: {
            args: Prisma.BillingPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          deleteMany: {
            args: Prisma.BillingPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillingPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillingPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>[]
          }
          upsert: {
            args: Prisma.BillingPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillingPaymentPayload>
          }
          aggregate: {
            args: Prisma.BillingPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillingPayment>
          }
          groupBy: {
            args: Prisma.BillingPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillingPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<BillingPaymentCountAggregateOutputType> | number
          }
        }
      }
      CollectionCase: {
        payload: Prisma.$CollectionCasePayload<ExtArgs>
        fields: Prisma.CollectionCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          findFirst: {
            args: Prisma.CollectionCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          findMany: {
            args: Prisma.CollectionCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>[]
          }
          create: {
            args: Prisma.CollectionCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          createMany: {
            args: Prisma.CollectionCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>[]
          }
          delete: {
            args: Prisma.CollectionCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          update: {
            args: Prisma.CollectionCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          deleteMany: {
            args: Prisma.CollectionCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionCaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>[]
          }
          upsert: {
            args: Prisma.CollectionCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePayload>
          }
          aggregate: {
            args: Prisma.CollectionCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionCase>
          }
          groupBy: {
            args: Prisma.CollectionCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCaseCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseCountAggregateOutputType> | number
          }
        }
      }
      CollectionCasePenalty: {
        payload: Prisma.$CollectionCasePenaltyPayload<ExtArgs>
        fields: Prisma.CollectionCasePenaltyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionCasePenaltyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePenaltyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionCasePenaltyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePenaltyPayload>
          }
          findFirst: {
            args: Prisma.CollectionCasePenaltyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePenaltyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionCasePenaltyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePenaltyPayload>
          }
          findMany: {
            args: Prisma.CollectionCasePenaltyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePenaltyPayload>[]
          }
          create: {
            args: Prisma.CollectionCasePenaltyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePenaltyPayload>
          }
          createMany: {
            args: Prisma.CollectionCasePenaltyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCasePenaltyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePenaltyPayload>[]
          }
          delete: {
            args: Prisma.CollectionCasePenaltyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePenaltyPayload>
          }
          update: {
            args: Prisma.CollectionCasePenaltyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePenaltyPayload>
          }
          deleteMany: {
            args: Prisma.CollectionCasePenaltyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionCasePenaltyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionCasePenaltyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePenaltyPayload>[]
          }
          upsert: {
            args: Prisma.CollectionCasePenaltyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePenaltyPayload>
          }
          aggregate: {
            args: Prisma.CollectionCasePenaltyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionCasePenalty>
          }
          groupBy: {
            args: Prisma.CollectionCasePenaltyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionCasePenaltyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCasePenaltyCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCasePenaltyCountAggregateOutputType> | number
          }
        }
      }
      CollectionCaseNotification: {
        payload: Prisma.$CollectionCaseNotificationPayload<ExtArgs>
        fields: Prisma.CollectionCaseNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionCaseNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionCaseNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseNotificationPayload>
          }
          findFirst: {
            args: Prisma.CollectionCaseNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionCaseNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseNotificationPayload>
          }
          findMany: {
            args: Prisma.CollectionCaseNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseNotificationPayload>[]
          }
          create: {
            args: Prisma.CollectionCaseNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseNotificationPayload>
          }
          createMany: {
            args: Prisma.CollectionCaseNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCaseNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseNotificationPayload>[]
          }
          delete: {
            args: Prisma.CollectionCaseNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseNotificationPayload>
          }
          update: {
            args: Prisma.CollectionCaseNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseNotificationPayload>
          }
          deleteMany: {
            args: Prisma.CollectionCaseNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionCaseNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionCaseNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseNotificationPayload>[]
          }
          upsert: {
            args: Prisma.CollectionCaseNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseNotificationPayload>
          }
          aggregate: {
            args: Prisma.CollectionCaseNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionCaseNotification>
          }
          groupBy: {
            args: Prisma.CollectionCaseNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCaseNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseNotificationCountAggregateOutputType> | number
          }
        }
      }
      CollectionCasePayment: {
        payload: Prisma.$CollectionCasePaymentPayload<ExtArgs>
        fields: Prisma.CollectionCasePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionCasePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionCasePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePaymentPayload>
          }
          findFirst: {
            args: Prisma.CollectionCasePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionCasePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePaymentPayload>
          }
          findMany: {
            args: Prisma.CollectionCasePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePaymentPayload>[]
          }
          create: {
            args: Prisma.CollectionCasePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePaymentPayload>
          }
          createMany: {
            args: Prisma.CollectionCasePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCasePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePaymentPayload>[]
          }
          delete: {
            args: Prisma.CollectionCasePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePaymentPayload>
          }
          update: {
            args: Prisma.CollectionCasePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePaymentPayload>
          }
          deleteMany: {
            args: Prisma.CollectionCasePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionCasePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionCasePaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePaymentPayload>[]
          }
          upsert: {
            args: Prisma.CollectionCasePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCasePaymentPayload>
          }
          aggregate: {
            args: Prisma.CollectionCasePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionCasePayment>
          }
          groupBy: {
            args: Prisma.CollectionCasePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionCasePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCasePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCasePaymentCountAggregateOutputType> | number
          }
        }
      }
      Debtor: {
        payload: Prisma.$DebtorPayload<ExtArgs>
        fields: Prisma.DebtorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          findFirst: {
            args: Prisma.DebtorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          findMany: {
            args: Prisma.DebtorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>[]
          }
          create: {
            args: Prisma.DebtorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          createMany: {
            args: Prisma.DebtorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DebtorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>[]
          }
          delete: {
            args: Prisma.DebtorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          update: {
            args: Prisma.DebtorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          deleteMany: {
            args: Prisma.DebtorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DebtorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>[]
          }
          upsert: {
            args: Prisma.DebtorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorPayload>
          }
          aggregate: {
            args: Prisma.DebtorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebtor>
          }
          groupBy: {
            args: Prisma.DebtorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DebtorCountArgs<ExtArgs>
            result: $Utils.Optional<DebtorCountAggregateOutputType> | number
          }
        }
      }
      ChatRoom: {
        payload: Prisma.$ChatRoomPayload<ExtArgs>
        fields: Prisma.ChatRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          findFirst: {
            args: Prisma.ChatRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          findMany: {
            args: Prisma.ChatRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>[]
          }
          create: {
            args: Prisma.ChatRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          createMany: {
            args: Prisma.ChatRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>[]
          }
          delete: {
            args: Prisma.ChatRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          update: {
            args: Prisma.ChatRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          deleteMany: {
            args: Prisma.ChatRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatRoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>[]
          }
          upsert: {
            args: Prisma.ChatRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatRoomPayload>
          }
          aggregate: {
            args: Prisma.ChatRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatRoom>
          }
          groupBy: {
            args: Prisma.ChatRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatRoomCountArgs<ExtArgs>
            result: $Utils.Optional<ChatRoomCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      DebtorIncome: {
        payload: Prisma.$DebtorIncomePayload<ExtArgs>
        fields: Prisma.DebtorIncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DebtorIncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DebtorIncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          findFirst: {
            args: Prisma.DebtorIncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DebtorIncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          findMany: {
            args: Prisma.DebtorIncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>[]
          }
          create: {
            args: Prisma.DebtorIncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          createMany: {
            args: Prisma.DebtorIncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DebtorIncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>[]
          }
          delete: {
            args: Prisma.DebtorIncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          update: {
            args: Prisma.DebtorIncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          deleteMany: {
            args: Prisma.DebtorIncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DebtorIncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DebtorIncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>[]
          }
          upsert: {
            args: Prisma.DebtorIncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DebtorIncomePayload>
          }
          aggregate: {
            args: Prisma.DebtorIncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDebtorIncome>
          }
          groupBy: {
            args: Prisma.DebtorIncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DebtorIncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DebtorIncomeCountArgs<ExtArgs>
            result: $Utils.Optional<DebtorIncomeCountAggregateOutputType> | number
          }
        }
      }
      CollectionCaseAgreement: {
        payload: Prisma.$CollectionCaseAgreementPayload<ExtArgs>
        fields: Prisma.CollectionCaseAgreementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionCaseAgreementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionCaseAgreementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementPayload>
          }
          findFirst: {
            args: Prisma.CollectionCaseAgreementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionCaseAgreementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementPayload>
          }
          findMany: {
            args: Prisma.CollectionCaseAgreementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementPayload>[]
          }
          create: {
            args: Prisma.CollectionCaseAgreementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementPayload>
          }
          createMany: {
            args: Prisma.CollectionCaseAgreementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCaseAgreementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementPayload>[]
          }
          delete: {
            args: Prisma.CollectionCaseAgreementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementPayload>
          }
          update: {
            args: Prisma.CollectionCaseAgreementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementPayload>
          }
          deleteMany: {
            args: Prisma.CollectionCaseAgreementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionCaseAgreementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionCaseAgreementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementPayload>[]
          }
          upsert: {
            args: Prisma.CollectionCaseAgreementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementPayload>
          }
          aggregate: {
            args: Prisma.CollectionCaseAgreementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionCaseAgreement>
          }
          groupBy: {
            args: Prisma.CollectionCaseAgreementGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseAgreementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCaseAgreementCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseAgreementCountAggregateOutputType> | number
          }
        }
      }
      CollectionCaseAgreementInstallment: {
        payload: Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>
        fields: Prisma.CollectionCaseAgreementInstallmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionCaseAgreementInstallmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementInstallmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionCaseAgreementInstallmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementInstallmentPayload>
          }
          findFirst: {
            args: Prisma.CollectionCaseAgreementInstallmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementInstallmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionCaseAgreementInstallmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementInstallmentPayload>
          }
          findMany: {
            args: Prisma.CollectionCaseAgreementInstallmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementInstallmentPayload>[]
          }
          create: {
            args: Prisma.CollectionCaseAgreementInstallmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementInstallmentPayload>
          }
          createMany: {
            args: Prisma.CollectionCaseAgreementInstallmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCaseAgreementInstallmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementInstallmentPayload>[]
          }
          delete: {
            args: Prisma.CollectionCaseAgreementInstallmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementInstallmentPayload>
          }
          update: {
            args: Prisma.CollectionCaseAgreementInstallmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementInstallmentPayload>
          }
          deleteMany: {
            args: Prisma.CollectionCaseAgreementInstallmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionCaseAgreementInstallmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionCaseAgreementInstallmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementInstallmentPayload>[]
          }
          upsert: {
            args: Prisma.CollectionCaseAgreementInstallmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionCaseAgreementInstallmentPayload>
          }
          aggregate: {
            args: Prisma.CollectionCaseAgreementInstallmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionCaseAgreementInstallment>
          }
          groupBy: {
            args: Prisma.CollectionCaseAgreementInstallmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseAgreementInstallmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCaseAgreementInstallmentCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCaseAgreementInstallmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    user?: UserOmit
    parameter?: ParameterOmit
    verdict?: VerdictOmit
    verdictInterest?: VerdictInterestOmit
    verdictInterestDetails?: VerdictInterestDetailsOmit
    verdictEmbargo?: VerdictEmbargoOmit
    verdictBailiffServices?: VerdictBailiffServicesOmit
    verdictAttachment?: VerdictAttachmentOmit
    interestType?: InterestTypeOmit
    interestDetail?: InterestDetailOmit
    billingInvoice?: BillingInvoiceOmit
    billingInvoiceDetail?: BillingInvoiceDetailOmit
    billingPayment?: BillingPaymentOmit
    collectionCase?: CollectionCaseOmit
    collectionCasePenalty?: CollectionCasePenaltyOmit
    collectionCaseNotification?: CollectionCaseNotificationOmit
    collectionCasePayment?: CollectionCasePaymentOmit
    debtor?: DebtorOmit
    chatRoom?: ChatRoomOmit
    chatMessage?: ChatMessageOmit
    debtorIncome?: DebtorIncomeOmit
    collectionCaseAgreement?: CollectionCaseAgreementOmit
    collectionCaseAgreementInstallment?: CollectionCaseAgreementInstallmentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    billing_invoice: number
    collection_cases: number
    debtors: number
    verdicts: number
    users: number
    chat_rooms: number
    agreements: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billing_invoice?: boolean | TenantCountOutputTypeCountBilling_invoiceArgs
    collection_cases?: boolean | TenantCountOutputTypeCountCollection_casesArgs
    debtors?: boolean | TenantCountOutputTypeCountDebtorsArgs
    verdicts?: boolean | TenantCountOutputTypeCountVerdictsArgs
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    chat_rooms?: boolean | TenantCountOutputTypeCountChat_roomsArgs
    agreements?: boolean | TenantCountOutputTypeCountAgreementsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBilling_invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCollection_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDebtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVerdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountChat_roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatRoomWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseAgreementWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    debtors: number
    verdict_bailiffs: number
    messages: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtors?: boolean | UserCountOutputTypeCountDebtorsArgs
    verdict_bailiffs?: boolean | UserCountOutputTypeCountVerdict_bailiffsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDebtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerdict_bailiffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type VerdictCountOutputType
   */

  export type VerdictCountOutputType = {
    attachments: number
    bailiff_services: number
    verdict_embargo: number
    verdict_interest: number
  }

  export type VerdictCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | VerdictCountOutputTypeCountAttachmentsArgs
    bailiff_services?: boolean | VerdictCountOutputTypeCountBailiff_servicesArgs
    verdict_embargo?: boolean | VerdictCountOutputTypeCountVerdict_embargoArgs
    verdict_interest?: boolean | VerdictCountOutputTypeCountVerdict_interestArgs
  }

  // Custom InputTypes
  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictCountOutputType
     */
    select?: VerdictCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictAttachmentWhereInput
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountBailiff_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictBailiffServicesWhereInput
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountVerdict_embargoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictEmbargoWhereInput
  }

  /**
   * VerdictCountOutputType without action
   */
  export type VerdictCountOutputTypeCountVerdict_interestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestWhereInput
  }


  /**
   * Count Type VerdictInterestCountOutputType
   */

  export type VerdictInterestCountOutputType = {
    details: number
  }

  export type VerdictInterestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | VerdictInterestCountOutputTypeCountDetailsArgs
  }

  // Custom InputTypes
  /**
   * VerdictInterestCountOutputType without action
   */
  export type VerdictInterestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestCountOutputType
     */
    select?: VerdictInterestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VerdictInterestCountOutputType without action
   */
  export type VerdictInterestCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestDetailsWhereInput
  }


  /**
   * Count Type InterestTypeCountOutputType
   */

  export type InterestTypeCountOutputType = {
    details: number
  }

  export type InterestTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | InterestTypeCountOutputTypeCountDetailsArgs
  }

  // Custom InputTypes
  /**
   * InterestTypeCountOutputType without action
   */
  export type InterestTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestTypeCountOutputType
     */
    select?: InterestTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterestTypeCountOutputType without action
   */
  export type InterestTypeCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestDetailWhereInput
  }


  /**
   * Count Type BillingInvoiceCountOutputType
   */

  export type BillingInvoiceCountOutputType = {
    details: number
    payments: number
  }

  export type BillingInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | BillingInvoiceCountOutputTypeCountDetailsArgs
    payments?: boolean | BillingInvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * BillingInvoiceCountOutputType without action
   */
  export type BillingInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceCountOutputType
     */
    select?: BillingInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillingInvoiceCountOutputType without action
   */
  export type BillingInvoiceCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceDetailWhereInput
  }

  /**
   * BillingInvoiceCountOutputType without action
   */
  export type BillingInvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingPaymentWhereInput
  }


  /**
   * Count Type CollectionCaseCountOutputType
   */

  export type CollectionCaseCountOutputType = {
    notifications: number
    payments: number
    agreements: number
    penalties: number
    chat_rooms: number
  }

  export type CollectionCaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | CollectionCaseCountOutputTypeCountNotificationsArgs
    payments?: boolean | CollectionCaseCountOutputTypeCountPaymentsArgs
    agreements?: boolean | CollectionCaseCountOutputTypeCountAgreementsArgs
    penalties?: boolean | CollectionCaseCountOutputTypeCountPenaltiesArgs
    chat_rooms?: boolean | CollectionCaseCountOutputTypeCountChat_roomsArgs
  }

  // Custom InputTypes
  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseCountOutputType
     */
    select?: CollectionCaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseNotificationWhereInput
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCasePaymentWhereInput
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseAgreementWhereInput
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountPenaltiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCasePenaltyWhereInput
  }

  /**
   * CollectionCaseCountOutputType without action
   */
  export type CollectionCaseCountOutputTypeCountChat_roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatRoomWhereInput
  }


  /**
   * Count Type CollectionCasePaymentCountOutputType
   */

  export type CollectionCasePaymentCountOutputType = {
    installments: number
  }

  export type CollectionCasePaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installments?: boolean | CollectionCasePaymentCountOutputTypeCountInstallmentsArgs
  }

  // Custom InputTypes
  /**
   * CollectionCasePaymentCountOutputType without action
   */
  export type CollectionCasePaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePaymentCountOutputType
     */
    select?: CollectionCasePaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionCasePaymentCountOutputType without action
   */
  export type CollectionCasePaymentCountOutputTypeCountInstallmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseAgreementInstallmentWhereInput
  }


  /**
   * Count Type DebtorCountOutputType
   */

  export type DebtorCountOutputType = {
    collection_cases: number
    incomes: number
    payment_agreements: number
    verdicts: number
  }

  export type DebtorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_cases?: boolean | DebtorCountOutputTypeCountCollection_casesArgs
    incomes?: boolean | DebtorCountOutputTypeCountIncomesArgs
    payment_agreements?: boolean | DebtorCountOutputTypeCountPayment_agreementsArgs
    verdicts?: boolean | DebtorCountOutputTypeCountVerdictsArgs
  }

  // Custom InputTypes
  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorCountOutputType
     */
    select?: DebtorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountCollection_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseWhereInput
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountIncomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorIncomeWhereInput
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountPayment_agreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseAgreementWhereInput
  }

  /**
   * DebtorCountOutputType without action
   */
  export type DebtorCountOutputTypeCountVerdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
  }


  /**
   * Count Type ChatRoomCountOutputType
   */

  export type ChatRoomCountOutputType = {
    messages: number
  }

  export type ChatRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatRoomCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatRoomCountOutputType without action
   */
  export type ChatRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoomCountOutputType
     */
    select?: ChatRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatRoomCountOutputType without action
   */
  export type ChatRoomCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type CollectionCaseAgreementCountOutputType
   */

  export type CollectionCaseAgreementCountOutputType = {
    installments: number
    payments: number
  }

  export type CollectionCaseAgreementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installments?: boolean | CollectionCaseAgreementCountOutputTypeCountInstallmentsArgs
    payments?: boolean | CollectionCaseAgreementCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * CollectionCaseAgreementCountOutputType without action
   */
  export type CollectionCaseAgreementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementCountOutputType
     */
    select?: CollectionCaseAgreementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionCaseAgreementCountOutputType without action
   */
  export type CollectionCaseAgreementCountOutputTypeCountInstallmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseAgreementInstallmentWhereInput
  }

  /**
   * CollectionCaseAgreementCountOutputType without action
   */
  export type CollectionCaseAgreementCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCasePaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantAvgAggregateOutputType = {
    number_of_employees: number | null
  }

  export type TenantSumAggregateOutputType = {
    number_of_employees: number | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    contact_email: string | null
    country_code: string | null
    kvk: string | null
    legal_name: string | null
    address: string | null
    city: string | null
    logo_url: string | null
    number_of_employees: number | null
    phone: string | null
    website: string | null
    terms_accepted: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    contact_email: string | null
    country_code: string | null
    kvk: string | null
    legal_name: string | null
    address: string | null
    city: string | null
    logo_url: string | null
    number_of_employees: number | null
    phone: string | null
    website: string | null
    terms_accepted: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    subdomain: number
    contact_email: number
    country_code: number
    kvk: number
    legal_name: number
    address: number
    city: number
    logo_url: number
    number_of_employees: number
    phone: number
    website: number
    terms_accepted: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TenantAvgAggregateInputType = {
    number_of_employees?: true
  }

  export type TenantSumAggregateInputType = {
    number_of_employees?: true
  }

  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    contact_email?: true
    country_code?: true
    kvk?: true
    legal_name?: true
    address?: true
    city?: true
    logo_url?: true
    number_of_employees?: true
    phone?: true
    website?: true
    terms_accepted?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    contact_email?: true
    country_code?: true
    kvk?: true
    legal_name?: true
    address?: true
    city?: true
    logo_url?: true
    number_of_employees?: true
    phone?: true
    website?: true
    terms_accepted?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    contact_email?: true
    country_code?: true
    kvk?: true
    legal_name?: true
    address?: true
    city?: true
    logo_url?: true
    number_of_employees?: true
    phone?: true
    website?: true
    terms_accepted?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _avg?: TenantAvgAggregateInputType
    _sum?: TenantSumAggregateInputType
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk: string | null
    legal_name: string | null
    address: string | null
    city: string | null
    logo_url: string | null
    number_of_employees: number | null
    phone: string | null
    website: string | null
    terms_accepted: boolean
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: TenantCountAggregateOutputType | null
    _avg: TenantAvgAggregateOutputType | null
    _sum: TenantSumAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    contact_email?: boolean
    country_code?: boolean
    kvk?: boolean
    legal_name?: boolean
    address?: boolean
    city?: boolean
    logo_url?: boolean
    number_of_employees?: boolean
    phone?: boolean
    website?: boolean
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    billing_invoice?: boolean | Tenant$billing_invoiceArgs<ExtArgs>
    collection_cases?: boolean | Tenant$collection_casesArgs<ExtArgs>
    debtors?: boolean | Tenant$debtorsArgs<ExtArgs>
    verdicts?: boolean | Tenant$verdictsArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    chat_rooms?: boolean | Tenant$chat_roomsArgs<ExtArgs>
    agreements?: boolean | Tenant$agreementsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    contact_email?: boolean
    country_code?: boolean
    kvk?: boolean
    legal_name?: boolean
    address?: boolean
    city?: boolean
    logo_url?: boolean
    number_of_employees?: boolean
    phone?: boolean
    website?: boolean
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    contact_email?: boolean
    country_code?: boolean
    kvk?: boolean
    legal_name?: boolean
    address?: boolean
    city?: boolean
    logo_url?: boolean
    number_of_employees?: boolean
    phone?: boolean
    website?: boolean
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    subdomain?: boolean
    contact_email?: boolean
    country_code?: boolean
    kvk?: boolean
    legal_name?: boolean
    address?: boolean
    city?: boolean
    logo_url?: boolean
    number_of_employees?: boolean
    phone?: boolean
    website?: boolean
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subdomain" | "contact_email" | "country_code" | "kvk" | "legal_name" | "address" | "city" | "logo_url" | "number_of_employees" | "phone" | "website" | "terms_accepted" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billing_invoice?: boolean | Tenant$billing_invoiceArgs<ExtArgs>
    collection_cases?: boolean | Tenant$collection_casesArgs<ExtArgs>
    debtors?: boolean | Tenant$debtorsArgs<ExtArgs>
    verdicts?: boolean | Tenant$verdictsArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    chat_rooms?: boolean | Tenant$chat_roomsArgs<ExtArgs>
    agreements?: boolean | Tenant$agreementsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      billing_invoice: Prisma.$BillingInvoicePayload<ExtArgs>[]
      collection_cases: Prisma.$CollectionCasePayload<ExtArgs>[]
      debtors: Prisma.$DebtorPayload<ExtArgs>[]
      verdicts: Prisma.$VerdictPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      chat_rooms: Prisma.$ChatRoomPayload<ExtArgs>[]
      agreements: Prisma.$CollectionCaseAgreementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subdomain: string
      contact_email: string
      country_code: string
      kvk: string | null
      legal_name: string | null
      address: string | null
      city: string | null
      logo_url: string | null
      number_of_employees: number | null
      phone: string | null
      website: string | null
      terms_accepted: boolean
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billing_invoice<T extends Tenant$billing_invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$billing_invoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collection_cases<T extends Tenant$collection_casesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$collection_casesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    debtors<T extends Tenant$debtorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$debtorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdicts<T extends Tenant$verdictsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$verdictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chat_rooms<T extends Tenant$chat_roomsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$chat_roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agreements<T extends Tenant$agreementsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$agreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly subdomain: FieldRef<"Tenant", 'String'>
    readonly contact_email: FieldRef<"Tenant", 'String'>
    readonly country_code: FieldRef<"Tenant", 'String'>
    readonly kvk: FieldRef<"Tenant", 'String'>
    readonly legal_name: FieldRef<"Tenant", 'String'>
    readonly address: FieldRef<"Tenant", 'String'>
    readonly city: FieldRef<"Tenant", 'String'>
    readonly logo_url: FieldRef<"Tenant", 'String'>
    readonly number_of_employees: FieldRef<"Tenant", 'Int'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly website: FieldRef<"Tenant", 'String'>
    readonly terms_accepted: FieldRef<"Tenant", 'Boolean'>
    readonly is_active: FieldRef<"Tenant", 'Boolean'>
    readonly created_at: FieldRef<"Tenant", 'DateTime'>
    readonly updated_at: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.billing_invoice
   */
  export type Tenant$billing_invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    where?: BillingInvoiceWhereInput
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    cursor?: BillingInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.collection_cases
   */
  export type Tenant$collection_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    where?: CollectionCaseWhereInput
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    cursor?: CollectionCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * Tenant.debtors
   */
  export type Tenant$debtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    where?: DebtorWhereInput
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    cursor?: DebtorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Tenant.verdicts
   */
  export type Tenant$verdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    cursor?: VerdictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.chat_rooms
   */
  export type Tenant$chat_roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    where?: ChatRoomWhereInput
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    cursor?: ChatRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * Tenant.agreements
   */
  export type Tenant$agreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    where?: CollectionCaseAgreementWhereInput
    orderBy?: CollectionCaseAgreementOrderByWithRelationInput | CollectionCaseAgreementOrderByWithRelationInput[]
    cursor?: CollectionCaseAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseAgreementScalarFieldEnum | CollectionCaseAgreementScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    fullname: string | null
    phone: string | null
    tenant_id: string | null
    role: $Enums.roleEnum | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    fullname: string | null
    phone: string | null
    tenant_id: string | null
    role: $Enums.roleEnum | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    fullname: number
    phone: number
    tenant_id: number
    role: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    fullname?: true
    phone?: true
    tenant_id?: true
    role?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    fullname?: true
    phone?: true
    tenant_id?: true
    role?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    fullname?: true
    phone?: true
    tenant_id?: true
    role?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password_hash: string | null
    fullname: string | null
    phone: string | null
    tenant_id: string
    role: $Enums.roleEnum
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    fullname?: boolean
    phone?: boolean
    tenant_id?: boolean
    role?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    debtors?: boolean | User$debtorsArgs<ExtArgs>
    verdict_bailiffs?: boolean | User$verdict_bailiffsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    fullname?: boolean
    phone?: boolean
    tenant_id?: boolean
    role?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    fullname?: boolean
    phone?: boolean
    tenant_id?: boolean
    role?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    fullname?: boolean
    phone?: boolean
    tenant_id?: boolean
    role?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password_hash" | "fullname" | "phone" | "tenant_id" | "role" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    debtors?: boolean | User$debtorsArgs<ExtArgs>
    verdict_bailiffs?: boolean | User$verdict_bailiffsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      debtors: Prisma.$DebtorPayload<ExtArgs>[]
      verdict_bailiffs: Prisma.$VerdictPayload<ExtArgs>[]
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password_hash: string | null
      fullname: string | null
      phone: string | null
      tenant_id: string
      role: $Enums.roleEnum
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    debtors<T extends User$debtorsArgs<ExtArgs> = {}>(args?: Subset<T, User$debtorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdict_bailiffs<T extends User$verdict_bailiffsArgs<ExtArgs> = {}>(args?: Subset<T, User$verdict_bailiffsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly fullname: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly tenant_id: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'roleEnum'>
    readonly is_active: FieldRef<"User", 'Boolean'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.debtors
   */
  export type User$debtorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    where?: DebtorWhereInput
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    cursor?: DebtorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * User.verdict_bailiffs
   */
  export type User$verdict_bailiffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    cursor?: VerdictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Parameter
   */

  export type AggregateParameter = {
    _count: ParameterCountAggregateOutputType | null
    _avg: ParameterAvgAggregateOutputType | null
    _sum: ParameterSumAggregateOutputType | null
    _min: ParameterMinAggregateOutputType | null
    _max: ParameterMaxAggregateOutputType | null
  }

  export type ParameterAvgAggregateOutputType = {
    collection_fee_rate: number | null
    abb_rate: number | null
    company_aanmaning_term_days: number | null
    consumer_aanmaning_term_days: number | null
    company_sommatie_term_days: number | null
    consumer_sommatie_term_days: number | null
    small_company_price: number | null
    small_company_pfc_contribution: number | null
    large_company_price: number | null
    large_company_pfc_contribution: number | null
    company_aanmaning_penalty: number | null
    natural_aanmaning_penalty: number | null
    company_sommatie_penalty: number | null
    natural_sommatie_penalty: number | null
    company_reaction_limit_days: number | null
    company_no_reaction_penalty: number | null
    natural_no_reaction_penalty: number | null
    company_payment_agreement_fee: number | null
    natural_payment_agreement_fee: number | null
    invoice_number_length: number | null
    invoice_sequence: number | null
  }

  export type ParameterSumAggregateOutputType = {
    collection_fee_rate: number | null
    abb_rate: number | null
    company_aanmaning_term_days: number | null
    consumer_aanmaning_term_days: number | null
    company_sommatie_term_days: number | null
    consumer_sommatie_term_days: number | null
    small_company_price: number | null
    small_company_pfc_contribution: number | null
    large_company_price: number | null
    large_company_pfc_contribution: number | null
    company_aanmaning_penalty: number | null
    natural_aanmaning_penalty: number | null
    company_sommatie_penalty: number | null
    natural_sommatie_penalty: number | null
    company_reaction_limit_days: number | null
    company_no_reaction_penalty: number | null
    natural_no_reaction_penalty: number | null
    company_payment_agreement_fee: number | null
    natural_payment_agreement_fee: number | null
    invoice_number_length: number | null
    invoice_sequence: number | null
  }

  export type ParameterMinAggregateOutputType = {
    id: string | null
    collection_fee_rate: number | null
    abb_rate: number | null
    company_aanmaning_term_days: number | null
    consumer_aanmaning_term_days: number | null
    company_sommatie_term_days: number | null
    consumer_sommatie_term_days: number | null
    small_company_price: number | null
    small_company_pfc_contribution: number | null
    large_company_price: number | null
    large_company_pfc_contribution: number | null
    company_aanmaning_penalty: number | null
    natural_aanmaning_penalty: number | null
    company_sommatie_penalty: number | null
    natural_sommatie_penalty: number | null
    company_reaction_limit_days: number | null
    company_no_reaction_penalty: number | null
    natural_no_reaction_penalty: number | null
    company_payment_agreement_fee: number | null
    natural_payment_agreement_fee: number | null
    invoice_number_length: number | null
    invoice_prefix: string | null
    invoice_sequence: number | null
    bank_account: string | null
    bank_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ParameterMaxAggregateOutputType = {
    id: string | null
    collection_fee_rate: number | null
    abb_rate: number | null
    company_aanmaning_term_days: number | null
    consumer_aanmaning_term_days: number | null
    company_sommatie_term_days: number | null
    consumer_sommatie_term_days: number | null
    small_company_price: number | null
    small_company_pfc_contribution: number | null
    large_company_price: number | null
    large_company_pfc_contribution: number | null
    company_aanmaning_penalty: number | null
    natural_aanmaning_penalty: number | null
    company_sommatie_penalty: number | null
    natural_sommatie_penalty: number | null
    company_reaction_limit_days: number | null
    company_no_reaction_penalty: number | null
    natural_no_reaction_penalty: number | null
    company_payment_agreement_fee: number | null
    natural_payment_agreement_fee: number | null
    invoice_number_length: number | null
    invoice_prefix: string | null
    invoice_sequence: number | null
    bank_account: string | null
    bank_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ParameterCountAggregateOutputType = {
    id: number
    collection_fee_rate: number
    abb_rate: number
    company_aanmaning_term_days: number
    consumer_aanmaning_term_days: number
    company_sommatie_term_days: number
    consumer_sommatie_term_days: number
    small_company_price: number
    small_company_pfc_contribution: number
    large_company_price: number
    large_company_pfc_contribution: number
    company_aanmaning_penalty: number
    natural_aanmaning_penalty: number
    company_sommatie_penalty: number
    natural_sommatie_penalty: number
    company_reaction_limit_days: number
    company_no_reaction_penalty: number
    natural_no_reaction_penalty: number
    company_payment_agreement_fee: number
    natural_payment_agreement_fee: number
    invoice_number_length: number
    invoice_prefix: number
    invoice_sequence: number
    bank_account: number
    bank_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ParameterAvgAggregateInputType = {
    collection_fee_rate?: true
    abb_rate?: true
    company_aanmaning_term_days?: true
    consumer_aanmaning_term_days?: true
    company_sommatie_term_days?: true
    consumer_sommatie_term_days?: true
    small_company_price?: true
    small_company_pfc_contribution?: true
    large_company_price?: true
    large_company_pfc_contribution?: true
    company_aanmaning_penalty?: true
    natural_aanmaning_penalty?: true
    company_sommatie_penalty?: true
    natural_sommatie_penalty?: true
    company_reaction_limit_days?: true
    company_no_reaction_penalty?: true
    natural_no_reaction_penalty?: true
    company_payment_agreement_fee?: true
    natural_payment_agreement_fee?: true
    invoice_number_length?: true
    invoice_sequence?: true
  }

  export type ParameterSumAggregateInputType = {
    collection_fee_rate?: true
    abb_rate?: true
    company_aanmaning_term_days?: true
    consumer_aanmaning_term_days?: true
    company_sommatie_term_days?: true
    consumer_sommatie_term_days?: true
    small_company_price?: true
    small_company_pfc_contribution?: true
    large_company_price?: true
    large_company_pfc_contribution?: true
    company_aanmaning_penalty?: true
    natural_aanmaning_penalty?: true
    company_sommatie_penalty?: true
    natural_sommatie_penalty?: true
    company_reaction_limit_days?: true
    company_no_reaction_penalty?: true
    natural_no_reaction_penalty?: true
    company_payment_agreement_fee?: true
    natural_payment_agreement_fee?: true
    invoice_number_length?: true
    invoice_sequence?: true
  }

  export type ParameterMinAggregateInputType = {
    id?: true
    collection_fee_rate?: true
    abb_rate?: true
    company_aanmaning_term_days?: true
    consumer_aanmaning_term_days?: true
    company_sommatie_term_days?: true
    consumer_sommatie_term_days?: true
    small_company_price?: true
    small_company_pfc_contribution?: true
    large_company_price?: true
    large_company_pfc_contribution?: true
    company_aanmaning_penalty?: true
    natural_aanmaning_penalty?: true
    company_sommatie_penalty?: true
    natural_sommatie_penalty?: true
    company_reaction_limit_days?: true
    company_no_reaction_penalty?: true
    natural_no_reaction_penalty?: true
    company_payment_agreement_fee?: true
    natural_payment_agreement_fee?: true
    invoice_number_length?: true
    invoice_prefix?: true
    invoice_sequence?: true
    bank_account?: true
    bank_name?: true
    created_at?: true
    updated_at?: true
  }

  export type ParameterMaxAggregateInputType = {
    id?: true
    collection_fee_rate?: true
    abb_rate?: true
    company_aanmaning_term_days?: true
    consumer_aanmaning_term_days?: true
    company_sommatie_term_days?: true
    consumer_sommatie_term_days?: true
    small_company_price?: true
    small_company_pfc_contribution?: true
    large_company_price?: true
    large_company_pfc_contribution?: true
    company_aanmaning_penalty?: true
    natural_aanmaning_penalty?: true
    company_sommatie_penalty?: true
    natural_sommatie_penalty?: true
    company_reaction_limit_days?: true
    company_no_reaction_penalty?: true
    natural_no_reaction_penalty?: true
    company_payment_agreement_fee?: true
    natural_payment_agreement_fee?: true
    invoice_number_length?: true
    invoice_prefix?: true
    invoice_sequence?: true
    bank_account?: true
    bank_name?: true
    created_at?: true
    updated_at?: true
  }

  export type ParameterCountAggregateInputType = {
    id?: true
    collection_fee_rate?: true
    abb_rate?: true
    company_aanmaning_term_days?: true
    consumer_aanmaning_term_days?: true
    company_sommatie_term_days?: true
    consumer_sommatie_term_days?: true
    small_company_price?: true
    small_company_pfc_contribution?: true
    large_company_price?: true
    large_company_pfc_contribution?: true
    company_aanmaning_penalty?: true
    natural_aanmaning_penalty?: true
    company_sommatie_penalty?: true
    natural_sommatie_penalty?: true
    company_reaction_limit_days?: true
    company_no_reaction_penalty?: true
    natural_no_reaction_penalty?: true
    company_payment_agreement_fee?: true
    natural_payment_agreement_fee?: true
    invoice_number_length?: true
    invoice_prefix?: true
    invoice_sequence?: true
    bank_account?: true
    bank_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parameter to aggregate.
     */
    where?: ParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParameterOrderByWithRelationInput | ParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parameters
    **/
    _count?: true | ParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParameterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParameterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParameterMaxAggregateInputType
  }

  export type GetParameterAggregateType<T extends ParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParameter[P]>
      : GetScalarType<T[P], AggregateParameter[P]>
  }




  export type ParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParameterWhereInput
    orderBy?: ParameterOrderByWithAggregationInput | ParameterOrderByWithAggregationInput[]
    by: ParameterScalarFieldEnum[] | ParameterScalarFieldEnum
    having?: ParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParameterCountAggregateInputType | true
    _avg?: ParameterAvgAggregateInputType
    _sum?: ParameterSumAggregateInputType
    _min?: ParameterMinAggregateInputType
    _max?: ParameterMaxAggregateInputType
  }

  export type ParameterGroupByOutputType = {
    id: string
    collection_fee_rate: number
    abb_rate: number
    company_aanmaning_term_days: number
    consumer_aanmaning_term_days: number
    company_sommatie_term_days: number
    consumer_sommatie_term_days: number
    small_company_price: number
    small_company_pfc_contribution: number
    large_company_price: number
    large_company_pfc_contribution: number
    company_aanmaning_penalty: number
    natural_aanmaning_penalty: number
    company_sommatie_penalty: number
    natural_sommatie_penalty: number
    company_reaction_limit_days: number
    company_no_reaction_penalty: number
    natural_no_reaction_penalty: number
    company_payment_agreement_fee: number
    natural_payment_agreement_fee: number
    invoice_number_length: number
    invoice_prefix: string
    invoice_sequence: number
    bank_account: string
    bank_name: string
    created_at: Date
    updated_at: Date
    _count: ParameterCountAggregateOutputType | null
    _avg: ParameterAvgAggregateOutputType | null
    _sum: ParameterSumAggregateOutputType | null
    _min: ParameterMinAggregateOutputType | null
    _max: ParameterMaxAggregateOutputType | null
  }

  type GetParameterGroupByPayload<T extends ParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParameterGroupByOutputType[P]>
            : GetScalarType<T[P], ParameterGroupByOutputType[P]>
        }
      >
    >


  export type ParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_fee_rate?: boolean
    abb_rate?: boolean
    company_aanmaning_term_days?: boolean
    consumer_aanmaning_term_days?: boolean
    company_sommatie_term_days?: boolean
    consumer_sommatie_term_days?: boolean
    small_company_price?: boolean
    small_company_pfc_contribution?: boolean
    large_company_price?: boolean
    large_company_pfc_contribution?: boolean
    company_aanmaning_penalty?: boolean
    natural_aanmaning_penalty?: boolean
    company_sommatie_penalty?: boolean
    natural_sommatie_penalty?: boolean
    company_reaction_limit_days?: boolean
    company_no_reaction_penalty?: boolean
    natural_no_reaction_penalty?: boolean
    company_payment_agreement_fee?: boolean
    natural_payment_agreement_fee?: boolean
    invoice_number_length?: boolean
    invoice_prefix?: boolean
    invoice_sequence?: boolean
    bank_account?: boolean
    bank_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["parameter"]>

  export type ParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_fee_rate?: boolean
    abb_rate?: boolean
    company_aanmaning_term_days?: boolean
    consumer_aanmaning_term_days?: boolean
    company_sommatie_term_days?: boolean
    consumer_sommatie_term_days?: boolean
    small_company_price?: boolean
    small_company_pfc_contribution?: boolean
    large_company_price?: boolean
    large_company_pfc_contribution?: boolean
    company_aanmaning_penalty?: boolean
    natural_aanmaning_penalty?: boolean
    company_sommatie_penalty?: boolean
    natural_sommatie_penalty?: boolean
    company_reaction_limit_days?: boolean
    company_no_reaction_penalty?: boolean
    natural_no_reaction_penalty?: boolean
    company_payment_agreement_fee?: boolean
    natural_payment_agreement_fee?: boolean
    invoice_number_length?: boolean
    invoice_prefix?: boolean
    invoice_sequence?: boolean
    bank_account?: boolean
    bank_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["parameter"]>

  export type ParameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_fee_rate?: boolean
    abb_rate?: boolean
    company_aanmaning_term_days?: boolean
    consumer_aanmaning_term_days?: boolean
    company_sommatie_term_days?: boolean
    consumer_sommatie_term_days?: boolean
    small_company_price?: boolean
    small_company_pfc_contribution?: boolean
    large_company_price?: boolean
    large_company_pfc_contribution?: boolean
    company_aanmaning_penalty?: boolean
    natural_aanmaning_penalty?: boolean
    company_sommatie_penalty?: boolean
    natural_sommatie_penalty?: boolean
    company_reaction_limit_days?: boolean
    company_no_reaction_penalty?: boolean
    natural_no_reaction_penalty?: boolean
    company_payment_agreement_fee?: boolean
    natural_payment_agreement_fee?: boolean
    invoice_number_length?: boolean
    invoice_prefix?: boolean
    invoice_sequence?: boolean
    bank_account?: boolean
    bank_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["parameter"]>

  export type ParameterSelectScalar = {
    id?: boolean
    collection_fee_rate?: boolean
    abb_rate?: boolean
    company_aanmaning_term_days?: boolean
    consumer_aanmaning_term_days?: boolean
    company_sommatie_term_days?: boolean
    consumer_sommatie_term_days?: boolean
    small_company_price?: boolean
    small_company_pfc_contribution?: boolean
    large_company_price?: boolean
    large_company_pfc_contribution?: boolean
    company_aanmaning_penalty?: boolean
    natural_aanmaning_penalty?: boolean
    company_sommatie_penalty?: boolean
    natural_sommatie_penalty?: boolean
    company_reaction_limit_days?: boolean
    company_no_reaction_penalty?: boolean
    natural_no_reaction_penalty?: boolean
    company_payment_agreement_fee?: boolean
    natural_payment_agreement_fee?: boolean
    invoice_number_length?: boolean
    invoice_prefix?: boolean
    invoice_sequence?: boolean
    bank_account?: boolean
    bank_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collection_fee_rate" | "abb_rate" | "company_aanmaning_term_days" | "consumer_aanmaning_term_days" | "company_sommatie_term_days" | "consumer_sommatie_term_days" | "small_company_price" | "small_company_pfc_contribution" | "large_company_price" | "large_company_pfc_contribution" | "company_aanmaning_penalty" | "natural_aanmaning_penalty" | "company_sommatie_penalty" | "natural_sommatie_penalty" | "company_reaction_limit_days" | "company_no_reaction_penalty" | "natural_no_reaction_penalty" | "company_payment_agreement_fee" | "natural_payment_agreement_fee" | "invoice_number_length" | "invoice_prefix" | "invoice_sequence" | "bank_account" | "bank_name" | "created_at" | "updated_at", ExtArgs["result"]["parameter"]>

  export type $ParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parameter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collection_fee_rate: number
      abb_rate: number
      company_aanmaning_term_days: number
      consumer_aanmaning_term_days: number
      company_sommatie_term_days: number
      consumer_sommatie_term_days: number
      small_company_price: number
      small_company_pfc_contribution: number
      large_company_price: number
      large_company_pfc_contribution: number
      company_aanmaning_penalty: number
      natural_aanmaning_penalty: number
      company_sommatie_penalty: number
      natural_sommatie_penalty: number
      company_reaction_limit_days: number
      company_no_reaction_penalty: number
      natural_no_reaction_penalty: number
      company_payment_agreement_fee: number
      natural_payment_agreement_fee: number
      invoice_number_length: number
      invoice_prefix: string
      invoice_sequence: number
      bank_account: string
      bank_name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["parameter"]>
    composites: {}
  }

  type ParameterGetPayload<S extends boolean | null | undefined | ParameterDefaultArgs> = $Result.GetResult<Prisma.$ParameterPayload, S>

  type ParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParameterCountAggregateInputType | true
    }

  export interface ParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parameter'], meta: { name: 'Parameter' } }
    /**
     * Find zero or one Parameter that matches the filter.
     * @param {ParameterFindUniqueArgs} args - Arguments to find a Parameter
     * @example
     * // Get one Parameter
     * const parameter = await prisma.parameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParameterFindUniqueArgs>(args: SelectSubset<T, ParameterFindUniqueArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParameterFindUniqueOrThrowArgs} args - Arguments to find a Parameter
     * @example
     * // Get one Parameter
     * const parameter = await prisma.parameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, ParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterFindFirstArgs} args - Arguments to find a Parameter
     * @example
     * // Get one Parameter
     * const parameter = await prisma.parameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParameterFindFirstArgs>(args?: SelectSubset<T, ParameterFindFirstArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterFindFirstOrThrowArgs} args - Arguments to find a Parameter
     * @example
     * // Get one Parameter
     * const parameter = await prisma.parameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, ParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parameters
     * const parameters = await prisma.parameter.findMany()
     * 
     * // Get first 10 Parameters
     * const parameters = await prisma.parameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parameterWithIdOnly = await prisma.parameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParameterFindManyArgs>(args?: SelectSubset<T, ParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parameter.
     * @param {ParameterCreateArgs} args - Arguments to create a Parameter.
     * @example
     * // Create one Parameter
     * const Parameter = await prisma.parameter.create({
     *   data: {
     *     // ... data to create a Parameter
     *   }
     * })
     * 
     */
    create<T extends ParameterCreateArgs>(args: SelectSubset<T, ParameterCreateArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parameters.
     * @param {ParameterCreateManyArgs} args - Arguments to create many Parameters.
     * @example
     * // Create many Parameters
     * const parameter = await prisma.parameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParameterCreateManyArgs>(args?: SelectSubset<T, ParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parameters and returns the data saved in the database.
     * @param {ParameterCreateManyAndReturnArgs} args - Arguments to create many Parameters.
     * @example
     * // Create many Parameters
     * const parameter = await prisma.parameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parameters and only return the `id`
     * const parameterWithIdOnly = await prisma.parameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, ParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parameter.
     * @param {ParameterDeleteArgs} args - Arguments to delete one Parameter.
     * @example
     * // Delete one Parameter
     * const Parameter = await prisma.parameter.delete({
     *   where: {
     *     // ... filter to delete one Parameter
     *   }
     * })
     * 
     */
    delete<T extends ParameterDeleteArgs>(args: SelectSubset<T, ParameterDeleteArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parameter.
     * @param {ParameterUpdateArgs} args - Arguments to update one Parameter.
     * @example
     * // Update one Parameter
     * const parameter = await prisma.parameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParameterUpdateArgs>(args: SelectSubset<T, ParameterUpdateArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parameters.
     * @param {ParameterDeleteManyArgs} args - Arguments to filter Parameters to delete.
     * @example
     * // Delete a few Parameters
     * const { count } = await prisma.parameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParameterDeleteManyArgs>(args?: SelectSubset<T, ParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parameters
     * const parameter = await prisma.parameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParameterUpdateManyArgs>(args: SelectSubset<T, ParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parameters and returns the data updated in the database.
     * @param {ParameterUpdateManyAndReturnArgs} args - Arguments to update many Parameters.
     * @example
     * // Update many Parameters
     * const parameter = await prisma.parameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parameters and only return the `id`
     * const parameterWithIdOnly = await prisma.parameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParameterUpdateManyAndReturnArgs>(args: SelectSubset<T, ParameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parameter.
     * @param {ParameterUpsertArgs} args - Arguments to update or create a Parameter.
     * @example
     * // Update or create a Parameter
     * const parameter = await prisma.parameter.upsert({
     *   create: {
     *     // ... data to create a Parameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parameter we want to update
     *   }
     * })
     */
    upsert<T extends ParameterUpsertArgs>(args: SelectSubset<T, ParameterUpsertArgs<ExtArgs>>): Prisma__ParameterClient<$Result.GetResult<Prisma.$ParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterCountArgs} args - Arguments to filter Parameters to count.
     * @example
     * // Count the number of Parameters
     * const count = await prisma.parameter.count({
     *   where: {
     *     // ... the filter for the Parameters we want to count
     *   }
     * })
    **/
    count<T extends ParameterCountArgs>(
      args?: Subset<T, ParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParameterAggregateArgs>(args: Subset<T, ParameterAggregateArgs>): Prisma.PrismaPromise<GetParameterAggregateType<T>>

    /**
     * Group by Parameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParameterGroupByArgs['orderBy'] }
        : { orderBy?: ParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parameter model
   */
  readonly fields: ParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parameter model
   */
  interface ParameterFieldRefs {
    readonly id: FieldRef<"Parameter", 'String'>
    readonly collection_fee_rate: FieldRef<"Parameter", 'Float'>
    readonly abb_rate: FieldRef<"Parameter", 'Float'>
    readonly company_aanmaning_term_days: FieldRef<"Parameter", 'Int'>
    readonly consumer_aanmaning_term_days: FieldRef<"Parameter", 'Int'>
    readonly company_sommatie_term_days: FieldRef<"Parameter", 'Int'>
    readonly consumer_sommatie_term_days: FieldRef<"Parameter", 'Int'>
    readonly small_company_price: FieldRef<"Parameter", 'Float'>
    readonly small_company_pfc_contribution: FieldRef<"Parameter", 'Float'>
    readonly large_company_price: FieldRef<"Parameter", 'Float'>
    readonly large_company_pfc_contribution: FieldRef<"Parameter", 'Float'>
    readonly company_aanmaning_penalty: FieldRef<"Parameter", 'Float'>
    readonly natural_aanmaning_penalty: FieldRef<"Parameter", 'Float'>
    readonly company_sommatie_penalty: FieldRef<"Parameter", 'Float'>
    readonly natural_sommatie_penalty: FieldRef<"Parameter", 'Float'>
    readonly company_reaction_limit_days: FieldRef<"Parameter", 'Int'>
    readonly company_no_reaction_penalty: FieldRef<"Parameter", 'Float'>
    readonly natural_no_reaction_penalty: FieldRef<"Parameter", 'Float'>
    readonly company_payment_agreement_fee: FieldRef<"Parameter", 'Float'>
    readonly natural_payment_agreement_fee: FieldRef<"Parameter", 'Float'>
    readonly invoice_number_length: FieldRef<"Parameter", 'Int'>
    readonly invoice_prefix: FieldRef<"Parameter", 'String'>
    readonly invoice_sequence: FieldRef<"Parameter", 'Int'>
    readonly bank_account: FieldRef<"Parameter", 'String'>
    readonly bank_name: FieldRef<"Parameter", 'String'>
    readonly created_at: FieldRef<"Parameter", 'DateTime'>
    readonly updated_at: FieldRef<"Parameter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parameter findUnique
   */
  export type ParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter, which Parameter to fetch.
     */
    where: ParameterWhereUniqueInput
  }

  /**
   * Parameter findUniqueOrThrow
   */
  export type ParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter, which Parameter to fetch.
     */
    where: ParameterWhereUniqueInput
  }

  /**
   * Parameter findFirst
   */
  export type ParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter, which Parameter to fetch.
     */
    where?: ParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParameterOrderByWithRelationInput | ParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parameters.
     */
    cursor?: ParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parameters.
     */
    distinct?: ParameterScalarFieldEnum | ParameterScalarFieldEnum[]
  }

  /**
   * Parameter findFirstOrThrow
   */
  export type ParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter, which Parameter to fetch.
     */
    where?: ParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParameterOrderByWithRelationInput | ParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parameters.
     */
    cursor?: ParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parameters.
     */
    distinct?: ParameterScalarFieldEnum | ParameterScalarFieldEnum[]
  }

  /**
   * Parameter findMany
   */
  export type ParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter, which Parameters to fetch.
     */
    where?: ParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parameters to fetch.
     */
    orderBy?: ParameterOrderByWithRelationInput | ParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parameters.
     */
    cursor?: ParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parameters.
     */
    skip?: number
    distinct?: ParameterScalarFieldEnum | ParameterScalarFieldEnum[]
  }

  /**
   * Parameter create
   */
  export type ParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * The data needed to create a Parameter.
     */
    data: XOR<ParameterCreateInput, ParameterUncheckedCreateInput>
  }

  /**
   * Parameter createMany
   */
  export type ParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parameters.
     */
    data: ParameterCreateManyInput | ParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parameter createManyAndReturn
   */
  export type ParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * The data used to create many Parameters.
     */
    data: ParameterCreateManyInput | ParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parameter update
   */
  export type ParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * The data needed to update a Parameter.
     */
    data: XOR<ParameterUpdateInput, ParameterUncheckedUpdateInput>
    /**
     * Choose, which Parameter to update.
     */
    where: ParameterWhereUniqueInput
  }

  /**
   * Parameter updateMany
   */
  export type ParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parameters.
     */
    data: XOR<ParameterUpdateManyMutationInput, ParameterUncheckedUpdateManyInput>
    /**
     * Filter which Parameters to update
     */
    where?: ParameterWhereInput
    /**
     * Limit how many Parameters to update.
     */
    limit?: number
  }

  /**
   * Parameter updateManyAndReturn
   */
  export type ParameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * The data used to update Parameters.
     */
    data: XOR<ParameterUpdateManyMutationInput, ParameterUncheckedUpdateManyInput>
    /**
     * Filter which Parameters to update
     */
    where?: ParameterWhereInput
    /**
     * Limit how many Parameters to update.
     */
    limit?: number
  }

  /**
   * Parameter upsert
   */
  export type ParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * The filter to search for the Parameter to update in case it exists.
     */
    where: ParameterWhereUniqueInput
    /**
     * In case the Parameter found by the `where` argument doesn't exist, create a new Parameter with this data.
     */
    create: XOR<ParameterCreateInput, ParameterUncheckedCreateInput>
    /**
     * In case the Parameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParameterUpdateInput, ParameterUncheckedUpdateInput>
  }

  /**
   * Parameter delete
   */
  export type ParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
    /**
     * Filter which Parameter to delete.
     */
    where: ParameterWhereUniqueInput
  }

  /**
   * Parameter deleteMany
   */
  export type ParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parameters to delete
     */
    where?: ParameterWhereInput
    /**
     * Limit how many Parameters to delete.
     */
    limit?: number
  }

  /**
   * Parameter without action
   */
  export type ParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parameter
     */
    select?: ParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parameter
     */
    omit?: ParameterOmit<ExtArgs> | null
  }


  /**
   * Model Verdict
   */

  export type AggregateVerdict = {
    _count: VerdictCountAggregateOutputType | null
    _avg: VerdictAvgAggregateOutputType | null
    _sum: VerdictSumAggregateOutputType | null
    _min: VerdictMinAggregateOutputType | null
    _max: VerdictMaxAggregateOutputType | null
  }

  export type VerdictAvgAggregateOutputType = {
    sentence_amount: number | null
    procesal_cost: number | null
  }

  export type VerdictSumAggregateOutputType = {
    sentence_amount: number | null
    procesal_cost: number | null
  }

  export type VerdictMinAggregateOutputType = {
    id: string | null
    invoice_number: string | null
    creditor_name: string | null
    debtor_id: string | null
    registration_number: string | null
    sentence_amount: number | null
    sentence_date: Date | null
    status: $Enums.VerdictStatus | null
    created_at: Date | null
    updated_at: Date | null
    procesal_cost: number | null
    tenant_id: string | null
    notes: string | null
    bailiff_id: string | null
  }

  export type VerdictMaxAggregateOutputType = {
    id: string | null
    invoice_number: string | null
    creditor_name: string | null
    debtor_id: string | null
    registration_number: string | null
    sentence_amount: number | null
    sentence_date: Date | null
    status: $Enums.VerdictStatus | null
    created_at: Date | null
    updated_at: Date | null
    procesal_cost: number | null
    tenant_id: string | null
    notes: string | null
    bailiff_id: string | null
  }

  export type VerdictCountAggregateOutputType = {
    id: number
    invoice_number: number
    creditor_name: number
    debtor_id: number
    registration_number: number
    sentence_amount: number
    sentence_date: number
    status: number
    created_at: number
    updated_at: number
    procesal_cost: number
    tenant_id: number
    notes: number
    bailiff_id: number
    _all: number
  }


  export type VerdictAvgAggregateInputType = {
    sentence_amount?: true
    procesal_cost?: true
  }

  export type VerdictSumAggregateInputType = {
    sentence_amount?: true
    procesal_cost?: true
  }

  export type VerdictMinAggregateInputType = {
    id?: true
    invoice_number?: true
    creditor_name?: true
    debtor_id?: true
    registration_number?: true
    sentence_amount?: true
    sentence_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    procesal_cost?: true
    tenant_id?: true
    notes?: true
    bailiff_id?: true
  }

  export type VerdictMaxAggregateInputType = {
    id?: true
    invoice_number?: true
    creditor_name?: true
    debtor_id?: true
    registration_number?: true
    sentence_amount?: true
    sentence_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    procesal_cost?: true
    tenant_id?: true
    notes?: true
    bailiff_id?: true
  }

  export type VerdictCountAggregateInputType = {
    id?: true
    invoice_number?: true
    creditor_name?: true
    debtor_id?: true
    registration_number?: true
    sentence_amount?: true
    sentence_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    procesal_cost?: true
    tenant_id?: true
    notes?: true
    bailiff_id?: true
    _all?: true
  }

  export type VerdictAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verdict to aggregate.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verdicts
    **/
    _count?: true | VerdictCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictMaxAggregateInputType
  }

  export type GetVerdictAggregateType<T extends VerdictAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdict]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdict[P]>
      : GetScalarType<T[P], AggregateVerdict[P]>
  }




  export type VerdictGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithAggregationInput | VerdictOrderByWithAggregationInput[]
    by: VerdictScalarFieldEnum[] | VerdictScalarFieldEnum
    having?: VerdictScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictCountAggregateInputType | true
    _avg?: VerdictAvgAggregateInputType
    _sum?: VerdictSumAggregateInputType
    _min?: VerdictMinAggregateInputType
    _max?: VerdictMaxAggregateInputType
  }

  export type VerdictGroupByOutputType = {
    id: string
    invoice_number: string
    creditor_name: string
    debtor_id: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date
    status: $Enums.VerdictStatus
    created_at: Date
    updated_at: Date
    procesal_cost: number | null
    tenant_id: string
    notes: string | null
    bailiff_id: string | null
    _count: VerdictCountAggregateOutputType | null
    _avg: VerdictAvgAggregateOutputType | null
    _sum: VerdictSumAggregateOutputType | null
    _min: VerdictMinAggregateOutputType | null
    _max: VerdictMaxAggregateOutputType | null
  }

  type GetVerdictGroupByPayload<T extends VerdictGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictGroupByOutputType[P]>
        }
      >
    >


  export type VerdictSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    creditor_name?: boolean
    debtor_id?: boolean
    registration_number?: boolean
    sentence_amount?: boolean
    sentence_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    procesal_cost?: boolean
    tenant_id?: boolean
    notes?: boolean
    bailiff_id?: boolean
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    attachments?: boolean | Verdict$attachmentsArgs<ExtArgs>
    bailiff_services?: boolean | Verdict$bailiff_servicesArgs<ExtArgs>
    verdict_embargo?: boolean | Verdict$verdict_embargoArgs<ExtArgs>
    verdict_interest?: boolean | Verdict$verdict_interestArgs<ExtArgs>
    _count?: boolean | VerdictCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    creditor_name?: boolean
    debtor_id?: boolean
    registration_number?: boolean
    sentence_amount?: boolean
    sentence_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    procesal_cost?: boolean
    tenant_id?: boolean
    notes?: boolean
    bailiff_id?: boolean
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    creditor_name?: boolean
    debtor_id?: boolean
    registration_number?: boolean
    sentence_amount?: boolean
    sentence_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    procesal_cost?: boolean
    tenant_id?: boolean
    notes?: boolean
    bailiff_id?: boolean
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdict"]>

  export type VerdictSelectScalar = {
    id?: boolean
    invoice_number?: boolean
    creditor_name?: boolean
    debtor_id?: boolean
    registration_number?: boolean
    sentence_amount?: boolean
    sentence_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    procesal_cost?: boolean
    tenant_id?: boolean
    notes?: boolean
    bailiff_id?: boolean
  }

  export type VerdictOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_number" | "creditor_name" | "debtor_id" | "registration_number" | "sentence_amount" | "sentence_date" | "status" | "created_at" | "updated_at" | "procesal_cost" | "tenant_id" | "notes" | "bailiff_id", ExtArgs["result"]["verdict"]>
  export type VerdictInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    attachments?: boolean | Verdict$attachmentsArgs<ExtArgs>
    bailiff_services?: boolean | Verdict$bailiff_servicesArgs<ExtArgs>
    verdict_embargo?: boolean | Verdict$verdict_embargoArgs<ExtArgs>
    verdict_interest?: boolean | Verdict$verdict_interestArgs<ExtArgs>
    _count?: boolean | VerdictCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VerdictIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VerdictIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bailiff?: boolean | Verdict$bailiffArgs<ExtArgs>
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $VerdictPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verdict"
    objects: {
      bailiff: Prisma.$UserPayload<ExtArgs> | null
      debtor: Prisma.$DebtorPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      attachments: Prisma.$VerdictAttachmentPayload<ExtArgs>[]
      bailiff_services: Prisma.$VerdictBailiffServicesPayload<ExtArgs>[]
      verdict_embargo: Prisma.$VerdictEmbargoPayload<ExtArgs>[]
      verdict_interest: Prisma.$VerdictInterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoice_number: string
      creditor_name: string
      debtor_id: string
      registration_number: string
      sentence_amount: number
      sentence_date: Date
      status: $Enums.VerdictStatus
      created_at: Date
      updated_at: Date
      procesal_cost: number | null
      tenant_id: string
      notes: string | null
      bailiff_id: string | null
    }, ExtArgs["result"]["verdict"]>
    composites: {}
  }

  type VerdictGetPayload<S extends boolean | null | undefined | VerdictDefaultArgs> = $Result.GetResult<Prisma.$VerdictPayload, S>

  type VerdictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictCountAggregateInputType | true
    }

  export interface VerdictDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verdict'], meta: { name: 'Verdict' } }
    /**
     * Find zero or one Verdict that matches the filter.
     * @param {VerdictFindUniqueArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictFindUniqueArgs>(args: SelectSubset<T, VerdictFindUniqueArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verdict that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictFindUniqueOrThrowArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verdict that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindFirstArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictFindFirstArgs>(args?: SelectSubset<T, VerdictFindFirstArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verdict that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindFirstOrThrowArgs} args - Arguments to find a Verdict
     * @example
     * // Get one Verdict
     * const verdict = await prisma.verdict.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verdicts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verdicts
     * const verdicts = await prisma.verdict.findMany()
     * 
     * // Get first 10 Verdicts
     * const verdicts = await prisma.verdict.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictWithIdOnly = await prisma.verdict.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictFindManyArgs>(args?: SelectSubset<T, VerdictFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verdict.
     * @param {VerdictCreateArgs} args - Arguments to create a Verdict.
     * @example
     * // Create one Verdict
     * const Verdict = await prisma.verdict.create({
     *   data: {
     *     // ... data to create a Verdict
     *   }
     * })
     * 
     */
    create<T extends VerdictCreateArgs>(args: SelectSubset<T, VerdictCreateArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verdicts.
     * @param {VerdictCreateManyArgs} args - Arguments to create many Verdicts.
     * @example
     * // Create many Verdicts
     * const verdict = await prisma.verdict.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictCreateManyArgs>(args?: SelectSubset<T, VerdictCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verdicts and returns the data saved in the database.
     * @param {VerdictCreateManyAndReturnArgs} args - Arguments to create many Verdicts.
     * @example
     * // Create many Verdicts
     * const verdict = await prisma.verdict.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verdicts and only return the `id`
     * const verdictWithIdOnly = await prisma.verdict.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verdict.
     * @param {VerdictDeleteArgs} args - Arguments to delete one Verdict.
     * @example
     * // Delete one Verdict
     * const Verdict = await prisma.verdict.delete({
     *   where: {
     *     // ... filter to delete one Verdict
     *   }
     * })
     * 
     */
    delete<T extends VerdictDeleteArgs>(args: SelectSubset<T, VerdictDeleteArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verdict.
     * @param {VerdictUpdateArgs} args - Arguments to update one Verdict.
     * @example
     * // Update one Verdict
     * const verdict = await prisma.verdict.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictUpdateArgs>(args: SelectSubset<T, VerdictUpdateArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verdicts.
     * @param {VerdictDeleteManyArgs} args - Arguments to filter Verdicts to delete.
     * @example
     * // Delete a few Verdicts
     * const { count } = await prisma.verdict.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictDeleteManyArgs>(args?: SelectSubset<T, VerdictDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verdicts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verdicts
     * const verdict = await prisma.verdict.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictUpdateManyArgs>(args: SelectSubset<T, VerdictUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verdicts and returns the data updated in the database.
     * @param {VerdictUpdateManyAndReturnArgs} args - Arguments to update many Verdicts.
     * @example
     * // Update many Verdicts
     * const verdict = await prisma.verdict.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verdicts and only return the `id`
     * const verdictWithIdOnly = await prisma.verdict.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verdict.
     * @param {VerdictUpsertArgs} args - Arguments to update or create a Verdict.
     * @example
     * // Update or create a Verdict
     * const verdict = await prisma.verdict.upsert({
     *   create: {
     *     // ... data to create a Verdict
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verdict we want to update
     *   }
     * })
     */
    upsert<T extends VerdictUpsertArgs>(args: SelectSubset<T, VerdictUpsertArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verdicts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictCountArgs} args - Arguments to filter Verdicts to count.
     * @example
     * // Count the number of Verdicts
     * const count = await prisma.verdict.count({
     *   where: {
     *     // ... the filter for the Verdicts we want to count
     *   }
     * })
    **/
    count<T extends VerdictCountArgs>(
      args?: Subset<T, VerdictCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verdict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictAggregateArgs>(args: Subset<T, VerdictAggregateArgs>): Prisma.PrismaPromise<GetVerdictAggregateType<T>>

    /**
     * Group by Verdict.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictGroupByArgs['orderBy'] }
        : { orderBy?: VerdictGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verdict model
   */
  readonly fields: VerdictFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verdict.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bailiff<T extends Verdict$bailiffArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$bailiffArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    debtor<T extends DebtorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtorDefaultArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Verdict$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bailiff_services<T extends Verdict$bailiff_servicesArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$bailiff_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdict_embargo<T extends Verdict$verdict_embargoArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$verdict_embargoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdict_interest<T extends Verdict$verdict_interestArgs<ExtArgs> = {}>(args?: Subset<T, Verdict$verdict_interestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verdict model
   */
  interface VerdictFieldRefs {
    readonly id: FieldRef<"Verdict", 'String'>
    readonly invoice_number: FieldRef<"Verdict", 'String'>
    readonly creditor_name: FieldRef<"Verdict", 'String'>
    readonly debtor_id: FieldRef<"Verdict", 'String'>
    readonly registration_number: FieldRef<"Verdict", 'String'>
    readonly sentence_amount: FieldRef<"Verdict", 'Float'>
    readonly sentence_date: FieldRef<"Verdict", 'DateTime'>
    readonly status: FieldRef<"Verdict", 'VerdictStatus'>
    readonly created_at: FieldRef<"Verdict", 'DateTime'>
    readonly updated_at: FieldRef<"Verdict", 'DateTime'>
    readonly procesal_cost: FieldRef<"Verdict", 'Float'>
    readonly tenant_id: FieldRef<"Verdict", 'String'>
    readonly notes: FieldRef<"Verdict", 'String'>
    readonly bailiff_id: FieldRef<"Verdict", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Verdict findUnique
   */
  export type VerdictFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict findUniqueOrThrow
   */
  export type VerdictFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict findFirst
   */
  export type VerdictFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verdicts.
     */
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict findFirstOrThrow
   */
  export type VerdictFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdict to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verdicts.
     */
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict findMany
   */
  export type VerdictFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter, which Verdicts to fetch.
     */
    where?: VerdictWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verdicts to fetch.
     */
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verdicts.
     */
    cursor?: VerdictWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verdicts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verdicts.
     */
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Verdict create
   */
  export type VerdictCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The data needed to create a Verdict.
     */
    data: XOR<VerdictCreateInput, VerdictUncheckedCreateInput>
  }

  /**
   * Verdict createMany
   */
  export type VerdictCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verdicts.
     */
    data: VerdictCreateManyInput | VerdictCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verdict createManyAndReturn
   */
  export type VerdictCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * The data used to create many Verdicts.
     */
    data: VerdictCreateManyInput | VerdictCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verdict update
   */
  export type VerdictUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The data needed to update a Verdict.
     */
    data: XOR<VerdictUpdateInput, VerdictUncheckedUpdateInput>
    /**
     * Choose, which Verdict to update.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict updateMany
   */
  export type VerdictUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verdicts.
     */
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyInput>
    /**
     * Filter which Verdicts to update
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to update.
     */
    limit?: number
  }

  /**
   * Verdict updateManyAndReturn
   */
  export type VerdictUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * The data used to update Verdicts.
     */
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyInput>
    /**
     * Filter which Verdicts to update
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verdict upsert
   */
  export type VerdictUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * The filter to search for the Verdict to update in case it exists.
     */
    where: VerdictWhereUniqueInput
    /**
     * In case the Verdict found by the `where` argument doesn't exist, create a new Verdict with this data.
     */
    create: XOR<VerdictCreateInput, VerdictUncheckedCreateInput>
    /**
     * In case the Verdict was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictUpdateInput, VerdictUncheckedUpdateInput>
  }

  /**
   * Verdict delete
   */
  export type VerdictDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    /**
     * Filter which Verdict to delete.
     */
    where: VerdictWhereUniqueInput
  }

  /**
   * Verdict deleteMany
   */
  export type VerdictDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verdicts to delete
     */
    where?: VerdictWhereInput
    /**
     * Limit how many Verdicts to delete.
     */
    limit?: number
  }

  /**
   * Verdict.bailiff
   */
  export type Verdict$bailiffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Verdict.attachments
   */
  export type Verdict$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    where?: VerdictAttachmentWhereInput
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    cursor?: VerdictAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * Verdict.bailiff_services
   */
  export type Verdict$bailiff_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    where?: VerdictBailiffServicesWhereInput
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    cursor?: VerdictBailiffServicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * Verdict.verdict_embargo
   */
  export type Verdict$verdict_embargoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    where?: VerdictEmbargoWhereInput
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    cursor?: VerdictEmbargoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * Verdict.verdict_interest
   */
  export type Verdict$verdict_interestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    where?: VerdictInterestWhereInput
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    cursor?: VerdictInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * Verdict without action
   */
  export type VerdictDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
  }


  /**
   * Model VerdictInterest
   */

  export type AggregateVerdictInterest = {
    _count: VerdictInterestCountAggregateOutputType | null
    _avg: VerdictInterestAvgAggregateOutputType | null
    _sum: VerdictInterestSumAggregateOutputType | null
    _min: VerdictInterestMinAggregateOutputType | null
    _max: VerdictInterestMaxAggregateOutputType | null
  }

  export type VerdictInterestAvgAggregateOutputType = {
    interest_type: number | null
    base_amount: number | null
    calculated_interest: number | null
    total_interest: number | null
  }

  export type VerdictInterestSumAggregateOutputType = {
    interest_type: number | null
    base_amount: number | null
    calculated_interest: number | null
    total_interest: number | null
  }

  export type VerdictInterestMinAggregateOutputType = {
    id: string | null
    interest_type: number | null
    base_amount: number | null
    calculated_interest: number | null
    calculation_start: Date | null
    calculation_end: Date | null
    total_interest: number | null
    created_at: Date | null
    updated_at: Date | null
    verdict_id: string | null
  }

  export type VerdictInterestMaxAggregateOutputType = {
    id: string | null
    interest_type: number | null
    base_amount: number | null
    calculated_interest: number | null
    calculation_start: Date | null
    calculation_end: Date | null
    total_interest: number | null
    created_at: Date | null
    updated_at: Date | null
    verdict_id: string | null
  }

  export type VerdictInterestCountAggregateOutputType = {
    id: number
    interest_type: number
    base_amount: number
    calculated_interest: number
    calculation_start: number
    calculation_end: number
    total_interest: number
    created_at: number
    updated_at: number
    verdict_id: number
    _all: number
  }


  export type VerdictInterestAvgAggregateInputType = {
    interest_type?: true
    base_amount?: true
    calculated_interest?: true
    total_interest?: true
  }

  export type VerdictInterestSumAggregateInputType = {
    interest_type?: true
    base_amount?: true
    calculated_interest?: true
    total_interest?: true
  }

  export type VerdictInterestMinAggregateInputType = {
    id?: true
    interest_type?: true
    base_amount?: true
    calculated_interest?: true
    calculation_start?: true
    calculation_end?: true
    total_interest?: true
    created_at?: true
    updated_at?: true
    verdict_id?: true
  }

  export type VerdictInterestMaxAggregateInputType = {
    id?: true
    interest_type?: true
    base_amount?: true
    calculated_interest?: true
    calculation_start?: true
    calculation_end?: true
    total_interest?: true
    created_at?: true
    updated_at?: true
    verdict_id?: true
  }

  export type VerdictInterestCountAggregateInputType = {
    id?: true
    interest_type?: true
    base_amount?: true
    calculated_interest?: true
    calculation_start?: true
    calculation_end?: true
    total_interest?: true
    created_at?: true
    updated_at?: true
    verdict_id?: true
    _all?: true
  }

  export type VerdictInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterest to aggregate.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictInterests
    **/
    _count?: true | VerdictInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictInterestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictInterestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictInterestMaxAggregateInputType
  }

  export type GetVerdictInterestAggregateType<T extends VerdictInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictInterest[P]>
      : GetScalarType<T[P], AggregateVerdictInterest[P]>
  }




  export type VerdictInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestWhereInput
    orderBy?: VerdictInterestOrderByWithAggregationInput | VerdictInterestOrderByWithAggregationInput[]
    by: VerdictInterestScalarFieldEnum[] | VerdictInterestScalarFieldEnum
    having?: VerdictInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictInterestCountAggregateInputType | true
    _avg?: VerdictInterestAvgAggregateInputType
    _sum?: VerdictInterestSumAggregateInputType
    _min?: VerdictInterestMinAggregateInputType
    _max?: VerdictInterestMaxAggregateInputType
  }

  export type VerdictInterestGroupByOutputType = {
    id: string
    interest_type: number
    base_amount: number
    calculated_interest: number | null
    calculation_start: Date
    calculation_end: Date
    total_interest: number
    created_at: Date
    updated_at: Date
    verdict_id: string | null
    _count: VerdictInterestCountAggregateOutputType | null
    _avg: VerdictInterestAvgAggregateOutputType | null
    _sum: VerdictInterestSumAggregateOutputType | null
    _min: VerdictInterestMinAggregateOutputType | null
    _max: VerdictInterestMaxAggregateOutputType | null
  }

  type GetVerdictInterestGroupByPayload<T extends VerdictInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictInterestGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictInterestGroupByOutputType[P]>
        }
      >
    >


  export type VerdictInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interest_type?: boolean
    base_amount?: boolean
    calculated_interest?: boolean
    calculation_start?: boolean
    calculation_end?: boolean
    total_interest?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict_id?: boolean
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
    details?: boolean | VerdictInterest$detailsArgs<ExtArgs>
    _count?: boolean | VerdictInterestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterest"]>

  export type VerdictInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interest_type?: boolean
    base_amount?: boolean
    calculated_interest?: boolean
    calculation_start?: boolean
    calculation_end?: boolean
    total_interest?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict_id?: boolean
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterest"]>

  export type VerdictInterestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interest_type?: boolean
    base_amount?: boolean
    calculated_interest?: boolean
    calculation_start?: boolean
    calculation_end?: boolean
    total_interest?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict_id?: boolean
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterest"]>

  export type VerdictInterestSelectScalar = {
    id?: boolean
    interest_type?: boolean
    base_amount?: boolean
    calculated_interest?: boolean
    calculation_start?: boolean
    calculation_end?: boolean
    total_interest?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict_id?: boolean
  }

  export type VerdictInterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interest_type" | "base_amount" | "calculated_interest" | "calculation_start" | "calculation_end" | "total_interest" | "created_at" | "updated_at" | "verdict_id", ExtArgs["result"]["verdictInterest"]>
  export type VerdictInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
    details?: boolean | VerdictInterest$detailsArgs<ExtArgs>
    _count?: boolean | VerdictInterestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VerdictInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }
  export type VerdictInterestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictInterest$verdictArgs<ExtArgs>
  }

  export type $VerdictInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictInterest"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs> | null
      details: Prisma.$VerdictInterestDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      interest_type: number
      base_amount: number
      calculated_interest: number | null
      calculation_start: Date
      calculation_end: Date
      total_interest: number
      created_at: Date
      updated_at: Date
      verdict_id: string | null
    }, ExtArgs["result"]["verdictInterest"]>
    composites: {}
  }

  type VerdictInterestGetPayload<S extends boolean | null | undefined | VerdictInterestDefaultArgs> = $Result.GetResult<Prisma.$VerdictInterestPayload, S>

  type VerdictInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictInterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictInterestCountAggregateInputType | true
    }

  export interface VerdictInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictInterest'], meta: { name: 'VerdictInterest' } }
    /**
     * Find zero or one VerdictInterest that matches the filter.
     * @param {VerdictInterestFindUniqueArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictInterestFindUniqueArgs>(args: SelectSubset<T, VerdictInterestFindUniqueArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictInterest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictInterestFindUniqueOrThrowArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestFindFirstArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictInterestFindFirstArgs>(args?: SelectSubset<T, VerdictInterestFindFirstArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestFindFirstOrThrowArgs} args - Arguments to find a VerdictInterest
     * @example
     * // Get one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictInterests
     * const verdictInterests = await prisma.verdictInterest.findMany()
     * 
     * // Get first 10 VerdictInterests
     * const verdictInterests = await prisma.verdictInterest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictInterestWithIdOnly = await prisma.verdictInterest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictInterestFindManyArgs>(args?: SelectSubset<T, VerdictInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictInterest.
     * @param {VerdictInterestCreateArgs} args - Arguments to create a VerdictInterest.
     * @example
     * // Create one VerdictInterest
     * const VerdictInterest = await prisma.verdictInterest.create({
     *   data: {
     *     // ... data to create a VerdictInterest
     *   }
     * })
     * 
     */
    create<T extends VerdictInterestCreateArgs>(args: SelectSubset<T, VerdictInterestCreateArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictInterests.
     * @param {VerdictInterestCreateManyArgs} args - Arguments to create many VerdictInterests.
     * @example
     * // Create many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictInterestCreateManyArgs>(args?: SelectSubset<T, VerdictInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictInterests and returns the data saved in the database.
     * @param {VerdictInterestCreateManyAndReturnArgs} args - Arguments to create many VerdictInterests.
     * @example
     * // Create many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictInterests and only return the `id`
     * const verdictInterestWithIdOnly = await prisma.verdictInterest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictInterest.
     * @param {VerdictInterestDeleteArgs} args - Arguments to delete one VerdictInterest.
     * @example
     * // Delete one VerdictInterest
     * const VerdictInterest = await prisma.verdictInterest.delete({
     *   where: {
     *     // ... filter to delete one VerdictInterest
     *   }
     * })
     * 
     */
    delete<T extends VerdictInterestDeleteArgs>(args: SelectSubset<T, VerdictInterestDeleteArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictInterest.
     * @param {VerdictInterestUpdateArgs} args - Arguments to update one VerdictInterest.
     * @example
     * // Update one VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictInterestUpdateArgs>(args: SelectSubset<T, VerdictInterestUpdateArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictInterests.
     * @param {VerdictInterestDeleteManyArgs} args - Arguments to filter VerdictInterests to delete.
     * @example
     * // Delete a few VerdictInterests
     * const { count } = await prisma.verdictInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictInterestDeleteManyArgs>(args?: SelectSubset<T, VerdictInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictInterestUpdateManyArgs>(args: SelectSubset<T, VerdictInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterests and returns the data updated in the database.
     * @param {VerdictInterestUpdateManyAndReturnArgs} args - Arguments to update many VerdictInterests.
     * @example
     * // Update many VerdictInterests
     * const verdictInterest = await prisma.verdictInterest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictInterests and only return the `id`
     * const verdictInterestWithIdOnly = await prisma.verdictInterest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictInterestUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictInterestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictInterest.
     * @param {VerdictInterestUpsertArgs} args - Arguments to update or create a VerdictInterest.
     * @example
     * // Update or create a VerdictInterest
     * const verdictInterest = await prisma.verdictInterest.upsert({
     *   create: {
     *     // ... data to create a VerdictInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictInterest we want to update
     *   }
     * })
     */
    upsert<T extends VerdictInterestUpsertArgs>(args: SelectSubset<T, VerdictInterestUpsertArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestCountArgs} args - Arguments to filter VerdictInterests to count.
     * @example
     * // Count the number of VerdictInterests
     * const count = await prisma.verdictInterest.count({
     *   where: {
     *     // ... the filter for the VerdictInterests we want to count
     *   }
     * })
    **/
    count<T extends VerdictInterestCountArgs>(
      args?: Subset<T, VerdictInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictInterestAggregateArgs>(args: Subset<T, VerdictInterestAggregateArgs>): Prisma.PrismaPromise<GetVerdictInterestAggregateType<T>>

    /**
     * Group by VerdictInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictInterestGroupByArgs['orderBy'] }
        : { orderBy?: VerdictInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictInterest model
   */
  readonly fields: VerdictInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictInterest$verdictArgs<ExtArgs> = {}>(args?: Subset<T, VerdictInterest$verdictArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    details<T extends VerdictInterest$detailsArgs<ExtArgs> = {}>(args?: Subset<T, VerdictInterest$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictInterest model
   */
  interface VerdictInterestFieldRefs {
    readonly id: FieldRef<"VerdictInterest", 'String'>
    readonly interest_type: FieldRef<"VerdictInterest", 'Int'>
    readonly base_amount: FieldRef<"VerdictInterest", 'Float'>
    readonly calculated_interest: FieldRef<"VerdictInterest", 'Float'>
    readonly calculation_start: FieldRef<"VerdictInterest", 'DateTime'>
    readonly calculation_end: FieldRef<"VerdictInterest", 'DateTime'>
    readonly total_interest: FieldRef<"VerdictInterest", 'Float'>
    readonly created_at: FieldRef<"VerdictInterest", 'DateTime'>
    readonly updated_at: FieldRef<"VerdictInterest", 'DateTime'>
    readonly verdict_id: FieldRef<"VerdictInterest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VerdictInterest findUnique
   */
  export type VerdictInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest findUniqueOrThrow
   */
  export type VerdictInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest findFirst
   */
  export type VerdictInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterests.
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterests.
     */
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * VerdictInterest findFirstOrThrow
   */
  export type VerdictInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterest to fetch.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterests.
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterests.
     */
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * VerdictInterest findMany
   */
  export type VerdictInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterests to fetch.
     */
    where?: VerdictInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterests to fetch.
     */
    orderBy?: VerdictInterestOrderByWithRelationInput | VerdictInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictInterests.
     */
    cursor?: VerdictInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterests.
     */
    skip?: number
    distinct?: VerdictInterestScalarFieldEnum | VerdictInterestScalarFieldEnum[]
  }

  /**
   * VerdictInterest create
   */
  export type VerdictInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictInterest.
     */
    data: XOR<VerdictInterestCreateInput, VerdictInterestUncheckedCreateInput>
  }

  /**
   * VerdictInterest createMany
   */
  export type VerdictInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictInterests.
     */
    data: VerdictInterestCreateManyInput | VerdictInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictInterest createManyAndReturn
   */
  export type VerdictInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictInterests.
     */
    data: VerdictInterestCreateManyInput | VerdictInterestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterest update
   */
  export type VerdictInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictInterest.
     */
    data: XOR<VerdictInterestUpdateInput, VerdictInterestUncheckedUpdateInput>
    /**
     * Choose, which VerdictInterest to update.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest updateMany
   */
  export type VerdictInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictInterests.
     */
    data: XOR<VerdictInterestUpdateManyMutationInput, VerdictInterestUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterests to update
     */
    where?: VerdictInterestWhereInput
    /**
     * Limit how many VerdictInterests to update.
     */
    limit?: number
  }

  /**
   * VerdictInterest updateManyAndReturn
   */
  export type VerdictInterestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * The data used to update VerdictInterests.
     */
    data: XOR<VerdictInterestUpdateManyMutationInput, VerdictInterestUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterests to update
     */
    where?: VerdictInterestWhereInput
    /**
     * Limit how many VerdictInterests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterest upsert
   */
  export type VerdictInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictInterest to update in case it exists.
     */
    where: VerdictInterestWhereUniqueInput
    /**
     * In case the VerdictInterest found by the `where` argument doesn't exist, create a new VerdictInterest with this data.
     */
    create: XOR<VerdictInterestCreateInput, VerdictInterestUncheckedCreateInput>
    /**
     * In case the VerdictInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictInterestUpdateInput, VerdictInterestUncheckedUpdateInput>
  }

  /**
   * VerdictInterest delete
   */
  export type VerdictInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
    /**
     * Filter which VerdictInterest to delete.
     */
    where: VerdictInterestWhereUniqueInput
  }

  /**
   * VerdictInterest deleteMany
   */
  export type VerdictInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterests to delete
     */
    where?: VerdictInterestWhereInput
    /**
     * Limit how many VerdictInterests to delete.
     */
    limit?: number
  }

  /**
   * VerdictInterest.verdict
   */
  export type VerdictInterest$verdictArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
  }

  /**
   * VerdictInterest.details
   */
  export type VerdictInterest$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    where?: VerdictInterestDetailsWhereInput
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    cursor?: VerdictInterestDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterest without action
   */
  export type VerdictInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterest
     */
    select?: VerdictInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterest
     */
    omit?: VerdictInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestInclude<ExtArgs> | null
  }


  /**
   * Model VerdictInterestDetails
   */

  export type AggregateVerdictInterestDetails = {
    _count: VerdictInterestDetailsCountAggregateOutputType | null
    _avg: VerdictInterestDetailsAvgAggregateOutputType | null
    _sum: VerdictInterestDetailsSumAggregateOutputType | null
    _min: VerdictInterestDetailsMinAggregateOutputType | null
    _max: VerdictInterestDetailsMaxAggregateOutputType | null
  }

  export type VerdictInterestDetailsAvgAggregateOutputType = {
    days: number | null
    annual_rate: number | null
    proportional_rate: number | null
    base_amount: number | null
    interest: number | null
    total: number | null
  }

  export type VerdictInterestDetailsSumAggregateOutputType = {
    days: number | null
    annual_rate: number | null
    proportional_rate: number | null
    base_amount: number | null
    interest: number | null
    total: number | null
  }

  export type VerdictInterestDetailsMinAggregateOutputType = {
    id: string | null
    period: string | null
    period_start: Date | null
    period_end: Date | null
    days: number | null
    annual_rate: number | null
    proportional_rate: number | null
    base_amount: number | null
    interest: number | null
    total: number | null
    verdict_interest_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VerdictInterestDetailsMaxAggregateOutputType = {
    id: string | null
    period: string | null
    period_start: Date | null
    period_end: Date | null
    days: number | null
    annual_rate: number | null
    proportional_rate: number | null
    base_amount: number | null
    interest: number | null
    total: number | null
    verdict_interest_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VerdictInterestDetailsCountAggregateOutputType = {
    id: number
    period: number
    period_start: number
    period_end: number
    days: number
    annual_rate: number
    proportional_rate: number
    base_amount: number
    interest: number
    total: number
    verdict_interest_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VerdictInterestDetailsAvgAggregateInputType = {
    days?: true
    annual_rate?: true
    proportional_rate?: true
    base_amount?: true
    interest?: true
    total?: true
  }

  export type VerdictInterestDetailsSumAggregateInputType = {
    days?: true
    annual_rate?: true
    proportional_rate?: true
    base_amount?: true
    interest?: true
    total?: true
  }

  export type VerdictInterestDetailsMinAggregateInputType = {
    id?: true
    period?: true
    period_start?: true
    period_end?: true
    days?: true
    annual_rate?: true
    proportional_rate?: true
    base_amount?: true
    interest?: true
    total?: true
    verdict_interest_id?: true
    created_at?: true
    updated_at?: true
  }

  export type VerdictInterestDetailsMaxAggregateInputType = {
    id?: true
    period?: true
    period_start?: true
    period_end?: true
    days?: true
    annual_rate?: true
    proportional_rate?: true
    base_amount?: true
    interest?: true
    total?: true
    verdict_interest_id?: true
    created_at?: true
    updated_at?: true
  }

  export type VerdictInterestDetailsCountAggregateInputType = {
    id?: true
    period?: true
    period_start?: true
    period_end?: true
    days?: true
    annual_rate?: true
    proportional_rate?: true
    base_amount?: true
    interest?: true
    total?: true
    verdict_interest_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VerdictInterestDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterestDetails to aggregate.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictInterestDetails
    **/
    _count?: true | VerdictInterestDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictInterestDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictInterestDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictInterestDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictInterestDetailsMaxAggregateInputType
  }

  export type GetVerdictInterestDetailsAggregateType<T extends VerdictInterestDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictInterestDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictInterestDetails[P]>
      : GetScalarType<T[P], AggregateVerdictInterestDetails[P]>
  }




  export type VerdictInterestDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictInterestDetailsWhereInput
    orderBy?: VerdictInterestDetailsOrderByWithAggregationInput | VerdictInterestDetailsOrderByWithAggregationInput[]
    by: VerdictInterestDetailsScalarFieldEnum[] | VerdictInterestDetailsScalarFieldEnum
    having?: VerdictInterestDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictInterestDetailsCountAggregateInputType | true
    _avg?: VerdictInterestDetailsAvgAggregateInputType
    _sum?: VerdictInterestDetailsSumAggregateInputType
    _min?: VerdictInterestDetailsMinAggregateInputType
    _max?: VerdictInterestDetailsMaxAggregateInputType
  }

  export type VerdictInterestDetailsGroupByOutputType = {
    id: string
    period: string
    period_start: Date
    period_end: Date
    days: number
    annual_rate: number
    proportional_rate: number
    base_amount: number
    interest: number
    total: number
    verdict_interest_id: string
    created_at: Date
    updated_at: Date
    _count: VerdictInterestDetailsCountAggregateOutputType | null
    _avg: VerdictInterestDetailsAvgAggregateOutputType | null
    _sum: VerdictInterestDetailsSumAggregateOutputType | null
    _min: VerdictInterestDetailsMinAggregateOutputType | null
    _max: VerdictInterestDetailsMaxAggregateOutputType | null
  }

  type GetVerdictInterestDetailsGroupByPayload<T extends VerdictInterestDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictInterestDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictInterestDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictInterestDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictInterestDetailsGroupByOutputType[P]>
        }
      >
    >


  export type VerdictInterestDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    period_start?: boolean
    period_end?: boolean
    days?: boolean
    annual_rate?: boolean
    proportional_rate?: boolean
    base_amount?: boolean
    interest?: boolean
    total?: boolean
    verdict_interest_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict_interest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterestDetails"]>

  export type VerdictInterestDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    period_start?: boolean
    period_end?: boolean
    days?: boolean
    annual_rate?: boolean
    proportional_rate?: boolean
    base_amount?: boolean
    interest?: boolean
    total?: boolean
    verdict_interest_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict_interest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterestDetails"]>

  export type VerdictInterestDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    period_start?: boolean
    period_end?: boolean
    days?: boolean
    annual_rate?: boolean
    proportional_rate?: boolean
    base_amount?: boolean
    interest?: boolean
    total?: boolean
    verdict_interest_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict_interest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictInterestDetails"]>

  export type VerdictInterestDetailsSelectScalar = {
    id?: boolean
    period?: boolean
    period_start?: boolean
    period_end?: boolean
    days?: boolean
    annual_rate?: boolean
    proportional_rate?: boolean
    base_amount?: boolean
    interest?: boolean
    total?: boolean
    verdict_interest_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VerdictInterestDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "period" | "period_start" | "period_end" | "days" | "annual_rate" | "proportional_rate" | "base_amount" | "interest" | "total" | "verdict_interest_id" | "created_at" | "updated_at", ExtArgs["result"]["verdictInterestDetails"]>
  export type VerdictInterestDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict_interest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }
  export type VerdictInterestDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict_interest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }
  export type VerdictInterestDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict_interest?: boolean | VerdictInterestDefaultArgs<ExtArgs>
  }

  export type $VerdictInterestDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictInterestDetails"
    objects: {
      verdict_interest: Prisma.$VerdictInterestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      period: string
      period_start: Date
      period_end: Date
      days: number
      annual_rate: number
      proportional_rate: number
      base_amount: number
      interest: number
      total: number
      verdict_interest_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["verdictInterestDetails"]>
    composites: {}
  }

  type VerdictInterestDetailsGetPayload<S extends boolean | null | undefined | VerdictInterestDetailsDefaultArgs> = $Result.GetResult<Prisma.$VerdictInterestDetailsPayload, S>

  type VerdictInterestDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictInterestDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictInterestDetailsCountAggregateInputType | true
    }

  export interface VerdictInterestDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictInterestDetails'], meta: { name: 'VerdictInterestDetails' } }
    /**
     * Find zero or one VerdictInterestDetails that matches the filter.
     * @param {VerdictInterestDetailsFindUniqueArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictInterestDetailsFindUniqueArgs>(args: SelectSubset<T, VerdictInterestDetailsFindUniqueArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictInterestDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictInterestDetailsFindUniqueOrThrowArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictInterestDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictInterestDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterestDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsFindFirstArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictInterestDetailsFindFirstArgs>(args?: SelectSubset<T, VerdictInterestDetailsFindFirstArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictInterestDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsFindFirstOrThrowArgs} args - Arguments to find a VerdictInterestDetails
     * @example
     * // Get one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictInterestDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictInterestDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictInterestDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findMany()
     * 
     * // Get first 10 VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictInterestDetailsWithIdOnly = await prisma.verdictInterestDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictInterestDetailsFindManyArgs>(args?: SelectSubset<T, VerdictInterestDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictInterestDetails.
     * @param {VerdictInterestDetailsCreateArgs} args - Arguments to create a VerdictInterestDetails.
     * @example
     * // Create one VerdictInterestDetails
     * const VerdictInterestDetails = await prisma.verdictInterestDetails.create({
     *   data: {
     *     // ... data to create a VerdictInterestDetails
     *   }
     * })
     * 
     */
    create<T extends VerdictInterestDetailsCreateArgs>(args: SelectSubset<T, VerdictInterestDetailsCreateArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictInterestDetails.
     * @param {VerdictInterestDetailsCreateManyArgs} args - Arguments to create many VerdictInterestDetails.
     * @example
     * // Create many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictInterestDetailsCreateManyArgs>(args?: SelectSubset<T, VerdictInterestDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictInterestDetails and returns the data saved in the database.
     * @param {VerdictInterestDetailsCreateManyAndReturnArgs} args - Arguments to create many VerdictInterestDetails.
     * @example
     * // Create many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictInterestDetails and only return the `id`
     * const verdictInterestDetailsWithIdOnly = await prisma.verdictInterestDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictInterestDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictInterestDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictInterestDetails.
     * @param {VerdictInterestDetailsDeleteArgs} args - Arguments to delete one VerdictInterestDetails.
     * @example
     * // Delete one VerdictInterestDetails
     * const VerdictInterestDetails = await prisma.verdictInterestDetails.delete({
     *   where: {
     *     // ... filter to delete one VerdictInterestDetails
     *   }
     * })
     * 
     */
    delete<T extends VerdictInterestDetailsDeleteArgs>(args: SelectSubset<T, VerdictInterestDetailsDeleteArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictInterestDetails.
     * @param {VerdictInterestDetailsUpdateArgs} args - Arguments to update one VerdictInterestDetails.
     * @example
     * // Update one VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictInterestDetailsUpdateArgs>(args: SelectSubset<T, VerdictInterestDetailsUpdateArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictInterestDetails.
     * @param {VerdictInterestDetailsDeleteManyArgs} args - Arguments to filter VerdictInterestDetails to delete.
     * @example
     * // Delete a few VerdictInterestDetails
     * const { count } = await prisma.verdictInterestDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictInterestDetailsDeleteManyArgs>(args?: SelectSubset<T, VerdictInterestDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictInterestDetailsUpdateManyArgs>(args: SelectSubset<T, VerdictInterestDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictInterestDetails and returns the data updated in the database.
     * @param {VerdictInterestDetailsUpdateManyAndReturnArgs} args - Arguments to update many VerdictInterestDetails.
     * @example
     * // Update many VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictInterestDetails and only return the `id`
     * const verdictInterestDetailsWithIdOnly = await prisma.verdictInterestDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictInterestDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictInterestDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictInterestDetails.
     * @param {VerdictInterestDetailsUpsertArgs} args - Arguments to update or create a VerdictInterestDetails.
     * @example
     * // Update or create a VerdictInterestDetails
     * const verdictInterestDetails = await prisma.verdictInterestDetails.upsert({
     *   create: {
     *     // ... data to create a VerdictInterestDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictInterestDetails we want to update
     *   }
     * })
     */
    upsert<T extends VerdictInterestDetailsUpsertArgs>(args: SelectSubset<T, VerdictInterestDetailsUpsertArgs<ExtArgs>>): Prisma__VerdictInterestDetailsClient<$Result.GetResult<Prisma.$VerdictInterestDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsCountArgs} args - Arguments to filter VerdictInterestDetails to count.
     * @example
     * // Count the number of VerdictInterestDetails
     * const count = await prisma.verdictInterestDetails.count({
     *   where: {
     *     // ... the filter for the VerdictInterestDetails we want to count
     *   }
     * })
    **/
    count<T extends VerdictInterestDetailsCountArgs>(
      args?: Subset<T, VerdictInterestDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictInterestDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictInterestDetailsAggregateArgs>(args: Subset<T, VerdictInterestDetailsAggregateArgs>): Prisma.PrismaPromise<GetVerdictInterestDetailsAggregateType<T>>

    /**
     * Group by VerdictInterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictInterestDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictInterestDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictInterestDetailsGroupByArgs['orderBy'] }
        : { orderBy?: VerdictInterestDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictInterestDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictInterestDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictInterestDetails model
   */
  readonly fields: VerdictInterestDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictInterestDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictInterestDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict_interest<T extends VerdictInterestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictInterestDefaultArgs<ExtArgs>>): Prisma__VerdictInterestClient<$Result.GetResult<Prisma.$VerdictInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictInterestDetails model
   */
  interface VerdictInterestDetailsFieldRefs {
    readonly id: FieldRef<"VerdictInterestDetails", 'String'>
    readonly period: FieldRef<"VerdictInterestDetails", 'String'>
    readonly period_start: FieldRef<"VerdictInterestDetails", 'DateTime'>
    readonly period_end: FieldRef<"VerdictInterestDetails", 'DateTime'>
    readonly days: FieldRef<"VerdictInterestDetails", 'Int'>
    readonly annual_rate: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly proportional_rate: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly base_amount: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly interest: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly total: FieldRef<"VerdictInterestDetails", 'Float'>
    readonly verdict_interest_id: FieldRef<"VerdictInterestDetails", 'String'>
    readonly created_at: FieldRef<"VerdictInterestDetails", 'DateTime'>
    readonly updated_at: FieldRef<"VerdictInterestDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerdictInterestDetails findUnique
   */
  export type VerdictInterestDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails findUniqueOrThrow
   */
  export type VerdictInterestDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails findFirst
   */
  export type VerdictInterestDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterestDetails.
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterestDetails.
     */
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterestDetails findFirstOrThrow
   */
  export type VerdictInterestDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictInterestDetails.
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictInterestDetails.
     */
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterestDetails findMany
   */
  export type VerdictInterestDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VerdictInterestDetails to fetch.
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictInterestDetails to fetch.
     */
    orderBy?: VerdictInterestDetailsOrderByWithRelationInput | VerdictInterestDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictInterestDetails.
     */
    cursor?: VerdictInterestDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictInterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictInterestDetails.
     */
    skip?: number
    distinct?: VerdictInterestDetailsScalarFieldEnum | VerdictInterestDetailsScalarFieldEnum[]
  }

  /**
   * VerdictInterestDetails create
   */
  export type VerdictInterestDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsCreateInput, VerdictInterestDetailsUncheckedCreateInput>
  }

  /**
   * VerdictInterestDetails createMany
   */
  export type VerdictInterestDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictInterestDetails.
     */
    data: VerdictInterestDetailsCreateManyInput | VerdictInterestDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictInterestDetails createManyAndReturn
   */
  export type VerdictInterestDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictInterestDetails.
     */
    data: VerdictInterestDetailsCreateManyInput | VerdictInterestDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterestDetails update
   */
  export type VerdictInterestDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsUpdateInput, VerdictInterestDetailsUncheckedUpdateInput>
    /**
     * Choose, which VerdictInterestDetails to update.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails updateMany
   */
  export type VerdictInterestDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsUpdateManyMutationInput, VerdictInterestDetailsUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterestDetails to update
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * Limit how many VerdictInterestDetails to update.
     */
    limit?: number
  }

  /**
   * VerdictInterestDetails updateManyAndReturn
   */
  export type VerdictInterestDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * The data used to update VerdictInterestDetails.
     */
    data: XOR<VerdictInterestDetailsUpdateManyMutationInput, VerdictInterestDetailsUncheckedUpdateManyInput>
    /**
     * Filter which VerdictInterestDetails to update
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * Limit how many VerdictInterestDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictInterestDetails upsert
   */
  export type VerdictInterestDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictInterestDetails to update in case it exists.
     */
    where: VerdictInterestDetailsWhereUniqueInput
    /**
     * In case the VerdictInterestDetails found by the `where` argument doesn't exist, create a new VerdictInterestDetails with this data.
     */
    create: XOR<VerdictInterestDetailsCreateInput, VerdictInterestDetailsUncheckedCreateInput>
    /**
     * In case the VerdictInterestDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictInterestDetailsUpdateInput, VerdictInterestDetailsUncheckedUpdateInput>
  }

  /**
   * VerdictInterestDetails delete
   */
  export type VerdictInterestDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
    /**
     * Filter which VerdictInterestDetails to delete.
     */
    where: VerdictInterestDetailsWhereUniqueInput
  }

  /**
   * VerdictInterestDetails deleteMany
   */
  export type VerdictInterestDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictInterestDetails to delete
     */
    where?: VerdictInterestDetailsWhereInput
    /**
     * Limit how many VerdictInterestDetails to delete.
     */
    limit?: number
  }

  /**
   * VerdictInterestDetails without action
   */
  export type VerdictInterestDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictInterestDetails
     */
    select?: VerdictInterestDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictInterestDetails
     */
    omit?: VerdictInterestDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInterestDetailsInclude<ExtArgs> | null
  }


  /**
   * Model VerdictEmbargo
   */

  export type AggregateVerdictEmbargo = {
    _count: VerdictEmbargoCountAggregateOutputType | null
    _avg: VerdictEmbargoAvgAggregateOutputType | null
    _sum: VerdictEmbargoSumAggregateOutputType | null
    _min: VerdictEmbargoMinAggregateOutputType | null
    _max: VerdictEmbargoMaxAggregateOutputType | null
  }

  export type VerdictEmbargoAvgAggregateOutputType = {
    embargo_amount: number | null
    total_amount: number | null
  }

  export type VerdictEmbargoSumAggregateOutputType = {
    embargo_amount: number | null
    total_amount: number | null
  }

  export type VerdictEmbargoMinAggregateOutputType = {
    id: string | null
    verdict_id: string | null
    company_name: string | null
    company_phone: string | null
    company_email: string | null
    company_address: string | null
    embargo_type: string | null
    embargo_date: Date | null
    embargo_amount: number | null
    total_amount: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VerdictEmbargoMaxAggregateOutputType = {
    id: string | null
    verdict_id: string | null
    company_name: string | null
    company_phone: string | null
    company_email: string | null
    company_address: string | null
    embargo_type: string | null
    embargo_date: Date | null
    embargo_amount: number | null
    total_amount: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VerdictEmbargoCountAggregateOutputType = {
    id: number
    verdict_id: number
    company_name: number
    company_phone: number
    company_email: number
    company_address: number
    embargo_type: number
    embargo_date: number
    embargo_amount: number
    total_amount: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VerdictEmbargoAvgAggregateInputType = {
    embargo_amount?: true
    total_amount?: true
  }

  export type VerdictEmbargoSumAggregateInputType = {
    embargo_amount?: true
    total_amount?: true
  }

  export type VerdictEmbargoMinAggregateInputType = {
    id?: true
    verdict_id?: true
    company_name?: true
    company_phone?: true
    company_email?: true
    company_address?: true
    embargo_type?: true
    embargo_date?: true
    embargo_amount?: true
    total_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type VerdictEmbargoMaxAggregateInputType = {
    id?: true
    verdict_id?: true
    company_name?: true
    company_phone?: true
    company_email?: true
    company_address?: true
    embargo_type?: true
    embargo_date?: true
    embargo_amount?: true
    total_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type VerdictEmbargoCountAggregateInputType = {
    id?: true
    verdict_id?: true
    company_name?: true
    company_phone?: true
    company_email?: true
    company_address?: true
    embargo_type?: true
    embargo_date?: true
    embargo_amount?: true
    total_amount?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VerdictEmbargoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictEmbargo to aggregate.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictEmbargos
    **/
    _count?: true | VerdictEmbargoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictEmbargoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictEmbargoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictEmbargoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictEmbargoMaxAggregateInputType
  }

  export type GetVerdictEmbargoAggregateType<T extends VerdictEmbargoAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictEmbargo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictEmbargo[P]>
      : GetScalarType<T[P], AggregateVerdictEmbargo[P]>
  }




  export type VerdictEmbargoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictEmbargoWhereInput
    orderBy?: VerdictEmbargoOrderByWithAggregationInput | VerdictEmbargoOrderByWithAggregationInput[]
    by: VerdictEmbargoScalarFieldEnum[] | VerdictEmbargoScalarFieldEnum
    having?: VerdictEmbargoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictEmbargoCountAggregateInputType | true
    _avg?: VerdictEmbargoAvgAggregateInputType
    _sum?: VerdictEmbargoSumAggregateInputType
    _min?: VerdictEmbargoMinAggregateInputType
    _max?: VerdictEmbargoMaxAggregateInputType
  }

  export type VerdictEmbargoGroupByOutputType = {
    id: string
    verdict_id: string
    company_name: string
    company_phone: string
    company_email: string
    company_address: string
    embargo_type: string
    embargo_date: Date
    embargo_amount: number
    total_amount: number
    created_at: Date
    updated_at: Date
    _count: VerdictEmbargoCountAggregateOutputType | null
    _avg: VerdictEmbargoAvgAggregateOutputType | null
    _sum: VerdictEmbargoSumAggregateOutputType | null
    _min: VerdictEmbargoMinAggregateOutputType | null
    _max: VerdictEmbargoMaxAggregateOutputType | null
  }

  type GetVerdictEmbargoGroupByPayload<T extends VerdictEmbargoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictEmbargoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictEmbargoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictEmbargoGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictEmbargoGroupByOutputType[P]>
        }
      >
    >


  export type VerdictEmbargoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdict_id?: boolean
    company_name?: boolean
    company_phone?: boolean
    company_email?: boolean
    company_address?: boolean
    embargo_type?: boolean
    embargo_date?: boolean
    embargo_amount?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictEmbargo"]>

  export type VerdictEmbargoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdict_id?: boolean
    company_name?: boolean
    company_phone?: boolean
    company_email?: boolean
    company_address?: boolean
    embargo_type?: boolean
    embargo_date?: boolean
    embargo_amount?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictEmbargo"]>

  export type VerdictEmbargoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdict_id?: boolean
    company_name?: boolean
    company_phone?: boolean
    company_email?: boolean
    company_address?: boolean
    embargo_type?: boolean
    embargo_date?: boolean
    embargo_amount?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictEmbargo"]>

  export type VerdictEmbargoSelectScalar = {
    id?: boolean
    verdict_id?: boolean
    company_name?: boolean
    company_phone?: boolean
    company_email?: boolean
    company_address?: boolean
    embargo_type?: boolean
    embargo_date?: boolean
    embargo_amount?: boolean
    total_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VerdictEmbargoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "verdict_id" | "company_name" | "company_phone" | "company_email" | "company_address" | "embargo_type" | "embargo_date" | "embargo_amount" | "total_amount" | "created_at" | "updated_at", ExtArgs["result"]["verdictEmbargo"]>
  export type VerdictEmbargoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictEmbargoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictEmbargoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }

  export type $VerdictEmbargoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictEmbargo"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      verdict_id: string
      company_name: string
      company_phone: string
      company_email: string
      company_address: string
      embargo_type: string
      embargo_date: Date
      embargo_amount: number
      total_amount: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["verdictEmbargo"]>
    composites: {}
  }

  type VerdictEmbargoGetPayload<S extends boolean | null | undefined | VerdictEmbargoDefaultArgs> = $Result.GetResult<Prisma.$VerdictEmbargoPayload, S>

  type VerdictEmbargoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictEmbargoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictEmbargoCountAggregateInputType | true
    }

  export interface VerdictEmbargoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictEmbargo'], meta: { name: 'VerdictEmbargo' } }
    /**
     * Find zero or one VerdictEmbargo that matches the filter.
     * @param {VerdictEmbargoFindUniqueArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictEmbargoFindUniqueArgs>(args: SelectSubset<T, VerdictEmbargoFindUniqueArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictEmbargo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictEmbargoFindUniqueOrThrowArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictEmbargoFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictEmbargoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictEmbargo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoFindFirstArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictEmbargoFindFirstArgs>(args?: SelectSubset<T, VerdictEmbargoFindFirstArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictEmbargo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoFindFirstOrThrowArgs} args - Arguments to find a VerdictEmbargo
     * @example
     * // Get one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictEmbargoFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictEmbargoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictEmbargos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictEmbargos
     * const verdictEmbargos = await prisma.verdictEmbargo.findMany()
     * 
     * // Get first 10 VerdictEmbargos
     * const verdictEmbargos = await prisma.verdictEmbargo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictEmbargoWithIdOnly = await prisma.verdictEmbargo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictEmbargoFindManyArgs>(args?: SelectSubset<T, VerdictEmbargoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictEmbargo.
     * @param {VerdictEmbargoCreateArgs} args - Arguments to create a VerdictEmbargo.
     * @example
     * // Create one VerdictEmbargo
     * const VerdictEmbargo = await prisma.verdictEmbargo.create({
     *   data: {
     *     // ... data to create a VerdictEmbargo
     *   }
     * })
     * 
     */
    create<T extends VerdictEmbargoCreateArgs>(args: SelectSubset<T, VerdictEmbargoCreateArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictEmbargos.
     * @param {VerdictEmbargoCreateManyArgs} args - Arguments to create many VerdictEmbargos.
     * @example
     * // Create many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictEmbargoCreateManyArgs>(args?: SelectSubset<T, VerdictEmbargoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictEmbargos and returns the data saved in the database.
     * @param {VerdictEmbargoCreateManyAndReturnArgs} args - Arguments to create many VerdictEmbargos.
     * @example
     * // Create many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictEmbargos and only return the `id`
     * const verdictEmbargoWithIdOnly = await prisma.verdictEmbargo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictEmbargoCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictEmbargoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictEmbargo.
     * @param {VerdictEmbargoDeleteArgs} args - Arguments to delete one VerdictEmbargo.
     * @example
     * // Delete one VerdictEmbargo
     * const VerdictEmbargo = await prisma.verdictEmbargo.delete({
     *   where: {
     *     // ... filter to delete one VerdictEmbargo
     *   }
     * })
     * 
     */
    delete<T extends VerdictEmbargoDeleteArgs>(args: SelectSubset<T, VerdictEmbargoDeleteArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictEmbargo.
     * @param {VerdictEmbargoUpdateArgs} args - Arguments to update one VerdictEmbargo.
     * @example
     * // Update one VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictEmbargoUpdateArgs>(args: SelectSubset<T, VerdictEmbargoUpdateArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictEmbargos.
     * @param {VerdictEmbargoDeleteManyArgs} args - Arguments to filter VerdictEmbargos to delete.
     * @example
     * // Delete a few VerdictEmbargos
     * const { count } = await prisma.verdictEmbargo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictEmbargoDeleteManyArgs>(args?: SelectSubset<T, VerdictEmbargoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictEmbargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictEmbargoUpdateManyArgs>(args: SelectSubset<T, VerdictEmbargoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictEmbargos and returns the data updated in the database.
     * @param {VerdictEmbargoUpdateManyAndReturnArgs} args - Arguments to update many VerdictEmbargos.
     * @example
     * // Update many VerdictEmbargos
     * const verdictEmbargo = await prisma.verdictEmbargo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictEmbargos and only return the `id`
     * const verdictEmbargoWithIdOnly = await prisma.verdictEmbargo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictEmbargoUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictEmbargoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictEmbargo.
     * @param {VerdictEmbargoUpsertArgs} args - Arguments to update or create a VerdictEmbargo.
     * @example
     * // Update or create a VerdictEmbargo
     * const verdictEmbargo = await prisma.verdictEmbargo.upsert({
     *   create: {
     *     // ... data to create a VerdictEmbargo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictEmbargo we want to update
     *   }
     * })
     */
    upsert<T extends VerdictEmbargoUpsertArgs>(args: SelectSubset<T, VerdictEmbargoUpsertArgs<ExtArgs>>): Prisma__VerdictEmbargoClient<$Result.GetResult<Prisma.$VerdictEmbargoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictEmbargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoCountArgs} args - Arguments to filter VerdictEmbargos to count.
     * @example
     * // Count the number of VerdictEmbargos
     * const count = await prisma.verdictEmbargo.count({
     *   where: {
     *     // ... the filter for the VerdictEmbargos we want to count
     *   }
     * })
    **/
    count<T extends VerdictEmbargoCountArgs>(
      args?: Subset<T, VerdictEmbargoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictEmbargoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictEmbargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictEmbargoAggregateArgs>(args: Subset<T, VerdictEmbargoAggregateArgs>): Prisma.PrismaPromise<GetVerdictEmbargoAggregateType<T>>

    /**
     * Group by VerdictEmbargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictEmbargoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictEmbargoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictEmbargoGroupByArgs['orderBy'] }
        : { orderBy?: VerdictEmbargoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictEmbargoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictEmbargoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictEmbargo model
   */
  readonly fields: VerdictEmbargoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictEmbargo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictEmbargoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictDefaultArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictEmbargo model
   */
  interface VerdictEmbargoFieldRefs {
    readonly id: FieldRef<"VerdictEmbargo", 'String'>
    readonly verdict_id: FieldRef<"VerdictEmbargo", 'String'>
    readonly company_name: FieldRef<"VerdictEmbargo", 'String'>
    readonly company_phone: FieldRef<"VerdictEmbargo", 'String'>
    readonly company_email: FieldRef<"VerdictEmbargo", 'String'>
    readonly company_address: FieldRef<"VerdictEmbargo", 'String'>
    readonly embargo_type: FieldRef<"VerdictEmbargo", 'String'>
    readonly embargo_date: FieldRef<"VerdictEmbargo", 'DateTime'>
    readonly embargo_amount: FieldRef<"VerdictEmbargo", 'Float'>
    readonly total_amount: FieldRef<"VerdictEmbargo", 'Float'>
    readonly created_at: FieldRef<"VerdictEmbargo", 'DateTime'>
    readonly updated_at: FieldRef<"VerdictEmbargo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerdictEmbargo findUnique
   */
  export type VerdictEmbargoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo findUniqueOrThrow
   */
  export type VerdictEmbargoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo findFirst
   */
  export type VerdictEmbargoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictEmbargos.
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictEmbargos.
     */
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * VerdictEmbargo findFirstOrThrow
   */
  export type VerdictEmbargoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargo to fetch.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictEmbargos.
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictEmbargos.
     */
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * VerdictEmbargo findMany
   */
  export type VerdictEmbargoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter, which VerdictEmbargos to fetch.
     */
    where?: VerdictEmbargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictEmbargos to fetch.
     */
    orderBy?: VerdictEmbargoOrderByWithRelationInput | VerdictEmbargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictEmbargos.
     */
    cursor?: VerdictEmbargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictEmbargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictEmbargos.
     */
    skip?: number
    distinct?: VerdictEmbargoScalarFieldEnum | VerdictEmbargoScalarFieldEnum[]
  }

  /**
   * VerdictEmbargo create
   */
  export type VerdictEmbargoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictEmbargo.
     */
    data: XOR<VerdictEmbargoCreateInput, VerdictEmbargoUncheckedCreateInput>
  }

  /**
   * VerdictEmbargo createMany
   */
  export type VerdictEmbargoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictEmbargos.
     */
    data: VerdictEmbargoCreateManyInput | VerdictEmbargoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictEmbargo createManyAndReturn
   */
  export type VerdictEmbargoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictEmbargos.
     */
    data: VerdictEmbargoCreateManyInput | VerdictEmbargoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictEmbargo update
   */
  export type VerdictEmbargoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictEmbargo.
     */
    data: XOR<VerdictEmbargoUpdateInput, VerdictEmbargoUncheckedUpdateInput>
    /**
     * Choose, which VerdictEmbargo to update.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo updateMany
   */
  export type VerdictEmbargoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictEmbargos.
     */
    data: XOR<VerdictEmbargoUpdateManyMutationInput, VerdictEmbargoUncheckedUpdateManyInput>
    /**
     * Filter which VerdictEmbargos to update
     */
    where?: VerdictEmbargoWhereInput
    /**
     * Limit how many VerdictEmbargos to update.
     */
    limit?: number
  }

  /**
   * VerdictEmbargo updateManyAndReturn
   */
  export type VerdictEmbargoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * The data used to update VerdictEmbargos.
     */
    data: XOR<VerdictEmbargoUpdateManyMutationInput, VerdictEmbargoUncheckedUpdateManyInput>
    /**
     * Filter which VerdictEmbargos to update
     */
    where?: VerdictEmbargoWhereInput
    /**
     * Limit how many VerdictEmbargos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictEmbargo upsert
   */
  export type VerdictEmbargoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictEmbargo to update in case it exists.
     */
    where: VerdictEmbargoWhereUniqueInput
    /**
     * In case the VerdictEmbargo found by the `where` argument doesn't exist, create a new VerdictEmbargo with this data.
     */
    create: XOR<VerdictEmbargoCreateInput, VerdictEmbargoUncheckedCreateInput>
    /**
     * In case the VerdictEmbargo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictEmbargoUpdateInput, VerdictEmbargoUncheckedUpdateInput>
  }

  /**
   * VerdictEmbargo delete
   */
  export type VerdictEmbargoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
    /**
     * Filter which VerdictEmbargo to delete.
     */
    where: VerdictEmbargoWhereUniqueInput
  }

  /**
   * VerdictEmbargo deleteMany
   */
  export type VerdictEmbargoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictEmbargos to delete
     */
    where?: VerdictEmbargoWhereInput
    /**
     * Limit how many VerdictEmbargos to delete.
     */
    limit?: number
  }

  /**
   * VerdictEmbargo without action
   */
  export type VerdictEmbargoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictEmbargo
     */
    select?: VerdictEmbargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictEmbargo
     */
    omit?: VerdictEmbargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictEmbargoInclude<ExtArgs> | null
  }


  /**
   * Model VerdictBailiffServices
   */

  export type AggregateVerdictBailiffServices = {
    _count: VerdictBailiffServicesCountAggregateOutputType | null
    _avg: VerdictBailiffServicesAvgAggregateOutputType | null
    _sum: VerdictBailiffServicesSumAggregateOutputType | null
    _min: VerdictBailiffServicesMinAggregateOutputType | null
    _max: VerdictBailiffServicesMaxAggregateOutputType | null
  }

  export type VerdictBailiffServicesAvgAggregateOutputType = {
    service_cost: number | null
  }

  export type VerdictBailiffServicesSumAggregateOutputType = {
    service_cost: number | null
  }

  export type VerdictBailiffServicesMinAggregateOutputType = {
    id: string | null
    verdict_id: string | null
    service_type: string | null
    service_cost: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VerdictBailiffServicesMaxAggregateOutputType = {
    id: string | null
    verdict_id: string | null
    service_type: string | null
    service_cost: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VerdictBailiffServicesCountAggregateOutputType = {
    id: number
    verdict_id: number
    service_type: number
    service_cost: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VerdictBailiffServicesAvgAggregateInputType = {
    service_cost?: true
  }

  export type VerdictBailiffServicesSumAggregateInputType = {
    service_cost?: true
  }

  export type VerdictBailiffServicesMinAggregateInputType = {
    id?: true
    verdict_id?: true
    service_type?: true
    service_cost?: true
    created_at?: true
    updated_at?: true
  }

  export type VerdictBailiffServicesMaxAggregateInputType = {
    id?: true
    verdict_id?: true
    service_type?: true
    service_cost?: true
    created_at?: true
    updated_at?: true
  }

  export type VerdictBailiffServicesCountAggregateInputType = {
    id?: true
    verdict_id?: true
    service_type?: true
    service_cost?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VerdictBailiffServicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictBailiffServices to aggregate.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictBailiffServices
    **/
    _count?: true | VerdictBailiffServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictBailiffServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictBailiffServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictBailiffServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictBailiffServicesMaxAggregateInputType
  }

  export type GetVerdictBailiffServicesAggregateType<T extends VerdictBailiffServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictBailiffServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictBailiffServices[P]>
      : GetScalarType<T[P], AggregateVerdictBailiffServices[P]>
  }




  export type VerdictBailiffServicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictBailiffServicesWhereInput
    orderBy?: VerdictBailiffServicesOrderByWithAggregationInput | VerdictBailiffServicesOrderByWithAggregationInput[]
    by: VerdictBailiffServicesScalarFieldEnum[] | VerdictBailiffServicesScalarFieldEnum
    having?: VerdictBailiffServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictBailiffServicesCountAggregateInputType | true
    _avg?: VerdictBailiffServicesAvgAggregateInputType
    _sum?: VerdictBailiffServicesSumAggregateInputType
    _min?: VerdictBailiffServicesMinAggregateInputType
    _max?: VerdictBailiffServicesMaxAggregateInputType
  }

  export type VerdictBailiffServicesGroupByOutputType = {
    id: string
    verdict_id: string
    service_type: string
    service_cost: number
    created_at: Date
    updated_at: Date
    _count: VerdictBailiffServicesCountAggregateOutputType | null
    _avg: VerdictBailiffServicesAvgAggregateOutputType | null
    _sum: VerdictBailiffServicesSumAggregateOutputType | null
    _min: VerdictBailiffServicesMinAggregateOutputType | null
    _max: VerdictBailiffServicesMaxAggregateOutputType | null
  }

  type GetVerdictBailiffServicesGroupByPayload<T extends VerdictBailiffServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictBailiffServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictBailiffServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictBailiffServicesGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictBailiffServicesGroupByOutputType[P]>
        }
      >
    >


  export type VerdictBailiffServicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdict_id?: boolean
    service_type?: boolean
    service_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictBailiffServices"]>

  export type VerdictBailiffServicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdict_id?: boolean
    service_type?: boolean
    service_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictBailiffServices"]>

  export type VerdictBailiffServicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdict_id?: boolean
    service_type?: boolean
    service_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictBailiffServices"]>

  export type VerdictBailiffServicesSelectScalar = {
    id?: boolean
    verdict_id?: boolean
    service_type?: boolean
    service_cost?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VerdictBailiffServicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "verdict_id" | "service_type" | "service_cost" | "created_at" | "updated_at", ExtArgs["result"]["verdictBailiffServices"]>
  export type VerdictBailiffServicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictBailiffServicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictBailiffServicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }

  export type $VerdictBailiffServicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictBailiffServices"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      verdict_id: string
      service_type: string
      service_cost: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["verdictBailiffServices"]>
    composites: {}
  }

  type VerdictBailiffServicesGetPayload<S extends boolean | null | undefined | VerdictBailiffServicesDefaultArgs> = $Result.GetResult<Prisma.$VerdictBailiffServicesPayload, S>

  type VerdictBailiffServicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictBailiffServicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictBailiffServicesCountAggregateInputType | true
    }

  export interface VerdictBailiffServicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictBailiffServices'], meta: { name: 'VerdictBailiffServices' } }
    /**
     * Find zero or one VerdictBailiffServices that matches the filter.
     * @param {VerdictBailiffServicesFindUniqueArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictBailiffServicesFindUniqueArgs>(args: SelectSubset<T, VerdictBailiffServicesFindUniqueArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictBailiffServices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictBailiffServicesFindUniqueOrThrowArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictBailiffServicesFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictBailiffServicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictBailiffServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesFindFirstArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictBailiffServicesFindFirstArgs>(args?: SelectSubset<T, VerdictBailiffServicesFindFirstArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictBailiffServices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesFindFirstOrThrowArgs} args - Arguments to find a VerdictBailiffServices
     * @example
     * // Get one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictBailiffServicesFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictBailiffServicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictBailiffServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findMany()
     * 
     * // Get first 10 VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictBailiffServicesWithIdOnly = await prisma.verdictBailiffServices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictBailiffServicesFindManyArgs>(args?: SelectSubset<T, VerdictBailiffServicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictBailiffServices.
     * @param {VerdictBailiffServicesCreateArgs} args - Arguments to create a VerdictBailiffServices.
     * @example
     * // Create one VerdictBailiffServices
     * const VerdictBailiffServices = await prisma.verdictBailiffServices.create({
     *   data: {
     *     // ... data to create a VerdictBailiffServices
     *   }
     * })
     * 
     */
    create<T extends VerdictBailiffServicesCreateArgs>(args: SelectSubset<T, VerdictBailiffServicesCreateArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictBailiffServices.
     * @param {VerdictBailiffServicesCreateManyArgs} args - Arguments to create many VerdictBailiffServices.
     * @example
     * // Create many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictBailiffServicesCreateManyArgs>(args?: SelectSubset<T, VerdictBailiffServicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictBailiffServices and returns the data saved in the database.
     * @param {VerdictBailiffServicesCreateManyAndReturnArgs} args - Arguments to create many VerdictBailiffServices.
     * @example
     * // Create many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictBailiffServices and only return the `id`
     * const verdictBailiffServicesWithIdOnly = await prisma.verdictBailiffServices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictBailiffServicesCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictBailiffServicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictBailiffServices.
     * @param {VerdictBailiffServicesDeleteArgs} args - Arguments to delete one VerdictBailiffServices.
     * @example
     * // Delete one VerdictBailiffServices
     * const VerdictBailiffServices = await prisma.verdictBailiffServices.delete({
     *   where: {
     *     // ... filter to delete one VerdictBailiffServices
     *   }
     * })
     * 
     */
    delete<T extends VerdictBailiffServicesDeleteArgs>(args: SelectSubset<T, VerdictBailiffServicesDeleteArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictBailiffServices.
     * @param {VerdictBailiffServicesUpdateArgs} args - Arguments to update one VerdictBailiffServices.
     * @example
     * // Update one VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictBailiffServicesUpdateArgs>(args: SelectSubset<T, VerdictBailiffServicesUpdateArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictBailiffServices.
     * @param {VerdictBailiffServicesDeleteManyArgs} args - Arguments to filter VerdictBailiffServices to delete.
     * @example
     * // Delete a few VerdictBailiffServices
     * const { count } = await prisma.verdictBailiffServices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictBailiffServicesDeleteManyArgs>(args?: SelectSubset<T, VerdictBailiffServicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictBailiffServicesUpdateManyArgs>(args: SelectSubset<T, VerdictBailiffServicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictBailiffServices and returns the data updated in the database.
     * @param {VerdictBailiffServicesUpdateManyAndReturnArgs} args - Arguments to update many VerdictBailiffServices.
     * @example
     * // Update many VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictBailiffServices and only return the `id`
     * const verdictBailiffServicesWithIdOnly = await prisma.verdictBailiffServices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictBailiffServicesUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictBailiffServicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictBailiffServices.
     * @param {VerdictBailiffServicesUpsertArgs} args - Arguments to update or create a VerdictBailiffServices.
     * @example
     * // Update or create a VerdictBailiffServices
     * const verdictBailiffServices = await prisma.verdictBailiffServices.upsert({
     *   create: {
     *     // ... data to create a VerdictBailiffServices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictBailiffServices we want to update
     *   }
     * })
     */
    upsert<T extends VerdictBailiffServicesUpsertArgs>(args: SelectSubset<T, VerdictBailiffServicesUpsertArgs<ExtArgs>>): Prisma__VerdictBailiffServicesClient<$Result.GetResult<Prisma.$VerdictBailiffServicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesCountArgs} args - Arguments to filter VerdictBailiffServices to count.
     * @example
     * // Count the number of VerdictBailiffServices
     * const count = await prisma.verdictBailiffServices.count({
     *   where: {
     *     // ... the filter for the VerdictBailiffServices we want to count
     *   }
     * })
    **/
    count<T extends VerdictBailiffServicesCountArgs>(
      args?: Subset<T, VerdictBailiffServicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictBailiffServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictBailiffServicesAggregateArgs>(args: Subset<T, VerdictBailiffServicesAggregateArgs>): Prisma.PrismaPromise<GetVerdictBailiffServicesAggregateType<T>>

    /**
     * Group by VerdictBailiffServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictBailiffServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictBailiffServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictBailiffServicesGroupByArgs['orderBy'] }
        : { orderBy?: VerdictBailiffServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictBailiffServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictBailiffServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictBailiffServices model
   */
  readonly fields: VerdictBailiffServicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictBailiffServices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictBailiffServicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictDefaultArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictBailiffServices model
   */
  interface VerdictBailiffServicesFieldRefs {
    readonly id: FieldRef<"VerdictBailiffServices", 'String'>
    readonly verdict_id: FieldRef<"VerdictBailiffServices", 'String'>
    readonly service_type: FieldRef<"VerdictBailiffServices", 'String'>
    readonly service_cost: FieldRef<"VerdictBailiffServices", 'Float'>
    readonly created_at: FieldRef<"VerdictBailiffServices", 'DateTime'>
    readonly updated_at: FieldRef<"VerdictBailiffServices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerdictBailiffServices findUnique
   */
  export type VerdictBailiffServicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices findUniqueOrThrow
   */
  export type VerdictBailiffServicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices findFirst
   */
  export type VerdictBailiffServicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictBailiffServices.
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictBailiffServices.
     */
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * VerdictBailiffServices findFirstOrThrow
   */
  export type VerdictBailiffServicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictBailiffServices.
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictBailiffServices.
     */
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * VerdictBailiffServices findMany
   */
  export type VerdictBailiffServicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter, which VerdictBailiffServices to fetch.
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictBailiffServices to fetch.
     */
    orderBy?: VerdictBailiffServicesOrderByWithRelationInput | VerdictBailiffServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictBailiffServices.
     */
    cursor?: VerdictBailiffServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictBailiffServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictBailiffServices.
     */
    skip?: number
    distinct?: VerdictBailiffServicesScalarFieldEnum | VerdictBailiffServicesScalarFieldEnum[]
  }

  /**
   * VerdictBailiffServices create
   */
  export type VerdictBailiffServicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesCreateInput, VerdictBailiffServicesUncheckedCreateInput>
  }

  /**
   * VerdictBailiffServices createMany
   */
  export type VerdictBailiffServicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictBailiffServices.
     */
    data: VerdictBailiffServicesCreateManyInput | VerdictBailiffServicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictBailiffServices createManyAndReturn
   */
  export type VerdictBailiffServicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictBailiffServices.
     */
    data: VerdictBailiffServicesCreateManyInput | VerdictBailiffServicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictBailiffServices update
   */
  export type VerdictBailiffServicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesUpdateInput, VerdictBailiffServicesUncheckedUpdateInput>
    /**
     * Choose, which VerdictBailiffServices to update.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices updateMany
   */
  export type VerdictBailiffServicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesUpdateManyMutationInput, VerdictBailiffServicesUncheckedUpdateManyInput>
    /**
     * Filter which VerdictBailiffServices to update
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * Limit how many VerdictBailiffServices to update.
     */
    limit?: number
  }

  /**
   * VerdictBailiffServices updateManyAndReturn
   */
  export type VerdictBailiffServicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * The data used to update VerdictBailiffServices.
     */
    data: XOR<VerdictBailiffServicesUpdateManyMutationInput, VerdictBailiffServicesUncheckedUpdateManyInput>
    /**
     * Filter which VerdictBailiffServices to update
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * Limit how many VerdictBailiffServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictBailiffServices upsert
   */
  export type VerdictBailiffServicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictBailiffServices to update in case it exists.
     */
    where: VerdictBailiffServicesWhereUniqueInput
    /**
     * In case the VerdictBailiffServices found by the `where` argument doesn't exist, create a new VerdictBailiffServices with this data.
     */
    create: XOR<VerdictBailiffServicesCreateInput, VerdictBailiffServicesUncheckedCreateInput>
    /**
     * In case the VerdictBailiffServices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictBailiffServicesUpdateInput, VerdictBailiffServicesUncheckedUpdateInput>
  }

  /**
   * VerdictBailiffServices delete
   */
  export type VerdictBailiffServicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
    /**
     * Filter which VerdictBailiffServices to delete.
     */
    where: VerdictBailiffServicesWhereUniqueInput
  }

  /**
   * VerdictBailiffServices deleteMany
   */
  export type VerdictBailiffServicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictBailiffServices to delete
     */
    where?: VerdictBailiffServicesWhereInput
    /**
     * Limit how many VerdictBailiffServices to delete.
     */
    limit?: number
  }

  /**
   * VerdictBailiffServices without action
   */
  export type VerdictBailiffServicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictBailiffServices
     */
    select?: VerdictBailiffServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictBailiffServices
     */
    omit?: VerdictBailiffServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictBailiffServicesInclude<ExtArgs> | null
  }


  /**
   * Model VerdictAttachment
   */

  export type AggregateVerdictAttachment = {
    _count: VerdictAttachmentCountAggregateOutputType | null
    _avg: VerdictAttachmentAvgAggregateOutputType | null
    _sum: VerdictAttachmentSumAggregateOutputType | null
    _min: VerdictAttachmentMinAggregateOutputType | null
    _max: VerdictAttachmentMaxAggregateOutputType | null
  }

  export type VerdictAttachmentAvgAggregateOutputType = {
    file_size: number | null
  }

  export type VerdictAttachmentSumAggregateOutputType = {
    file_size: bigint | null
  }

  export type VerdictAttachmentMinAggregateOutputType = {
    id: string | null
    verdict_id: string | null
    file_path: string | null
    file_size: bigint | null
    created_at: Date | null
    updated_at: Date | null
    file_name: string | null
  }

  export type VerdictAttachmentMaxAggregateOutputType = {
    id: string | null
    verdict_id: string | null
    file_path: string | null
    file_size: bigint | null
    created_at: Date | null
    updated_at: Date | null
    file_name: string | null
  }

  export type VerdictAttachmentCountAggregateOutputType = {
    id: number
    verdict_id: number
    file_path: number
    file_size: number
    created_at: number
    updated_at: number
    file_name: number
    _all: number
  }


  export type VerdictAttachmentAvgAggregateInputType = {
    file_size?: true
  }

  export type VerdictAttachmentSumAggregateInputType = {
    file_size?: true
  }

  export type VerdictAttachmentMinAggregateInputType = {
    id?: true
    verdict_id?: true
    file_path?: true
    file_size?: true
    created_at?: true
    updated_at?: true
    file_name?: true
  }

  export type VerdictAttachmentMaxAggregateInputType = {
    id?: true
    verdict_id?: true
    file_path?: true
    file_size?: true
    created_at?: true
    updated_at?: true
    file_name?: true
  }

  export type VerdictAttachmentCountAggregateInputType = {
    id?: true
    verdict_id?: true
    file_path?: true
    file_size?: true
    created_at?: true
    updated_at?: true
    file_name?: true
    _all?: true
  }

  export type VerdictAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictAttachment to aggregate.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerdictAttachments
    **/
    _count?: true | VerdictAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerdictAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerdictAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerdictAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerdictAttachmentMaxAggregateInputType
  }

  export type GetVerdictAttachmentAggregateType<T extends VerdictAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateVerdictAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerdictAttachment[P]>
      : GetScalarType<T[P], AggregateVerdictAttachment[P]>
  }




  export type VerdictAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerdictAttachmentWhereInput
    orderBy?: VerdictAttachmentOrderByWithAggregationInput | VerdictAttachmentOrderByWithAggregationInput[]
    by: VerdictAttachmentScalarFieldEnum[] | VerdictAttachmentScalarFieldEnum
    having?: VerdictAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerdictAttachmentCountAggregateInputType | true
    _avg?: VerdictAttachmentAvgAggregateInputType
    _sum?: VerdictAttachmentSumAggregateInputType
    _min?: VerdictAttachmentMinAggregateInputType
    _max?: VerdictAttachmentMaxAggregateInputType
  }

  export type VerdictAttachmentGroupByOutputType = {
    id: string
    verdict_id: string
    file_path: string
    file_size: bigint
    created_at: Date
    updated_at: Date
    file_name: string
    _count: VerdictAttachmentCountAggregateOutputType | null
    _avg: VerdictAttachmentAvgAggregateOutputType | null
    _sum: VerdictAttachmentSumAggregateOutputType | null
    _min: VerdictAttachmentMinAggregateOutputType | null
    _max: VerdictAttachmentMaxAggregateOutputType | null
  }

  type GetVerdictAttachmentGroupByPayload<T extends VerdictAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerdictAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerdictAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerdictAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], VerdictAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type VerdictAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdict_id?: boolean
    file_path?: boolean
    file_size?: boolean
    created_at?: boolean
    updated_at?: boolean
    file_name?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictAttachment"]>

  export type VerdictAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdict_id?: boolean
    file_path?: boolean
    file_size?: boolean
    created_at?: boolean
    updated_at?: boolean
    file_name?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictAttachment"]>

  export type VerdictAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verdict_id?: boolean
    file_path?: boolean
    file_size?: boolean
    created_at?: boolean
    updated_at?: boolean
    file_name?: boolean
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verdictAttachment"]>

  export type VerdictAttachmentSelectScalar = {
    id?: boolean
    verdict_id?: boolean
    file_path?: boolean
    file_size?: boolean
    created_at?: boolean
    updated_at?: boolean
    file_name?: boolean
  }

  export type VerdictAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "verdict_id" | "file_path" | "file_size" | "created_at" | "updated_at" | "file_name", ExtArgs["result"]["verdictAttachment"]>
  export type VerdictAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }
  export type VerdictAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verdict?: boolean | VerdictDefaultArgs<ExtArgs>
  }

  export type $VerdictAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerdictAttachment"
    objects: {
      verdict: Prisma.$VerdictPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      verdict_id: string
      file_path: string
      file_size: bigint
      created_at: Date
      updated_at: Date
      file_name: string
    }, ExtArgs["result"]["verdictAttachment"]>
    composites: {}
  }

  type VerdictAttachmentGetPayload<S extends boolean | null | undefined | VerdictAttachmentDefaultArgs> = $Result.GetResult<Prisma.$VerdictAttachmentPayload, S>

  type VerdictAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerdictAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerdictAttachmentCountAggregateInputType | true
    }

  export interface VerdictAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerdictAttachment'], meta: { name: 'VerdictAttachment' } }
    /**
     * Find zero or one VerdictAttachment that matches the filter.
     * @param {VerdictAttachmentFindUniqueArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerdictAttachmentFindUniqueArgs>(args: SelectSubset<T, VerdictAttachmentFindUniqueArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerdictAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerdictAttachmentFindUniqueOrThrowArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerdictAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, VerdictAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentFindFirstArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerdictAttachmentFindFirstArgs>(args?: SelectSubset<T, VerdictAttachmentFindFirstArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerdictAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentFindFirstOrThrowArgs} args - Arguments to find a VerdictAttachment
     * @example
     * // Get one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerdictAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, VerdictAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerdictAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerdictAttachments
     * const verdictAttachments = await prisma.verdictAttachment.findMany()
     * 
     * // Get first 10 VerdictAttachments
     * const verdictAttachments = await prisma.verdictAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verdictAttachmentWithIdOnly = await prisma.verdictAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerdictAttachmentFindManyArgs>(args?: SelectSubset<T, VerdictAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerdictAttachment.
     * @param {VerdictAttachmentCreateArgs} args - Arguments to create a VerdictAttachment.
     * @example
     * // Create one VerdictAttachment
     * const VerdictAttachment = await prisma.verdictAttachment.create({
     *   data: {
     *     // ... data to create a VerdictAttachment
     *   }
     * })
     * 
     */
    create<T extends VerdictAttachmentCreateArgs>(args: SelectSubset<T, VerdictAttachmentCreateArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerdictAttachments.
     * @param {VerdictAttachmentCreateManyArgs} args - Arguments to create many VerdictAttachments.
     * @example
     * // Create many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerdictAttachmentCreateManyArgs>(args?: SelectSubset<T, VerdictAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerdictAttachments and returns the data saved in the database.
     * @param {VerdictAttachmentCreateManyAndReturnArgs} args - Arguments to create many VerdictAttachments.
     * @example
     * // Create many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerdictAttachments and only return the `id`
     * const verdictAttachmentWithIdOnly = await prisma.verdictAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerdictAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, VerdictAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerdictAttachment.
     * @param {VerdictAttachmentDeleteArgs} args - Arguments to delete one VerdictAttachment.
     * @example
     * // Delete one VerdictAttachment
     * const VerdictAttachment = await prisma.verdictAttachment.delete({
     *   where: {
     *     // ... filter to delete one VerdictAttachment
     *   }
     * })
     * 
     */
    delete<T extends VerdictAttachmentDeleteArgs>(args: SelectSubset<T, VerdictAttachmentDeleteArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerdictAttachment.
     * @param {VerdictAttachmentUpdateArgs} args - Arguments to update one VerdictAttachment.
     * @example
     * // Update one VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerdictAttachmentUpdateArgs>(args: SelectSubset<T, VerdictAttachmentUpdateArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerdictAttachments.
     * @param {VerdictAttachmentDeleteManyArgs} args - Arguments to filter VerdictAttachments to delete.
     * @example
     * // Delete a few VerdictAttachments
     * const { count } = await prisma.verdictAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerdictAttachmentDeleteManyArgs>(args?: SelectSubset<T, VerdictAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerdictAttachmentUpdateManyArgs>(args: SelectSubset<T, VerdictAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerdictAttachments and returns the data updated in the database.
     * @param {VerdictAttachmentUpdateManyAndReturnArgs} args - Arguments to update many VerdictAttachments.
     * @example
     * // Update many VerdictAttachments
     * const verdictAttachment = await prisma.verdictAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerdictAttachments and only return the `id`
     * const verdictAttachmentWithIdOnly = await prisma.verdictAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerdictAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, VerdictAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerdictAttachment.
     * @param {VerdictAttachmentUpsertArgs} args - Arguments to update or create a VerdictAttachment.
     * @example
     * // Update or create a VerdictAttachment
     * const verdictAttachment = await prisma.verdictAttachment.upsert({
     *   create: {
     *     // ... data to create a VerdictAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerdictAttachment we want to update
     *   }
     * })
     */
    upsert<T extends VerdictAttachmentUpsertArgs>(args: SelectSubset<T, VerdictAttachmentUpsertArgs<ExtArgs>>): Prisma__VerdictAttachmentClient<$Result.GetResult<Prisma.$VerdictAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerdictAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentCountArgs} args - Arguments to filter VerdictAttachments to count.
     * @example
     * // Count the number of VerdictAttachments
     * const count = await prisma.verdictAttachment.count({
     *   where: {
     *     // ... the filter for the VerdictAttachments we want to count
     *   }
     * })
    **/
    count<T extends VerdictAttachmentCountArgs>(
      args?: Subset<T, VerdictAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerdictAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerdictAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerdictAttachmentAggregateArgs>(args: Subset<T, VerdictAttachmentAggregateArgs>): Prisma.PrismaPromise<GetVerdictAttachmentAggregateType<T>>

    /**
     * Group by VerdictAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerdictAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerdictAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerdictAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: VerdictAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerdictAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerdictAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerdictAttachment model
   */
  readonly fields: VerdictAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerdictAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerdictAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verdict<T extends VerdictDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VerdictDefaultArgs<ExtArgs>>): Prisma__VerdictClient<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerdictAttachment model
   */
  interface VerdictAttachmentFieldRefs {
    readonly id: FieldRef<"VerdictAttachment", 'String'>
    readonly verdict_id: FieldRef<"VerdictAttachment", 'String'>
    readonly file_path: FieldRef<"VerdictAttachment", 'String'>
    readonly file_size: FieldRef<"VerdictAttachment", 'BigInt'>
    readonly created_at: FieldRef<"VerdictAttachment", 'DateTime'>
    readonly updated_at: FieldRef<"VerdictAttachment", 'DateTime'>
    readonly file_name: FieldRef<"VerdictAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VerdictAttachment findUnique
   */
  export type VerdictAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment findUniqueOrThrow
   */
  export type VerdictAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment findFirst
   */
  export type VerdictAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictAttachments.
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictAttachments.
     */
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * VerdictAttachment findFirstOrThrow
   */
  export type VerdictAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachment to fetch.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerdictAttachments.
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerdictAttachments.
     */
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * VerdictAttachment findMany
   */
  export type VerdictAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which VerdictAttachments to fetch.
     */
    where?: VerdictAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerdictAttachments to fetch.
     */
    orderBy?: VerdictAttachmentOrderByWithRelationInput | VerdictAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerdictAttachments.
     */
    cursor?: VerdictAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerdictAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerdictAttachments.
     */
    skip?: number
    distinct?: VerdictAttachmentScalarFieldEnum | VerdictAttachmentScalarFieldEnum[]
  }

  /**
   * VerdictAttachment create
   */
  export type VerdictAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a VerdictAttachment.
     */
    data: XOR<VerdictAttachmentCreateInput, VerdictAttachmentUncheckedCreateInput>
  }

  /**
   * VerdictAttachment createMany
   */
  export type VerdictAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerdictAttachments.
     */
    data: VerdictAttachmentCreateManyInput | VerdictAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerdictAttachment createManyAndReturn
   */
  export type VerdictAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many VerdictAttachments.
     */
    data: VerdictAttachmentCreateManyInput | VerdictAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictAttachment update
   */
  export type VerdictAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a VerdictAttachment.
     */
    data: XOR<VerdictAttachmentUpdateInput, VerdictAttachmentUncheckedUpdateInput>
    /**
     * Choose, which VerdictAttachment to update.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment updateMany
   */
  export type VerdictAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerdictAttachments.
     */
    data: XOR<VerdictAttachmentUpdateManyMutationInput, VerdictAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which VerdictAttachments to update
     */
    where?: VerdictAttachmentWhereInput
    /**
     * Limit how many VerdictAttachments to update.
     */
    limit?: number
  }

  /**
   * VerdictAttachment updateManyAndReturn
   */
  export type VerdictAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update VerdictAttachments.
     */
    data: XOR<VerdictAttachmentUpdateManyMutationInput, VerdictAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which VerdictAttachments to update
     */
    where?: VerdictAttachmentWhereInput
    /**
     * Limit how many VerdictAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerdictAttachment upsert
   */
  export type VerdictAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the VerdictAttachment to update in case it exists.
     */
    where: VerdictAttachmentWhereUniqueInput
    /**
     * In case the VerdictAttachment found by the `where` argument doesn't exist, create a new VerdictAttachment with this data.
     */
    create: XOR<VerdictAttachmentCreateInput, VerdictAttachmentUncheckedCreateInput>
    /**
     * In case the VerdictAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerdictAttachmentUpdateInput, VerdictAttachmentUncheckedUpdateInput>
  }

  /**
   * VerdictAttachment delete
   */
  export type VerdictAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
    /**
     * Filter which VerdictAttachment to delete.
     */
    where: VerdictAttachmentWhereUniqueInput
  }

  /**
   * VerdictAttachment deleteMany
   */
  export type VerdictAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerdictAttachments to delete
     */
    where?: VerdictAttachmentWhereInput
    /**
     * Limit how many VerdictAttachments to delete.
     */
    limit?: number
  }

  /**
   * VerdictAttachment without action
   */
  export type VerdictAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerdictAttachment
     */
    select?: VerdictAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerdictAttachment
     */
    omit?: VerdictAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model InterestType
   */

  export type AggregateInterestType = {
    _count: InterestTypeCountAggregateOutputType | null
    _avg: InterestTypeAvgAggregateOutputType | null
    _sum: InterestTypeSumAggregateOutputType | null
    _min: InterestTypeMinAggregateOutputType | null
    _max: InterestTypeMaxAggregateOutputType | null
  }

  export type InterestTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type InterestTypeSumAggregateOutputType = {
    id: number | null
  }

  export type InterestTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    calculation_type: $Enums.CalculationTypeEnum | null
  }

  export type InterestTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    calculation_type: $Enums.CalculationTypeEnum | null
  }

  export type InterestTypeCountAggregateOutputType = {
    id: number
    name: number
    calculation_type: number
    _all: number
  }


  export type InterestTypeAvgAggregateInputType = {
    id?: true
  }

  export type InterestTypeSumAggregateInputType = {
    id?: true
  }

  export type InterestTypeMinAggregateInputType = {
    id?: true
    name?: true
    calculation_type?: true
  }

  export type InterestTypeMaxAggregateInputType = {
    id?: true
    name?: true
    calculation_type?: true
  }

  export type InterestTypeCountAggregateInputType = {
    id?: true
    name?: true
    calculation_type?: true
    _all?: true
  }

  export type InterestTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestType to aggregate.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterestTypes
    **/
    _count?: true | InterestTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterestTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterestTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestTypeMaxAggregateInputType
  }

  export type GetInterestTypeAggregateType<T extends InterestTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateInterestType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterestType[P]>
      : GetScalarType<T[P], AggregateInterestType[P]>
  }




  export type InterestTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestTypeWhereInput
    orderBy?: InterestTypeOrderByWithAggregationInput | InterestTypeOrderByWithAggregationInput[]
    by: InterestTypeScalarFieldEnum[] | InterestTypeScalarFieldEnum
    having?: InterestTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestTypeCountAggregateInputType | true
    _avg?: InterestTypeAvgAggregateInputType
    _sum?: InterestTypeSumAggregateInputType
    _min?: InterestTypeMinAggregateInputType
    _max?: InterestTypeMaxAggregateInputType
  }

  export type InterestTypeGroupByOutputType = {
    id: number
    name: string
    calculation_type: $Enums.CalculationTypeEnum
    _count: InterestTypeCountAggregateOutputType | null
    _avg: InterestTypeAvgAggregateOutputType | null
    _sum: InterestTypeSumAggregateOutputType | null
    _min: InterestTypeMinAggregateOutputType | null
    _max: InterestTypeMaxAggregateOutputType | null
  }

  type GetInterestTypeGroupByPayload<T extends InterestTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestTypeGroupByOutputType[P]>
            : GetScalarType<T[P], InterestTypeGroupByOutputType[P]>
        }
      >
    >


  export type InterestTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calculation_type?: boolean
    details?: boolean | InterestType$detailsArgs<ExtArgs>
    _count?: boolean | InterestTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestType"]>

  export type InterestTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calculation_type?: boolean
  }, ExtArgs["result"]["interestType"]>

  export type InterestTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    calculation_type?: boolean
  }, ExtArgs["result"]["interestType"]>

  export type InterestTypeSelectScalar = {
    id?: boolean
    name?: boolean
    calculation_type?: boolean
  }

  export type InterestTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "calculation_type", ExtArgs["result"]["interestType"]>
  export type InterestTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | InterestType$detailsArgs<ExtArgs>
    _count?: boolean | InterestTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InterestTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InterestTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InterestTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterestType"
    objects: {
      details: Prisma.$InterestDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      calculation_type: $Enums.CalculationTypeEnum
    }, ExtArgs["result"]["interestType"]>
    composites: {}
  }

  type InterestTypeGetPayload<S extends boolean | null | undefined | InterestTypeDefaultArgs> = $Result.GetResult<Prisma.$InterestTypePayload, S>

  type InterestTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterestTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterestTypeCountAggregateInputType | true
    }

  export interface InterestTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterestType'], meta: { name: 'InterestType' } }
    /**
     * Find zero or one InterestType that matches the filter.
     * @param {InterestTypeFindUniqueArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestTypeFindUniqueArgs>(args: SelectSubset<T, InterestTypeFindUniqueArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterestType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterestTypeFindUniqueOrThrowArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeFindFirstArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestTypeFindFirstArgs>(args?: SelectSubset<T, InterestTypeFindFirstArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeFindFirstOrThrowArgs} args - Arguments to find a InterestType
     * @example
     * // Get one InterestType
     * const interestType = await prisma.interestType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterestTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterestTypes
     * const interestTypes = await prisma.interestType.findMany()
     * 
     * // Get first 10 InterestTypes
     * const interestTypes = await prisma.interestType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestTypeWithIdOnly = await prisma.interestType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestTypeFindManyArgs>(args?: SelectSubset<T, InterestTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterestType.
     * @param {InterestTypeCreateArgs} args - Arguments to create a InterestType.
     * @example
     * // Create one InterestType
     * const InterestType = await prisma.interestType.create({
     *   data: {
     *     // ... data to create a InterestType
     *   }
     * })
     * 
     */
    create<T extends InterestTypeCreateArgs>(args: SelectSubset<T, InterestTypeCreateArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterestTypes.
     * @param {InterestTypeCreateManyArgs} args - Arguments to create many InterestTypes.
     * @example
     * // Create many InterestTypes
     * const interestType = await prisma.interestType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestTypeCreateManyArgs>(args?: SelectSubset<T, InterestTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterestTypes and returns the data saved in the database.
     * @param {InterestTypeCreateManyAndReturnArgs} args - Arguments to create many InterestTypes.
     * @example
     * // Create many InterestTypes
     * const interestType = await prisma.interestType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterestTypes and only return the `id`
     * const interestTypeWithIdOnly = await prisma.interestType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterestType.
     * @param {InterestTypeDeleteArgs} args - Arguments to delete one InterestType.
     * @example
     * // Delete one InterestType
     * const InterestType = await prisma.interestType.delete({
     *   where: {
     *     // ... filter to delete one InterestType
     *   }
     * })
     * 
     */
    delete<T extends InterestTypeDeleteArgs>(args: SelectSubset<T, InterestTypeDeleteArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterestType.
     * @param {InterestTypeUpdateArgs} args - Arguments to update one InterestType.
     * @example
     * // Update one InterestType
     * const interestType = await prisma.interestType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestTypeUpdateArgs>(args: SelectSubset<T, InterestTypeUpdateArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterestTypes.
     * @param {InterestTypeDeleteManyArgs} args - Arguments to filter InterestTypes to delete.
     * @example
     * // Delete a few InterestTypes
     * const { count } = await prisma.interestType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestTypeDeleteManyArgs>(args?: SelectSubset<T, InterestTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterestTypes
     * const interestType = await prisma.interestType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestTypeUpdateManyArgs>(args: SelectSubset<T, InterestTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestTypes and returns the data updated in the database.
     * @param {InterestTypeUpdateManyAndReturnArgs} args - Arguments to update many InterestTypes.
     * @example
     * // Update many InterestTypes
     * const interestType = await prisma.interestType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterestTypes and only return the `id`
     * const interestTypeWithIdOnly = await prisma.interestType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterestTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, InterestTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterestType.
     * @param {InterestTypeUpsertArgs} args - Arguments to update or create a InterestType.
     * @example
     * // Update or create a InterestType
     * const interestType = await prisma.interestType.upsert({
     *   create: {
     *     // ... data to create a InterestType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterestType we want to update
     *   }
     * })
     */
    upsert<T extends InterestTypeUpsertArgs>(args: SelectSubset<T, InterestTypeUpsertArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterestTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeCountArgs} args - Arguments to filter InterestTypes to count.
     * @example
     * // Count the number of InterestTypes
     * const count = await prisma.interestType.count({
     *   where: {
     *     // ... the filter for the InterestTypes we want to count
     *   }
     * })
    **/
    count<T extends InterestTypeCountArgs>(
      args?: Subset<T, InterestTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterestType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestTypeAggregateArgs>(args: Subset<T, InterestTypeAggregateArgs>): Prisma.PrismaPromise<GetInterestTypeAggregateType<T>>

    /**
     * Group by InterestType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestTypeGroupByArgs['orderBy'] }
        : { orderBy?: InterestTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterestType model
   */
  readonly fields: InterestTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterestType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    details<T extends InterestType$detailsArgs<ExtArgs> = {}>(args?: Subset<T, InterestType$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterestType model
   */
  interface InterestTypeFieldRefs {
    readonly id: FieldRef<"InterestType", 'Int'>
    readonly name: FieldRef<"InterestType", 'String'>
    readonly calculation_type: FieldRef<"InterestType", 'CalculationTypeEnum'>
  }
    

  // Custom InputTypes
  /**
   * InterestType findUnique
   */
  export type InterestTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType findUniqueOrThrow
   */
  export type InterestTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType findFirst
   */
  export type InterestTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestTypes.
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestTypes.
     */
    distinct?: InterestTypeScalarFieldEnum | InterestTypeScalarFieldEnum[]
  }

  /**
   * InterestType findFirstOrThrow
   */
  export type InterestTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestType to fetch.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestTypes.
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestTypes.
     */
    distinct?: InterestTypeScalarFieldEnum | InterestTypeScalarFieldEnum[]
  }

  /**
   * InterestType findMany
   */
  export type InterestTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter, which InterestTypes to fetch.
     */
    where?: InterestTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestTypes to fetch.
     */
    orderBy?: InterestTypeOrderByWithRelationInput | InterestTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterestTypes.
     */
    cursor?: InterestTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestTypes.
     */
    skip?: number
    distinct?: InterestTypeScalarFieldEnum | InterestTypeScalarFieldEnum[]
  }

  /**
   * InterestType create
   */
  export type InterestTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a InterestType.
     */
    data: XOR<InterestTypeCreateInput, InterestTypeUncheckedCreateInput>
  }

  /**
   * InterestType createMany
   */
  export type InterestTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterestTypes.
     */
    data: InterestTypeCreateManyInput | InterestTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterestType createManyAndReturn
   */
  export type InterestTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * The data used to create many InterestTypes.
     */
    data: InterestTypeCreateManyInput | InterestTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterestType update
   */
  export type InterestTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a InterestType.
     */
    data: XOR<InterestTypeUpdateInput, InterestTypeUncheckedUpdateInput>
    /**
     * Choose, which InterestType to update.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType updateMany
   */
  export type InterestTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterestTypes.
     */
    data: XOR<InterestTypeUpdateManyMutationInput, InterestTypeUncheckedUpdateManyInput>
    /**
     * Filter which InterestTypes to update
     */
    where?: InterestTypeWhereInput
    /**
     * Limit how many InterestTypes to update.
     */
    limit?: number
  }

  /**
   * InterestType updateManyAndReturn
   */
  export type InterestTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * The data used to update InterestTypes.
     */
    data: XOR<InterestTypeUpdateManyMutationInput, InterestTypeUncheckedUpdateManyInput>
    /**
     * Filter which InterestTypes to update
     */
    where?: InterestTypeWhereInput
    /**
     * Limit how many InterestTypes to update.
     */
    limit?: number
  }

  /**
   * InterestType upsert
   */
  export type InterestTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the InterestType to update in case it exists.
     */
    where: InterestTypeWhereUniqueInput
    /**
     * In case the InterestType found by the `where` argument doesn't exist, create a new InterestType with this data.
     */
    create: XOR<InterestTypeCreateInput, InterestTypeUncheckedCreateInput>
    /**
     * In case the InterestType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestTypeUpdateInput, InterestTypeUncheckedUpdateInput>
  }

  /**
   * InterestType delete
   */
  export type InterestTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
    /**
     * Filter which InterestType to delete.
     */
    where: InterestTypeWhereUniqueInput
  }

  /**
   * InterestType deleteMany
   */
  export type InterestTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestTypes to delete
     */
    where?: InterestTypeWhereInput
    /**
     * Limit how many InterestTypes to delete.
     */
    limit?: number
  }

  /**
   * InterestType.details
   */
  export type InterestType$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    where?: InterestDetailWhereInput
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    cursor?: InterestDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestType without action
   */
  export type InterestTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestType
     */
    select?: InterestTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestType
     */
    omit?: InterestTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestTypeInclude<ExtArgs> | null
  }


  /**
   * Model InterestDetail
   */

  export type AggregateInterestDetail = {
    _count: InterestDetailCountAggregateOutputType | null
    _avg: InterestDetailAvgAggregateOutputType | null
    _sum: InterestDetailSumAggregateOutputType | null
    _min: InterestDetailMinAggregateOutputType | null
    _max: InterestDetailMaxAggregateOutputType | null
  }

  export type InterestDetailAvgAggregateOutputType = {
    id: number | null
    rate: number | null
    interest_type_id: number | null
  }

  export type InterestDetailSumAggregateOutputType = {
    id: number | null
    rate: number | null
    interest_type_id: number | null
  }

  export type InterestDetailMinAggregateOutputType = {
    id: number | null
    date: string | null
    rate: number | null
    interest_type_id: number | null
  }

  export type InterestDetailMaxAggregateOutputType = {
    id: number | null
    date: string | null
    rate: number | null
    interest_type_id: number | null
  }

  export type InterestDetailCountAggregateOutputType = {
    id: number
    date: number
    rate: number
    interest_type_id: number
    _all: number
  }


  export type InterestDetailAvgAggregateInputType = {
    id?: true
    rate?: true
    interest_type_id?: true
  }

  export type InterestDetailSumAggregateInputType = {
    id?: true
    rate?: true
    interest_type_id?: true
  }

  export type InterestDetailMinAggregateInputType = {
    id?: true
    date?: true
    rate?: true
    interest_type_id?: true
  }

  export type InterestDetailMaxAggregateInputType = {
    id?: true
    date?: true
    rate?: true
    interest_type_id?: true
  }

  export type InterestDetailCountAggregateInputType = {
    id?: true
    date?: true
    rate?: true
    interest_type_id?: true
    _all?: true
  }

  export type InterestDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestDetail to aggregate.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterestDetails
    **/
    _count?: true | InterestDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterestDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterestDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestDetailMaxAggregateInputType
  }

  export type GetInterestDetailAggregateType<T extends InterestDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateInterestDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterestDetail[P]>
      : GetScalarType<T[P], AggregateInterestDetail[P]>
  }




  export type InterestDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestDetailWhereInput
    orderBy?: InterestDetailOrderByWithAggregationInput | InterestDetailOrderByWithAggregationInput[]
    by: InterestDetailScalarFieldEnum[] | InterestDetailScalarFieldEnum
    having?: InterestDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestDetailCountAggregateInputType | true
    _avg?: InterestDetailAvgAggregateInputType
    _sum?: InterestDetailSumAggregateInputType
    _min?: InterestDetailMinAggregateInputType
    _max?: InterestDetailMaxAggregateInputType
  }

  export type InterestDetailGroupByOutputType = {
    id: number
    date: string
    rate: number
    interest_type_id: number
    _count: InterestDetailCountAggregateOutputType | null
    _avg: InterestDetailAvgAggregateOutputType | null
    _sum: InterestDetailSumAggregateOutputType | null
    _min: InterestDetailMinAggregateOutputType | null
    _max: InterestDetailMaxAggregateOutputType | null
  }

  type GetInterestDetailGroupByPayload<T extends InterestDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestDetailGroupByOutputType[P]>
            : GetScalarType<T[P], InterestDetailGroupByOutputType[P]>
        }
      >
    >


  export type InterestDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    rate?: boolean
    interest_type_id?: boolean
    interest_type?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestDetail"]>

  export type InterestDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    rate?: boolean
    interest_type_id?: boolean
    interest_type?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestDetail"]>

  export type InterestDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    rate?: boolean
    interest_type_id?: boolean
    interest_type?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interestDetail"]>

  export type InterestDetailSelectScalar = {
    id?: boolean
    date?: boolean
    rate?: boolean
    interest_type_id?: boolean
  }

  export type InterestDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "rate" | "interest_type_id", ExtArgs["result"]["interestDetail"]>
  export type InterestDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interest_type?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }
  export type InterestDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interest_type?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }
  export type InterestDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interest_type?: boolean | InterestTypeDefaultArgs<ExtArgs>
  }

  export type $InterestDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterestDetail"
    objects: {
      interest_type: Prisma.$InterestTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: string
      rate: number
      interest_type_id: number
    }, ExtArgs["result"]["interestDetail"]>
    composites: {}
  }

  type InterestDetailGetPayload<S extends boolean | null | undefined | InterestDetailDefaultArgs> = $Result.GetResult<Prisma.$InterestDetailPayload, S>

  type InterestDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterestDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterestDetailCountAggregateInputType | true
    }

  export interface InterestDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterestDetail'], meta: { name: 'InterestDetail' } }
    /**
     * Find zero or one InterestDetail that matches the filter.
     * @param {InterestDetailFindUniqueArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestDetailFindUniqueArgs>(args: SelectSubset<T, InterestDetailFindUniqueArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterestDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterestDetailFindUniqueOrThrowArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailFindFirstArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestDetailFindFirstArgs>(args?: SelectSubset<T, InterestDetailFindFirstArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterestDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailFindFirstOrThrowArgs} args - Arguments to find a InterestDetail
     * @example
     * // Get one InterestDetail
     * const interestDetail = await prisma.interestDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterestDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterestDetails
     * const interestDetails = await prisma.interestDetail.findMany()
     * 
     * // Get first 10 InterestDetails
     * const interestDetails = await prisma.interestDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestDetailWithIdOnly = await prisma.interestDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestDetailFindManyArgs>(args?: SelectSubset<T, InterestDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterestDetail.
     * @param {InterestDetailCreateArgs} args - Arguments to create a InterestDetail.
     * @example
     * // Create one InterestDetail
     * const InterestDetail = await prisma.interestDetail.create({
     *   data: {
     *     // ... data to create a InterestDetail
     *   }
     * })
     * 
     */
    create<T extends InterestDetailCreateArgs>(args: SelectSubset<T, InterestDetailCreateArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterestDetails.
     * @param {InterestDetailCreateManyArgs} args - Arguments to create many InterestDetails.
     * @example
     * // Create many InterestDetails
     * const interestDetail = await prisma.interestDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestDetailCreateManyArgs>(args?: SelectSubset<T, InterestDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterestDetails and returns the data saved in the database.
     * @param {InterestDetailCreateManyAndReturnArgs} args - Arguments to create many InterestDetails.
     * @example
     * // Create many InterestDetails
     * const interestDetail = await prisma.interestDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterestDetails and only return the `id`
     * const interestDetailWithIdOnly = await prisma.interestDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterestDetail.
     * @param {InterestDetailDeleteArgs} args - Arguments to delete one InterestDetail.
     * @example
     * // Delete one InterestDetail
     * const InterestDetail = await prisma.interestDetail.delete({
     *   where: {
     *     // ... filter to delete one InterestDetail
     *   }
     * })
     * 
     */
    delete<T extends InterestDetailDeleteArgs>(args: SelectSubset<T, InterestDetailDeleteArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterestDetail.
     * @param {InterestDetailUpdateArgs} args - Arguments to update one InterestDetail.
     * @example
     * // Update one InterestDetail
     * const interestDetail = await prisma.interestDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestDetailUpdateArgs>(args: SelectSubset<T, InterestDetailUpdateArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterestDetails.
     * @param {InterestDetailDeleteManyArgs} args - Arguments to filter InterestDetails to delete.
     * @example
     * // Delete a few InterestDetails
     * const { count } = await prisma.interestDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestDetailDeleteManyArgs>(args?: SelectSubset<T, InterestDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterestDetails
     * const interestDetail = await prisma.interestDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestDetailUpdateManyArgs>(args: SelectSubset<T, InterestDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterestDetails and returns the data updated in the database.
     * @param {InterestDetailUpdateManyAndReturnArgs} args - Arguments to update many InterestDetails.
     * @example
     * // Update many InterestDetails
     * const interestDetail = await prisma.interestDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterestDetails and only return the `id`
     * const interestDetailWithIdOnly = await prisma.interestDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterestDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, InterestDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterestDetail.
     * @param {InterestDetailUpsertArgs} args - Arguments to update or create a InterestDetail.
     * @example
     * // Update or create a InterestDetail
     * const interestDetail = await prisma.interestDetail.upsert({
     *   create: {
     *     // ... data to create a InterestDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterestDetail we want to update
     *   }
     * })
     */
    upsert<T extends InterestDetailUpsertArgs>(args: SelectSubset<T, InterestDetailUpsertArgs<ExtArgs>>): Prisma__InterestDetailClient<$Result.GetResult<Prisma.$InterestDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterestDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailCountArgs} args - Arguments to filter InterestDetails to count.
     * @example
     * // Count the number of InterestDetails
     * const count = await prisma.interestDetail.count({
     *   where: {
     *     // ... the filter for the InterestDetails we want to count
     *   }
     * })
    **/
    count<T extends InterestDetailCountArgs>(
      args?: Subset<T, InterestDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterestDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestDetailAggregateArgs>(args: Subset<T, InterestDetailAggregateArgs>): Prisma.PrismaPromise<GetInterestDetailAggregateType<T>>

    /**
     * Group by InterestDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestDetailGroupByArgs['orderBy'] }
        : { orderBy?: InterestDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterestDetail model
   */
  readonly fields: InterestDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterestDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interest_type<T extends InterestTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterestTypeDefaultArgs<ExtArgs>>): Prisma__InterestTypeClient<$Result.GetResult<Prisma.$InterestTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterestDetail model
   */
  interface InterestDetailFieldRefs {
    readonly id: FieldRef<"InterestDetail", 'Int'>
    readonly date: FieldRef<"InterestDetail", 'String'>
    readonly rate: FieldRef<"InterestDetail", 'Float'>
    readonly interest_type_id: FieldRef<"InterestDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InterestDetail findUnique
   */
  export type InterestDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail findUniqueOrThrow
   */
  export type InterestDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail findFirst
   */
  export type InterestDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestDetails.
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestDetails.
     */
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestDetail findFirstOrThrow
   */
  export type InterestDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetail to fetch.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterestDetails.
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterestDetails.
     */
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestDetail findMany
   */
  export type InterestDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter, which InterestDetails to fetch.
     */
    where?: InterestDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterestDetails to fetch.
     */
    orderBy?: InterestDetailOrderByWithRelationInput | InterestDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterestDetails.
     */
    cursor?: InterestDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterestDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterestDetails.
     */
    skip?: number
    distinct?: InterestDetailScalarFieldEnum | InterestDetailScalarFieldEnum[]
  }

  /**
   * InterestDetail create
   */
  export type InterestDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a InterestDetail.
     */
    data: XOR<InterestDetailCreateInput, InterestDetailUncheckedCreateInput>
  }

  /**
   * InterestDetail createMany
   */
  export type InterestDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterestDetails.
     */
    data: InterestDetailCreateManyInput | InterestDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterestDetail createManyAndReturn
   */
  export type InterestDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * The data used to create many InterestDetails.
     */
    data: InterestDetailCreateManyInput | InterestDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterestDetail update
   */
  export type InterestDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a InterestDetail.
     */
    data: XOR<InterestDetailUpdateInput, InterestDetailUncheckedUpdateInput>
    /**
     * Choose, which InterestDetail to update.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail updateMany
   */
  export type InterestDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterestDetails.
     */
    data: XOR<InterestDetailUpdateManyMutationInput, InterestDetailUncheckedUpdateManyInput>
    /**
     * Filter which InterestDetails to update
     */
    where?: InterestDetailWhereInput
    /**
     * Limit how many InterestDetails to update.
     */
    limit?: number
  }

  /**
   * InterestDetail updateManyAndReturn
   */
  export type InterestDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * The data used to update InterestDetails.
     */
    data: XOR<InterestDetailUpdateManyMutationInput, InterestDetailUncheckedUpdateManyInput>
    /**
     * Filter which InterestDetails to update
     */
    where?: InterestDetailWhereInput
    /**
     * Limit how many InterestDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterestDetail upsert
   */
  export type InterestDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the InterestDetail to update in case it exists.
     */
    where: InterestDetailWhereUniqueInput
    /**
     * In case the InterestDetail found by the `where` argument doesn't exist, create a new InterestDetail with this data.
     */
    create: XOR<InterestDetailCreateInput, InterestDetailUncheckedCreateInput>
    /**
     * In case the InterestDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestDetailUpdateInput, InterestDetailUncheckedUpdateInput>
  }

  /**
   * InterestDetail delete
   */
  export type InterestDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
    /**
     * Filter which InterestDetail to delete.
     */
    where: InterestDetailWhereUniqueInput
  }

  /**
   * InterestDetail deleteMany
   */
  export type InterestDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterestDetails to delete
     */
    where?: InterestDetailWhereInput
    /**
     * Limit how many InterestDetails to delete.
     */
    limit?: number
  }

  /**
   * InterestDetail without action
   */
  export type InterestDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestDetail
     */
    select?: InterestDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterestDetail
     */
    omit?: InterestDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestDetailInclude<ExtArgs> | null
  }


  /**
   * Model BillingInvoice
   */

  export type AggregateBillingInvoice = {
    _count: BillingInvoiceCountAggregateOutputType | null
    _avg: BillingInvoiceAvgAggregateOutputType | null
    _sum: BillingInvoiceSumAggregateOutputType | null
    _min: BillingInvoiceMinAggregateOutputType | null
    _max: BillingInvoiceMaxAggregateOutputType | null
  }

  export type BillingInvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillingInvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type BillingInvoiceMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    invoice_number: string | null
    amount: number | null
    currency: string | null
    issue_date: Date | null
    due_date: Date | null
    description: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BillingInvoiceMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    invoice_number: string | null
    amount: number | null
    currency: string | null
    issue_date: Date | null
    due_date: Date | null
    description: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BillingInvoiceCountAggregateOutputType = {
    id: number
    tenant_id: number
    invoice_number: number
    amount: number
    currency: number
    issue_date: number
    due_date: number
    description: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BillingInvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type BillingInvoiceSumAggregateInputType = {
    amount?: true
  }

  export type BillingInvoiceMinAggregateInputType = {
    id?: true
    tenant_id?: true
    invoice_number?: true
    amount?: true
    currency?: true
    issue_date?: true
    due_date?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type BillingInvoiceMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    invoice_number?: true
    amount?: true
    currency?: true
    issue_date?: true
    due_date?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type BillingInvoiceCountAggregateInputType = {
    id?: true
    tenant_id?: true
    invoice_number?: true
    amount?: true
    currency?: true
    issue_date?: true
    due_date?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BillingInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoice to aggregate.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingInvoices
    **/
    _count?: true | BillingInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingInvoiceMaxAggregateInputType
  }

  export type GetBillingInvoiceAggregateType<T extends BillingInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingInvoice[P]>
      : GetScalarType<T[P], AggregateBillingInvoice[P]>
  }




  export type BillingInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceWhereInput
    orderBy?: BillingInvoiceOrderByWithAggregationInput | BillingInvoiceOrderByWithAggregationInput[]
    by: BillingInvoiceScalarFieldEnum[] | BillingInvoiceScalarFieldEnum
    having?: BillingInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingInvoiceCountAggregateInputType | true
    _avg?: BillingInvoiceAvgAggregateInputType
    _sum?: BillingInvoiceSumAggregateInputType
    _min?: BillingInvoiceMinAggregateInputType
    _max?: BillingInvoiceMaxAggregateInputType
  }

  export type BillingInvoiceGroupByOutputType = {
    id: string
    tenant_id: string
    invoice_number: string
    amount: number
    currency: string
    issue_date: Date
    due_date: Date
    description: string | null
    status: string
    created_at: Date
    updated_at: Date
    _count: BillingInvoiceCountAggregateOutputType | null
    _avg: BillingInvoiceAvgAggregateOutputType | null
    _sum: BillingInvoiceSumAggregateOutputType | null
    _min: BillingInvoiceMinAggregateOutputType | null
    _max: BillingInvoiceMaxAggregateOutputType | null
  }

  type GetBillingInvoiceGroupByPayload<T extends BillingInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], BillingInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type BillingInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    invoice_number?: boolean
    amount?: boolean
    currency?: boolean
    issue_date?: boolean
    due_date?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    details?: boolean | BillingInvoice$detailsArgs<ExtArgs>
    payments?: boolean | BillingInvoice$paymentsArgs<ExtArgs>
    _count?: boolean | BillingInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoice"]>

  export type BillingInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    invoice_number?: boolean
    amount?: boolean
    currency?: boolean
    issue_date?: boolean
    due_date?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoice"]>

  export type BillingInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    invoice_number?: boolean
    amount?: boolean
    currency?: boolean
    issue_date?: boolean
    due_date?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoice"]>

  export type BillingInvoiceSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    invoice_number?: boolean
    amount?: boolean
    currency?: boolean
    issue_date?: boolean
    due_date?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BillingInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "invoice_number" | "amount" | "currency" | "issue_date" | "due_date" | "description" | "status" | "created_at" | "updated_at", ExtArgs["result"]["billingInvoice"]>
  export type BillingInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    details?: boolean | BillingInvoice$detailsArgs<ExtArgs>
    payments?: boolean | BillingInvoice$paymentsArgs<ExtArgs>
    _count?: boolean | BillingInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillingInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type BillingInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $BillingInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingInvoice"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      details: Prisma.$BillingInvoiceDetailPayload<ExtArgs>[]
      payments: Prisma.$BillingPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      invoice_number: string
      amount: number
      currency: string
      issue_date: Date
      due_date: Date
      description: string | null
      status: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["billingInvoice"]>
    composites: {}
  }

  type BillingInvoiceGetPayload<S extends boolean | null | undefined | BillingInvoiceDefaultArgs> = $Result.GetResult<Prisma.$BillingInvoicePayload, S>

  type BillingInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingInvoiceCountAggregateInputType | true
    }

  export interface BillingInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingInvoice'], meta: { name: 'BillingInvoice' } }
    /**
     * Find zero or one BillingInvoice that matches the filter.
     * @param {BillingInvoiceFindUniqueArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingInvoiceFindUniqueArgs>(args: SelectSubset<T, BillingInvoiceFindUniqueArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingInvoiceFindUniqueOrThrowArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceFindFirstArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingInvoiceFindFirstArgs>(args?: SelectSubset<T, BillingInvoiceFindFirstArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceFindFirstOrThrowArgs} args - Arguments to find a BillingInvoice
     * @example
     * // Get one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingInvoices
     * const billingInvoices = await prisma.billingInvoice.findMany()
     * 
     * // Get first 10 BillingInvoices
     * const billingInvoices = await prisma.billingInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingInvoiceWithIdOnly = await prisma.billingInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingInvoiceFindManyArgs>(args?: SelectSubset<T, BillingInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingInvoice.
     * @param {BillingInvoiceCreateArgs} args - Arguments to create a BillingInvoice.
     * @example
     * // Create one BillingInvoice
     * const BillingInvoice = await prisma.billingInvoice.create({
     *   data: {
     *     // ... data to create a BillingInvoice
     *   }
     * })
     * 
     */
    create<T extends BillingInvoiceCreateArgs>(args: SelectSubset<T, BillingInvoiceCreateArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingInvoices.
     * @param {BillingInvoiceCreateManyArgs} args - Arguments to create many BillingInvoices.
     * @example
     * // Create many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingInvoiceCreateManyArgs>(args?: SelectSubset<T, BillingInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingInvoices and returns the data saved in the database.
     * @param {BillingInvoiceCreateManyAndReturnArgs} args - Arguments to create many BillingInvoices.
     * @example
     * // Create many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingInvoices and only return the `id`
     * const billingInvoiceWithIdOnly = await prisma.billingInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingInvoice.
     * @param {BillingInvoiceDeleteArgs} args - Arguments to delete one BillingInvoice.
     * @example
     * // Delete one BillingInvoice
     * const BillingInvoice = await prisma.billingInvoice.delete({
     *   where: {
     *     // ... filter to delete one BillingInvoice
     *   }
     * })
     * 
     */
    delete<T extends BillingInvoiceDeleteArgs>(args: SelectSubset<T, BillingInvoiceDeleteArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingInvoice.
     * @param {BillingInvoiceUpdateArgs} args - Arguments to update one BillingInvoice.
     * @example
     * // Update one BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingInvoiceUpdateArgs>(args: SelectSubset<T, BillingInvoiceUpdateArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingInvoices.
     * @param {BillingInvoiceDeleteManyArgs} args - Arguments to filter BillingInvoices to delete.
     * @example
     * // Delete a few BillingInvoices
     * const { count } = await prisma.billingInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingInvoiceDeleteManyArgs>(args?: SelectSubset<T, BillingInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingInvoiceUpdateManyArgs>(args: SelectSubset<T, BillingInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoices and returns the data updated in the database.
     * @param {BillingInvoiceUpdateManyAndReturnArgs} args - Arguments to update many BillingInvoices.
     * @example
     * // Update many BillingInvoices
     * const billingInvoice = await prisma.billingInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingInvoices and only return the `id`
     * const billingInvoiceWithIdOnly = await prisma.billingInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingInvoice.
     * @param {BillingInvoiceUpsertArgs} args - Arguments to update or create a BillingInvoice.
     * @example
     * // Update or create a BillingInvoice
     * const billingInvoice = await prisma.billingInvoice.upsert({
     *   create: {
     *     // ... data to create a BillingInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingInvoice we want to update
     *   }
     * })
     */
    upsert<T extends BillingInvoiceUpsertArgs>(args: SelectSubset<T, BillingInvoiceUpsertArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceCountArgs} args - Arguments to filter BillingInvoices to count.
     * @example
     * // Count the number of BillingInvoices
     * const count = await prisma.billingInvoice.count({
     *   where: {
     *     // ... the filter for the BillingInvoices we want to count
     *   }
     * })
    **/
    count<T extends BillingInvoiceCountArgs>(
      args?: Subset<T, BillingInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingInvoiceAggregateArgs>(args: Subset<T, BillingInvoiceAggregateArgs>): Prisma.PrismaPromise<GetBillingInvoiceAggregateType<T>>

    /**
     * Group by BillingInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: BillingInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingInvoice model
   */
  readonly fields: BillingInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    details<T extends BillingInvoice$detailsArgs<ExtArgs> = {}>(args?: Subset<T, BillingInvoice$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends BillingInvoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, BillingInvoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingInvoice model
   */
  interface BillingInvoiceFieldRefs {
    readonly id: FieldRef<"BillingInvoice", 'String'>
    readonly tenant_id: FieldRef<"BillingInvoice", 'String'>
    readonly invoice_number: FieldRef<"BillingInvoice", 'String'>
    readonly amount: FieldRef<"BillingInvoice", 'Float'>
    readonly currency: FieldRef<"BillingInvoice", 'String'>
    readonly issue_date: FieldRef<"BillingInvoice", 'DateTime'>
    readonly due_date: FieldRef<"BillingInvoice", 'DateTime'>
    readonly description: FieldRef<"BillingInvoice", 'String'>
    readonly status: FieldRef<"BillingInvoice", 'String'>
    readonly created_at: FieldRef<"BillingInvoice", 'DateTime'>
    readonly updated_at: FieldRef<"BillingInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillingInvoice findUnique
   */
  export type BillingInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice findUniqueOrThrow
   */
  export type BillingInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice findFirst
   */
  export type BillingInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoices.
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoices.
     */
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * BillingInvoice findFirstOrThrow
   */
  export type BillingInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoice to fetch.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoices.
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoices.
     */
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * BillingInvoice findMany
   */
  export type BillingInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoices to fetch.
     */
    where?: BillingInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoices to fetch.
     */
    orderBy?: BillingInvoiceOrderByWithRelationInput | BillingInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingInvoices.
     */
    cursor?: BillingInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoices.
     */
    skip?: number
    distinct?: BillingInvoiceScalarFieldEnum | BillingInvoiceScalarFieldEnum[]
  }

  /**
   * BillingInvoice create
   */
  export type BillingInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingInvoice.
     */
    data: XOR<BillingInvoiceCreateInput, BillingInvoiceUncheckedCreateInput>
  }

  /**
   * BillingInvoice createMany
   */
  export type BillingInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingInvoices.
     */
    data: BillingInvoiceCreateManyInput | BillingInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingInvoice createManyAndReturn
   */
  export type BillingInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many BillingInvoices.
     */
    data: BillingInvoiceCreateManyInput | BillingInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoice update
   */
  export type BillingInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingInvoice.
     */
    data: XOR<BillingInvoiceUpdateInput, BillingInvoiceUncheckedUpdateInput>
    /**
     * Choose, which BillingInvoice to update.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice updateMany
   */
  export type BillingInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingInvoices.
     */
    data: XOR<BillingInvoiceUpdateManyMutationInput, BillingInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoices to update
     */
    where?: BillingInvoiceWhereInput
    /**
     * Limit how many BillingInvoices to update.
     */
    limit?: number
  }

  /**
   * BillingInvoice updateManyAndReturn
   */
  export type BillingInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update BillingInvoices.
     */
    data: XOR<BillingInvoiceUpdateManyMutationInput, BillingInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoices to update
     */
    where?: BillingInvoiceWhereInput
    /**
     * Limit how many BillingInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoice upsert
   */
  export type BillingInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingInvoice to update in case it exists.
     */
    where: BillingInvoiceWhereUniqueInput
    /**
     * In case the BillingInvoice found by the `where` argument doesn't exist, create a new BillingInvoice with this data.
     */
    create: XOR<BillingInvoiceCreateInput, BillingInvoiceUncheckedCreateInput>
    /**
     * In case the BillingInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingInvoiceUpdateInput, BillingInvoiceUncheckedUpdateInput>
  }

  /**
   * BillingInvoice delete
   */
  export type BillingInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    /**
     * Filter which BillingInvoice to delete.
     */
    where: BillingInvoiceWhereUniqueInput
  }

  /**
   * BillingInvoice deleteMany
   */
  export type BillingInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoices to delete
     */
    where?: BillingInvoiceWhereInput
    /**
     * Limit how many BillingInvoices to delete.
     */
    limit?: number
  }

  /**
   * BillingInvoice.details
   */
  export type BillingInvoice$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    where?: BillingInvoiceDetailWhereInput
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    cursor?: BillingInvoiceDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoice.payments
   */
  export type BillingInvoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    where?: BillingPaymentWhereInput
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    cursor?: BillingPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingInvoice without action
   */
  export type BillingInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model BillingInvoiceDetail
   */

  export type AggregateBillingInvoiceDetail = {
    _count: BillingInvoiceDetailCountAggregateOutputType | null
    _avg: BillingInvoiceDetailAvgAggregateOutputType | null
    _sum: BillingInvoiceDetailSumAggregateOutputType | null
    _min: BillingInvoiceDetailMinAggregateOutputType | null
    _max: BillingInvoiceDetailMaxAggregateOutputType | null
  }

  export type BillingInvoiceDetailAvgAggregateOutputType = {
    item_quantity: number | null
    item_unit_price: number | null
    item_total_price: number | null
    item_tax_rate: number | null
    item_tax_amount: number | null
    item_total_with_tax: number | null
  }

  export type BillingInvoiceDetailSumAggregateOutputType = {
    item_quantity: number | null
    item_unit_price: number | null
    item_total_price: number | null
    item_tax_rate: number | null
    item_tax_amount: number | null
    item_total_with_tax: number | null
  }

  export type BillingInvoiceDetailMinAggregateOutputType = {
    id: string | null
    item_description: string | null
    item_quantity: number | null
    item_unit_price: number | null
    item_total_price: number | null
    item_tax_rate: number | null
    item_tax_amount: number | null
    item_total_with_tax: number | null
    created_at: Date | null
    updated_at: Date | null
    billing_invoice_id: string | null
  }

  export type BillingInvoiceDetailMaxAggregateOutputType = {
    id: string | null
    item_description: string | null
    item_quantity: number | null
    item_unit_price: number | null
    item_total_price: number | null
    item_tax_rate: number | null
    item_tax_amount: number | null
    item_total_with_tax: number | null
    created_at: Date | null
    updated_at: Date | null
    billing_invoice_id: string | null
  }

  export type BillingInvoiceDetailCountAggregateOutputType = {
    id: number
    item_description: number
    item_quantity: number
    item_unit_price: number
    item_total_price: number
    item_tax_rate: number
    item_tax_amount: number
    item_total_with_tax: number
    created_at: number
    updated_at: number
    billing_invoice_id: number
    _all: number
  }


  export type BillingInvoiceDetailAvgAggregateInputType = {
    item_quantity?: true
    item_unit_price?: true
    item_total_price?: true
    item_tax_rate?: true
    item_tax_amount?: true
    item_total_with_tax?: true
  }

  export type BillingInvoiceDetailSumAggregateInputType = {
    item_quantity?: true
    item_unit_price?: true
    item_total_price?: true
    item_tax_rate?: true
    item_tax_amount?: true
    item_total_with_tax?: true
  }

  export type BillingInvoiceDetailMinAggregateInputType = {
    id?: true
    item_description?: true
    item_quantity?: true
    item_unit_price?: true
    item_total_price?: true
    item_tax_rate?: true
    item_tax_amount?: true
    item_total_with_tax?: true
    created_at?: true
    updated_at?: true
    billing_invoice_id?: true
  }

  export type BillingInvoiceDetailMaxAggregateInputType = {
    id?: true
    item_description?: true
    item_quantity?: true
    item_unit_price?: true
    item_total_price?: true
    item_tax_rate?: true
    item_tax_amount?: true
    item_total_with_tax?: true
    created_at?: true
    updated_at?: true
    billing_invoice_id?: true
  }

  export type BillingInvoiceDetailCountAggregateInputType = {
    id?: true
    item_description?: true
    item_quantity?: true
    item_unit_price?: true
    item_total_price?: true
    item_tax_rate?: true
    item_tax_amount?: true
    item_total_with_tax?: true
    created_at?: true
    updated_at?: true
    billing_invoice_id?: true
    _all?: true
  }

  export type BillingInvoiceDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoiceDetail to aggregate.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingInvoiceDetails
    **/
    _count?: true | BillingInvoiceDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingInvoiceDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingInvoiceDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingInvoiceDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingInvoiceDetailMaxAggregateInputType
  }

  export type GetBillingInvoiceDetailAggregateType<T extends BillingInvoiceDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingInvoiceDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingInvoiceDetail[P]>
      : GetScalarType<T[P], AggregateBillingInvoiceDetail[P]>
  }




  export type BillingInvoiceDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingInvoiceDetailWhereInput
    orderBy?: BillingInvoiceDetailOrderByWithAggregationInput | BillingInvoiceDetailOrderByWithAggregationInput[]
    by: BillingInvoiceDetailScalarFieldEnum[] | BillingInvoiceDetailScalarFieldEnum
    having?: BillingInvoiceDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingInvoiceDetailCountAggregateInputType | true
    _avg?: BillingInvoiceDetailAvgAggregateInputType
    _sum?: BillingInvoiceDetailSumAggregateInputType
    _min?: BillingInvoiceDetailMinAggregateInputType
    _max?: BillingInvoiceDetailMaxAggregateInputType
  }

  export type BillingInvoiceDetailGroupByOutputType = {
    id: string
    item_description: string
    item_quantity: number
    item_unit_price: number
    item_total_price: number
    item_tax_rate: number
    item_tax_amount: number
    item_total_with_tax: number
    created_at: Date
    updated_at: Date
    billing_invoice_id: string | null
    _count: BillingInvoiceDetailCountAggregateOutputType | null
    _avg: BillingInvoiceDetailAvgAggregateOutputType | null
    _sum: BillingInvoiceDetailSumAggregateOutputType | null
    _min: BillingInvoiceDetailMinAggregateOutputType | null
    _max: BillingInvoiceDetailMaxAggregateOutputType | null
  }

  type GetBillingInvoiceDetailGroupByPayload<T extends BillingInvoiceDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingInvoiceDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingInvoiceDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingInvoiceDetailGroupByOutputType[P]>
            : GetScalarType<T[P], BillingInvoiceDetailGroupByOutputType[P]>
        }
      >
    >


  export type BillingInvoiceDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_description?: boolean
    item_quantity?: boolean
    item_unit_price?: boolean
    item_total_price?: boolean
    item_tax_rate?: boolean
    item_tax_amount?: boolean
    item_total_with_tax?: boolean
    created_at?: boolean
    updated_at?: boolean
    billing_invoice_id?: boolean
    billing_invoice?: boolean | BillingInvoiceDetail$billing_invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoiceDetail"]>

  export type BillingInvoiceDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_description?: boolean
    item_quantity?: boolean
    item_unit_price?: boolean
    item_total_price?: boolean
    item_tax_rate?: boolean
    item_tax_amount?: boolean
    item_total_with_tax?: boolean
    created_at?: boolean
    updated_at?: boolean
    billing_invoice_id?: boolean
    billing_invoice?: boolean | BillingInvoiceDetail$billing_invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoiceDetail"]>

  export type BillingInvoiceDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_description?: boolean
    item_quantity?: boolean
    item_unit_price?: boolean
    item_total_price?: boolean
    item_tax_rate?: boolean
    item_tax_amount?: boolean
    item_total_with_tax?: boolean
    created_at?: boolean
    updated_at?: boolean
    billing_invoice_id?: boolean
    billing_invoice?: boolean | BillingInvoiceDetail$billing_invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingInvoiceDetail"]>

  export type BillingInvoiceDetailSelectScalar = {
    id?: boolean
    item_description?: boolean
    item_quantity?: boolean
    item_unit_price?: boolean
    item_total_price?: boolean
    item_tax_rate?: boolean
    item_tax_amount?: boolean
    item_total_with_tax?: boolean
    created_at?: boolean
    updated_at?: boolean
    billing_invoice_id?: boolean
  }

  export type BillingInvoiceDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item_description" | "item_quantity" | "item_unit_price" | "item_total_price" | "item_tax_rate" | "item_tax_amount" | "item_total_with_tax" | "created_at" | "updated_at" | "billing_invoice_id", ExtArgs["result"]["billingInvoiceDetail"]>
  export type BillingInvoiceDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billing_invoice?: boolean | BillingInvoiceDetail$billing_invoiceArgs<ExtArgs>
  }
  export type BillingInvoiceDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billing_invoice?: boolean | BillingInvoiceDetail$billing_invoiceArgs<ExtArgs>
  }
  export type BillingInvoiceDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billing_invoice?: boolean | BillingInvoiceDetail$billing_invoiceArgs<ExtArgs>
  }

  export type $BillingInvoiceDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingInvoiceDetail"
    objects: {
      billing_invoice: Prisma.$BillingInvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      item_description: string
      item_quantity: number
      item_unit_price: number
      item_total_price: number
      item_tax_rate: number
      item_tax_amount: number
      item_total_with_tax: number
      created_at: Date
      updated_at: Date
      billing_invoice_id: string | null
    }, ExtArgs["result"]["billingInvoiceDetail"]>
    composites: {}
  }

  type BillingInvoiceDetailGetPayload<S extends boolean | null | undefined | BillingInvoiceDetailDefaultArgs> = $Result.GetResult<Prisma.$BillingInvoiceDetailPayload, S>

  type BillingInvoiceDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingInvoiceDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingInvoiceDetailCountAggregateInputType | true
    }

  export interface BillingInvoiceDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingInvoiceDetail'], meta: { name: 'BillingInvoiceDetail' } }
    /**
     * Find zero or one BillingInvoiceDetail that matches the filter.
     * @param {BillingInvoiceDetailFindUniqueArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingInvoiceDetailFindUniqueArgs>(args: SelectSubset<T, BillingInvoiceDetailFindUniqueArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingInvoiceDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingInvoiceDetailFindUniqueOrThrowArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingInvoiceDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingInvoiceDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoiceDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailFindFirstArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingInvoiceDetailFindFirstArgs>(args?: SelectSubset<T, BillingInvoiceDetailFindFirstArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingInvoiceDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailFindFirstOrThrowArgs} args - Arguments to find a BillingInvoiceDetail
     * @example
     * // Get one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingInvoiceDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingInvoiceDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingInvoiceDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingInvoiceDetails
     * const billingInvoiceDetails = await prisma.billingInvoiceDetail.findMany()
     * 
     * // Get first 10 BillingInvoiceDetails
     * const billingInvoiceDetails = await prisma.billingInvoiceDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingInvoiceDetailWithIdOnly = await prisma.billingInvoiceDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingInvoiceDetailFindManyArgs>(args?: SelectSubset<T, BillingInvoiceDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingInvoiceDetail.
     * @param {BillingInvoiceDetailCreateArgs} args - Arguments to create a BillingInvoiceDetail.
     * @example
     * // Create one BillingInvoiceDetail
     * const BillingInvoiceDetail = await prisma.billingInvoiceDetail.create({
     *   data: {
     *     // ... data to create a BillingInvoiceDetail
     *   }
     * })
     * 
     */
    create<T extends BillingInvoiceDetailCreateArgs>(args: SelectSubset<T, BillingInvoiceDetailCreateArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingInvoiceDetails.
     * @param {BillingInvoiceDetailCreateManyArgs} args - Arguments to create many BillingInvoiceDetails.
     * @example
     * // Create many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingInvoiceDetailCreateManyArgs>(args?: SelectSubset<T, BillingInvoiceDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingInvoiceDetails and returns the data saved in the database.
     * @param {BillingInvoiceDetailCreateManyAndReturnArgs} args - Arguments to create many BillingInvoiceDetails.
     * @example
     * // Create many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingInvoiceDetails and only return the `id`
     * const billingInvoiceDetailWithIdOnly = await prisma.billingInvoiceDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingInvoiceDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingInvoiceDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingInvoiceDetail.
     * @param {BillingInvoiceDetailDeleteArgs} args - Arguments to delete one BillingInvoiceDetail.
     * @example
     * // Delete one BillingInvoiceDetail
     * const BillingInvoiceDetail = await prisma.billingInvoiceDetail.delete({
     *   where: {
     *     // ... filter to delete one BillingInvoiceDetail
     *   }
     * })
     * 
     */
    delete<T extends BillingInvoiceDetailDeleteArgs>(args: SelectSubset<T, BillingInvoiceDetailDeleteArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingInvoiceDetail.
     * @param {BillingInvoiceDetailUpdateArgs} args - Arguments to update one BillingInvoiceDetail.
     * @example
     * // Update one BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingInvoiceDetailUpdateArgs>(args: SelectSubset<T, BillingInvoiceDetailUpdateArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingInvoiceDetails.
     * @param {BillingInvoiceDetailDeleteManyArgs} args - Arguments to filter BillingInvoiceDetails to delete.
     * @example
     * // Delete a few BillingInvoiceDetails
     * const { count } = await prisma.billingInvoiceDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingInvoiceDetailDeleteManyArgs>(args?: SelectSubset<T, BillingInvoiceDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoiceDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingInvoiceDetailUpdateManyArgs>(args: SelectSubset<T, BillingInvoiceDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingInvoiceDetails and returns the data updated in the database.
     * @param {BillingInvoiceDetailUpdateManyAndReturnArgs} args - Arguments to update many BillingInvoiceDetails.
     * @example
     * // Update many BillingInvoiceDetails
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingInvoiceDetails and only return the `id`
     * const billingInvoiceDetailWithIdOnly = await prisma.billingInvoiceDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingInvoiceDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingInvoiceDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingInvoiceDetail.
     * @param {BillingInvoiceDetailUpsertArgs} args - Arguments to update or create a BillingInvoiceDetail.
     * @example
     * // Update or create a BillingInvoiceDetail
     * const billingInvoiceDetail = await prisma.billingInvoiceDetail.upsert({
     *   create: {
     *     // ... data to create a BillingInvoiceDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingInvoiceDetail we want to update
     *   }
     * })
     */
    upsert<T extends BillingInvoiceDetailUpsertArgs>(args: SelectSubset<T, BillingInvoiceDetailUpsertArgs<ExtArgs>>): Prisma__BillingInvoiceDetailClient<$Result.GetResult<Prisma.$BillingInvoiceDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingInvoiceDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailCountArgs} args - Arguments to filter BillingInvoiceDetails to count.
     * @example
     * // Count the number of BillingInvoiceDetails
     * const count = await prisma.billingInvoiceDetail.count({
     *   where: {
     *     // ... the filter for the BillingInvoiceDetails we want to count
     *   }
     * })
    **/
    count<T extends BillingInvoiceDetailCountArgs>(
      args?: Subset<T, BillingInvoiceDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingInvoiceDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingInvoiceDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingInvoiceDetailAggregateArgs>(args: Subset<T, BillingInvoiceDetailAggregateArgs>): Prisma.PrismaPromise<GetBillingInvoiceDetailAggregateType<T>>

    /**
     * Group by BillingInvoiceDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingInvoiceDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingInvoiceDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingInvoiceDetailGroupByArgs['orderBy'] }
        : { orderBy?: BillingInvoiceDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingInvoiceDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingInvoiceDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingInvoiceDetail model
   */
  readonly fields: BillingInvoiceDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingInvoiceDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingInvoiceDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billing_invoice<T extends BillingInvoiceDetail$billing_invoiceArgs<ExtArgs> = {}>(args?: Subset<T, BillingInvoiceDetail$billing_invoiceArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingInvoiceDetail model
   */
  interface BillingInvoiceDetailFieldRefs {
    readonly id: FieldRef<"BillingInvoiceDetail", 'String'>
    readonly item_description: FieldRef<"BillingInvoiceDetail", 'String'>
    readonly item_quantity: FieldRef<"BillingInvoiceDetail", 'Int'>
    readonly item_unit_price: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly item_total_price: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly item_tax_rate: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly item_tax_amount: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly item_total_with_tax: FieldRef<"BillingInvoiceDetail", 'Float'>
    readonly created_at: FieldRef<"BillingInvoiceDetail", 'DateTime'>
    readonly updated_at: FieldRef<"BillingInvoiceDetail", 'DateTime'>
    readonly billing_invoice_id: FieldRef<"BillingInvoiceDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BillingInvoiceDetail findUnique
   */
  export type BillingInvoiceDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail findUniqueOrThrow
   */
  export type BillingInvoiceDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail findFirst
   */
  export type BillingInvoiceDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoiceDetails.
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoiceDetails.
     */
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoiceDetail findFirstOrThrow
   */
  export type BillingInvoiceDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetail to fetch.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingInvoiceDetails.
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingInvoiceDetails.
     */
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoiceDetail findMany
   */
  export type BillingInvoiceDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which BillingInvoiceDetails to fetch.
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingInvoiceDetails to fetch.
     */
    orderBy?: BillingInvoiceDetailOrderByWithRelationInput | BillingInvoiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingInvoiceDetails.
     */
    cursor?: BillingInvoiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingInvoiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingInvoiceDetails.
     */
    skip?: number
    distinct?: BillingInvoiceDetailScalarFieldEnum | BillingInvoiceDetailScalarFieldEnum[]
  }

  /**
   * BillingInvoiceDetail create
   */
  export type BillingInvoiceDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingInvoiceDetail.
     */
    data: XOR<BillingInvoiceDetailCreateInput, BillingInvoiceDetailUncheckedCreateInput>
  }

  /**
   * BillingInvoiceDetail createMany
   */
  export type BillingInvoiceDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingInvoiceDetails.
     */
    data: BillingInvoiceDetailCreateManyInput | BillingInvoiceDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingInvoiceDetail createManyAndReturn
   */
  export type BillingInvoiceDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * The data used to create many BillingInvoiceDetails.
     */
    data: BillingInvoiceDetailCreateManyInput | BillingInvoiceDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoiceDetail update
   */
  export type BillingInvoiceDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingInvoiceDetail.
     */
    data: XOR<BillingInvoiceDetailUpdateInput, BillingInvoiceDetailUncheckedUpdateInput>
    /**
     * Choose, which BillingInvoiceDetail to update.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail updateMany
   */
  export type BillingInvoiceDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingInvoiceDetails.
     */
    data: XOR<BillingInvoiceDetailUpdateManyMutationInput, BillingInvoiceDetailUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoiceDetails to update
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * Limit how many BillingInvoiceDetails to update.
     */
    limit?: number
  }

  /**
   * BillingInvoiceDetail updateManyAndReturn
   */
  export type BillingInvoiceDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * The data used to update BillingInvoiceDetails.
     */
    data: XOR<BillingInvoiceDetailUpdateManyMutationInput, BillingInvoiceDetailUncheckedUpdateManyInput>
    /**
     * Filter which BillingInvoiceDetails to update
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * Limit how many BillingInvoiceDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingInvoiceDetail upsert
   */
  export type BillingInvoiceDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingInvoiceDetail to update in case it exists.
     */
    where: BillingInvoiceDetailWhereUniqueInput
    /**
     * In case the BillingInvoiceDetail found by the `where` argument doesn't exist, create a new BillingInvoiceDetail with this data.
     */
    create: XOR<BillingInvoiceDetailCreateInput, BillingInvoiceDetailUncheckedCreateInput>
    /**
     * In case the BillingInvoiceDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingInvoiceDetailUpdateInput, BillingInvoiceDetailUncheckedUpdateInput>
  }

  /**
   * BillingInvoiceDetail delete
   */
  export type BillingInvoiceDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
    /**
     * Filter which BillingInvoiceDetail to delete.
     */
    where: BillingInvoiceDetailWhereUniqueInput
  }

  /**
   * BillingInvoiceDetail deleteMany
   */
  export type BillingInvoiceDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingInvoiceDetails to delete
     */
    where?: BillingInvoiceDetailWhereInput
    /**
     * Limit how many BillingInvoiceDetails to delete.
     */
    limit?: number
  }

  /**
   * BillingInvoiceDetail.billing_invoice
   */
  export type BillingInvoiceDetail$billing_invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    where?: BillingInvoiceWhereInput
  }

  /**
   * BillingInvoiceDetail without action
   */
  export type BillingInvoiceDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoiceDetail
     */
    select?: BillingInvoiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoiceDetail
     */
    omit?: BillingInvoiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceDetailInclude<ExtArgs> | null
  }


  /**
   * Model BillingPayment
   */

  export type AggregateBillingPayment = {
    _count: BillingPaymentCountAggregateOutputType | null
    _avg: BillingPaymentAvgAggregateOutputType | null
    _sum: BillingPaymentSumAggregateOutputType | null
    _min: BillingPaymentMinAggregateOutputType | null
    _max: BillingPaymentMaxAggregateOutputType | null
  }

  export type BillingPaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type BillingPaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type BillingPaymentMinAggregateOutputType = {
    id: string | null
    payment_date: Date | null
    amount: number | null
    payment_method: string | null
    transaction_id: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    billing_invoice_id: string | null
  }

  export type BillingPaymentMaxAggregateOutputType = {
    id: string | null
    payment_date: Date | null
    amount: number | null
    payment_method: string | null
    transaction_id: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    billing_invoice_id: string | null
  }

  export type BillingPaymentCountAggregateOutputType = {
    id: number
    payment_date: number
    amount: number
    payment_method: number
    transaction_id: number
    status: number
    created_at: number
    updated_at: number
    billing_invoice_id: number
    _all: number
  }


  export type BillingPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type BillingPaymentSumAggregateInputType = {
    amount?: true
  }

  export type BillingPaymentMinAggregateInputType = {
    id?: true
    payment_date?: true
    amount?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    billing_invoice_id?: true
  }

  export type BillingPaymentMaxAggregateInputType = {
    id?: true
    payment_date?: true
    amount?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    billing_invoice_id?: true
  }

  export type BillingPaymentCountAggregateInputType = {
    id?: true
    payment_date?: true
    amount?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    billing_invoice_id?: true
    _all?: true
  }

  export type BillingPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPayment to aggregate.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingPayments
    **/
    _count?: true | BillingPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingPaymentMaxAggregateInputType
  }

  export type GetBillingPaymentAggregateType<T extends BillingPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingPayment[P]>
      : GetScalarType<T[P], AggregateBillingPayment[P]>
  }




  export type BillingPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillingPaymentWhereInput
    orderBy?: BillingPaymentOrderByWithAggregationInput | BillingPaymentOrderByWithAggregationInput[]
    by: BillingPaymentScalarFieldEnum[] | BillingPaymentScalarFieldEnum
    having?: BillingPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingPaymentCountAggregateInputType | true
    _avg?: BillingPaymentAvgAggregateInputType
    _sum?: BillingPaymentSumAggregateInputType
    _min?: BillingPaymentMinAggregateInputType
    _max?: BillingPaymentMaxAggregateInputType
  }

  export type BillingPaymentGroupByOutputType = {
    id: string
    payment_date: Date
    amount: number
    payment_method: string
    transaction_id: string | null
    status: string
    created_at: Date
    updated_at: Date
    billing_invoice_id: string | null
    _count: BillingPaymentCountAggregateOutputType | null
    _avg: BillingPaymentAvgAggregateOutputType | null
    _sum: BillingPaymentSumAggregateOutputType | null
    _min: BillingPaymentMinAggregateOutputType | null
    _max: BillingPaymentMaxAggregateOutputType | null
  }

  type GetBillingPaymentGroupByPayload<T extends BillingPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], BillingPaymentGroupByOutputType[P]>
        }
      >
    >


  export type BillingPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment_date?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    billing_invoice_id?: boolean
    billing_invoice?: boolean | BillingPayment$billing_invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingPayment"]>

  export type BillingPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment_date?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    billing_invoice_id?: boolean
    billing_invoice?: boolean | BillingPayment$billing_invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingPayment"]>

  export type BillingPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment_date?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    billing_invoice_id?: boolean
    billing_invoice?: boolean | BillingPayment$billing_invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["billingPayment"]>

  export type BillingPaymentSelectScalar = {
    id?: boolean
    payment_date?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    billing_invoice_id?: boolean
  }

  export type BillingPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "payment_date" | "amount" | "payment_method" | "transaction_id" | "status" | "created_at" | "updated_at" | "billing_invoice_id", ExtArgs["result"]["billingPayment"]>
  export type BillingPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billing_invoice?: boolean | BillingPayment$billing_invoiceArgs<ExtArgs>
  }
  export type BillingPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billing_invoice?: boolean | BillingPayment$billing_invoiceArgs<ExtArgs>
  }
  export type BillingPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billing_invoice?: boolean | BillingPayment$billing_invoiceArgs<ExtArgs>
  }

  export type $BillingPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillingPayment"
    objects: {
      billing_invoice: Prisma.$BillingInvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      payment_date: Date
      amount: number
      payment_method: string
      transaction_id: string | null
      status: string
      created_at: Date
      updated_at: Date
      billing_invoice_id: string | null
    }, ExtArgs["result"]["billingPayment"]>
    composites: {}
  }

  type BillingPaymentGetPayload<S extends boolean | null | undefined | BillingPaymentDefaultArgs> = $Result.GetResult<Prisma.$BillingPaymentPayload, S>

  type BillingPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillingPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillingPaymentCountAggregateInputType | true
    }

  export interface BillingPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingPayment'], meta: { name: 'BillingPayment' } }
    /**
     * Find zero or one BillingPayment that matches the filter.
     * @param {BillingPaymentFindUniqueArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillingPaymentFindUniqueArgs>(args: SelectSubset<T, BillingPaymentFindUniqueArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillingPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillingPaymentFindUniqueOrThrowArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillingPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, BillingPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentFindFirstArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillingPaymentFindFirstArgs>(args?: SelectSubset<T, BillingPaymentFindFirstArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillingPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentFindFirstOrThrowArgs} args - Arguments to find a BillingPayment
     * @example
     * // Get one BillingPayment
     * const billingPayment = await prisma.billingPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillingPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, BillingPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillingPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingPayments
     * const billingPayments = await prisma.billingPayment.findMany()
     * 
     * // Get first 10 BillingPayments
     * const billingPayments = await prisma.billingPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingPaymentWithIdOnly = await prisma.billingPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillingPaymentFindManyArgs>(args?: SelectSubset<T, BillingPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillingPayment.
     * @param {BillingPaymentCreateArgs} args - Arguments to create a BillingPayment.
     * @example
     * // Create one BillingPayment
     * const BillingPayment = await prisma.billingPayment.create({
     *   data: {
     *     // ... data to create a BillingPayment
     *   }
     * })
     * 
     */
    create<T extends BillingPaymentCreateArgs>(args: SelectSubset<T, BillingPaymentCreateArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillingPayments.
     * @param {BillingPaymentCreateManyArgs} args - Arguments to create many BillingPayments.
     * @example
     * // Create many BillingPayments
     * const billingPayment = await prisma.billingPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillingPaymentCreateManyArgs>(args?: SelectSubset<T, BillingPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillingPayments and returns the data saved in the database.
     * @param {BillingPaymentCreateManyAndReturnArgs} args - Arguments to create many BillingPayments.
     * @example
     * // Create many BillingPayments
     * const billingPayment = await prisma.billingPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillingPayments and only return the `id`
     * const billingPaymentWithIdOnly = await prisma.billingPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillingPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, BillingPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillingPayment.
     * @param {BillingPaymentDeleteArgs} args - Arguments to delete one BillingPayment.
     * @example
     * // Delete one BillingPayment
     * const BillingPayment = await prisma.billingPayment.delete({
     *   where: {
     *     // ... filter to delete one BillingPayment
     *   }
     * })
     * 
     */
    delete<T extends BillingPaymentDeleteArgs>(args: SelectSubset<T, BillingPaymentDeleteArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillingPayment.
     * @param {BillingPaymentUpdateArgs} args - Arguments to update one BillingPayment.
     * @example
     * // Update one BillingPayment
     * const billingPayment = await prisma.billingPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillingPaymentUpdateArgs>(args: SelectSubset<T, BillingPaymentUpdateArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillingPayments.
     * @param {BillingPaymentDeleteManyArgs} args - Arguments to filter BillingPayments to delete.
     * @example
     * // Delete a few BillingPayments
     * const { count } = await prisma.billingPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillingPaymentDeleteManyArgs>(args?: SelectSubset<T, BillingPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingPayments
     * const billingPayment = await prisma.billingPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillingPaymentUpdateManyArgs>(args: SelectSubset<T, BillingPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingPayments and returns the data updated in the database.
     * @param {BillingPaymentUpdateManyAndReturnArgs} args - Arguments to update many BillingPayments.
     * @example
     * // Update many BillingPayments
     * const billingPayment = await prisma.billingPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillingPayments and only return the `id`
     * const billingPaymentWithIdOnly = await prisma.billingPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillingPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, BillingPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillingPayment.
     * @param {BillingPaymentUpsertArgs} args - Arguments to update or create a BillingPayment.
     * @example
     * // Update or create a BillingPayment
     * const billingPayment = await prisma.billingPayment.upsert({
     *   create: {
     *     // ... data to create a BillingPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingPayment we want to update
     *   }
     * })
     */
    upsert<T extends BillingPaymentUpsertArgs>(args: SelectSubset<T, BillingPaymentUpsertArgs<ExtArgs>>): Prisma__BillingPaymentClient<$Result.GetResult<Prisma.$BillingPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillingPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentCountArgs} args - Arguments to filter BillingPayments to count.
     * @example
     * // Count the number of BillingPayments
     * const count = await prisma.billingPayment.count({
     *   where: {
     *     // ... the filter for the BillingPayments we want to count
     *   }
     * })
    **/
    count<T extends BillingPaymentCountArgs>(
      args?: Subset<T, BillingPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingPaymentAggregateArgs>(args: Subset<T, BillingPaymentAggregateArgs>): Prisma.PrismaPromise<GetBillingPaymentAggregateType<T>>

    /**
     * Group by BillingPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingPaymentGroupByArgs['orderBy'] }
        : { orderBy?: BillingPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingPayment model
   */
  readonly fields: BillingPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillingPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billing_invoice<T extends BillingPayment$billing_invoiceArgs<ExtArgs> = {}>(args?: Subset<T, BillingPayment$billing_invoiceArgs<ExtArgs>>): Prisma__BillingInvoiceClient<$Result.GetResult<Prisma.$BillingInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillingPayment model
   */
  interface BillingPaymentFieldRefs {
    readonly id: FieldRef<"BillingPayment", 'String'>
    readonly payment_date: FieldRef<"BillingPayment", 'DateTime'>
    readonly amount: FieldRef<"BillingPayment", 'Float'>
    readonly payment_method: FieldRef<"BillingPayment", 'String'>
    readonly transaction_id: FieldRef<"BillingPayment", 'String'>
    readonly status: FieldRef<"BillingPayment", 'String'>
    readonly created_at: FieldRef<"BillingPayment", 'DateTime'>
    readonly updated_at: FieldRef<"BillingPayment", 'DateTime'>
    readonly billing_invoice_id: FieldRef<"BillingPayment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BillingPayment findUnique
   */
  export type BillingPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment findUniqueOrThrow
   */
  export type BillingPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment findFirst
   */
  export type BillingPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPayments.
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPayments.
     */
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingPayment findFirstOrThrow
   */
  export type BillingPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayment to fetch.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingPayments.
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingPayments.
     */
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingPayment findMany
   */
  export type BillingPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter, which BillingPayments to fetch.
     */
    where?: BillingPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingPayments to fetch.
     */
    orderBy?: BillingPaymentOrderByWithRelationInput | BillingPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingPayments.
     */
    cursor?: BillingPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingPayments.
     */
    skip?: number
    distinct?: BillingPaymentScalarFieldEnum | BillingPaymentScalarFieldEnum[]
  }

  /**
   * BillingPayment create
   */
  export type BillingPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a BillingPayment.
     */
    data: XOR<BillingPaymentCreateInput, BillingPaymentUncheckedCreateInput>
  }

  /**
   * BillingPayment createMany
   */
  export type BillingPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingPayments.
     */
    data: BillingPaymentCreateManyInput | BillingPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BillingPayment createManyAndReturn
   */
  export type BillingPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many BillingPayments.
     */
    data: BillingPaymentCreateManyInput | BillingPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingPayment update
   */
  export type BillingPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a BillingPayment.
     */
    data: XOR<BillingPaymentUpdateInput, BillingPaymentUncheckedUpdateInput>
    /**
     * Choose, which BillingPayment to update.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment updateMany
   */
  export type BillingPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingPayments.
     */
    data: XOR<BillingPaymentUpdateManyMutationInput, BillingPaymentUncheckedUpdateManyInput>
    /**
     * Filter which BillingPayments to update
     */
    where?: BillingPaymentWhereInput
    /**
     * Limit how many BillingPayments to update.
     */
    limit?: number
  }

  /**
   * BillingPayment updateManyAndReturn
   */
  export type BillingPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * The data used to update BillingPayments.
     */
    data: XOR<BillingPaymentUpdateManyMutationInput, BillingPaymentUncheckedUpdateManyInput>
    /**
     * Filter which BillingPayments to update
     */
    where?: BillingPaymentWhereInput
    /**
     * Limit how many BillingPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillingPayment upsert
   */
  export type BillingPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the BillingPayment to update in case it exists.
     */
    where: BillingPaymentWhereUniqueInput
    /**
     * In case the BillingPayment found by the `where` argument doesn't exist, create a new BillingPayment with this data.
     */
    create: XOR<BillingPaymentCreateInput, BillingPaymentUncheckedCreateInput>
    /**
     * In case the BillingPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingPaymentUpdateInput, BillingPaymentUncheckedUpdateInput>
  }

  /**
   * BillingPayment delete
   */
  export type BillingPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
    /**
     * Filter which BillingPayment to delete.
     */
    where: BillingPaymentWhereUniqueInput
  }

  /**
   * BillingPayment deleteMany
   */
  export type BillingPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingPayments to delete
     */
    where?: BillingPaymentWhereInput
    /**
     * Limit how many BillingPayments to delete.
     */
    limit?: number
  }

  /**
   * BillingPayment.billing_invoice
   */
  export type BillingPayment$billing_invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingInvoice
     */
    select?: BillingInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingInvoice
     */
    omit?: BillingInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingInvoiceInclude<ExtArgs> | null
    where?: BillingInvoiceWhereInput
  }

  /**
   * BillingPayment without action
   */
  export type BillingPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingPayment
     */
    select?: BillingPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillingPayment
     */
    omit?: BillingPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillingPaymentInclude<ExtArgs> | null
  }


  /**
   * Model CollectionCase
   */

  export type AggregateCollectionCase = {
    _count: CollectionCaseCountAggregateOutputType | null
    _avg: CollectionCaseAvgAggregateOutputType | null
    _sum: CollectionCaseSumAggregateOutputType | null
    _min: CollectionCaseMinAggregateOutputType | null
    _max: CollectionCaseMaxAggregateOutputType | null
  }

  export type CollectionCaseAvgAggregateOutputType = {
    amount_original: Decimal | null
    amount_due: Decimal | null
    amount_to_receive: Decimal | null
  }

  export type CollectionCaseSumAggregateOutputType = {
    amount_original: Decimal | null
    amount_due: Decimal | null
    amount_to_receive: Decimal | null
  }

  export type CollectionCaseMinAggregateOutputType = {
    id: string | null
    reference_number: string | null
    issue_date: Date | null
    due_date: Date | null
    reminder1_sent_at: Date | null
    reminder1_due_date: Date | null
    reminder2_sent_at: Date | null
    reminder2_due_date: Date | null
    tenant_id: string | null
    debtor_id: string | null
    amount_original: Decimal | null
    amount_due: Decimal | null
    amount_to_receive: Decimal | null
    status: $Enums.CollectionCaseStatus | null
    notification_status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CollectionCaseMaxAggregateOutputType = {
    id: string | null
    reference_number: string | null
    issue_date: Date | null
    due_date: Date | null
    reminder1_sent_at: Date | null
    reminder1_due_date: Date | null
    reminder2_sent_at: Date | null
    reminder2_due_date: Date | null
    tenant_id: string | null
    debtor_id: string | null
    amount_original: Decimal | null
    amount_due: Decimal | null
    amount_to_receive: Decimal | null
    status: $Enums.CollectionCaseStatus | null
    notification_status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CollectionCaseCountAggregateOutputType = {
    id: number
    reference_number: number
    issue_date: number
    due_date: number
    reminder1_sent_at: number
    reminder1_due_date: number
    reminder2_sent_at: number
    reminder2_due_date: number
    tenant_id: number
    debtor_id: number
    amount_original: number
    amount_due: number
    amount_to_receive: number
    status: number
    notification_status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CollectionCaseAvgAggregateInputType = {
    amount_original?: true
    amount_due?: true
    amount_to_receive?: true
  }

  export type CollectionCaseSumAggregateInputType = {
    amount_original?: true
    amount_due?: true
    amount_to_receive?: true
  }

  export type CollectionCaseMinAggregateInputType = {
    id?: true
    reference_number?: true
    issue_date?: true
    due_date?: true
    reminder1_sent_at?: true
    reminder1_due_date?: true
    reminder2_sent_at?: true
    reminder2_due_date?: true
    tenant_id?: true
    debtor_id?: true
    amount_original?: true
    amount_due?: true
    amount_to_receive?: true
    status?: true
    notification_status?: true
    created_at?: true
    updated_at?: true
  }

  export type CollectionCaseMaxAggregateInputType = {
    id?: true
    reference_number?: true
    issue_date?: true
    due_date?: true
    reminder1_sent_at?: true
    reminder1_due_date?: true
    reminder2_sent_at?: true
    reminder2_due_date?: true
    tenant_id?: true
    debtor_id?: true
    amount_original?: true
    amount_due?: true
    amount_to_receive?: true
    status?: true
    notification_status?: true
    created_at?: true
    updated_at?: true
  }

  export type CollectionCaseCountAggregateInputType = {
    id?: true
    reference_number?: true
    issue_date?: true
    due_date?: true
    reminder1_sent_at?: true
    reminder1_due_date?: true
    reminder2_sent_at?: true
    reminder2_due_date?: true
    tenant_id?: true
    debtor_id?: true
    amount_original?: true
    amount_due?: true
    amount_to_receive?: true
    status?: true
    notification_status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CollectionCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCase to aggregate.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionCases
    **/
    _count?: true | CollectionCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionCaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionCaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionCaseMaxAggregateInputType
  }

  export type GetCollectionCaseAggregateType<T extends CollectionCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionCase[P]>
      : GetScalarType<T[P], AggregateCollectionCase[P]>
  }




  export type CollectionCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseWhereInput
    orderBy?: CollectionCaseOrderByWithAggregationInput | CollectionCaseOrderByWithAggregationInput[]
    by: CollectionCaseScalarFieldEnum[] | CollectionCaseScalarFieldEnum
    having?: CollectionCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCaseCountAggregateInputType | true
    _avg?: CollectionCaseAvgAggregateInputType
    _sum?: CollectionCaseSumAggregateInputType
    _min?: CollectionCaseMinAggregateInputType
    _max?: CollectionCaseMaxAggregateInputType
  }

  export type CollectionCaseGroupByOutputType = {
    id: string
    reference_number: string | null
    issue_date: Date | null
    due_date: Date | null
    reminder1_sent_at: Date | null
    reminder1_due_date: Date | null
    reminder2_sent_at: Date | null
    reminder2_due_date: Date | null
    tenant_id: string
    debtor_id: string
    amount_original: Decimal
    amount_due: Decimal
    amount_to_receive: Decimal
    status: $Enums.CollectionCaseStatus
    notification_status: string | null
    created_at: Date
    updated_at: Date
    _count: CollectionCaseCountAggregateOutputType | null
    _avg: CollectionCaseAvgAggregateOutputType | null
    _sum: CollectionCaseSumAggregateOutputType | null
    _min: CollectionCaseMinAggregateOutputType | null
    _max: CollectionCaseMaxAggregateOutputType | null
  }

  type GetCollectionCaseGroupByPayload<T extends CollectionCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionCaseGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionCaseGroupByOutputType[P]>
        }
      >
    >


  export type CollectionCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference_number?: boolean
    issue_date?: boolean
    due_date?: boolean
    reminder1_sent_at?: boolean
    reminder1_due_date?: boolean
    reminder2_sent_at?: boolean
    reminder2_due_date?: boolean
    tenant_id?: boolean
    debtor_id?: boolean
    amount_original?: boolean
    amount_due?: boolean
    amount_to_receive?: boolean
    status?: boolean
    notification_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    notifications?: boolean | CollectionCase$notificationsArgs<ExtArgs>
    payments?: boolean | CollectionCase$paymentsArgs<ExtArgs>
    agreements?: boolean | CollectionCase$agreementsArgs<ExtArgs>
    penalties?: boolean | CollectionCase$penaltiesArgs<ExtArgs>
    chat_rooms?: boolean | CollectionCase$chat_roomsArgs<ExtArgs>
    _count?: boolean | CollectionCaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCase"]>

  export type CollectionCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference_number?: boolean
    issue_date?: boolean
    due_date?: boolean
    reminder1_sent_at?: boolean
    reminder1_due_date?: boolean
    reminder2_sent_at?: boolean
    reminder2_due_date?: boolean
    tenant_id?: boolean
    debtor_id?: boolean
    amount_original?: boolean
    amount_due?: boolean
    amount_to_receive?: boolean
    status?: boolean
    notification_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCase"]>

  export type CollectionCaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reference_number?: boolean
    issue_date?: boolean
    due_date?: boolean
    reminder1_sent_at?: boolean
    reminder1_due_date?: boolean
    reminder2_sent_at?: boolean
    reminder2_due_date?: boolean
    tenant_id?: boolean
    debtor_id?: boolean
    amount_original?: boolean
    amount_due?: boolean
    amount_to_receive?: boolean
    status?: boolean
    notification_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCase"]>

  export type CollectionCaseSelectScalar = {
    id?: boolean
    reference_number?: boolean
    issue_date?: boolean
    due_date?: boolean
    reminder1_sent_at?: boolean
    reminder1_due_date?: boolean
    reminder2_sent_at?: boolean
    reminder2_due_date?: boolean
    tenant_id?: boolean
    debtor_id?: boolean
    amount_original?: boolean
    amount_due?: boolean
    amount_to_receive?: boolean
    status?: boolean
    notification_status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CollectionCaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reference_number" | "issue_date" | "due_date" | "reminder1_sent_at" | "reminder1_due_date" | "reminder2_sent_at" | "reminder2_due_date" | "tenant_id" | "debtor_id" | "amount_original" | "amount_due" | "amount_to_receive" | "status" | "notification_status" | "created_at" | "updated_at", ExtArgs["result"]["collectionCase"]>
  export type CollectionCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    notifications?: boolean | CollectionCase$notificationsArgs<ExtArgs>
    payments?: boolean | CollectionCase$paymentsArgs<ExtArgs>
    agreements?: boolean | CollectionCase$agreementsArgs<ExtArgs>
    penalties?: boolean | CollectionCase$penaltiesArgs<ExtArgs>
    chat_rooms?: boolean | CollectionCase$chat_roomsArgs<ExtArgs>
    _count?: boolean | CollectionCaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollectionCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CollectionCaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CollectionCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionCase"
    objects: {
      debtor: Prisma.$DebtorPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      notifications: Prisma.$CollectionCaseNotificationPayload<ExtArgs>[]
      payments: Prisma.$CollectionCasePaymentPayload<ExtArgs>[]
      agreements: Prisma.$CollectionCaseAgreementPayload<ExtArgs>[]
      penalties: Prisma.$CollectionCasePenaltyPayload<ExtArgs>[]
      chat_rooms: Prisma.$ChatRoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reference_number: string | null
      issue_date: Date | null
      due_date: Date | null
      reminder1_sent_at: Date | null
      reminder1_due_date: Date | null
      reminder2_sent_at: Date | null
      reminder2_due_date: Date | null
      tenant_id: string
      debtor_id: string
      amount_original: Prisma.Decimal
      amount_due: Prisma.Decimal
      amount_to_receive: Prisma.Decimal
      status: $Enums.CollectionCaseStatus
      notification_status: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["collectionCase"]>
    composites: {}
  }

  type CollectionCaseGetPayload<S extends boolean | null | undefined | CollectionCaseDefaultArgs> = $Result.GetResult<Prisma.$CollectionCasePayload, S>

  type CollectionCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionCaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCaseCountAggregateInputType | true
    }

  export interface CollectionCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionCase'], meta: { name: 'CollectionCase' } }
    /**
     * Find zero or one CollectionCase that matches the filter.
     * @param {CollectionCaseFindUniqueArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionCaseFindUniqueArgs>(args: SelectSubset<T, CollectionCaseFindUniqueArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionCase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionCaseFindUniqueOrThrowArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseFindFirstArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionCaseFindFirstArgs>(args?: SelectSubset<T, CollectionCaseFindFirstArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseFindFirstOrThrowArgs} args - Arguments to find a CollectionCase
     * @example
     * // Get one CollectionCase
     * const collectionCase = await prisma.collectionCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionCases
     * const collectionCases = await prisma.collectionCase.findMany()
     * 
     * // Get first 10 CollectionCases
     * const collectionCases = await prisma.collectionCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionCaseWithIdOnly = await prisma.collectionCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionCaseFindManyArgs>(args?: SelectSubset<T, CollectionCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionCase.
     * @param {CollectionCaseCreateArgs} args - Arguments to create a CollectionCase.
     * @example
     * // Create one CollectionCase
     * const CollectionCase = await prisma.collectionCase.create({
     *   data: {
     *     // ... data to create a CollectionCase
     *   }
     * })
     * 
     */
    create<T extends CollectionCaseCreateArgs>(args: SelectSubset<T, CollectionCaseCreateArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionCases.
     * @param {CollectionCaseCreateManyArgs} args - Arguments to create many CollectionCases.
     * @example
     * // Create many CollectionCases
     * const collectionCase = await prisma.collectionCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCaseCreateManyArgs>(args?: SelectSubset<T, CollectionCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionCases and returns the data saved in the database.
     * @param {CollectionCaseCreateManyAndReturnArgs} args - Arguments to create many CollectionCases.
     * @example
     * // Create many CollectionCases
     * const collectionCase = await prisma.collectionCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionCases and only return the `id`
     * const collectionCaseWithIdOnly = await prisma.collectionCase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionCase.
     * @param {CollectionCaseDeleteArgs} args - Arguments to delete one CollectionCase.
     * @example
     * // Delete one CollectionCase
     * const CollectionCase = await prisma.collectionCase.delete({
     *   where: {
     *     // ... filter to delete one CollectionCase
     *   }
     * })
     * 
     */
    delete<T extends CollectionCaseDeleteArgs>(args: SelectSubset<T, CollectionCaseDeleteArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionCase.
     * @param {CollectionCaseUpdateArgs} args - Arguments to update one CollectionCase.
     * @example
     * // Update one CollectionCase
     * const collectionCase = await prisma.collectionCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionCaseUpdateArgs>(args: SelectSubset<T, CollectionCaseUpdateArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionCases.
     * @param {CollectionCaseDeleteManyArgs} args - Arguments to filter CollectionCases to delete.
     * @example
     * // Delete a few CollectionCases
     * const { count } = await prisma.collectionCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionCaseDeleteManyArgs>(args?: SelectSubset<T, CollectionCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionCases
     * const collectionCase = await prisma.collectionCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionCaseUpdateManyArgs>(args: SelectSubset<T, CollectionCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCases and returns the data updated in the database.
     * @param {CollectionCaseUpdateManyAndReturnArgs} args - Arguments to update many CollectionCases.
     * @example
     * // Update many CollectionCases
     * const collectionCase = await prisma.collectionCase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionCases and only return the `id`
     * const collectionCaseWithIdOnly = await prisma.collectionCase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionCaseUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionCaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionCase.
     * @param {CollectionCaseUpsertArgs} args - Arguments to update or create a CollectionCase.
     * @example
     * // Update or create a CollectionCase
     * const collectionCase = await prisma.collectionCase.upsert({
     *   create: {
     *     // ... data to create a CollectionCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionCase we want to update
     *   }
     * })
     */
    upsert<T extends CollectionCaseUpsertArgs>(args: SelectSubset<T, CollectionCaseUpsertArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseCountArgs} args - Arguments to filter CollectionCases to count.
     * @example
     * // Count the number of CollectionCases
     * const count = await prisma.collectionCase.count({
     *   where: {
     *     // ... the filter for the CollectionCases we want to count
     *   }
     * })
    **/
    count<T extends CollectionCaseCountArgs>(
      args?: Subset<T, CollectionCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionCaseAggregateArgs>(args: Subset<T, CollectionCaseAggregateArgs>): Prisma.PrismaPromise<GetCollectionCaseAggregateType<T>>

    /**
     * Group by CollectionCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionCaseGroupByArgs['orderBy'] }
        : { orderBy?: CollectionCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionCase model
   */
  readonly fields: CollectionCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    debtor<T extends DebtorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtorDefaultArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends CollectionCase$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends CollectionCase$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agreements<T extends CollectionCase$agreementsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$agreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    penalties<T extends CollectionCase$penaltiesArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$penaltiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chat_rooms<T extends CollectionCase$chat_roomsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCase$chat_roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionCase model
   */
  interface CollectionCaseFieldRefs {
    readonly id: FieldRef<"CollectionCase", 'String'>
    readonly reference_number: FieldRef<"CollectionCase", 'String'>
    readonly issue_date: FieldRef<"CollectionCase", 'DateTime'>
    readonly due_date: FieldRef<"CollectionCase", 'DateTime'>
    readonly reminder1_sent_at: FieldRef<"CollectionCase", 'DateTime'>
    readonly reminder1_due_date: FieldRef<"CollectionCase", 'DateTime'>
    readonly reminder2_sent_at: FieldRef<"CollectionCase", 'DateTime'>
    readonly reminder2_due_date: FieldRef<"CollectionCase", 'DateTime'>
    readonly tenant_id: FieldRef<"CollectionCase", 'String'>
    readonly debtor_id: FieldRef<"CollectionCase", 'String'>
    readonly amount_original: FieldRef<"CollectionCase", 'Decimal'>
    readonly amount_due: FieldRef<"CollectionCase", 'Decimal'>
    readonly amount_to_receive: FieldRef<"CollectionCase", 'Decimal'>
    readonly status: FieldRef<"CollectionCase", 'CollectionCaseStatus'>
    readonly notification_status: FieldRef<"CollectionCase", 'String'>
    readonly created_at: FieldRef<"CollectionCase", 'DateTime'>
    readonly updated_at: FieldRef<"CollectionCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionCase findUnique
   */
  export type CollectionCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase findUniqueOrThrow
   */
  export type CollectionCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase findFirst
   */
  export type CollectionCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCases.
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCases.
     */
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * CollectionCase findFirstOrThrow
   */
  export type CollectionCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCase to fetch.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCases.
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCases.
     */
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * CollectionCase findMany
   */
  export type CollectionCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCases to fetch.
     */
    where?: CollectionCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCases to fetch.
     */
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionCases.
     */
    cursor?: CollectionCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCases.
     */
    skip?: number
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * CollectionCase create
   */
  export type CollectionCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a CollectionCase.
     */
    data: XOR<CollectionCaseCreateInput, CollectionCaseUncheckedCreateInput>
  }

  /**
   * CollectionCase createMany
   */
  export type CollectionCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionCases.
     */
    data: CollectionCaseCreateManyInput | CollectionCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionCase createManyAndReturn
   */
  export type CollectionCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionCases.
     */
    data: CollectionCaseCreateManyInput | CollectionCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCase update
   */
  export type CollectionCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a CollectionCase.
     */
    data: XOR<CollectionCaseUpdateInput, CollectionCaseUncheckedUpdateInput>
    /**
     * Choose, which CollectionCase to update.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase updateMany
   */
  export type CollectionCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionCases.
     */
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCases to update
     */
    where?: CollectionCaseWhereInput
    /**
     * Limit how many CollectionCases to update.
     */
    limit?: number
  }

  /**
   * CollectionCase updateManyAndReturn
   */
  export type CollectionCaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * The data used to update CollectionCases.
     */
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCases to update
     */
    where?: CollectionCaseWhereInput
    /**
     * Limit how many CollectionCases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCase upsert
   */
  export type CollectionCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the CollectionCase to update in case it exists.
     */
    where: CollectionCaseWhereUniqueInput
    /**
     * In case the CollectionCase found by the `where` argument doesn't exist, create a new CollectionCase with this data.
     */
    create: XOR<CollectionCaseCreateInput, CollectionCaseUncheckedCreateInput>
    /**
     * In case the CollectionCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionCaseUpdateInput, CollectionCaseUncheckedUpdateInput>
  }

  /**
   * CollectionCase delete
   */
  export type CollectionCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    /**
     * Filter which CollectionCase to delete.
     */
    where: CollectionCaseWhereUniqueInput
  }

  /**
   * CollectionCase deleteMany
   */
  export type CollectionCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCases to delete
     */
    where?: CollectionCaseWhereInput
    /**
     * Limit how many CollectionCases to delete.
     */
    limit?: number
  }

  /**
   * CollectionCase.notifications
   */
  export type CollectionCase$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationInclude<ExtArgs> | null
    where?: CollectionCaseNotificationWhereInput
    orderBy?: CollectionCaseNotificationOrderByWithRelationInput | CollectionCaseNotificationOrderByWithRelationInput[]
    cursor?: CollectionCaseNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseNotificationScalarFieldEnum | CollectionCaseNotificationScalarFieldEnum[]
  }

  /**
   * CollectionCase.payments
   */
  export type CollectionCase$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    where?: CollectionCasePaymentWhereInput
    orderBy?: CollectionCasePaymentOrderByWithRelationInput | CollectionCasePaymentOrderByWithRelationInput[]
    cursor?: CollectionCasePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCasePaymentScalarFieldEnum | CollectionCasePaymentScalarFieldEnum[]
  }

  /**
   * CollectionCase.agreements
   */
  export type CollectionCase$agreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    where?: CollectionCaseAgreementWhereInput
    orderBy?: CollectionCaseAgreementOrderByWithRelationInput | CollectionCaseAgreementOrderByWithRelationInput[]
    cursor?: CollectionCaseAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseAgreementScalarFieldEnum | CollectionCaseAgreementScalarFieldEnum[]
  }

  /**
   * CollectionCase.penalties
   */
  export type CollectionCase$penaltiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyInclude<ExtArgs> | null
    where?: CollectionCasePenaltyWhereInput
    orderBy?: CollectionCasePenaltyOrderByWithRelationInput | CollectionCasePenaltyOrderByWithRelationInput[]
    cursor?: CollectionCasePenaltyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCasePenaltyScalarFieldEnum | CollectionCasePenaltyScalarFieldEnum[]
  }

  /**
   * CollectionCase.chat_rooms
   */
  export type CollectionCase$chat_roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    where?: ChatRoomWhereInput
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    cursor?: ChatRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * CollectionCase without action
   */
  export type CollectionCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
  }


  /**
   * Model CollectionCasePenalty
   */

  export type AggregateCollectionCasePenalty = {
    _count: CollectionCasePenaltyCountAggregateOutputType | null
    _avg: CollectionCasePenaltyAvgAggregateOutputType | null
    _sum: CollectionCasePenaltySumAggregateOutputType | null
    _min: CollectionCasePenaltyMinAggregateOutputType | null
    _max: CollectionCasePenaltyMaxAggregateOutputType | null
  }

  export type CollectionCasePenaltyAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type CollectionCasePenaltySumAggregateOutputType = {
    amount: Decimal | null
  }

  export type CollectionCasePenaltyMinAggregateOutputType = {
    id: string | null
    collection_case_id: string | null
    description: string | null
    amount: Decimal | null
    date_applied: Date | null
    is_paid: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CollectionCasePenaltyMaxAggregateOutputType = {
    id: string | null
    collection_case_id: string | null
    description: string | null
    amount: Decimal | null
    date_applied: Date | null
    is_paid: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CollectionCasePenaltyCountAggregateOutputType = {
    id: number
    collection_case_id: number
    description: number
    amount: number
    date_applied: number
    is_paid: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CollectionCasePenaltyAvgAggregateInputType = {
    amount?: true
  }

  export type CollectionCasePenaltySumAggregateInputType = {
    amount?: true
  }

  export type CollectionCasePenaltyMinAggregateInputType = {
    id?: true
    collection_case_id?: true
    description?: true
    amount?: true
    date_applied?: true
    is_paid?: true
    created_at?: true
    updated_at?: true
  }

  export type CollectionCasePenaltyMaxAggregateInputType = {
    id?: true
    collection_case_id?: true
    description?: true
    amount?: true
    date_applied?: true
    is_paid?: true
    created_at?: true
    updated_at?: true
  }

  export type CollectionCasePenaltyCountAggregateInputType = {
    id?: true
    collection_case_id?: true
    description?: true
    amount?: true
    date_applied?: true
    is_paid?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CollectionCasePenaltyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCasePenalty to aggregate.
     */
    where?: CollectionCasePenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCasePenalties to fetch.
     */
    orderBy?: CollectionCasePenaltyOrderByWithRelationInput | CollectionCasePenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionCasePenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCasePenalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCasePenalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionCasePenalties
    **/
    _count?: true | CollectionCasePenaltyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionCasePenaltyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionCasePenaltySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionCasePenaltyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionCasePenaltyMaxAggregateInputType
  }

  export type GetCollectionCasePenaltyAggregateType<T extends CollectionCasePenaltyAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionCasePenalty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionCasePenalty[P]>
      : GetScalarType<T[P], AggregateCollectionCasePenalty[P]>
  }




  export type CollectionCasePenaltyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCasePenaltyWhereInput
    orderBy?: CollectionCasePenaltyOrderByWithAggregationInput | CollectionCasePenaltyOrderByWithAggregationInput[]
    by: CollectionCasePenaltyScalarFieldEnum[] | CollectionCasePenaltyScalarFieldEnum
    having?: CollectionCasePenaltyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCasePenaltyCountAggregateInputType | true
    _avg?: CollectionCasePenaltyAvgAggregateInputType
    _sum?: CollectionCasePenaltySumAggregateInputType
    _min?: CollectionCasePenaltyMinAggregateInputType
    _max?: CollectionCasePenaltyMaxAggregateInputType
  }

  export type CollectionCasePenaltyGroupByOutputType = {
    id: string
    collection_case_id: string
    description: string | null
    amount: Decimal
    date_applied: Date
    is_paid: boolean
    created_at: Date
    updated_at: Date
    _count: CollectionCasePenaltyCountAggregateOutputType | null
    _avg: CollectionCasePenaltyAvgAggregateOutputType | null
    _sum: CollectionCasePenaltySumAggregateOutputType | null
    _min: CollectionCasePenaltyMinAggregateOutputType | null
    _max: CollectionCasePenaltyMaxAggregateOutputType | null
  }

  type GetCollectionCasePenaltyGroupByPayload<T extends CollectionCasePenaltyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionCasePenaltyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionCasePenaltyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionCasePenaltyGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionCasePenaltyGroupByOutputType[P]>
        }
      >
    >


  export type CollectionCasePenaltySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_case_id?: boolean
    description?: boolean
    amount?: boolean
    date_applied?: boolean
    is_paid?: boolean
    created_at?: boolean
    updated_at?: boolean
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCasePenalty"]>

  export type CollectionCasePenaltySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_case_id?: boolean
    description?: boolean
    amount?: boolean
    date_applied?: boolean
    is_paid?: boolean
    created_at?: boolean
    updated_at?: boolean
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCasePenalty"]>

  export type CollectionCasePenaltySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_case_id?: boolean
    description?: boolean
    amount?: boolean
    date_applied?: boolean
    is_paid?: boolean
    created_at?: boolean
    updated_at?: boolean
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCasePenalty"]>

  export type CollectionCasePenaltySelectScalar = {
    id?: boolean
    collection_case_id?: boolean
    description?: boolean
    amount?: boolean
    date_applied?: boolean
    is_paid?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CollectionCasePenaltyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collection_case_id" | "description" | "amount" | "date_applied" | "is_paid" | "created_at" | "updated_at", ExtArgs["result"]["collectionCasePenalty"]>
  export type CollectionCasePenaltyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type CollectionCasePenaltyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type CollectionCasePenaltyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }

  export type $CollectionCasePenaltyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionCasePenalty"
    objects: {
      collection_case: Prisma.$CollectionCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collection_case_id: string
      description: string | null
      amount: Prisma.Decimal
      date_applied: Date
      is_paid: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["collectionCasePenalty"]>
    composites: {}
  }

  type CollectionCasePenaltyGetPayload<S extends boolean | null | undefined | CollectionCasePenaltyDefaultArgs> = $Result.GetResult<Prisma.$CollectionCasePenaltyPayload, S>

  type CollectionCasePenaltyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionCasePenaltyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCasePenaltyCountAggregateInputType | true
    }

  export interface CollectionCasePenaltyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionCasePenalty'], meta: { name: 'CollectionCasePenalty' } }
    /**
     * Find zero or one CollectionCasePenalty that matches the filter.
     * @param {CollectionCasePenaltyFindUniqueArgs} args - Arguments to find a CollectionCasePenalty
     * @example
     * // Get one CollectionCasePenalty
     * const collectionCasePenalty = await prisma.collectionCasePenalty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionCasePenaltyFindUniqueArgs>(args: SelectSubset<T, CollectionCasePenaltyFindUniqueArgs<ExtArgs>>): Prisma__CollectionCasePenaltyClient<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionCasePenalty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionCasePenaltyFindUniqueOrThrowArgs} args - Arguments to find a CollectionCasePenalty
     * @example
     * // Get one CollectionCasePenalty
     * const collectionCasePenalty = await prisma.collectionCasePenalty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionCasePenaltyFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionCasePenaltyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionCasePenaltyClient<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCasePenalty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePenaltyFindFirstArgs} args - Arguments to find a CollectionCasePenalty
     * @example
     * // Get one CollectionCasePenalty
     * const collectionCasePenalty = await prisma.collectionCasePenalty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionCasePenaltyFindFirstArgs>(args?: SelectSubset<T, CollectionCasePenaltyFindFirstArgs<ExtArgs>>): Prisma__CollectionCasePenaltyClient<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCasePenalty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePenaltyFindFirstOrThrowArgs} args - Arguments to find a CollectionCasePenalty
     * @example
     * // Get one CollectionCasePenalty
     * const collectionCasePenalty = await prisma.collectionCasePenalty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionCasePenaltyFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionCasePenaltyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionCasePenaltyClient<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionCasePenalties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePenaltyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionCasePenalties
     * const collectionCasePenalties = await prisma.collectionCasePenalty.findMany()
     * 
     * // Get first 10 CollectionCasePenalties
     * const collectionCasePenalties = await prisma.collectionCasePenalty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionCasePenaltyWithIdOnly = await prisma.collectionCasePenalty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionCasePenaltyFindManyArgs>(args?: SelectSubset<T, CollectionCasePenaltyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionCasePenalty.
     * @param {CollectionCasePenaltyCreateArgs} args - Arguments to create a CollectionCasePenalty.
     * @example
     * // Create one CollectionCasePenalty
     * const CollectionCasePenalty = await prisma.collectionCasePenalty.create({
     *   data: {
     *     // ... data to create a CollectionCasePenalty
     *   }
     * })
     * 
     */
    create<T extends CollectionCasePenaltyCreateArgs>(args: SelectSubset<T, CollectionCasePenaltyCreateArgs<ExtArgs>>): Prisma__CollectionCasePenaltyClient<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionCasePenalties.
     * @param {CollectionCasePenaltyCreateManyArgs} args - Arguments to create many CollectionCasePenalties.
     * @example
     * // Create many CollectionCasePenalties
     * const collectionCasePenalty = await prisma.collectionCasePenalty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCasePenaltyCreateManyArgs>(args?: SelectSubset<T, CollectionCasePenaltyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionCasePenalties and returns the data saved in the database.
     * @param {CollectionCasePenaltyCreateManyAndReturnArgs} args - Arguments to create many CollectionCasePenalties.
     * @example
     * // Create many CollectionCasePenalties
     * const collectionCasePenalty = await prisma.collectionCasePenalty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionCasePenalties and only return the `id`
     * const collectionCasePenaltyWithIdOnly = await prisma.collectionCasePenalty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCasePenaltyCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCasePenaltyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionCasePenalty.
     * @param {CollectionCasePenaltyDeleteArgs} args - Arguments to delete one CollectionCasePenalty.
     * @example
     * // Delete one CollectionCasePenalty
     * const CollectionCasePenalty = await prisma.collectionCasePenalty.delete({
     *   where: {
     *     // ... filter to delete one CollectionCasePenalty
     *   }
     * })
     * 
     */
    delete<T extends CollectionCasePenaltyDeleteArgs>(args: SelectSubset<T, CollectionCasePenaltyDeleteArgs<ExtArgs>>): Prisma__CollectionCasePenaltyClient<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionCasePenalty.
     * @param {CollectionCasePenaltyUpdateArgs} args - Arguments to update one CollectionCasePenalty.
     * @example
     * // Update one CollectionCasePenalty
     * const collectionCasePenalty = await prisma.collectionCasePenalty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionCasePenaltyUpdateArgs>(args: SelectSubset<T, CollectionCasePenaltyUpdateArgs<ExtArgs>>): Prisma__CollectionCasePenaltyClient<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionCasePenalties.
     * @param {CollectionCasePenaltyDeleteManyArgs} args - Arguments to filter CollectionCasePenalties to delete.
     * @example
     * // Delete a few CollectionCasePenalties
     * const { count } = await prisma.collectionCasePenalty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionCasePenaltyDeleteManyArgs>(args?: SelectSubset<T, CollectionCasePenaltyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCasePenalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePenaltyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionCasePenalties
     * const collectionCasePenalty = await prisma.collectionCasePenalty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionCasePenaltyUpdateManyArgs>(args: SelectSubset<T, CollectionCasePenaltyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCasePenalties and returns the data updated in the database.
     * @param {CollectionCasePenaltyUpdateManyAndReturnArgs} args - Arguments to update many CollectionCasePenalties.
     * @example
     * // Update many CollectionCasePenalties
     * const collectionCasePenalty = await prisma.collectionCasePenalty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionCasePenalties and only return the `id`
     * const collectionCasePenaltyWithIdOnly = await prisma.collectionCasePenalty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionCasePenaltyUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionCasePenaltyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionCasePenalty.
     * @param {CollectionCasePenaltyUpsertArgs} args - Arguments to update or create a CollectionCasePenalty.
     * @example
     * // Update or create a CollectionCasePenalty
     * const collectionCasePenalty = await prisma.collectionCasePenalty.upsert({
     *   create: {
     *     // ... data to create a CollectionCasePenalty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionCasePenalty we want to update
     *   }
     * })
     */
    upsert<T extends CollectionCasePenaltyUpsertArgs>(args: SelectSubset<T, CollectionCasePenaltyUpsertArgs<ExtArgs>>): Prisma__CollectionCasePenaltyClient<$Result.GetResult<Prisma.$CollectionCasePenaltyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionCasePenalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePenaltyCountArgs} args - Arguments to filter CollectionCasePenalties to count.
     * @example
     * // Count the number of CollectionCasePenalties
     * const count = await prisma.collectionCasePenalty.count({
     *   where: {
     *     // ... the filter for the CollectionCasePenalties we want to count
     *   }
     * })
    **/
    count<T extends CollectionCasePenaltyCountArgs>(
      args?: Subset<T, CollectionCasePenaltyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCasePenaltyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionCasePenalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePenaltyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionCasePenaltyAggregateArgs>(args: Subset<T, CollectionCasePenaltyAggregateArgs>): Prisma.PrismaPromise<GetCollectionCasePenaltyAggregateType<T>>

    /**
     * Group by CollectionCasePenalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePenaltyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionCasePenaltyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionCasePenaltyGroupByArgs['orderBy'] }
        : { orderBy?: CollectionCasePenaltyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionCasePenaltyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionCasePenaltyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionCasePenalty model
   */
  readonly fields: CollectionCasePenaltyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionCasePenalty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionCasePenaltyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection_case<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionCasePenalty model
   */
  interface CollectionCasePenaltyFieldRefs {
    readonly id: FieldRef<"CollectionCasePenalty", 'String'>
    readonly collection_case_id: FieldRef<"CollectionCasePenalty", 'String'>
    readonly description: FieldRef<"CollectionCasePenalty", 'String'>
    readonly amount: FieldRef<"CollectionCasePenalty", 'Decimal'>
    readonly date_applied: FieldRef<"CollectionCasePenalty", 'DateTime'>
    readonly is_paid: FieldRef<"CollectionCasePenalty", 'Boolean'>
    readonly created_at: FieldRef<"CollectionCasePenalty", 'DateTime'>
    readonly updated_at: FieldRef<"CollectionCasePenalty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionCasePenalty findUnique
   */
  export type CollectionCasePenaltyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCasePenalty to fetch.
     */
    where: CollectionCasePenaltyWhereUniqueInput
  }

  /**
   * CollectionCasePenalty findUniqueOrThrow
   */
  export type CollectionCasePenaltyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCasePenalty to fetch.
     */
    where: CollectionCasePenaltyWhereUniqueInput
  }

  /**
   * CollectionCasePenalty findFirst
   */
  export type CollectionCasePenaltyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCasePenalty to fetch.
     */
    where?: CollectionCasePenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCasePenalties to fetch.
     */
    orderBy?: CollectionCasePenaltyOrderByWithRelationInput | CollectionCasePenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCasePenalties.
     */
    cursor?: CollectionCasePenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCasePenalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCasePenalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCasePenalties.
     */
    distinct?: CollectionCasePenaltyScalarFieldEnum | CollectionCasePenaltyScalarFieldEnum[]
  }

  /**
   * CollectionCasePenalty findFirstOrThrow
   */
  export type CollectionCasePenaltyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCasePenalty to fetch.
     */
    where?: CollectionCasePenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCasePenalties to fetch.
     */
    orderBy?: CollectionCasePenaltyOrderByWithRelationInput | CollectionCasePenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCasePenalties.
     */
    cursor?: CollectionCasePenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCasePenalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCasePenalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCasePenalties.
     */
    distinct?: CollectionCasePenaltyScalarFieldEnum | CollectionCasePenaltyScalarFieldEnum[]
  }

  /**
   * CollectionCasePenalty findMany
   */
  export type CollectionCasePenaltyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCasePenalties to fetch.
     */
    where?: CollectionCasePenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCasePenalties to fetch.
     */
    orderBy?: CollectionCasePenaltyOrderByWithRelationInput | CollectionCasePenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionCasePenalties.
     */
    cursor?: CollectionCasePenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCasePenalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCasePenalties.
     */
    skip?: number
    distinct?: CollectionCasePenaltyScalarFieldEnum | CollectionCasePenaltyScalarFieldEnum[]
  }

  /**
   * CollectionCasePenalty create
   */
  export type CollectionCasePenaltyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyInclude<ExtArgs> | null
    /**
     * The data needed to create a CollectionCasePenalty.
     */
    data: XOR<CollectionCasePenaltyCreateInput, CollectionCasePenaltyUncheckedCreateInput>
  }

  /**
   * CollectionCasePenalty createMany
   */
  export type CollectionCasePenaltyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionCasePenalties.
     */
    data: CollectionCasePenaltyCreateManyInput | CollectionCasePenaltyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionCasePenalty createManyAndReturn
   */
  export type CollectionCasePenaltyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionCasePenalties.
     */
    data: CollectionCasePenaltyCreateManyInput | CollectionCasePenaltyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCasePenalty update
   */
  export type CollectionCasePenaltyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyInclude<ExtArgs> | null
    /**
     * The data needed to update a CollectionCasePenalty.
     */
    data: XOR<CollectionCasePenaltyUpdateInput, CollectionCasePenaltyUncheckedUpdateInput>
    /**
     * Choose, which CollectionCasePenalty to update.
     */
    where: CollectionCasePenaltyWhereUniqueInput
  }

  /**
   * CollectionCasePenalty updateMany
   */
  export type CollectionCasePenaltyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionCasePenalties.
     */
    data: XOR<CollectionCasePenaltyUpdateManyMutationInput, CollectionCasePenaltyUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCasePenalties to update
     */
    where?: CollectionCasePenaltyWhereInput
    /**
     * Limit how many CollectionCasePenalties to update.
     */
    limit?: number
  }

  /**
   * CollectionCasePenalty updateManyAndReturn
   */
  export type CollectionCasePenaltyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * The data used to update CollectionCasePenalties.
     */
    data: XOR<CollectionCasePenaltyUpdateManyMutationInput, CollectionCasePenaltyUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCasePenalties to update
     */
    where?: CollectionCasePenaltyWhereInput
    /**
     * Limit how many CollectionCasePenalties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCasePenalty upsert
   */
  export type CollectionCasePenaltyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyInclude<ExtArgs> | null
    /**
     * The filter to search for the CollectionCasePenalty to update in case it exists.
     */
    where: CollectionCasePenaltyWhereUniqueInput
    /**
     * In case the CollectionCasePenalty found by the `where` argument doesn't exist, create a new CollectionCasePenalty with this data.
     */
    create: XOR<CollectionCasePenaltyCreateInput, CollectionCasePenaltyUncheckedCreateInput>
    /**
     * In case the CollectionCasePenalty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionCasePenaltyUpdateInput, CollectionCasePenaltyUncheckedUpdateInput>
  }

  /**
   * CollectionCasePenalty delete
   */
  export type CollectionCasePenaltyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyInclude<ExtArgs> | null
    /**
     * Filter which CollectionCasePenalty to delete.
     */
    where: CollectionCasePenaltyWhereUniqueInput
  }

  /**
   * CollectionCasePenalty deleteMany
   */
  export type CollectionCasePenaltyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCasePenalties to delete
     */
    where?: CollectionCasePenaltyWhereInput
    /**
     * Limit how many CollectionCasePenalties to delete.
     */
    limit?: number
  }

  /**
   * CollectionCasePenalty without action
   */
  export type CollectionCasePenaltyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePenalty
     */
    select?: CollectionCasePenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePenalty
     */
    omit?: CollectionCasePenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePenaltyInclude<ExtArgs> | null
  }


  /**
   * Model CollectionCaseNotification
   */

  export type AggregateCollectionCaseNotification = {
    _count: CollectionCaseNotificationCountAggregateOutputType | null
    _min: CollectionCaseNotificationMinAggregateOutputType | null
    _max: CollectionCaseNotificationMaxAggregateOutputType | null
  }

  export type CollectionCaseNotificationMinAggregateOutputType = {
    id: string | null
    collection_case_id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    sent_at: Date | null
    read: boolean | null
    created_at: Date | null
  }

  export type CollectionCaseNotificationMaxAggregateOutputType = {
    id: string | null
    collection_case_id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    sent_at: Date | null
    read: boolean | null
    created_at: Date | null
  }

  export type CollectionCaseNotificationCountAggregateOutputType = {
    id: number
    collection_case_id: number
    type: number
    title: number
    message: number
    sent_at: number
    read: number
    created_at: number
    _all: number
  }


  export type CollectionCaseNotificationMinAggregateInputType = {
    id?: true
    collection_case_id?: true
    type?: true
    title?: true
    message?: true
    sent_at?: true
    read?: true
    created_at?: true
  }

  export type CollectionCaseNotificationMaxAggregateInputType = {
    id?: true
    collection_case_id?: true
    type?: true
    title?: true
    message?: true
    sent_at?: true
    read?: true
    created_at?: true
  }

  export type CollectionCaseNotificationCountAggregateInputType = {
    id?: true
    collection_case_id?: true
    type?: true
    title?: true
    message?: true
    sent_at?: true
    read?: true
    created_at?: true
    _all?: true
  }

  export type CollectionCaseNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCaseNotification to aggregate.
     */
    where?: CollectionCaseNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseNotifications to fetch.
     */
    orderBy?: CollectionCaseNotificationOrderByWithRelationInput | CollectionCaseNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionCaseNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionCaseNotifications
    **/
    _count?: true | CollectionCaseNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionCaseNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionCaseNotificationMaxAggregateInputType
  }

  export type GetCollectionCaseNotificationAggregateType<T extends CollectionCaseNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionCaseNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionCaseNotification[P]>
      : GetScalarType<T[P], AggregateCollectionCaseNotification[P]>
  }




  export type CollectionCaseNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseNotificationWhereInput
    orderBy?: CollectionCaseNotificationOrderByWithAggregationInput | CollectionCaseNotificationOrderByWithAggregationInput[]
    by: CollectionCaseNotificationScalarFieldEnum[] | CollectionCaseNotificationScalarFieldEnum
    having?: CollectionCaseNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCaseNotificationCountAggregateInputType | true
    _min?: CollectionCaseNotificationMinAggregateInputType
    _max?: CollectionCaseNotificationMaxAggregateInputType
  }

  export type CollectionCaseNotificationGroupByOutputType = {
    id: string
    collection_case_id: string
    type: $Enums.NotificationType
    title: string
    message: string
    sent_at: Date
    read: boolean
    created_at: Date
    _count: CollectionCaseNotificationCountAggregateOutputType | null
    _min: CollectionCaseNotificationMinAggregateOutputType | null
    _max: CollectionCaseNotificationMaxAggregateOutputType | null
  }

  type GetCollectionCaseNotificationGroupByPayload<T extends CollectionCaseNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionCaseNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionCaseNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionCaseNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionCaseNotificationGroupByOutputType[P]>
        }
      >
    >


  export type CollectionCaseNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_case_id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sent_at?: boolean
    read?: boolean
    created_at?: boolean
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCaseNotification"]>

  export type CollectionCaseNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_case_id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sent_at?: boolean
    read?: boolean
    created_at?: boolean
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCaseNotification"]>

  export type CollectionCaseNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_case_id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sent_at?: boolean
    read?: boolean
    created_at?: boolean
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCaseNotification"]>

  export type CollectionCaseNotificationSelectScalar = {
    id?: boolean
    collection_case_id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    sent_at?: boolean
    read?: boolean
    created_at?: boolean
  }

  export type CollectionCaseNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collection_case_id" | "type" | "title" | "message" | "sent_at" | "read" | "created_at", ExtArgs["result"]["collectionCaseNotification"]>
  export type CollectionCaseNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type CollectionCaseNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type CollectionCaseNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }

  export type $CollectionCaseNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionCaseNotification"
    objects: {
      collection_case: Prisma.$CollectionCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collection_case_id: string
      type: $Enums.NotificationType
      title: string
      message: string
      sent_at: Date
      read: boolean
      created_at: Date
    }, ExtArgs["result"]["collectionCaseNotification"]>
    composites: {}
  }

  type CollectionCaseNotificationGetPayload<S extends boolean | null | undefined | CollectionCaseNotificationDefaultArgs> = $Result.GetResult<Prisma.$CollectionCaseNotificationPayload, S>

  type CollectionCaseNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionCaseNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCaseNotificationCountAggregateInputType | true
    }

  export interface CollectionCaseNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionCaseNotification'], meta: { name: 'CollectionCaseNotification' } }
    /**
     * Find zero or one CollectionCaseNotification that matches the filter.
     * @param {CollectionCaseNotificationFindUniqueArgs} args - Arguments to find a CollectionCaseNotification
     * @example
     * // Get one CollectionCaseNotification
     * const collectionCaseNotification = await prisma.collectionCaseNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionCaseNotificationFindUniqueArgs>(args: SelectSubset<T, CollectionCaseNotificationFindUniqueArgs<ExtArgs>>): Prisma__CollectionCaseNotificationClient<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionCaseNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionCaseNotificationFindUniqueOrThrowArgs} args - Arguments to find a CollectionCaseNotification
     * @example
     * // Get one CollectionCaseNotification
     * const collectionCaseNotification = await prisma.collectionCaseNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionCaseNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionCaseNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseNotificationClient<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCaseNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseNotificationFindFirstArgs} args - Arguments to find a CollectionCaseNotification
     * @example
     * // Get one CollectionCaseNotification
     * const collectionCaseNotification = await prisma.collectionCaseNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionCaseNotificationFindFirstArgs>(args?: SelectSubset<T, CollectionCaseNotificationFindFirstArgs<ExtArgs>>): Prisma__CollectionCaseNotificationClient<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCaseNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseNotificationFindFirstOrThrowArgs} args - Arguments to find a CollectionCaseNotification
     * @example
     * // Get one CollectionCaseNotification
     * const collectionCaseNotification = await prisma.collectionCaseNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionCaseNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionCaseNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseNotificationClient<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionCaseNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionCaseNotifications
     * const collectionCaseNotifications = await prisma.collectionCaseNotification.findMany()
     * 
     * // Get first 10 CollectionCaseNotifications
     * const collectionCaseNotifications = await prisma.collectionCaseNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionCaseNotificationWithIdOnly = await prisma.collectionCaseNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionCaseNotificationFindManyArgs>(args?: SelectSubset<T, CollectionCaseNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionCaseNotification.
     * @param {CollectionCaseNotificationCreateArgs} args - Arguments to create a CollectionCaseNotification.
     * @example
     * // Create one CollectionCaseNotification
     * const CollectionCaseNotification = await prisma.collectionCaseNotification.create({
     *   data: {
     *     // ... data to create a CollectionCaseNotification
     *   }
     * })
     * 
     */
    create<T extends CollectionCaseNotificationCreateArgs>(args: SelectSubset<T, CollectionCaseNotificationCreateArgs<ExtArgs>>): Prisma__CollectionCaseNotificationClient<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionCaseNotifications.
     * @param {CollectionCaseNotificationCreateManyArgs} args - Arguments to create many CollectionCaseNotifications.
     * @example
     * // Create many CollectionCaseNotifications
     * const collectionCaseNotification = await prisma.collectionCaseNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCaseNotificationCreateManyArgs>(args?: SelectSubset<T, CollectionCaseNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionCaseNotifications and returns the data saved in the database.
     * @param {CollectionCaseNotificationCreateManyAndReturnArgs} args - Arguments to create many CollectionCaseNotifications.
     * @example
     * // Create many CollectionCaseNotifications
     * const collectionCaseNotification = await prisma.collectionCaseNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionCaseNotifications and only return the `id`
     * const collectionCaseNotificationWithIdOnly = await prisma.collectionCaseNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCaseNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCaseNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionCaseNotification.
     * @param {CollectionCaseNotificationDeleteArgs} args - Arguments to delete one CollectionCaseNotification.
     * @example
     * // Delete one CollectionCaseNotification
     * const CollectionCaseNotification = await prisma.collectionCaseNotification.delete({
     *   where: {
     *     // ... filter to delete one CollectionCaseNotification
     *   }
     * })
     * 
     */
    delete<T extends CollectionCaseNotificationDeleteArgs>(args: SelectSubset<T, CollectionCaseNotificationDeleteArgs<ExtArgs>>): Prisma__CollectionCaseNotificationClient<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionCaseNotification.
     * @param {CollectionCaseNotificationUpdateArgs} args - Arguments to update one CollectionCaseNotification.
     * @example
     * // Update one CollectionCaseNotification
     * const collectionCaseNotification = await prisma.collectionCaseNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionCaseNotificationUpdateArgs>(args: SelectSubset<T, CollectionCaseNotificationUpdateArgs<ExtArgs>>): Prisma__CollectionCaseNotificationClient<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionCaseNotifications.
     * @param {CollectionCaseNotificationDeleteManyArgs} args - Arguments to filter CollectionCaseNotifications to delete.
     * @example
     * // Delete a few CollectionCaseNotifications
     * const { count } = await prisma.collectionCaseNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionCaseNotificationDeleteManyArgs>(args?: SelectSubset<T, CollectionCaseNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCaseNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionCaseNotifications
     * const collectionCaseNotification = await prisma.collectionCaseNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionCaseNotificationUpdateManyArgs>(args: SelectSubset<T, CollectionCaseNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCaseNotifications and returns the data updated in the database.
     * @param {CollectionCaseNotificationUpdateManyAndReturnArgs} args - Arguments to update many CollectionCaseNotifications.
     * @example
     * // Update many CollectionCaseNotifications
     * const collectionCaseNotification = await prisma.collectionCaseNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionCaseNotifications and only return the `id`
     * const collectionCaseNotificationWithIdOnly = await prisma.collectionCaseNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionCaseNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionCaseNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionCaseNotification.
     * @param {CollectionCaseNotificationUpsertArgs} args - Arguments to update or create a CollectionCaseNotification.
     * @example
     * // Update or create a CollectionCaseNotification
     * const collectionCaseNotification = await prisma.collectionCaseNotification.upsert({
     *   create: {
     *     // ... data to create a CollectionCaseNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionCaseNotification we want to update
     *   }
     * })
     */
    upsert<T extends CollectionCaseNotificationUpsertArgs>(args: SelectSubset<T, CollectionCaseNotificationUpsertArgs<ExtArgs>>): Prisma__CollectionCaseNotificationClient<$Result.GetResult<Prisma.$CollectionCaseNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionCaseNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseNotificationCountArgs} args - Arguments to filter CollectionCaseNotifications to count.
     * @example
     * // Count the number of CollectionCaseNotifications
     * const count = await prisma.collectionCaseNotification.count({
     *   where: {
     *     // ... the filter for the CollectionCaseNotifications we want to count
     *   }
     * })
    **/
    count<T extends CollectionCaseNotificationCountArgs>(
      args?: Subset<T, CollectionCaseNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCaseNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionCaseNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionCaseNotificationAggregateArgs>(args: Subset<T, CollectionCaseNotificationAggregateArgs>): Prisma.PrismaPromise<GetCollectionCaseNotificationAggregateType<T>>

    /**
     * Group by CollectionCaseNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionCaseNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionCaseNotificationGroupByArgs['orderBy'] }
        : { orderBy?: CollectionCaseNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionCaseNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionCaseNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionCaseNotification model
   */
  readonly fields: CollectionCaseNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionCaseNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionCaseNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection_case<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionCaseNotification model
   */
  interface CollectionCaseNotificationFieldRefs {
    readonly id: FieldRef<"CollectionCaseNotification", 'String'>
    readonly collection_case_id: FieldRef<"CollectionCaseNotification", 'String'>
    readonly type: FieldRef<"CollectionCaseNotification", 'NotificationType'>
    readonly title: FieldRef<"CollectionCaseNotification", 'String'>
    readonly message: FieldRef<"CollectionCaseNotification", 'String'>
    readonly sent_at: FieldRef<"CollectionCaseNotification", 'DateTime'>
    readonly read: FieldRef<"CollectionCaseNotification", 'Boolean'>
    readonly created_at: FieldRef<"CollectionCaseNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionCaseNotification findUnique
   */
  export type CollectionCaseNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseNotification to fetch.
     */
    where: CollectionCaseNotificationWhereUniqueInput
  }

  /**
   * CollectionCaseNotification findUniqueOrThrow
   */
  export type CollectionCaseNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseNotification to fetch.
     */
    where: CollectionCaseNotificationWhereUniqueInput
  }

  /**
   * CollectionCaseNotification findFirst
   */
  export type CollectionCaseNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseNotification to fetch.
     */
    where?: CollectionCaseNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseNotifications to fetch.
     */
    orderBy?: CollectionCaseNotificationOrderByWithRelationInput | CollectionCaseNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCaseNotifications.
     */
    cursor?: CollectionCaseNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCaseNotifications.
     */
    distinct?: CollectionCaseNotificationScalarFieldEnum | CollectionCaseNotificationScalarFieldEnum[]
  }

  /**
   * CollectionCaseNotification findFirstOrThrow
   */
  export type CollectionCaseNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseNotification to fetch.
     */
    where?: CollectionCaseNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseNotifications to fetch.
     */
    orderBy?: CollectionCaseNotificationOrderByWithRelationInput | CollectionCaseNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCaseNotifications.
     */
    cursor?: CollectionCaseNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCaseNotifications.
     */
    distinct?: CollectionCaseNotificationScalarFieldEnum | CollectionCaseNotificationScalarFieldEnum[]
  }

  /**
   * CollectionCaseNotification findMany
   */
  export type CollectionCaseNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseNotifications to fetch.
     */
    where?: CollectionCaseNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseNotifications to fetch.
     */
    orderBy?: CollectionCaseNotificationOrderByWithRelationInput | CollectionCaseNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionCaseNotifications.
     */
    cursor?: CollectionCaseNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseNotifications.
     */
    skip?: number
    distinct?: CollectionCaseNotificationScalarFieldEnum | CollectionCaseNotificationScalarFieldEnum[]
  }

  /**
   * CollectionCaseNotification create
   */
  export type CollectionCaseNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a CollectionCaseNotification.
     */
    data: XOR<CollectionCaseNotificationCreateInput, CollectionCaseNotificationUncheckedCreateInput>
  }

  /**
   * CollectionCaseNotification createMany
   */
  export type CollectionCaseNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionCaseNotifications.
     */
    data: CollectionCaseNotificationCreateManyInput | CollectionCaseNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionCaseNotification createManyAndReturn
   */
  export type CollectionCaseNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionCaseNotifications.
     */
    data: CollectionCaseNotificationCreateManyInput | CollectionCaseNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCaseNotification update
   */
  export type CollectionCaseNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a CollectionCaseNotification.
     */
    data: XOR<CollectionCaseNotificationUpdateInput, CollectionCaseNotificationUncheckedUpdateInput>
    /**
     * Choose, which CollectionCaseNotification to update.
     */
    where: CollectionCaseNotificationWhereUniqueInput
  }

  /**
   * CollectionCaseNotification updateMany
   */
  export type CollectionCaseNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionCaseNotifications.
     */
    data: XOR<CollectionCaseNotificationUpdateManyMutationInput, CollectionCaseNotificationUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCaseNotifications to update
     */
    where?: CollectionCaseNotificationWhereInput
    /**
     * Limit how many CollectionCaseNotifications to update.
     */
    limit?: number
  }

  /**
   * CollectionCaseNotification updateManyAndReturn
   */
  export type CollectionCaseNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * The data used to update CollectionCaseNotifications.
     */
    data: XOR<CollectionCaseNotificationUpdateManyMutationInput, CollectionCaseNotificationUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCaseNotifications to update
     */
    where?: CollectionCaseNotificationWhereInput
    /**
     * Limit how many CollectionCaseNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCaseNotification upsert
   */
  export type CollectionCaseNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the CollectionCaseNotification to update in case it exists.
     */
    where: CollectionCaseNotificationWhereUniqueInput
    /**
     * In case the CollectionCaseNotification found by the `where` argument doesn't exist, create a new CollectionCaseNotification with this data.
     */
    create: XOR<CollectionCaseNotificationCreateInput, CollectionCaseNotificationUncheckedCreateInput>
    /**
     * In case the CollectionCaseNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionCaseNotificationUpdateInput, CollectionCaseNotificationUncheckedUpdateInput>
  }

  /**
   * CollectionCaseNotification delete
   */
  export type CollectionCaseNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationInclude<ExtArgs> | null
    /**
     * Filter which CollectionCaseNotification to delete.
     */
    where: CollectionCaseNotificationWhereUniqueInput
  }

  /**
   * CollectionCaseNotification deleteMany
   */
  export type CollectionCaseNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCaseNotifications to delete
     */
    where?: CollectionCaseNotificationWhereInput
    /**
     * Limit how many CollectionCaseNotifications to delete.
     */
    limit?: number
  }

  /**
   * CollectionCaseNotification without action
   */
  export type CollectionCaseNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseNotification
     */
    select?: CollectionCaseNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseNotification
     */
    omit?: CollectionCaseNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseNotificationInclude<ExtArgs> | null
  }


  /**
   * Model CollectionCasePayment
   */

  export type AggregateCollectionCasePayment = {
    _count: CollectionCasePaymentCountAggregateOutputType | null
    _avg: CollectionCasePaymentAvgAggregateOutputType | null
    _sum: CollectionCasePaymentSumAggregateOutputType | null
    _min: CollectionCasePaymentMinAggregateOutputType | null
    _max: CollectionCasePaymentMaxAggregateOutputType | null
  }

  export type CollectionCasePaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type CollectionCasePaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type CollectionCasePaymentMinAggregateOutputType = {
    id: string | null
    method: $Enums.PaymentMethod | null
    amount: Decimal | null
    collection_case_id: string | null
    payment_date: Date | null
    reference_number: string | null
    agreement_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CollectionCasePaymentMaxAggregateOutputType = {
    id: string | null
    method: $Enums.PaymentMethod | null
    amount: Decimal | null
    collection_case_id: string | null
    payment_date: Date | null
    reference_number: string | null
    agreement_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CollectionCasePaymentCountAggregateOutputType = {
    id: number
    method: number
    amount: number
    collection_case_id: number
    payment_date: number
    reference_number: number
    agreement_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CollectionCasePaymentAvgAggregateInputType = {
    amount?: true
  }

  export type CollectionCasePaymentSumAggregateInputType = {
    amount?: true
  }

  export type CollectionCasePaymentMinAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    collection_case_id?: true
    payment_date?: true
    reference_number?: true
    agreement_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CollectionCasePaymentMaxAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    collection_case_id?: true
    payment_date?: true
    reference_number?: true
    agreement_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CollectionCasePaymentCountAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    collection_case_id?: true
    payment_date?: true
    reference_number?: true
    agreement_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CollectionCasePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCasePayment to aggregate.
     */
    where?: CollectionCasePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCasePayments to fetch.
     */
    orderBy?: CollectionCasePaymentOrderByWithRelationInput | CollectionCasePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionCasePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCasePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCasePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionCasePayments
    **/
    _count?: true | CollectionCasePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionCasePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionCasePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionCasePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionCasePaymentMaxAggregateInputType
  }

  export type GetCollectionCasePaymentAggregateType<T extends CollectionCasePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionCasePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionCasePayment[P]>
      : GetScalarType<T[P], AggregateCollectionCasePayment[P]>
  }




  export type CollectionCasePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCasePaymentWhereInput
    orderBy?: CollectionCasePaymentOrderByWithAggregationInput | CollectionCasePaymentOrderByWithAggregationInput[]
    by: CollectionCasePaymentScalarFieldEnum[] | CollectionCasePaymentScalarFieldEnum
    having?: CollectionCasePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCasePaymentCountAggregateInputType | true
    _avg?: CollectionCasePaymentAvgAggregateInputType
    _sum?: CollectionCasePaymentSumAggregateInputType
    _min?: CollectionCasePaymentMinAggregateInputType
    _max?: CollectionCasePaymentMaxAggregateInputType
  }

  export type CollectionCasePaymentGroupByOutputType = {
    id: string
    method: $Enums.PaymentMethod
    amount: Decimal
    collection_case_id: string
    payment_date: Date
    reference_number: string | null
    agreement_id: string | null
    created_at: Date
    updated_at: Date
    _count: CollectionCasePaymentCountAggregateOutputType | null
    _avg: CollectionCasePaymentAvgAggregateOutputType | null
    _sum: CollectionCasePaymentSumAggregateOutputType | null
    _min: CollectionCasePaymentMinAggregateOutputType | null
    _max: CollectionCasePaymentMaxAggregateOutputType | null
  }

  type GetCollectionCasePaymentGroupByPayload<T extends CollectionCasePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionCasePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionCasePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionCasePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionCasePaymentGroupByOutputType[P]>
        }
      >
    >


  export type CollectionCasePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    collection_case_id?: boolean
    payment_date?: boolean
    reference_number?: boolean
    agreement_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    agreement?: boolean | CollectionCasePayment$agreementArgs<ExtArgs>
    installments?: boolean | CollectionCasePayment$installmentsArgs<ExtArgs>
    _count?: boolean | CollectionCasePaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCasePayment"]>

  export type CollectionCasePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    collection_case_id?: boolean
    payment_date?: boolean
    reference_number?: boolean
    agreement_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    agreement?: boolean | CollectionCasePayment$agreementArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCasePayment"]>

  export type CollectionCasePaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    collection_case_id?: boolean
    payment_date?: boolean
    reference_number?: boolean
    agreement_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    agreement?: boolean | CollectionCasePayment$agreementArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCasePayment"]>

  export type CollectionCasePaymentSelectScalar = {
    id?: boolean
    method?: boolean
    amount?: boolean
    collection_case_id?: boolean
    payment_date?: boolean
    reference_number?: boolean
    agreement_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CollectionCasePaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "method" | "amount" | "collection_case_id" | "payment_date" | "reference_number" | "agreement_id" | "created_at" | "updated_at", ExtArgs["result"]["collectionCasePayment"]>
  export type CollectionCasePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    agreement?: boolean | CollectionCasePayment$agreementArgs<ExtArgs>
    installments?: boolean | CollectionCasePayment$installmentsArgs<ExtArgs>
    _count?: boolean | CollectionCasePaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollectionCasePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    agreement?: boolean | CollectionCasePayment$agreementArgs<ExtArgs>
  }
  export type CollectionCasePaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    agreement?: boolean | CollectionCasePayment$agreementArgs<ExtArgs>
  }

  export type $CollectionCasePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionCasePayment"
    objects: {
      collection_case: Prisma.$CollectionCasePayload<ExtArgs>
      agreement: Prisma.$CollectionCaseAgreementPayload<ExtArgs> | null
      installments: Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      method: $Enums.PaymentMethod
      amount: Prisma.Decimal
      collection_case_id: string
      payment_date: Date
      reference_number: string | null
      agreement_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["collectionCasePayment"]>
    composites: {}
  }

  type CollectionCasePaymentGetPayload<S extends boolean | null | undefined | CollectionCasePaymentDefaultArgs> = $Result.GetResult<Prisma.$CollectionCasePaymentPayload, S>

  type CollectionCasePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionCasePaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCasePaymentCountAggregateInputType | true
    }

  export interface CollectionCasePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionCasePayment'], meta: { name: 'CollectionCasePayment' } }
    /**
     * Find zero or one CollectionCasePayment that matches the filter.
     * @param {CollectionCasePaymentFindUniqueArgs} args - Arguments to find a CollectionCasePayment
     * @example
     * // Get one CollectionCasePayment
     * const collectionCasePayment = await prisma.collectionCasePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionCasePaymentFindUniqueArgs>(args: SelectSubset<T, CollectionCasePaymentFindUniqueArgs<ExtArgs>>): Prisma__CollectionCasePaymentClient<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionCasePayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionCasePaymentFindUniqueOrThrowArgs} args - Arguments to find a CollectionCasePayment
     * @example
     * // Get one CollectionCasePayment
     * const collectionCasePayment = await prisma.collectionCasePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionCasePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionCasePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionCasePaymentClient<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCasePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePaymentFindFirstArgs} args - Arguments to find a CollectionCasePayment
     * @example
     * // Get one CollectionCasePayment
     * const collectionCasePayment = await prisma.collectionCasePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionCasePaymentFindFirstArgs>(args?: SelectSubset<T, CollectionCasePaymentFindFirstArgs<ExtArgs>>): Prisma__CollectionCasePaymentClient<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCasePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePaymentFindFirstOrThrowArgs} args - Arguments to find a CollectionCasePayment
     * @example
     * // Get one CollectionCasePayment
     * const collectionCasePayment = await prisma.collectionCasePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionCasePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionCasePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionCasePaymentClient<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionCasePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionCasePayments
     * const collectionCasePayments = await prisma.collectionCasePayment.findMany()
     * 
     * // Get first 10 CollectionCasePayments
     * const collectionCasePayments = await prisma.collectionCasePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionCasePaymentWithIdOnly = await prisma.collectionCasePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionCasePaymentFindManyArgs>(args?: SelectSubset<T, CollectionCasePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionCasePayment.
     * @param {CollectionCasePaymentCreateArgs} args - Arguments to create a CollectionCasePayment.
     * @example
     * // Create one CollectionCasePayment
     * const CollectionCasePayment = await prisma.collectionCasePayment.create({
     *   data: {
     *     // ... data to create a CollectionCasePayment
     *   }
     * })
     * 
     */
    create<T extends CollectionCasePaymentCreateArgs>(args: SelectSubset<T, CollectionCasePaymentCreateArgs<ExtArgs>>): Prisma__CollectionCasePaymentClient<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionCasePayments.
     * @param {CollectionCasePaymentCreateManyArgs} args - Arguments to create many CollectionCasePayments.
     * @example
     * // Create many CollectionCasePayments
     * const collectionCasePayment = await prisma.collectionCasePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCasePaymentCreateManyArgs>(args?: SelectSubset<T, CollectionCasePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionCasePayments and returns the data saved in the database.
     * @param {CollectionCasePaymentCreateManyAndReturnArgs} args - Arguments to create many CollectionCasePayments.
     * @example
     * // Create many CollectionCasePayments
     * const collectionCasePayment = await prisma.collectionCasePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionCasePayments and only return the `id`
     * const collectionCasePaymentWithIdOnly = await prisma.collectionCasePayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCasePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCasePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionCasePayment.
     * @param {CollectionCasePaymentDeleteArgs} args - Arguments to delete one CollectionCasePayment.
     * @example
     * // Delete one CollectionCasePayment
     * const CollectionCasePayment = await prisma.collectionCasePayment.delete({
     *   where: {
     *     // ... filter to delete one CollectionCasePayment
     *   }
     * })
     * 
     */
    delete<T extends CollectionCasePaymentDeleteArgs>(args: SelectSubset<T, CollectionCasePaymentDeleteArgs<ExtArgs>>): Prisma__CollectionCasePaymentClient<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionCasePayment.
     * @param {CollectionCasePaymentUpdateArgs} args - Arguments to update one CollectionCasePayment.
     * @example
     * // Update one CollectionCasePayment
     * const collectionCasePayment = await prisma.collectionCasePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionCasePaymentUpdateArgs>(args: SelectSubset<T, CollectionCasePaymentUpdateArgs<ExtArgs>>): Prisma__CollectionCasePaymentClient<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionCasePayments.
     * @param {CollectionCasePaymentDeleteManyArgs} args - Arguments to filter CollectionCasePayments to delete.
     * @example
     * // Delete a few CollectionCasePayments
     * const { count } = await prisma.collectionCasePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionCasePaymentDeleteManyArgs>(args?: SelectSubset<T, CollectionCasePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCasePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionCasePayments
     * const collectionCasePayment = await prisma.collectionCasePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionCasePaymentUpdateManyArgs>(args: SelectSubset<T, CollectionCasePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCasePayments and returns the data updated in the database.
     * @param {CollectionCasePaymentUpdateManyAndReturnArgs} args - Arguments to update many CollectionCasePayments.
     * @example
     * // Update many CollectionCasePayments
     * const collectionCasePayment = await prisma.collectionCasePayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionCasePayments and only return the `id`
     * const collectionCasePaymentWithIdOnly = await prisma.collectionCasePayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionCasePaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionCasePaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionCasePayment.
     * @param {CollectionCasePaymentUpsertArgs} args - Arguments to update or create a CollectionCasePayment.
     * @example
     * // Update or create a CollectionCasePayment
     * const collectionCasePayment = await prisma.collectionCasePayment.upsert({
     *   create: {
     *     // ... data to create a CollectionCasePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionCasePayment we want to update
     *   }
     * })
     */
    upsert<T extends CollectionCasePaymentUpsertArgs>(args: SelectSubset<T, CollectionCasePaymentUpsertArgs<ExtArgs>>): Prisma__CollectionCasePaymentClient<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionCasePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePaymentCountArgs} args - Arguments to filter CollectionCasePayments to count.
     * @example
     * // Count the number of CollectionCasePayments
     * const count = await prisma.collectionCasePayment.count({
     *   where: {
     *     // ... the filter for the CollectionCasePayments we want to count
     *   }
     * })
    **/
    count<T extends CollectionCasePaymentCountArgs>(
      args?: Subset<T, CollectionCasePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCasePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionCasePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionCasePaymentAggregateArgs>(args: Subset<T, CollectionCasePaymentAggregateArgs>): Prisma.PrismaPromise<GetCollectionCasePaymentAggregateType<T>>

    /**
     * Group by CollectionCasePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCasePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionCasePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionCasePaymentGroupByArgs['orderBy'] }
        : { orderBy?: CollectionCasePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionCasePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionCasePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionCasePayment model
   */
  readonly fields: CollectionCasePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionCasePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionCasePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection_case<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agreement<T extends CollectionCasePayment$agreementArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCasePayment$agreementArgs<ExtArgs>>): Prisma__CollectionCaseAgreementClient<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    installments<T extends CollectionCasePayment$installmentsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCasePayment$installmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionCasePayment model
   */
  interface CollectionCasePaymentFieldRefs {
    readonly id: FieldRef<"CollectionCasePayment", 'String'>
    readonly method: FieldRef<"CollectionCasePayment", 'PaymentMethod'>
    readonly amount: FieldRef<"CollectionCasePayment", 'Decimal'>
    readonly collection_case_id: FieldRef<"CollectionCasePayment", 'String'>
    readonly payment_date: FieldRef<"CollectionCasePayment", 'DateTime'>
    readonly reference_number: FieldRef<"CollectionCasePayment", 'String'>
    readonly agreement_id: FieldRef<"CollectionCasePayment", 'String'>
    readonly created_at: FieldRef<"CollectionCasePayment", 'DateTime'>
    readonly updated_at: FieldRef<"CollectionCasePayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionCasePayment findUnique
   */
  export type CollectionCasePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCasePayment to fetch.
     */
    where: CollectionCasePaymentWhereUniqueInput
  }

  /**
   * CollectionCasePayment findUniqueOrThrow
   */
  export type CollectionCasePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCasePayment to fetch.
     */
    where: CollectionCasePaymentWhereUniqueInput
  }

  /**
   * CollectionCasePayment findFirst
   */
  export type CollectionCasePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCasePayment to fetch.
     */
    where?: CollectionCasePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCasePayments to fetch.
     */
    orderBy?: CollectionCasePaymentOrderByWithRelationInput | CollectionCasePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCasePayments.
     */
    cursor?: CollectionCasePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCasePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCasePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCasePayments.
     */
    distinct?: CollectionCasePaymentScalarFieldEnum | CollectionCasePaymentScalarFieldEnum[]
  }

  /**
   * CollectionCasePayment findFirstOrThrow
   */
  export type CollectionCasePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCasePayment to fetch.
     */
    where?: CollectionCasePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCasePayments to fetch.
     */
    orderBy?: CollectionCasePaymentOrderByWithRelationInput | CollectionCasePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCasePayments.
     */
    cursor?: CollectionCasePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCasePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCasePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCasePayments.
     */
    distinct?: CollectionCasePaymentScalarFieldEnum | CollectionCasePaymentScalarFieldEnum[]
  }

  /**
   * CollectionCasePayment findMany
   */
  export type CollectionCasePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCasePayments to fetch.
     */
    where?: CollectionCasePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCasePayments to fetch.
     */
    orderBy?: CollectionCasePaymentOrderByWithRelationInput | CollectionCasePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionCasePayments.
     */
    cursor?: CollectionCasePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCasePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCasePayments.
     */
    skip?: number
    distinct?: CollectionCasePaymentScalarFieldEnum | CollectionCasePaymentScalarFieldEnum[]
  }

  /**
   * CollectionCasePayment create
   */
  export type CollectionCasePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a CollectionCasePayment.
     */
    data: XOR<CollectionCasePaymentCreateInput, CollectionCasePaymentUncheckedCreateInput>
  }

  /**
   * CollectionCasePayment createMany
   */
  export type CollectionCasePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionCasePayments.
     */
    data: CollectionCasePaymentCreateManyInput | CollectionCasePaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionCasePayment createManyAndReturn
   */
  export type CollectionCasePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionCasePayments.
     */
    data: CollectionCasePaymentCreateManyInput | CollectionCasePaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCasePayment update
   */
  export type CollectionCasePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a CollectionCasePayment.
     */
    data: XOR<CollectionCasePaymentUpdateInput, CollectionCasePaymentUncheckedUpdateInput>
    /**
     * Choose, which CollectionCasePayment to update.
     */
    where: CollectionCasePaymentWhereUniqueInput
  }

  /**
   * CollectionCasePayment updateMany
   */
  export type CollectionCasePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionCasePayments.
     */
    data: XOR<CollectionCasePaymentUpdateManyMutationInput, CollectionCasePaymentUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCasePayments to update
     */
    where?: CollectionCasePaymentWhereInput
    /**
     * Limit how many CollectionCasePayments to update.
     */
    limit?: number
  }

  /**
   * CollectionCasePayment updateManyAndReturn
   */
  export type CollectionCasePaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * The data used to update CollectionCasePayments.
     */
    data: XOR<CollectionCasePaymentUpdateManyMutationInput, CollectionCasePaymentUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCasePayments to update
     */
    where?: CollectionCasePaymentWhereInput
    /**
     * Limit how many CollectionCasePayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCasePayment upsert
   */
  export type CollectionCasePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the CollectionCasePayment to update in case it exists.
     */
    where: CollectionCasePaymentWhereUniqueInput
    /**
     * In case the CollectionCasePayment found by the `where` argument doesn't exist, create a new CollectionCasePayment with this data.
     */
    create: XOR<CollectionCasePaymentCreateInput, CollectionCasePaymentUncheckedCreateInput>
    /**
     * In case the CollectionCasePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionCasePaymentUpdateInput, CollectionCasePaymentUncheckedUpdateInput>
  }

  /**
   * CollectionCasePayment delete
   */
  export type CollectionCasePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    /**
     * Filter which CollectionCasePayment to delete.
     */
    where: CollectionCasePaymentWhereUniqueInput
  }

  /**
   * CollectionCasePayment deleteMany
   */
  export type CollectionCasePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCasePayments to delete
     */
    where?: CollectionCasePaymentWhereInput
    /**
     * Limit how many CollectionCasePayments to delete.
     */
    limit?: number
  }

  /**
   * CollectionCasePayment.agreement
   */
  export type CollectionCasePayment$agreementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    where?: CollectionCaseAgreementWhereInput
  }

  /**
   * CollectionCasePayment.installments
   */
  export type CollectionCasePayment$installmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
    where?: CollectionCaseAgreementInstallmentWhereInput
    orderBy?: CollectionCaseAgreementInstallmentOrderByWithRelationInput | CollectionCaseAgreementInstallmentOrderByWithRelationInput[]
    cursor?: CollectionCaseAgreementInstallmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseAgreementInstallmentScalarFieldEnum | CollectionCaseAgreementInstallmentScalarFieldEnum[]
  }

  /**
   * CollectionCasePayment without action
   */
  export type CollectionCasePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
  }


  /**
   * Model Debtor
   */

  export type AggregateDebtor = {
    _count: DebtorCountAggregateOutputType | null
    _avg: DebtorAvgAggregateOutputType | null
    _sum: DebtorSumAggregateOutputType | null
    _min: DebtorMinAggregateOutputType | null
    _max: DebtorMaxAggregateOutputType | null
  }

  export type DebtorAvgAggregateOutputType = {
    total_income: number | null
  }

  export type DebtorSumAggregateOutputType = {
    total_income: number | null
  }

  export type DebtorMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    user_id: string | null
    fullname: string | null
    email: string | null
    phone: string | null
    address: string | null
    person_type: $Enums.PersonType | null
    identification_type: $Enums.IdentificationType | null
    identification: string | null
    total_income: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DebtorMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    user_id: string | null
    fullname: string | null
    email: string | null
    phone: string | null
    address: string | null
    person_type: $Enums.PersonType | null
    identification_type: $Enums.IdentificationType | null
    identification: string | null
    total_income: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DebtorCountAggregateOutputType = {
    id: number
    tenant_id: number
    user_id: number
    fullname: number
    email: number
    phone: number
    address: number
    person_type: number
    identification_type: number
    identification: number
    total_income: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DebtorAvgAggregateInputType = {
    total_income?: true
  }

  export type DebtorSumAggregateInputType = {
    total_income?: true
  }

  export type DebtorMinAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    fullname?: true
    email?: true
    phone?: true
    address?: true
    person_type?: true
    identification_type?: true
    identification?: true
    total_income?: true
    created_at?: true
    updated_at?: true
  }

  export type DebtorMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    fullname?: true
    email?: true
    phone?: true
    address?: true
    person_type?: true
    identification_type?: true
    identification?: true
    total_income?: true
    created_at?: true
    updated_at?: true
  }

  export type DebtorCountAggregateInputType = {
    id?: true
    tenant_id?: true
    user_id?: true
    fullname?: true
    email?: true
    phone?: true
    address?: true
    person_type?: true
    identification_type?: true
    identification?: true
    total_income?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DebtorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debtor to aggregate.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Debtors
    **/
    _count?: true | DebtorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtorMaxAggregateInputType
  }

  export type GetDebtorAggregateType<T extends DebtorAggregateArgs> = {
        [P in keyof T & keyof AggregateDebtor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebtor[P]>
      : GetScalarType<T[P], AggregateDebtor[P]>
  }




  export type DebtorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorWhereInput
    orderBy?: DebtorOrderByWithAggregationInput | DebtorOrderByWithAggregationInput[]
    by: DebtorScalarFieldEnum[] | DebtorScalarFieldEnum
    having?: DebtorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtorCountAggregateInputType | true
    _avg?: DebtorAvgAggregateInputType
    _sum?: DebtorSumAggregateInputType
    _min?: DebtorMinAggregateInputType
    _max?: DebtorMaxAggregateInputType
  }

  export type DebtorGroupByOutputType = {
    id: string
    tenant_id: string
    user_id: string | null
    fullname: string
    email: string
    phone: string | null
    address: string | null
    person_type: $Enums.PersonType
    identification_type: $Enums.IdentificationType | null
    identification: string | null
    total_income: number | null
    created_at: Date
    updated_at: Date
    _count: DebtorCountAggregateOutputType | null
    _avg: DebtorAvgAggregateOutputType | null
    _sum: DebtorSumAggregateOutputType | null
    _min: DebtorMinAggregateOutputType | null
    _max: DebtorMaxAggregateOutputType | null
  }

  type GetDebtorGroupByPayload<T extends DebtorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtorGroupByOutputType[P]>
            : GetScalarType<T[P], DebtorGroupByOutputType[P]>
        }
      >
    >


  export type DebtorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    person_type?: boolean
    identification_type?: boolean
    identification?: boolean
    total_income?: boolean
    created_at?: boolean
    updated_at?: boolean
    collection_cases?: boolean | Debtor$collection_casesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
    incomes?: boolean | Debtor$incomesArgs<ExtArgs>
    payment_agreements?: boolean | Debtor$payment_agreementsArgs<ExtArgs>
    verdicts?: boolean | Debtor$verdictsArgs<ExtArgs>
    _count?: boolean | DebtorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtor"]>

  export type DebtorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    person_type?: boolean
    identification_type?: boolean
    identification?: boolean
    total_income?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }, ExtArgs["result"]["debtor"]>

  export type DebtorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    person_type?: boolean
    identification_type?: boolean
    identification?: boolean
    total_income?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }, ExtArgs["result"]["debtor"]>

  export type DebtorSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    user_id?: boolean
    fullname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    person_type?: boolean
    identification_type?: boolean
    identification?: boolean
    total_income?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type DebtorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "user_id" | "fullname" | "email" | "phone" | "address" | "person_type" | "identification_type" | "identification" | "total_income" | "created_at" | "updated_at", ExtArgs["result"]["debtor"]>
  export type DebtorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection_cases?: boolean | Debtor$collection_casesArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
    incomes?: boolean | Debtor$incomesArgs<ExtArgs>
    payment_agreements?: boolean | Debtor$payment_agreementsArgs<ExtArgs>
    verdicts?: boolean | Debtor$verdictsArgs<ExtArgs>
    _count?: boolean | DebtorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DebtorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }
  export type DebtorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | Debtor$userArgs<ExtArgs>
  }

  export type $DebtorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Debtor"
    objects: {
      collection_cases: Prisma.$CollectionCasePayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      incomes: Prisma.$DebtorIncomePayload<ExtArgs>[]
      payment_agreements: Prisma.$CollectionCaseAgreementPayload<ExtArgs>[]
      verdicts: Prisma.$VerdictPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      user_id: string | null
      fullname: string
      email: string
      phone: string | null
      address: string | null
      person_type: $Enums.PersonType
      identification_type: $Enums.IdentificationType | null
      identification: string | null
      total_income: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["debtor"]>
    composites: {}
  }

  type DebtorGetPayload<S extends boolean | null | undefined | DebtorDefaultArgs> = $Result.GetResult<Prisma.$DebtorPayload, S>

  type DebtorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DebtorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DebtorCountAggregateInputType | true
    }

  export interface DebtorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Debtor'], meta: { name: 'Debtor' } }
    /**
     * Find zero or one Debtor that matches the filter.
     * @param {DebtorFindUniqueArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtorFindUniqueArgs>(args: SelectSubset<T, DebtorFindUniqueArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Debtor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DebtorFindUniqueOrThrowArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtorFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debtor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorFindFirstArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtorFindFirstArgs>(args?: SelectSubset<T, DebtorFindFirstArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Debtor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorFindFirstOrThrowArgs} args - Arguments to find a Debtor
     * @example
     * // Get one Debtor
     * const debtor = await prisma.debtor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtorFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Debtors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Debtors
     * const debtors = await prisma.debtor.findMany()
     * 
     * // Get first 10 Debtors
     * const debtors = await prisma.debtor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtorWithIdOnly = await prisma.debtor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtorFindManyArgs>(args?: SelectSubset<T, DebtorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Debtor.
     * @param {DebtorCreateArgs} args - Arguments to create a Debtor.
     * @example
     * // Create one Debtor
     * const Debtor = await prisma.debtor.create({
     *   data: {
     *     // ... data to create a Debtor
     *   }
     * })
     * 
     */
    create<T extends DebtorCreateArgs>(args: SelectSubset<T, DebtorCreateArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Debtors.
     * @param {DebtorCreateManyArgs} args - Arguments to create many Debtors.
     * @example
     * // Create many Debtors
     * const debtor = await prisma.debtor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtorCreateManyArgs>(args?: SelectSubset<T, DebtorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Debtors and returns the data saved in the database.
     * @param {DebtorCreateManyAndReturnArgs} args - Arguments to create many Debtors.
     * @example
     * // Create many Debtors
     * const debtor = await prisma.debtor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Debtors and only return the `id`
     * const debtorWithIdOnly = await prisma.debtor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DebtorCreateManyAndReturnArgs>(args?: SelectSubset<T, DebtorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Debtor.
     * @param {DebtorDeleteArgs} args - Arguments to delete one Debtor.
     * @example
     * // Delete one Debtor
     * const Debtor = await prisma.debtor.delete({
     *   where: {
     *     // ... filter to delete one Debtor
     *   }
     * })
     * 
     */
    delete<T extends DebtorDeleteArgs>(args: SelectSubset<T, DebtorDeleteArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Debtor.
     * @param {DebtorUpdateArgs} args - Arguments to update one Debtor.
     * @example
     * // Update one Debtor
     * const debtor = await prisma.debtor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtorUpdateArgs>(args: SelectSubset<T, DebtorUpdateArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Debtors.
     * @param {DebtorDeleteManyArgs} args - Arguments to filter Debtors to delete.
     * @example
     * // Delete a few Debtors
     * const { count } = await prisma.debtor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtorDeleteManyArgs>(args?: SelectSubset<T, DebtorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debtors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Debtors
     * const debtor = await prisma.debtor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtorUpdateManyArgs>(args: SelectSubset<T, DebtorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debtors and returns the data updated in the database.
     * @param {DebtorUpdateManyAndReturnArgs} args - Arguments to update many Debtors.
     * @example
     * // Update many Debtors
     * const debtor = await prisma.debtor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Debtors and only return the `id`
     * const debtorWithIdOnly = await prisma.debtor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DebtorUpdateManyAndReturnArgs>(args: SelectSubset<T, DebtorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Debtor.
     * @param {DebtorUpsertArgs} args - Arguments to update or create a Debtor.
     * @example
     * // Update or create a Debtor
     * const debtor = await prisma.debtor.upsert({
     *   create: {
     *     // ... data to create a Debtor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Debtor we want to update
     *   }
     * })
     */
    upsert<T extends DebtorUpsertArgs>(args: SelectSubset<T, DebtorUpsertArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Debtors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorCountArgs} args - Arguments to filter Debtors to count.
     * @example
     * // Count the number of Debtors
     * const count = await prisma.debtor.count({
     *   where: {
     *     // ... the filter for the Debtors we want to count
     *   }
     * })
    **/
    count<T extends DebtorCountArgs>(
      args?: Subset<T, DebtorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Debtor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtorAggregateArgs>(args: Subset<T, DebtorAggregateArgs>): Prisma.PrismaPromise<GetDebtorAggregateType<T>>

    /**
     * Group by Debtor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtorGroupByArgs['orderBy'] }
        : { orderBy?: DebtorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Debtor model
   */
  readonly fields: DebtorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Debtor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection_cases<T extends Debtor$collection_casesArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$collection_casesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Debtor$userArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    incomes<T extends Debtor$incomesArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$incomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment_agreements<T extends Debtor$payment_agreementsArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$payment_agreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verdicts<T extends Debtor$verdictsArgs<ExtArgs> = {}>(args?: Subset<T, Debtor$verdictsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerdictPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Debtor model
   */
  interface DebtorFieldRefs {
    readonly id: FieldRef<"Debtor", 'String'>
    readonly tenant_id: FieldRef<"Debtor", 'String'>
    readonly user_id: FieldRef<"Debtor", 'String'>
    readonly fullname: FieldRef<"Debtor", 'String'>
    readonly email: FieldRef<"Debtor", 'String'>
    readonly phone: FieldRef<"Debtor", 'String'>
    readonly address: FieldRef<"Debtor", 'String'>
    readonly person_type: FieldRef<"Debtor", 'PersonType'>
    readonly identification_type: FieldRef<"Debtor", 'IdentificationType'>
    readonly identification: FieldRef<"Debtor", 'String'>
    readonly total_income: FieldRef<"Debtor", 'Float'>
    readonly created_at: FieldRef<"Debtor", 'DateTime'>
    readonly updated_at: FieldRef<"Debtor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Debtor findUnique
   */
  export type DebtorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor findUniqueOrThrow
   */
  export type DebtorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor findFirst
   */
  export type DebtorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debtors.
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debtors.
     */
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Debtor findFirstOrThrow
   */
  export type DebtorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtor to fetch.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Debtors.
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Debtors.
     */
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Debtor findMany
   */
  export type DebtorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter, which Debtors to fetch.
     */
    where?: DebtorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Debtors to fetch.
     */
    orderBy?: DebtorOrderByWithRelationInput | DebtorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Debtors.
     */
    cursor?: DebtorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Debtors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Debtors.
     */
    skip?: number
    distinct?: DebtorScalarFieldEnum | DebtorScalarFieldEnum[]
  }

  /**
   * Debtor create
   */
  export type DebtorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * The data needed to create a Debtor.
     */
    data: XOR<DebtorCreateInput, DebtorUncheckedCreateInput>
  }

  /**
   * Debtor createMany
   */
  export type DebtorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Debtors.
     */
    data: DebtorCreateManyInput | DebtorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Debtor createManyAndReturn
   */
  export type DebtorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * The data used to create many Debtors.
     */
    data: DebtorCreateManyInput | DebtorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Debtor update
   */
  export type DebtorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * The data needed to update a Debtor.
     */
    data: XOR<DebtorUpdateInput, DebtorUncheckedUpdateInput>
    /**
     * Choose, which Debtor to update.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor updateMany
   */
  export type DebtorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Debtors.
     */
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyInput>
    /**
     * Filter which Debtors to update
     */
    where?: DebtorWhereInput
    /**
     * Limit how many Debtors to update.
     */
    limit?: number
  }

  /**
   * Debtor updateManyAndReturn
   */
  export type DebtorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * The data used to update Debtors.
     */
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyInput>
    /**
     * Filter which Debtors to update
     */
    where?: DebtorWhereInput
    /**
     * Limit how many Debtors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Debtor upsert
   */
  export type DebtorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * The filter to search for the Debtor to update in case it exists.
     */
    where: DebtorWhereUniqueInput
    /**
     * In case the Debtor found by the `where` argument doesn't exist, create a new Debtor with this data.
     */
    create: XOR<DebtorCreateInput, DebtorUncheckedCreateInput>
    /**
     * In case the Debtor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtorUpdateInput, DebtorUncheckedUpdateInput>
  }

  /**
   * Debtor delete
   */
  export type DebtorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    /**
     * Filter which Debtor to delete.
     */
    where: DebtorWhereUniqueInput
  }

  /**
   * Debtor deleteMany
   */
  export type DebtorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Debtors to delete
     */
    where?: DebtorWhereInput
    /**
     * Limit how many Debtors to delete.
     */
    limit?: number
  }

  /**
   * Debtor.collection_cases
   */
  export type Debtor$collection_casesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCase
     */
    select?: CollectionCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCase
     */
    omit?: CollectionCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseInclude<ExtArgs> | null
    where?: CollectionCaseWhereInput
    orderBy?: CollectionCaseOrderByWithRelationInput | CollectionCaseOrderByWithRelationInput[]
    cursor?: CollectionCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseScalarFieldEnum | CollectionCaseScalarFieldEnum[]
  }

  /**
   * Debtor.user
   */
  export type Debtor$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Debtor.incomes
   */
  export type Debtor$incomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    where?: DebtorIncomeWhereInput
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    cursor?: DebtorIncomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * Debtor.payment_agreements
   */
  export type Debtor$payment_agreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    where?: CollectionCaseAgreementWhereInput
    orderBy?: CollectionCaseAgreementOrderByWithRelationInput | CollectionCaseAgreementOrderByWithRelationInput[]
    cursor?: CollectionCaseAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseAgreementScalarFieldEnum | CollectionCaseAgreementScalarFieldEnum[]
  }

  /**
   * Debtor.verdicts
   */
  export type Debtor$verdictsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verdict
     */
    select?: VerdictSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verdict
     */
    omit?: VerdictOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerdictInclude<ExtArgs> | null
    where?: VerdictWhereInput
    orderBy?: VerdictOrderByWithRelationInput | VerdictOrderByWithRelationInput[]
    cursor?: VerdictWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerdictScalarFieldEnum | VerdictScalarFieldEnum[]
  }

  /**
   * Debtor without action
   */
  export type DebtorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
  }


  /**
   * Model ChatRoom
   */

  export type AggregateChatRoom = {
    _count: ChatRoomCountAggregateOutputType | null
    _min: ChatRoomMinAggregateOutputType | null
    _max: ChatRoomMaxAggregateOutputType | null
  }

  export type ChatRoomMinAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    collection_case_id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChatRoomMaxAggregateOutputType = {
    id: string | null
    tenant_id: string | null
    collection_case_id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChatRoomCountAggregateOutputType = {
    id: number
    tenant_id: number
    collection_case_id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChatRoomMinAggregateInputType = {
    id?: true
    tenant_id?: true
    collection_case_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ChatRoomMaxAggregateInputType = {
    id?: true
    tenant_id?: true
    collection_case_id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type ChatRoomCountAggregateInputType = {
    id?: true
    tenant_id?: true
    collection_case_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChatRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatRoom to aggregate.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatRooms
    **/
    _count?: true | ChatRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatRoomMaxAggregateInputType
  }

  export type GetChatRoomAggregateType<T extends ChatRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateChatRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatRoom[P]>
      : GetScalarType<T[P], AggregateChatRoom[P]>
  }




  export type ChatRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatRoomWhereInput
    orderBy?: ChatRoomOrderByWithAggregationInput | ChatRoomOrderByWithAggregationInput[]
    by: ChatRoomScalarFieldEnum[] | ChatRoomScalarFieldEnum
    having?: ChatRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatRoomCountAggregateInputType | true
    _min?: ChatRoomMinAggregateInputType
    _max?: ChatRoomMaxAggregateInputType
  }

  export type ChatRoomGroupByOutputType = {
    id: string
    tenant_id: string
    collection_case_id: string
    name: string
    created_at: Date
    updated_at: Date
    _count: ChatRoomCountAggregateOutputType | null
    _min: ChatRoomMinAggregateOutputType | null
    _max: ChatRoomMaxAggregateOutputType | null
  }

  type GetChatRoomGroupByPayload<T extends ChatRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatRoomGroupByOutputType[P]>
            : GetScalarType<T[P], ChatRoomGroupByOutputType[P]>
        }
      >
    >


  export type ChatRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    collection_case_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    messages?: boolean | ChatRoom$messagesArgs<ExtArgs>
    _count?: boolean | ChatRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatRoom"]>

  export type ChatRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    collection_case_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatRoom"]>

  export type ChatRoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenant_id?: boolean
    collection_case_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatRoom"]>

  export type ChatRoomSelectScalar = {
    id?: boolean
    tenant_id?: boolean
    collection_case_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ChatRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenant_id" | "collection_case_id" | "name" | "created_at" | "updated_at", ExtArgs["result"]["chatRoom"]>
  export type ChatRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    messages?: boolean | ChatRoom$messagesArgs<ExtArgs>
    _count?: boolean | ChatRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type ChatRoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }

  export type $ChatRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatRoom"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      collection_case: Prisma.$CollectionCasePayload<ExtArgs>
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenant_id: string
      collection_case_id: string
      name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["chatRoom"]>
    composites: {}
  }

  type ChatRoomGetPayload<S extends boolean | null | undefined | ChatRoomDefaultArgs> = $Result.GetResult<Prisma.$ChatRoomPayload, S>

  type ChatRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatRoomCountAggregateInputType | true
    }

  export interface ChatRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatRoom'], meta: { name: 'ChatRoom' } }
    /**
     * Find zero or one ChatRoom that matches the filter.
     * @param {ChatRoomFindUniqueArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatRoomFindUniqueArgs>(args: SelectSubset<T, ChatRoomFindUniqueArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatRoomFindUniqueOrThrowArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomFindFirstArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatRoomFindFirstArgs>(args?: SelectSubset<T, ChatRoomFindFirstArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomFindFirstOrThrowArgs} args - Arguments to find a ChatRoom
     * @example
     * // Get one ChatRoom
     * const chatRoom = await prisma.chatRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatRooms
     * const chatRooms = await prisma.chatRoom.findMany()
     * 
     * // Get first 10 ChatRooms
     * const chatRooms = await prisma.chatRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatRoomWithIdOnly = await prisma.chatRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatRoomFindManyArgs>(args?: SelectSubset<T, ChatRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatRoom.
     * @param {ChatRoomCreateArgs} args - Arguments to create a ChatRoom.
     * @example
     * // Create one ChatRoom
     * const ChatRoom = await prisma.chatRoom.create({
     *   data: {
     *     // ... data to create a ChatRoom
     *   }
     * })
     * 
     */
    create<T extends ChatRoomCreateArgs>(args: SelectSubset<T, ChatRoomCreateArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatRooms.
     * @param {ChatRoomCreateManyArgs} args - Arguments to create many ChatRooms.
     * @example
     * // Create many ChatRooms
     * const chatRoom = await prisma.chatRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatRoomCreateManyArgs>(args?: SelectSubset<T, ChatRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatRooms and returns the data saved in the database.
     * @param {ChatRoomCreateManyAndReturnArgs} args - Arguments to create many ChatRooms.
     * @example
     * // Create many ChatRooms
     * const chatRoom = await prisma.chatRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatRooms and only return the `id`
     * const chatRoomWithIdOnly = await prisma.chatRoom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatRoom.
     * @param {ChatRoomDeleteArgs} args - Arguments to delete one ChatRoom.
     * @example
     * // Delete one ChatRoom
     * const ChatRoom = await prisma.chatRoom.delete({
     *   where: {
     *     // ... filter to delete one ChatRoom
     *   }
     * })
     * 
     */
    delete<T extends ChatRoomDeleteArgs>(args: SelectSubset<T, ChatRoomDeleteArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatRoom.
     * @param {ChatRoomUpdateArgs} args - Arguments to update one ChatRoom.
     * @example
     * // Update one ChatRoom
     * const chatRoom = await prisma.chatRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatRoomUpdateArgs>(args: SelectSubset<T, ChatRoomUpdateArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatRooms.
     * @param {ChatRoomDeleteManyArgs} args - Arguments to filter ChatRooms to delete.
     * @example
     * // Delete a few ChatRooms
     * const { count } = await prisma.chatRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatRoomDeleteManyArgs>(args?: SelectSubset<T, ChatRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatRooms
     * const chatRoom = await prisma.chatRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatRoomUpdateManyArgs>(args: SelectSubset<T, ChatRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatRooms and returns the data updated in the database.
     * @param {ChatRoomUpdateManyAndReturnArgs} args - Arguments to update many ChatRooms.
     * @example
     * // Update many ChatRooms
     * const chatRoom = await prisma.chatRoom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatRooms and only return the `id`
     * const chatRoomWithIdOnly = await prisma.chatRoom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatRoomUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatRoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatRoom.
     * @param {ChatRoomUpsertArgs} args - Arguments to update or create a ChatRoom.
     * @example
     * // Update or create a ChatRoom
     * const chatRoom = await prisma.chatRoom.upsert({
     *   create: {
     *     // ... data to create a ChatRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatRoom we want to update
     *   }
     * })
     */
    upsert<T extends ChatRoomUpsertArgs>(args: SelectSubset<T, ChatRoomUpsertArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomCountArgs} args - Arguments to filter ChatRooms to count.
     * @example
     * // Count the number of ChatRooms
     * const count = await prisma.chatRoom.count({
     *   where: {
     *     // ... the filter for the ChatRooms we want to count
     *   }
     * })
    **/
    count<T extends ChatRoomCountArgs>(
      args?: Subset<T, ChatRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatRoomAggregateArgs>(args: Subset<T, ChatRoomAggregateArgs>): Prisma.PrismaPromise<GetChatRoomAggregateType<T>>

    /**
     * Group by ChatRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatRoomGroupByArgs['orderBy'] }
        : { orderBy?: ChatRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatRoom model
   */
  readonly fields: ChatRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    collection_case<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends ChatRoom$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatRoom$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatRoom model
   */
  interface ChatRoomFieldRefs {
    readonly id: FieldRef<"ChatRoom", 'String'>
    readonly tenant_id: FieldRef<"ChatRoom", 'String'>
    readonly collection_case_id: FieldRef<"ChatRoom", 'String'>
    readonly name: FieldRef<"ChatRoom", 'String'>
    readonly created_at: FieldRef<"ChatRoom", 'DateTime'>
    readonly updated_at: FieldRef<"ChatRoom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatRoom findUnique
   */
  export type ChatRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom findUniqueOrThrow
   */
  export type ChatRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom findFirst
   */
  export type ChatRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatRooms.
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatRooms.
     */
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * ChatRoom findFirstOrThrow
   */
  export type ChatRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRoom to fetch.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatRooms.
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatRooms.
     */
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * ChatRoom findMany
   */
  export type ChatRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter, which ChatRooms to fetch.
     */
    where?: ChatRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatRooms to fetch.
     */
    orderBy?: ChatRoomOrderByWithRelationInput | ChatRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatRooms.
     */
    cursor?: ChatRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatRooms.
     */
    skip?: number
    distinct?: ChatRoomScalarFieldEnum | ChatRoomScalarFieldEnum[]
  }

  /**
   * ChatRoom create
   */
  export type ChatRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatRoom.
     */
    data: XOR<ChatRoomCreateInput, ChatRoomUncheckedCreateInput>
  }

  /**
   * ChatRoom createMany
   */
  export type ChatRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatRooms.
     */
    data: ChatRoomCreateManyInput | ChatRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatRoom createManyAndReturn
   */
  export type ChatRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * The data used to create many ChatRooms.
     */
    data: ChatRoomCreateManyInput | ChatRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatRoom update
   */
  export type ChatRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatRoom.
     */
    data: XOR<ChatRoomUpdateInput, ChatRoomUncheckedUpdateInput>
    /**
     * Choose, which ChatRoom to update.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom updateMany
   */
  export type ChatRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatRooms.
     */
    data: XOR<ChatRoomUpdateManyMutationInput, ChatRoomUncheckedUpdateManyInput>
    /**
     * Filter which ChatRooms to update
     */
    where?: ChatRoomWhereInput
    /**
     * Limit how many ChatRooms to update.
     */
    limit?: number
  }

  /**
   * ChatRoom updateManyAndReturn
   */
  export type ChatRoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * The data used to update ChatRooms.
     */
    data: XOR<ChatRoomUpdateManyMutationInput, ChatRoomUncheckedUpdateManyInput>
    /**
     * Filter which ChatRooms to update
     */
    where?: ChatRoomWhereInput
    /**
     * Limit how many ChatRooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatRoom upsert
   */
  export type ChatRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatRoom to update in case it exists.
     */
    where: ChatRoomWhereUniqueInput
    /**
     * In case the ChatRoom found by the `where` argument doesn't exist, create a new ChatRoom with this data.
     */
    create: XOR<ChatRoomCreateInput, ChatRoomUncheckedCreateInput>
    /**
     * In case the ChatRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatRoomUpdateInput, ChatRoomUncheckedUpdateInput>
  }

  /**
   * ChatRoom delete
   */
  export type ChatRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
    /**
     * Filter which ChatRoom to delete.
     */
    where: ChatRoomWhereUniqueInput
  }

  /**
   * ChatRoom deleteMany
   */
  export type ChatRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatRooms to delete
     */
    where?: ChatRoomWhereInput
    /**
     * Limit how many ChatRooms to delete.
     */
    limit?: number
  }

  /**
   * ChatRoom.messages
   */
  export type ChatRoom$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatRoom without action
   */
  export type ChatRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatRoom
     */
    select?: ChatRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatRoom
     */
    omit?: ChatRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatRoomInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    room_id: string | null
    sender_id: string | null
    message: string | null
    file_url: string | null
    file_name: string | null
    timestamp: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    room_id: string | null
    sender_id: string | null
    message: string | null
    file_url: string | null
    file_name: string | null
    timestamp: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    room_id: number
    sender_id: number
    message: number
    file_url: number
    file_name: number
    timestamp: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    room_id?: true
    sender_id?: true
    message?: true
    file_url?: true
    file_name?: true
    timestamp?: true
    created_at?: true
    updated_at?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    room_id?: true
    sender_id?: true
    message?: true
    file_url?: true
    file_name?: true
    timestamp?: true
    created_at?: true
    updated_at?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    room_id?: true
    sender_id?: true
    message?: true
    file_url?: true
    file_name?: true
    timestamp?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    room_id: string
    sender_id: string
    message: string
    file_url: string | null
    file_name: string | null
    timestamp: Date
    created_at: Date
    updated_at: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    room_id?: boolean
    sender_id?: boolean
    message?: boolean
    file_url?: boolean
    file_name?: boolean
    timestamp?: boolean
    created_at?: boolean
    updated_at?: boolean
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    room_id?: boolean
    sender_id?: boolean
    message?: boolean
    file_url?: boolean
    file_name?: boolean
    timestamp?: boolean
    created_at?: boolean
    updated_at?: boolean
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    room_id?: boolean
    sender_id?: boolean
    message?: boolean
    file_url?: boolean
    file_name?: boolean
    timestamp?: boolean
    created_at?: boolean
    updated_at?: boolean
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    room_id?: boolean
    sender_id?: boolean
    message?: boolean
    file_url?: boolean
    file_name?: boolean
    timestamp?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "room_id" | "sender_id" | "message" | "file_url" | "file_name" | "timestamp" | "created_at" | "updated_at", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | ChatRoomDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      room: Prisma.$ChatRoomPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      room_id: string
      sender_id: string
      message: string
      file_url: string | null
      file_name: string | null
      timestamp: Date
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends ChatRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatRoomDefaultArgs<ExtArgs>>): Prisma__ChatRoomClient<$Result.GetResult<Prisma.$ChatRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly room_id: FieldRef<"ChatMessage", 'String'>
    readonly sender_id: FieldRef<"ChatMessage", 'String'>
    readonly message: FieldRef<"ChatMessage", 'String'>
    readonly file_url: FieldRef<"ChatMessage", 'String'>
    readonly file_name: FieldRef<"ChatMessage", 'String'>
    readonly timestamp: FieldRef<"ChatMessage", 'DateTime'>
    readonly created_at: FieldRef<"ChatMessage", 'DateTime'>
    readonly updated_at: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model DebtorIncome
   */

  export type AggregateDebtorIncome = {
    _count: DebtorIncomeCountAggregateOutputType | null
    _avg: DebtorIncomeAvgAggregateOutputType | null
    _sum: DebtorIncomeSumAggregateOutputType | null
    _min: DebtorIncomeMinAggregateOutputType | null
    _max: DebtorIncomeMaxAggregateOutputType | null
  }

  export type DebtorIncomeAvgAggregateOutputType = {
    amount: number | null
  }

  export type DebtorIncomeSumAggregateOutputType = {
    amount: number | null
  }

  export type DebtorIncomeMinAggregateOutputType = {
    id: string | null
    debtor_id: string | null
    amount: number | null
    source: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DebtorIncomeMaxAggregateOutputType = {
    id: string | null
    debtor_id: string | null
    amount: number | null
    source: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DebtorIncomeCountAggregateOutputType = {
    id: number
    debtor_id: number
    amount: number
    source: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DebtorIncomeAvgAggregateInputType = {
    amount?: true
  }

  export type DebtorIncomeSumAggregateInputType = {
    amount?: true
  }

  export type DebtorIncomeMinAggregateInputType = {
    id?: true
    debtor_id?: true
    amount?: true
    source?: true
    created_at?: true
    updated_at?: true
  }

  export type DebtorIncomeMaxAggregateInputType = {
    id?: true
    debtor_id?: true
    amount?: true
    source?: true
    created_at?: true
    updated_at?: true
  }

  export type DebtorIncomeCountAggregateInputType = {
    id?: true
    debtor_id?: true
    amount?: true
    source?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DebtorIncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtorIncome to aggregate.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DebtorIncomes
    **/
    _count?: true | DebtorIncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebtorIncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebtorIncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebtorIncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebtorIncomeMaxAggregateInputType
  }

  export type GetDebtorIncomeAggregateType<T extends DebtorIncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateDebtorIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebtorIncome[P]>
      : GetScalarType<T[P], AggregateDebtorIncome[P]>
  }




  export type DebtorIncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DebtorIncomeWhereInput
    orderBy?: DebtorIncomeOrderByWithAggregationInput | DebtorIncomeOrderByWithAggregationInput[]
    by: DebtorIncomeScalarFieldEnum[] | DebtorIncomeScalarFieldEnum
    having?: DebtorIncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebtorIncomeCountAggregateInputType | true
    _avg?: DebtorIncomeAvgAggregateInputType
    _sum?: DebtorIncomeSumAggregateInputType
    _min?: DebtorIncomeMinAggregateInputType
    _max?: DebtorIncomeMaxAggregateInputType
  }

  export type DebtorIncomeGroupByOutputType = {
    id: string
    debtor_id: string
    amount: number
    source: string
    created_at: Date
    updated_at: Date
    _count: DebtorIncomeCountAggregateOutputType | null
    _avg: DebtorIncomeAvgAggregateOutputType | null
    _sum: DebtorIncomeSumAggregateOutputType | null
    _min: DebtorIncomeMinAggregateOutputType | null
    _max: DebtorIncomeMaxAggregateOutputType | null
  }

  type GetDebtorIncomeGroupByPayload<T extends DebtorIncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DebtorIncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebtorIncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebtorIncomeGroupByOutputType[P]>
            : GetScalarType<T[P], DebtorIncomeGroupByOutputType[P]>
        }
      >
    >


  export type DebtorIncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtor_id?: boolean
    amount?: boolean
    source?: boolean
    created_at?: boolean
    updated_at?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtorIncome"]>

  export type DebtorIncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtor_id?: boolean
    amount?: boolean
    source?: boolean
    created_at?: boolean
    updated_at?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtorIncome"]>

  export type DebtorIncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    debtor_id?: boolean
    amount?: boolean
    source?: boolean
    created_at?: boolean
    updated_at?: boolean
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["debtorIncome"]>

  export type DebtorIncomeSelectScalar = {
    id?: boolean
    debtor_id?: boolean
    amount?: boolean
    source?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type DebtorIncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "debtor_id" | "amount" | "source" | "created_at" | "updated_at", ExtArgs["result"]["debtorIncome"]>
  export type DebtorIncomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }
  export type DebtorIncomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }
  export type DebtorIncomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    debtor?: boolean | DebtorDefaultArgs<ExtArgs>
  }

  export type $DebtorIncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DebtorIncome"
    objects: {
      debtor: Prisma.$DebtorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      debtor_id: string
      amount: number
      source: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["debtorIncome"]>
    composites: {}
  }

  type DebtorIncomeGetPayload<S extends boolean | null | undefined | DebtorIncomeDefaultArgs> = $Result.GetResult<Prisma.$DebtorIncomePayload, S>

  type DebtorIncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DebtorIncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DebtorIncomeCountAggregateInputType | true
    }

  export interface DebtorIncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DebtorIncome'], meta: { name: 'DebtorIncome' } }
    /**
     * Find zero or one DebtorIncome that matches the filter.
     * @param {DebtorIncomeFindUniqueArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DebtorIncomeFindUniqueArgs>(args: SelectSubset<T, DebtorIncomeFindUniqueArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DebtorIncome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DebtorIncomeFindUniqueOrThrowArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DebtorIncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, DebtorIncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DebtorIncome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeFindFirstArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DebtorIncomeFindFirstArgs>(args?: SelectSubset<T, DebtorIncomeFindFirstArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DebtorIncome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeFindFirstOrThrowArgs} args - Arguments to find a DebtorIncome
     * @example
     * // Get one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DebtorIncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, DebtorIncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DebtorIncomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DebtorIncomes
     * const debtorIncomes = await prisma.debtorIncome.findMany()
     * 
     * // Get first 10 DebtorIncomes
     * const debtorIncomes = await prisma.debtorIncome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const debtorIncomeWithIdOnly = await prisma.debtorIncome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DebtorIncomeFindManyArgs>(args?: SelectSubset<T, DebtorIncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DebtorIncome.
     * @param {DebtorIncomeCreateArgs} args - Arguments to create a DebtorIncome.
     * @example
     * // Create one DebtorIncome
     * const DebtorIncome = await prisma.debtorIncome.create({
     *   data: {
     *     // ... data to create a DebtorIncome
     *   }
     * })
     * 
     */
    create<T extends DebtorIncomeCreateArgs>(args: SelectSubset<T, DebtorIncomeCreateArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DebtorIncomes.
     * @param {DebtorIncomeCreateManyArgs} args - Arguments to create many DebtorIncomes.
     * @example
     * // Create many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DebtorIncomeCreateManyArgs>(args?: SelectSubset<T, DebtorIncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DebtorIncomes and returns the data saved in the database.
     * @param {DebtorIncomeCreateManyAndReturnArgs} args - Arguments to create many DebtorIncomes.
     * @example
     * // Create many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DebtorIncomes and only return the `id`
     * const debtorIncomeWithIdOnly = await prisma.debtorIncome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DebtorIncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, DebtorIncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DebtorIncome.
     * @param {DebtorIncomeDeleteArgs} args - Arguments to delete one DebtorIncome.
     * @example
     * // Delete one DebtorIncome
     * const DebtorIncome = await prisma.debtorIncome.delete({
     *   where: {
     *     // ... filter to delete one DebtorIncome
     *   }
     * })
     * 
     */
    delete<T extends DebtorIncomeDeleteArgs>(args: SelectSubset<T, DebtorIncomeDeleteArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DebtorIncome.
     * @param {DebtorIncomeUpdateArgs} args - Arguments to update one DebtorIncome.
     * @example
     * // Update one DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DebtorIncomeUpdateArgs>(args: SelectSubset<T, DebtorIncomeUpdateArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DebtorIncomes.
     * @param {DebtorIncomeDeleteManyArgs} args - Arguments to filter DebtorIncomes to delete.
     * @example
     * // Delete a few DebtorIncomes
     * const { count } = await prisma.debtorIncome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DebtorIncomeDeleteManyArgs>(args?: SelectSubset<T, DebtorIncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DebtorIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DebtorIncomeUpdateManyArgs>(args: SelectSubset<T, DebtorIncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DebtorIncomes and returns the data updated in the database.
     * @param {DebtorIncomeUpdateManyAndReturnArgs} args - Arguments to update many DebtorIncomes.
     * @example
     * // Update many DebtorIncomes
     * const debtorIncome = await prisma.debtorIncome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DebtorIncomes and only return the `id`
     * const debtorIncomeWithIdOnly = await prisma.debtorIncome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DebtorIncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, DebtorIncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DebtorIncome.
     * @param {DebtorIncomeUpsertArgs} args - Arguments to update or create a DebtorIncome.
     * @example
     * // Update or create a DebtorIncome
     * const debtorIncome = await prisma.debtorIncome.upsert({
     *   create: {
     *     // ... data to create a DebtorIncome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DebtorIncome we want to update
     *   }
     * })
     */
    upsert<T extends DebtorIncomeUpsertArgs>(args: SelectSubset<T, DebtorIncomeUpsertArgs<ExtArgs>>): Prisma__DebtorIncomeClient<$Result.GetResult<Prisma.$DebtorIncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DebtorIncomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeCountArgs} args - Arguments to filter DebtorIncomes to count.
     * @example
     * // Count the number of DebtorIncomes
     * const count = await prisma.debtorIncome.count({
     *   where: {
     *     // ... the filter for the DebtorIncomes we want to count
     *   }
     * })
    **/
    count<T extends DebtorIncomeCountArgs>(
      args?: Subset<T, DebtorIncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebtorIncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DebtorIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebtorIncomeAggregateArgs>(args: Subset<T, DebtorIncomeAggregateArgs>): Prisma.PrismaPromise<GetDebtorIncomeAggregateType<T>>

    /**
     * Group by DebtorIncome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebtorIncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebtorIncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebtorIncomeGroupByArgs['orderBy'] }
        : { orderBy?: DebtorIncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebtorIncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebtorIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DebtorIncome model
   */
  readonly fields: DebtorIncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DebtorIncome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DebtorIncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    debtor<T extends DebtorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DebtorDefaultArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DebtorIncome model
   */
  interface DebtorIncomeFieldRefs {
    readonly id: FieldRef<"DebtorIncome", 'String'>
    readonly debtor_id: FieldRef<"DebtorIncome", 'String'>
    readonly amount: FieldRef<"DebtorIncome", 'Float'>
    readonly source: FieldRef<"DebtorIncome", 'String'>
    readonly created_at: FieldRef<"DebtorIncome", 'DateTime'>
    readonly updated_at: FieldRef<"DebtorIncome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DebtorIncome findUnique
   */
  export type DebtorIncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome findUniqueOrThrow
   */
  export type DebtorIncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome findFirst
   */
  export type DebtorIncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtorIncomes.
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtorIncomes.
     */
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * DebtorIncome findFirstOrThrow
   */
  export type DebtorIncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncome to fetch.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DebtorIncomes.
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DebtorIncomes.
     */
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * DebtorIncome findMany
   */
  export type DebtorIncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter, which DebtorIncomes to fetch.
     */
    where?: DebtorIncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DebtorIncomes to fetch.
     */
    orderBy?: DebtorIncomeOrderByWithRelationInput | DebtorIncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DebtorIncomes.
     */
    cursor?: DebtorIncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DebtorIncomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DebtorIncomes.
     */
    skip?: number
    distinct?: DebtorIncomeScalarFieldEnum | DebtorIncomeScalarFieldEnum[]
  }

  /**
   * DebtorIncome create
   */
  export type DebtorIncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * The data needed to create a DebtorIncome.
     */
    data: XOR<DebtorIncomeCreateInput, DebtorIncomeUncheckedCreateInput>
  }

  /**
   * DebtorIncome createMany
   */
  export type DebtorIncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DebtorIncomes.
     */
    data: DebtorIncomeCreateManyInput | DebtorIncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DebtorIncome createManyAndReturn
   */
  export type DebtorIncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * The data used to create many DebtorIncomes.
     */
    data: DebtorIncomeCreateManyInput | DebtorIncomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DebtorIncome update
   */
  export type DebtorIncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * The data needed to update a DebtorIncome.
     */
    data: XOR<DebtorIncomeUpdateInput, DebtorIncomeUncheckedUpdateInput>
    /**
     * Choose, which DebtorIncome to update.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome updateMany
   */
  export type DebtorIncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DebtorIncomes.
     */
    data: XOR<DebtorIncomeUpdateManyMutationInput, DebtorIncomeUncheckedUpdateManyInput>
    /**
     * Filter which DebtorIncomes to update
     */
    where?: DebtorIncomeWhereInput
    /**
     * Limit how many DebtorIncomes to update.
     */
    limit?: number
  }

  /**
   * DebtorIncome updateManyAndReturn
   */
  export type DebtorIncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * The data used to update DebtorIncomes.
     */
    data: XOR<DebtorIncomeUpdateManyMutationInput, DebtorIncomeUncheckedUpdateManyInput>
    /**
     * Filter which DebtorIncomes to update
     */
    where?: DebtorIncomeWhereInput
    /**
     * Limit how many DebtorIncomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DebtorIncome upsert
   */
  export type DebtorIncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * The filter to search for the DebtorIncome to update in case it exists.
     */
    where: DebtorIncomeWhereUniqueInput
    /**
     * In case the DebtorIncome found by the `where` argument doesn't exist, create a new DebtorIncome with this data.
     */
    create: XOR<DebtorIncomeCreateInput, DebtorIncomeUncheckedCreateInput>
    /**
     * In case the DebtorIncome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DebtorIncomeUpdateInput, DebtorIncomeUncheckedUpdateInput>
  }

  /**
   * DebtorIncome delete
   */
  export type DebtorIncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
    /**
     * Filter which DebtorIncome to delete.
     */
    where: DebtorIncomeWhereUniqueInput
  }

  /**
   * DebtorIncome deleteMany
   */
  export type DebtorIncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DebtorIncomes to delete
     */
    where?: DebtorIncomeWhereInput
    /**
     * Limit how many DebtorIncomes to delete.
     */
    limit?: number
  }

  /**
   * DebtorIncome without action
   */
  export type DebtorIncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DebtorIncome
     */
    select?: DebtorIncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DebtorIncome
     */
    omit?: DebtorIncomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorIncomeInclude<ExtArgs> | null
  }


  /**
   * Model CollectionCaseAgreement
   */

  export type AggregateCollectionCaseAgreement = {
    _count: CollectionCaseAgreementCountAggregateOutputType | null
    _avg: CollectionCaseAgreementAvgAggregateOutputType | null
    _sum: CollectionCaseAgreementSumAggregateOutputType | null
    _min: CollectionCaseAgreementMinAggregateOutputType | null
    _max: CollectionCaseAgreementMaxAggregateOutputType | null
  }

  export type CollectionCaseAgreementAvgAggregateOutputType = {
    total_amount: Decimal | null
    installment_amount: Decimal | null
    installments_count: number | null
  }

  export type CollectionCaseAgreementSumAggregateOutputType = {
    total_amount: Decimal | null
    installment_amount: Decimal | null
    installments_count: number | null
  }

  export type CollectionCaseAgreementMinAggregateOutputType = {
    id: string | null
    collection_case_id: string | null
    debtor_id: string | null
    total_amount: Decimal | null
    installment_amount: Decimal | null
    installments_count: number | null
    start_date: Date | null
    end_date: Date | null
    status: $Enums.AgreementStatus | null
    tenant_id: string | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CollectionCaseAgreementMaxAggregateOutputType = {
    id: string | null
    collection_case_id: string | null
    debtor_id: string | null
    total_amount: Decimal | null
    installment_amount: Decimal | null
    installments_count: number | null
    start_date: Date | null
    end_date: Date | null
    status: $Enums.AgreementStatus | null
    tenant_id: string | null
    comment: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CollectionCaseAgreementCountAggregateOutputType = {
    id: number
    collection_case_id: number
    debtor_id: number
    total_amount: number
    installment_amount: number
    installments_count: number
    start_date: number
    end_date: number
    status: number
    tenant_id: number
    comment: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CollectionCaseAgreementAvgAggregateInputType = {
    total_amount?: true
    installment_amount?: true
    installments_count?: true
  }

  export type CollectionCaseAgreementSumAggregateInputType = {
    total_amount?: true
    installment_amount?: true
    installments_count?: true
  }

  export type CollectionCaseAgreementMinAggregateInputType = {
    id?: true
    collection_case_id?: true
    debtor_id?: true
    total_amount?: true
    installment_amount?: true
    installments_count?: true
    start_date?: true
    end_date?: true
    status?: true
    tenant_id?: true
    comment?: true
    created_at?: true
    updated_at?: true
  }

  export type CollectionCaseAgreementMaxAggregateInputType = {
    id?: true
    collection_case_id?: true
    debtor_id?: true
    total_amount?: true
    installment_amount?: true
    installments_count?: true
    start_date?: true
    end_date?: true
    status?: true
    tenant_id?: true
    comment?: true
    created_at?: true
    updated_at?: true
  }

  export type CollectionCaseAgreementCountAggregateInputType = {
    id?: true
    collection_case_id?: true
    debtor_id?: true
    total_amount?: true
    installment_amount?: true
    installments_count?: true
    start_date?: true
    end_date?: true
    status?: true
    tenant_id?: true
    comment?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CollectionCaseAgreementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCaseAgreement to aggregate.
     */
    where?: CollectionCaseAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseAgreements to fetch.
     */
    orderBy?: CollectionCaseAgreementOrderByWithRelationInput | CollectionCaseAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionCaseAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionCaseAgreements
    **/
    _count?: true | CollectionCaseAgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionCaseAgreementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionCaseAgreementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionCaseAgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionCaseAgreementMaxAggregateInputType
  }

  export type GetCollectionCaseAgreementAggregateType<T extends CollectionCaseAgreementAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionCaseAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionCaseAgreement[P]>
      : GetScalarType<T[P], AggregateCollectionCaseAgreement[P]>
  }




  export type CollectionCaseAgreementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseAgreementWhereInput
    orderBy?: CollectionCaseAgreementOrderByWithAggregationInput | CollectionCaseAgreementOrderByWithAggregationInput[]
    by: CollectionCaseAgreementScalarFieldEnum[] | CollectionCaseAgreementScalarFieldEnum
    having?: CollectionCaseAgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCaseAgreementCountAggregateInputType | true
    _avg?: CollectionCaseAgreementAvgAggregateInputType
    _sum?: CollectionCaseAgreementSumAggregateInputType
    _min?: CollectionCaseAgreementMinAggregateInputType
    _max?: CollectionCaseAgreementMaxAggregateInputType
  }

  export type CollectionCaseAgreementGroupByOutputType = {
    id: string
    collection_case_id: string
    debtor_id: string | null
    total_amount: Decimal
    installment_amount: Decimal
    installments_count: number
    start_date: Date
    end_date: Date
    status: $Enums.AgreementStatus
    tenant_id: string
    comment: string | null
    created_at: Date
    updated_at: Date
    _count: CollectionCaseAgreementCountAggregateOutputType | null
    _avg: CollectionCaseAgreementAvgAggregateOutputType | null
    _sum: CollectionCaseAgreementSumAggregateOutputType | null
    _min: CollectionCaseAgreementMinAggregateOutputType | null
    _max: CollectionCaseAgreementMaxAggregateOutputType | null
  }

  type GetCollectionCaseAgreementGroupByPayload<T extends CollectionCaseAgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionCaseAgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionCaseAgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionCaseAgreementGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionCaseAgreementGroupByOutputType[P]>
        }
      >
    >


  export type CollectionCaseAgreementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_case_id?: boolean
    debtor_id?: boolean
    total_amount?: boolean
    installment_amount?: boolean
    installments_count?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    tenant_id?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    debtor?: boolean | CollectionCaseAgreement$debtorArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    installments?: boolean | CollectionCaseAgreement$installmentsArgs<ExtArgs>
    payments?: boolean | CollectionCaseAgreement$paymentsArgs<ExtArgs>
    _count?: boolean | CollectionCaseAgreementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCaseAgreement"]>

  export type CollectionCaseAgreementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_case_id?: boolean
    debtor_id?: boolean
    total_amount?: boolean
    installment_amount?: boolean
    installments_count?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    tenant_id?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    debtor?: boolean | CollectionCaseAgreement$debtorArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCaseAgreement"]>

  export type CollectionCaseAgreementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collection_case_id?: boolean
    debtor_id?: boolean
    total_amount?: boolean
    installment_amount?: boolean
    installments_count?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    tenant_id?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    debtor?: boolean | CollectionCaseAgreement$debtorArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCaseAgreement"]>

  export type CollectionCaseAgreementSelectScalar = {
    id?: boolean
    collection_case_id?: boolean
    debtor_id?: boolean
    total_amount?: boolean
    installment_amount?: boolean
    installments_count?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    tenant_id?: boolean
    comment?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CollectionCaseAgreementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collection_case_id" | "debtor_id" | "total_amount" | "installment_amount" | "installments_count" | "start_date" | "end_date" | "status" | "tenant_id" | "comment" | "created_at" | "updated_at", ExtArgs["result"]["collectionCaseAgreement"]>
  export type CollectionCaseAgreementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    debtor?: boolean | CollectionCaseAgreement$debtorArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
    installments?: boolean | CollectionCaseAgreement$installmentsArgs<ExtArgs>
    payments?: boolean | CollectionCaseAgreement$paymentsArgs<ExtArgs>
    _count?: boolean | CollectionCaseAgreementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollectionCaseAgreementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    debtor?: boolean | CollectionCaseAgreement$debtorArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }
  export type CollectionCaseAgreementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    debtor?: boolean | CollectionCaseAgreement$debtorArgs<ExtArgs>
    collection_case?: boolean | CollectionCaseDefaultArgs<ExtArgs>
  }

  export type $CollectionCaseAgreementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionCaseAgreement"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      debtor: Prisma.$DebtorPayload<ExtArgs> | null
      collection_case: Prisma.$CollectionCasePayload<ExtArgs>
      installments: Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>[]
      payments: Prisma.$CollectionCasePaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collection_case_id: string
      debtor_id: string | null
      total_amount: Prisma.Decimal
      installment_amount: Prisma.Decimal
      installments_count: number
      start_date: Date
      end_date: Date
      status: $Enums.AgreementStatus
      tenant_id: string
      comment: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["collectionCaseAgreement"]>
    composites: {}
  }

  type CollectionCaseAgreementGetPayload<S extends boolean | null | undefined | CollectionCaseAgreementDefaultArgs> = $Result.GetResult<Prisma.$CollectionCaseAgreementPayload, S>

  type CollectionCaseAgreementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionCaseAgreementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCaseAgreementCountAggregateInputType | true
    }

  export interface CollectionCaseAgreementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionCaseAgreement'], meta: { name: 'CollectionCaseAgreement' } }
    /**
     * Find zero or one CollectionCaseAgreement that matches the filter.
     * @param {CollectionCaseAgreementFindUniqueArgs} args - Arguments to find a CollectionCaseAgreement
     * @example
     * // Get one CollectionCaseAgreement
     * const collectionCaseAgreement = await prisma.collectionCaseAgreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionCaseAgreementFindUniqueArgs>(args: SelectSubset<T, CollectionCaseAgreementFindUniqueArgs<ExtArgs>>): Prisma__CollectionCaseAgreementClient<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionCaseAgreement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionCaseAgreementFindUniqueOrThrowArgs} args - Arguments to find a CollectionCaseAgreement
     * @example
     * // Get one CollectionCaseAgreement
     * const collectionCaseAgreement = await prisma.collectionCaseAgreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionCaseAgreementFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionCaseAgreementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseAgreementClient<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCaseAgreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementFindFirstArgs} args - Arguments to find a CollectionCaseAgreement
     * @example
     * // Get one CollectionCaseAgreement
     * const collectionCaseAgreement = await prisma.collectionCaseAgreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionCaseAgreementFindFirstArgs>(args?: SelectSubset<T, CollectionCaseAgreementFindFirstArgs<ExtArgs>>): Prisma__CollectionCaseAgreementClient<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCaseAgreement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementFindFirstOrThrowArgs} args - Arguments to find a CollectionCaseAgreement
     * @example
     * // Get one CollectionCaseAgreement
     * const collectionCaseAgreement = await prisma.collectionCaseAgreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionCaseAgreementFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionCaseAgreementFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseAgreementClient<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionCaseAgreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionCaseAgreements
     * const collectionCaseAgreements = await prisma.collectionCaseAgreement.findMany()
     * 
     * // Get first 10 CollectionCaseAgreements
     * const collectionCaseAgreements = await prisma.collectionCaseAgreement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionCaseAgreementWithIdOnly = await prisma.collectionCaseAgreement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionCaseAgreementFindManyArgs>(args?: SelectSubset<T, CollectionCaseAgreementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionCaseAgreement.
     * @param {CollectionCaseAgreementCreateArgs} args - Arguments to create a CollectionCaseAgreement.
     * @example
     * // Create one CollectionCaseAgreement
     * const CollectionCaseAgreement = await prisma.collectionCaseAgreement.create({
     *   data: {
     *     // ... data to create a CollectionCaseAgreement
     *   }
     * })
     * 
     */
    create<T extends CollectionCaseAgreementCreateArgs>(args: SelectSubset<T, CollectionCaseAgreementCreateArgs<ExtArgs>>): Prisma__CollectionCaseAgreementClient<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionCaseAgreements.
     * @param {CollectionCaseAgreementCreateManyArgs} args - Arguments to create many CollectionCaseAgreements.
     * @example
     * // Create many CollectionCaseAgreements
     * const collectionCaseAgreement = await prisma.collectionCaseAgreement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCaseAgreementCreateManyArgs>(args?: SelectSubset<T, CollectionCaseAgreementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionCaseAgreements and returns the data saved in the database.
     * @param {CollectionCaseAgreementCreateManyAndReturnArgs} args - Arguments to create many CollectionCaseAgreements.
     * @example
     * // Create many CollectionCaseAgreements
     * const collectionCaseAgreement = await prisma.collectionCaseAgreement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionCaseAgreements and only return the `id`
     * const collectionCaseAgreementWithIdOnly = await prisma.collectionCaseAgreement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCaseAgreementCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCaseAgreementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionCaseAgreement.
     * @param {CollectionCaseAgreementDeleteArgs} args - Arguments to delete one CollectionCaseAgreement.
     * @example
     * // Delete one CollectionCaseAgreement
     * const CollectionCaseAgreement = await prisma.collectionCaseAgreement.delete({
     *   where: {
     *     // ... filter to delete one CollectionCaseAgreement
     *   }
     * })
     * 
     */
    delete<T extends CollectionCaseAgreementDeleteArgs>(args: SelectSubset<T, CollectionCaseAgreementDeleteArgs<ExtArgs>>): Prisma__CollectionCaseAgreementClient<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionCaseAgreement.
     * @param {CollectionCaseAgreementUpdateArgs} args - Arguments to update one CollectionCaseAgreement.
     * @example
     * // Update one CollectionCaseAgreement
     * const collectionCaseAgreement = await prisma.collectionCaseAgreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionCaseAgreementUpdateArgs>(args: SelectSubset<T, CollectionCaseAgreementUpdateArgs<ExtArgs>>): Prisma__CollectionCaseAgreementClient<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionCaseAgreements.
     * @param {CollectionCaseAgreementDeleteManyArgs} args - Arguments to filter CollectionCaseAgreements to delete.
     * @example
     * // Delete a few CollectionCaseAgreements
     * const { count } = await prisma.collectionCaseAgreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionCaseAgreementDeleteManyArgs>(args?: SelectSubset<T, CollectionCaseAgreementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCaseAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionCaseAgreements
     * const collectionCaseAgreement = await prisma.collectionCaseAgreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionCaseAgreementUpdateManyArgs>(args: SelectSubset<T, CollectionCaseAgreementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCaseAgreements and returns the data updated in the database.
     * @param {CollectionCaseAgreementUpdateManyAndReturnArgs} args - Arguments to update many CollectionCaseAgreements.
     * @example
     * // Update many CollectionCaseAgreements
     * const collectionCaseAgreement = await prisma.collectionCaseAgreement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionCaseAgreements and only return the `id`
     * const collectionCaseAgreementWithIdOnly = await prisma.collectionCaseAgreement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionCaseAgreementUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionCaseAgreementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionCaseAgreement.
     * @param {CollectionCaseAgreementUpsertArgs} args - Arguments to update or create a CollectionCaseAgreement.
     * @example
     * // Update or create a CollectionCaseAgreement
     * const collectionCaseAgreement = await prisma.collectionCaseAgreement.upsert({
     *   create: {
     *     // ... data to create a CollectionCaseAgreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionCaseAgreement we want to update
     *   }
     * })
     */
    upsert<T extends CollectionCaseAgreementUpsertArgs>(args: SelectSubset<T, CollectionCaseAgreementUpsertArgs<ExtArgs>>): Prisma__CollectionCaseAgreementClient<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionCaseAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementCountArgs} args - Arguments to filter CollectionCaseAgreements to count.
     * @example
     * // Count the number of CollectionCaseAgreements
     * const count = await prisma.collectionCaseAgreement.count({
     *   where: {
     *     // ... the filter for the CollectionCaseAgreements we want to count
     *   }
     * })
    **/
    count<T extends CollectionCaseAgreementCountArgs>(
      args?: Subset<T, CollectionCaseAgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCaseAgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionCaseAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionCaseAgreementAggregateArgs>(args: Subset<T, CollectionCaseAgreementAggregateArgs>): Prisma.PrismaPromise<GetCollectionCaseAgreementAggregateType<T>>

    /**
     * Group by CollectionCaseAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionCaseAgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionCaseAgreementGroupByArgs['orderBy'] }
        : { orderBy?: CollectionCaseAgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionCaseAgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionCaseAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionCaseAgreement model
   */
  readonly fields: CollectionCaseAgreementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionCaseAgreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionCaseAgreementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    debtor<T extends CollectionCaseAgreement$debtorArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseAgreement$debtorArgs<ExtArgs>>): Prisma__DebtorClient<$Result.GetResult<Prisma.$DebtorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    collection_case<T extends CollectionCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseDefaultArgs<ExtArgs>>): Prisma__CollectionCaseClient<$Result.GetResult<Prisma.$CollectionCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    installments<T extends CollectionCaseAgreement$installmentsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseAgreement$installmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends CollectionCaseAgreement$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseAgreement$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionCaseAgreement model
   */
  interface CollectionCaseAgreementFieldRefs {
    readonly id: FieldRef<"CollectionCaseAgreement", 'String'>
    readonly collection_case_id: FieldRef<"CollectionCaseAgreement", 'String'>
    readonly debtor_id: FieldRef<"CollectionCaseAgreement", 'String'>
    readonly total_amount: FieldRef<"CollectionCaseAgreement", 'Decimal'>
    readonly installment_amount: FieldRef<"CollectionCaseAgreement", 'Decimal'>
    readonly installments_count: FieldRef<"CollectionCaseAgreement", 'Int'>
    readonly start_date: FieldRef<"CollectionCaseAgreement", 'DateTime'>
    readonly end_date: FieldRef<"CollectionCaseAgreement", 'DateTime'>
    readonly status: FieldRef<"CollectionCaseAgreement", 'AgreementStatus'>
    readonly tenant_id: FieldRef<"CollectionCaseAgreement", 'String'>
    readonly comment: FieldRef<"CollectionCaseAgreement", 'String'>
    readonly created_at: FieldRef<"CollectionCaseAgreement", 'DateTime'>
    readonly updated_at: FieldRef<"CollectionCaseAgreement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionCaseAgreement findUnique
   */
  export type CollectionCaseAgreementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseAgreement to fetch.
     */
    where: CollectionCaseAgreementWhereUniqueInput
  }

  /**
   * CollectionCaseAgreement findUniqueOrThrow
   */
  export type CollectionCaseAgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseAgreement to fetch.
     */
    where: CollectionCaseAgreementWhereUniqueInput
  }

  /**
   * CollectionCaseAgreement findFirst
   */
  export type CollectionCaseAgreementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseAgreement to fetch.
     */
    where?: CollectionCaseAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseAgreements to fetch.
     */
    orderBy?: CollectionCaseAgreementOrderByWithRelationInput | CollectionCaseAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCaseAgreements.
     */
    cursor?: CollectionCaseAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCaseAgreements.
     */
    distinct?: CollectionCaseAgreementScalarFieldEnum | CollectionCaseAgreementScalarFieldEnum[]
  }

  /**
   * CollectionCaseAgreement findFirstOrThrow
   */
  export type CollectionCaseAgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseAgreement to fetch.
     */
    where?: CollectionCaseAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseAgreements to fetch.
     */
    orderBy?: CollectionCaseAgreementOrderByWithRelationInput | CollectionCaseAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCaseAgreements.
     */
    cursor?: CollectionCaseAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCaseAgreements.
     */
    distinct?: CollectionCaseAgreementScalarFieldEnum | CollectionCaseAgreementScalarFieldEnum[]
  }

  /**
   * CollectionCaseAgreement findMany
   */
  export type CollectionCaseAgreementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseAgreements to fetch.
     */
    where?: CollectionCaseAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseAgreements to fetch.
     */
    orderBy?: CollectionCaseAgreementOrderByWithRelationInput | CollectionCaseAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionCaseAgreements.
     */
    cursor?: CollectionCaseAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseAgreements.
     */
    skip?: number
    distinct?: CollectionCaseAgreementScalarFieldEnum | CollectionCaseAgreementScalarFieldEnum[]
  }

  /**
   * CollectionCaseAgreement create
   */
  export type CollectionCaseAgreementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a CollectionCaseAgreement.
     */
    data: XOR<CollectionCaseAgreementCreateInput, CollectionCaseAgreementUncheckedCreateInput>
  }

  /**
   * CollectionCaseAgreement createMany
   */
  export type CollectionCaseAgreementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionCaseAgreements.
     */
    data: CollectionCaseAgreementCreateManyInput | CollectionCaseAgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionCaseAgreement createManyAndReturn
   */
  export type CollectionCaseAgreementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionCaseAgreements.
     */
    data: CollectionCaseAgreementCreateManyInput | CollectionCaseAgreementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCaseAgreement update
   */
  export type CollectionCaseAgreementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a CollectionCaseAgreement.
     */
    data: XOR<CollectionCaseAgreementUpdateInput, CollectionCaseAgreementUncheckedUpdateInput>
    /**
     * Choose, which CollectionCaseAgreement to update.
     */
    where: CollectionCaseAgreementWhereUniqueInput
  }

  /**
   * CollectionCaseAgreement updateMany
   */
  export type CollectionCaseAgreementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionCaseAgreements.
     */
    data: XOR<CollectionCaseAgreementUpdateManyMutationInput, CollectionCaseAgreementUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCaseAgreements to update
     */
    where?: CollectionCaseAgreementWhereInput
    /**
     * Limit how many CollectionCaseAgreements to update.
     */
    limit?: number
  }

  /**
   * CollectionCaseAgreement updateManyAndReturn
   */
  export type CollectionCaseAgreementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * The data used to update CollectionCaseAgreements.
     */
    data: XOR<CollectionCaseAgreementUpdateManyMutationInput, CollectionCaseAgreementUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCaseAgreements to update
     */
    where?: CollectionCaseAgreementWhereInput
    /**
     * Limit how many CollectionCaseAgreements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCaseAgreement upsert
   */
  export type CollectionCaseAgreementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the CollectionCaseAgreement to update in case it exists.
     */
    where: CollectionCaseAgreementWhereUniqueInput
    /**
     * In case the CollectionCaseAgreement found by the `where` argument doesn't exist, create a new CollectionCaseAgreement with this data.
     */
    create: XOR<CollectionCaseAgreementCreateInput, CollectionCaseAgreementUncheckedCreateInput>
    /**
     * In case the CollectionCaseAgreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionCaseAgreementUpdateInput, CollectionCaseAgreementUncheckedUpdateInput>
  }

  /**
   * CollectionCaseAgreement delete
   */
  export type CollectionCaseAgreementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
    /**
     * Filter which CollectionCaseAgreement to delete.
     */
    where: CollectionCaseAgreementWhereUniqueInput
  }

  /**
   * CollectionCaseAgreement deleteMany
   */
  export type CollectionCaseAgreementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCaseAgreements to delete
     */
    where?: CollectionCaseAgreementWhereInput
    /**
     * Limit how many CollectionCaseAgreements to delete.
     */
    limit?: number
  }

  /**
   * CollectionCaseAgreement.debtor
   */
  export type CollectionCaseAgreement$debtorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Debtor
     */
    select?: DebtorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Debtor
     */
    omit?: DebtorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DebtorInclude<ExtArgs> | null
    where?: DebtorWhereInput
  }

  /**
   * CollectionCaseAgreement.installments
   */
  export type CollectionCaseAgreement$installmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
    where?: CollectionCaseAgreementInstallmentWhereInput
    orderBy?: CollectionCaseAgreementInstallmentOrderByWithRelationInput | CollectionCaseAgreementInstallmentOrderByWithRelationInput[]
    cursor?: CollectionCaseAgreementInstallmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCaseAgreementInstallmentScalarFieldEnum | CollectionCaseAgreementInstallmentScalarFieldEnum[]
  }

  /**
   * CollectionCaseAgreement.payments
   */
  export type CollectionCaseAgreement$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    where?: CollectionCasePaymentWhereInput
    orderBy?: CollectionCasePaymentOrderByWithRelationInput | CollectionCasePaymentOrderByWithRelationInput[]
    cursor?: CollectionCasePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionCasePaymentScalarFieldEnum | CollectionCasePaymentScalarFieldEnum[]
  }

  /**
   * CollectionCaseAgreement without action
   */
  export type CollectionCaseAgreementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreement
     */
    select?: CollectionCaseAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreement
     */
    omit?: CollectionCaseAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInclude<ExtArgs> | null
  }


  /**
   * Model CollectionCaseAgreementInstallment
   */

  export type AggregateCollectionCaseAgreementInstallment = {
    _count: CollectionCaseAgreementInstallmentCountAggregateOutputType | null
    _avg: CollectionCaseAgreementInstallmentAvgAggregateOutputType | null
    _sum: CollectionCaseAgreementInstallmentSumAggregateOutputType | null
    _min: CollectionCaseAgreementInstallmentMinAggregateOutputType | null
    _max: CollectionCaseAgreementInstallmentMaxAggregateOutputType | null
  }

  export type CollectionCaseAgreementInstallmentAvgAggregateOutputType = {
    number: number | null
    amount: Decimal | null
  }

  export type CollectionCaseAgreementInstallmentSumAggregateOutputType = {
    number: number | null
    amount: Decimal | null
  }

  export type CollectionCaseAgreementInstallmentMinAggregateOutputType = {
    id: string | null
    agreement_id: string | null
    number: number | null
    due_date: Date | null
    amount: Decimal | null
    status: $Enums.InstallmentStatus | null
    payment_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CollectionCaseAgreementInstallmentMaxAggregateOutputType = {
    id: string | null
    agreement_id: string | null
    number: number | null
    due_date: Date | null
    amount: Decimal | null
    status: $Enums.InstallmentStatus | null
    payment_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CollectionCaseAgreementInstallmentCountAggregateOutputType = {
    id: number
    agreement_id: number
    number: number
    due_date: number
    amount: number
    status: number
    payment_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CollectionCaseAgreementInstallmentAvgAggregateInputType = {
    number?: true
    amount?: true
  }

  export type CollectionCaseAgreementInstallmentSumAggregateInputType = {
    number?: true
    amount?: true
  }

  export type CollectionCaseAgreementInstallmentMinAggregateInputType = {
    id?: true
    agreement_id?: true
    number?: true
    due_date?: true
    amount?: true
    status?: true
    payment_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CollectionCaseAgreementInstallmentMaxAggregateInputType = {
    id?: true
    agreement_id?: true
    number?: true
    due_date?: true
    amount?: true
    status?: true
    payment_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CollectionCaseAgreementInstallmentCountAggregateInputType = {
    id?: true
    agreement_id?: true
    number?: true
    due_date?: true
    amount?: true
    status?: true
    payment_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CollectionCaseAgreementInstallmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCaseAgreementInstallment to aggregate.
     */
    where?: CollectionCaseAgreementInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseAgreementInstallments to fetch.
     */
    orderBy?: CollectionCaseAgreementInstallmentOrderByWithRelationInput | CollectionCaseAgreementInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionCaseAgreementInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseAgreementInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseAgreementInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionCaseAgreementInstallments
    **/
    _count?: true | CollectionCaseAgreementInstallmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionCaseAgreementInstallmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionCaseAgreementInstallmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionCaseAgreementInstallmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionCaseAgreementInstallmentMaxAggregateInputType
  }

  export type GetCollectionCaseAgreementInstallmentAggregateType<T extends CollectionCaseAgreementInstallmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionCaseAgreementInstallment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionCaseAgreementInstallment[P]>
      : GetScalarType<T[P], AggregateCollectionCaseAgreementInstallment[P]>
  }




  export type CollectionCaseAgreementInstallmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionCaseAgreementInstallmentWhereInput
    orderBy?: CollectionCaseAgreementInstallmentOrderByWithAggregationInput | CollectionCaseAgreementInstallmentOrderByWithAggregationInput[]
    by: CollectionCaseAgreementInstallmentScalarFieldEnum[] | CollectionCaseAgreementInstallmentScalarFieldEnum
    having?: CollectionCaseAgreementInstallmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCaseAgreementInstallmentCountAggregateInputType | true
    _avg?: CollectionCaseAgreementInstallmentAvgAggregateInputType
    _sum?: CollectionCaseAgreementInstallmentSumAggregateInputType
    _min?: CollectionCaseAgreementInstallmentMinAggregateInputType
    _max?: CollectionCaseAgreementInstallmentMaxAggregateInputType
  }

  export type CollectionCaseAgreementInstallmentGroupByOutputType = {
    id: string
    agreement_id: string
    number: number
    due_date: Date
    amount: Decimal
    status: $Enums.InstallmentStatus
    payment_id: string | null
    created_at: Date
    updated_at: Date
    _count: CollectionCaseAgreementInstallmentCountAggregateOutputType | null
    _avg: CollectionCaseAgreementInstallmentAvgAggregateOutputType | null
    _sum: CollectionCaseAgreementInstallmentSumAggregateOutputType | null
    _min: CollectionCaseAgreementInstallmentMinAggregateOutputType | null
    _max: CollectionCaseAgreementInstallmentMaxAggregateOutputType | null
  }

  type GetCollectionCaseAgreementInstallmentGroupByPayload<T extends CollectionCaseAgreementInstallmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionCaseAgreementInstallmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionCaseAgreementInstallmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionCaseAgreementInstallmentGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionCaseAgreementInstallmentGroupByOutputType[P]>
        }
      >
    >


  export type CollectionCaseAgreementInstallmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agreement_id?: boolean
    number?: boolean
    due_date?: boolean
    amount?: boolean
    status?: boolean
    payment_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    agreement?: boolean | CollectionCaseAgreementDefaultArgs<ExtArgs>
    payment?: boolean | CollectionCaseAgreementInstallment$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCaseAgreementInstallment"]>

  export type CollectionCaseAgreementInstallmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agreement_id?: boolean
    number?: boolean
    due_date?: boolean
    amount?: boolean
    status?: boolean
    payment_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    agreement?: boolean | CollectionCaseAgreementDefaultArgs<ExtArgs>
    payment?: boolean | CollectionCaseAgreementInstallment$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCaseAgreementInstallment"]>

  export type CollectionCaseAgreementInstallmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agreement_id?: boolean
    number?: boolean
    due_date?: boolean
    amount?: boolean
    status?: boolean
    payment_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    agreement?: boolean | CollectionCaseAgreementDefaultArgs<ExtArgs>
    payment?: boolean | CollectionCaseAgreementInstallment$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["collectionCaseAgreementInstallment"]>

  export type CollectionCaseAgreementInstallmentSelectScalar = {
    id?: boolean
    agreement_id?: boolean
    number?: boolean
    due_date?: boolean
    amount?: boolean
    status?: boolean
    payment_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CollectionCaseAgreementInstallmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agreement_id" | "number" | "due_date" | "amount" | "status" | "payment_id" | "created_at" | "updated_at", ExtArgs["result"]["collectionCaseAgreementInstallment"]>
  export type CollectionCaseAgreementInstallmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreement?: boolean | CollectionCaseAgreementDefaultArgs<ExtArgs>
    payment?: boolean | CollectionCaseAgreementInstallment$paymentArgs<ExtArgs>
  }
  export type CollectionCaseAgreementInstallmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreement?: boolean | CollectionCaseAgreementDefaultArgs<ExtArgs>
    payment?: boolean | CollectionCaseAgreementInstallment$paymentArgs<ExtArgs>
  }
  export type CollectionCaseAgreementInstallmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreement?: boolean | CollectionCaseAgreementDefaultArgs<ExtArgs>
    payment?: boolean | CollectionCaseAgreementInstallment$paymentArgs<ExtArgs>
  }

  export type $CollectionCaseAgreementInstallmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionCaseAgreementInstallment"
    objects: {
      agreement: Prisma.$CollectionCaseAgreementPayload<ExtArgs>
      payment: Prisma.$CollectionCasePaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agreement_id: string
      number: number
      due_date: Date
      amount: Prisma.Decimal
      status: $Enums.InstallmentStatus
      payment_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["collectionCaseAgreementInstallment"]>
    composites: {}
  }

  type CollectionCaseAgreementInstallmentGetPayload<S extends boolean | null | undefined | CollectionCaseAgreementInstallmentDefaultArgs> = $Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload, S>

  type CollectionCaseAgreementInstallmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionCaseAgreementInstallmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCaseAgreementInstallmentCountAggregateInputType | true
    }

  export interface CollectionCaseAgreementInstallmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionCaseAgreementInstallment'], meta: { name: 'CollectionCaseAgreementInstallment' } }
    /**
     * Find zero or one CollectionCaseAgreementInstallment that matches the filter.
     * @param {CollectionCaseAgreementInstallmentFindUniqueArgs} args - Arguments to find a CollectionCaseAgreementInstallment
     * @example
     * // Get one CollectionCaseAgreementInstallment
     * const collectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionCaseAgreementInstallmentFindUniqueArgs>(args: SelectSubset<T, CollectionCaseAgreementInstallmentFindUniqueArgs<ExtArgs>>): Prisma__CollectionCaseAgreementInstallmentClient<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionCaseAgreementInstallment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionCaseAgreementInstallmentFindUniqueOrThrowArgs} args - Arguments to find a CollectionCaseAgreementInstallment
     * @example
     * // Get one CollectionCaseAgreementInstallment
     * const collectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionCaseAgreementInstallmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionCaseAgreementInstallmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseAgreementInstallmentClient<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCaseAgreementInstallment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementInstallmentFindFirstArgs} args - Arguments to find a CollectionCaseAgreementInstallment
     * @example
     * // Get one CollectionCaseAgreementInstallment
     * const collectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionCaseAgreementInstallmentFindFirstArgs>(args?: SelectSubset<T, CollectionCaseAgreementInstallmentFindFirstArgs<ExtArgs>>): Prisma__CollectionCaseAgreementInstallmentClient<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionCaseAgreementInstallment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementInstallmentFindFirstOrThrowArgs} args - Arguments to find a CollectionCaseAgreementInstallment
     * @example
     * // Get one CollectionCaseAgreementInstallment
     * const collectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionCaseAgreementInstallmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionCaseAgreementInstallmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionCaseAgreementInstallmentClient<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionCaseAgreementInstallments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementInstallmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionCaseAgreementInstallments
     * const collectionCaseAgreementInstallments = await prisma.collectionCaseAgreementInstallment.findMany()
     * 
     * // Get first 10 CollectionCaseAgreementInstallments
     * const collectionCaseAgreementInstallments = await prisma.collectionCaseAgreementInstallment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionCaseAgreementInstallmentWithIdOnly = await prisma.collectionCaseAgreementInstallment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionCaseAgreementInstallmentFindManyArgs>(args?: SelectSubset<T, CollectionCaseAgreementInstallmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionCaseAgreementInstallment.
     * @param {CollectionCaseAgreementInstallmentCreateArgs} args - Arguments to create a CollectionCaseAgreementInstallment.
     * @example
     * // Create one CollectionCaseAgreementInstallment
     * const CollectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.create({
     *   data: {
     *     // ... data to create a CollectionCaseAgreementInstallment
     *   }
     * })
     * 
     */
    create<T extends CollectionCaseAgreementInstallmentCreateArgs>(args: SelectSubset<T, CollectionCaseAgreementInstallmentCreateArgs<ExtArgs>>): Prisma__CollectionCaseAgreementInstallmentClient<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionCaseAgreementInstallments.
     * @param {CollectionCaseAgreementInstallmentCreateManyArgs} args - Arguments to create many CollectionCaseAgreementInstallments.
     * @example
     * // Create many CollectionCaseAgreementInstallments
     * const collectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCaseAgreementInstallmentCreateManyArgs>(args?: SelectSubset<T, CollectionCaseAgreementInstallmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionCaseAgreementInstallments and returns the data saved in the database.
     * @param {CollectionCaseAgreementInstallmentCreateManyAndReturnArgs} args - Arguments to create many CollectionCaseAgreementInstallments.
     * @example
     * // Create many CollectionCaseAgreementInstallments
     * const collectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionCaseAgreementInstallments and only return the `id`
     * const collectionCaseAgreementInstallmentWithIdOnly = await prisma.collectionCaseAgreementInstallment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCaseAgreementInstallmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCaseAgreementInstallmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionCaseAgreementInstallment.
     * @param {CollectionCaseAgreementInstallmentDeleteArgs} args - Arguments to delete one CollectionCaseAgreementInstallment.
     * @example
     * // Delete one CollectionCaseAgreementInstallment
     * const CollectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.delete({
     *   where: {
     *     // ... filter to delete one CollectionCaseAgreementInstallment
     *   }
     * })
     * 
     */
    delete<T extends CollectionCaseAgreementInstallmentDeleteArgs>(args: SelectSubset<T, CollectionCaseAgreementInstallmentDeleteArgs<ExtArgs>>): Prisma__CollectionCaseAgreementInstallmentClient<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionCaseAgreementInstallment.
     * @param {CollectionCaseAgreementInstallmentUpdateArgs} args - Arguments to update one CollectionCaseAgreementInstallment.
     * @example
     * // Update one CollectionCaseAgreementInstallment
     * const collectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionCaseAgreementInstallmentUpdateArgs>(args: SelectSubset<T, CollectionCaseAgreementInstallmentUpdateArgs<ExtArgs>>): Prisma__CollectionCaseAgreementInstallmentClient<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionCaseAgreementInstallments.
     * @param {CollectionCaseAgreementInstallmentDeleteManyArgs} args - Arguments to filter CollectionCaseAgreementInstallments to delete.
     * @example
     * // Delete a few CollectionCaseAgreementInstallments
     * const { count } = await prisma.collectionCaseAgreementInstallment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionCaseAgreementInstallmentDeleteManyArgs>(args?: SelectSubset<T, CollectionCaseAgreementInstallmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCaseAgreementInstallments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementInstallmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionCaseAgreementInstallments
     * const collectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionCaseAgreementInstallmentUpdateManyArgs>(args: SelectSubset<T, CollectionCaseAgreementInstallmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionCaseAgreementInstallments and returns the data updated in the database.
     * @param {CollectionCaseAgreementInstallmentUpdateManyAndReturnArgs} args - Arguments to update many CollectionCaseAgreementInstallments.
     * @example
     * // Update many CollectionCaseAgreementInstallments
     * const collectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionCaseAgreementInstallments and only return the `id`
     * const collectionCaseAgreementInstallmentWithIdOnly = await prisma.collectionCaseAgreementInstallment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionCaseAgreementInstallmentUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionCaseAgreementInstallmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionCaseAgreementInstallment.
     * @param {CollectionCaseAgreementInstallmentUpsertArgs} args - Arguments to update or create a CollectionCaseAgreementInstallment.
     * @example
     * // Update or create a CollectionCaseAgreementInstallment
     * const collectionCaseAgreementInstallment = await prisma.collectionCaseAgreementInstallment.upsert({
     *   create: {
     *     // ... data to create a CollectionCaseAgreementInstallment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionCaseAgreementInstallment we want to update
     *   }
     * })
     */
    upsert<T extends CollectionCaseAgreementInstallmentUpsertArgs>(args: SelectSubset<T, CollectionCaseAgreementInstallmentUpsertArgs<ExtArgs>>): Prisma__CollectionCaseAgreementInstallmentClient<$Result.GetResult<Prisma.$CollectionCaseAgreementInstallmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionCaseAgreementInstallments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementInstallmentCountArgs} args - Arguments to filter CollectionCaseAgreementInstallments to count.
     * @example
     * // Count the number of CollectionCaseAgreementInstallments
     * const count = await prisma.collectionCaseAgreementInstallment.count({
     *   where: {
     *     // ... the filter for the CollectionCaseAgreementInstallments we want to count
     *   }
     * })
    **/
    count<T extends CollectionCaseAgreementInstallmentCountArgs>(
      args?: Subset<T, CollectionCaseAgreementInstallmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCaseAgreementInstallmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionCaseAgreementInstallment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementInstallmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionCaseAgreementInstallmentAggregateArgs>(args: Subset<T, CollectionCaseAgreementInstallmentAggregateArgs>): Prisma.PrismaPromise<GetCollectionCaseAgreementInstallmentAggregateType<T>>

    /**
     * Group by CollectionCaseAgreementInstallment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCaseAgreementInstallmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionCaseAgreementInstallmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionCaseAgreementInstallmentGroupByArgs['orderBy'] }
        : { orderBy?: CollectionCaseAgreementInstallmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionCaseAgreementInstallmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionCaseAgreementInstallmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionCaseAgreementInstallment model
   */
  readonly fields: CollectionCaseAgreementInstallmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionCaseAgreementInstallment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionCaseAgreementInstallmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agreement<T extends CollectionCaseAgreementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseAgreementDefaultArgs<ExtArgs>>): Prisma__CollectionCaseAgreementClient<$Result.GetResult<Prisma.$CollectionCaseAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment<T extends CollectionCaseAgreementInstallment$paymentArgs<ExtArgs> = {}>(args?: Subset<T, CollectionCaseAgreementInstallment$paymentArgs<ExtArgs>>): Prisma__CollectionCasePaymentClient<$Result.GetResult<Prisma.$CollectionCasePaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionCaseAgreementInstallment model
   */
  interface CollectionCaseAgreementInstallmentFieldRefs {
    readonly id: FieldRef<"CollectionCaseAgreementInstallment", 'String'>
    readonly agreement_id: FieldRef<"CollectionCaseAgreementInstallment", 'String'>
    readonly number: FieldRef<"CollectionCaseAgreementInstallment", 'Int'>
    readonly due_date: FieldRef<"CollectionCaseAgreementInstallment", 'DateTime'>
    readonly amount: FieldRef<"CollectionCaseAgreementInstallment", 'Decimal'>
    readonly status: FieldRef<"CollectionCaseAgreementInstallment", 'InstallmentStatus'>
    readonly payment_id: FieldRef<"CollectionCaseAgreementInstallment", 'String'>
    readonly created_at: FieldRef<"CollectionCaseAgreementInstallment", 'DateTime'>
    readonly updated_at: FieldRef<"CollectionCaseAgreementInstallment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionCaseAgreementInstallment findUnique
   */
  export type CollectionCaseAgreementInstallmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseAgreementInstallment to fetch.
     */
    where: CollectionCaseAgreementInstallmentWhereUniqueInput
  }

  /**
   * CollectionCaseAgreementInstallment findUniqueOrThrow
   */
  export type CollectionCaseAgreementInstallmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseAgreementInstallment to fetch.
     */
    where: CollectionCaseAgreementInstallmentWhereUniqueInput
  }

  /**
   * CollectionCaseAgreementInstallment findFirst
   */
  export type CollectionCaseAgreementInstallmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseAgreementInstallment to fetch.
     */
    where?: CollectionCaseAgreementInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseAgreementInstallments to fetch.
     */
    orderBy?: CollectionCaseAgreementInstallmentOrderByWithRelationInput | CollectionCaseAgreementInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCaseAgreementInstallments.
     */
    cursor?: CollectionCaseAgreementInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseAgreementInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseAgreementInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCaseAgreementInstallments.
     */
    distinct?: CollectionCaseAgreementInstallmentScalarFieldEnum | CollectionCaseAgreementInstallmentScalarFieldEnum[]
  }

  /**
   * CollectionCaseAgreementInstallment findFirstOrThrow
   */
  export type CollectionCaseAgreementInstallmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseAgreementInstallment to fetch.
     */
    where?: CollectionCaseAgreementInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseAgreementInstallments to fetch.
     */
    orderBy?: CollectionCaseAgreementInstallmentOrderByWithRelationInput | CollectionCaseAgreementInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionCaseAgreementInstallments.
     */
    cursor?: CollectionCaseAgreementInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseAgreementInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseAgreementInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionCaseAgreementInstallments.
     */
    distinct?: CollectionCaseAgreementInstallmentScalarFieldEnum | CollectionCaseAgreementInstallmentScalarFieldEnum[]
  }

  /**
   * CollectionCaseAgreementInstallment findMany
   */
  export type CollectionCaseAgreementInstallmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which CollectionCaseAgreementInstallments to fetch.
     */
    where?: CollectionCaseAgreementInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionCaseAgreementInstallments to fetch.
     */
    orderBy?: CollectionCaseAgreementInstallmentOrderByWithRelationInput | CollectionCaseAgreementInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionCaseAgreementInstallments.
     */
    cursor?: CollectionCaseAgreementInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionCaseAgreementInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionCaseAgreementInstallments.
     */
    skip?: number
    distinct?: CollectionCaseAgreementInstallmentScalarFieldEnum | CollectionCaseAgreementInstallmentScalarFieldEnum[]
  }

  /**
   * CollectionCaseAgreementInstallment create
   */
  export type CollectionCaseAgreementInstallmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CollectionCaseAgreementInstallment.
     */
    data: XOR<CollectionCaseAgreementInstallmentCreateInput, CollectionCaseAgreementInstallmentUncheckedCreateInput>
  }

  /**
   * CollectionCaseAgreementInstallment createMany
   */
  export type CollectionCaseAgreementInstallmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionCaseAgreementInstallments.
     */
    data: CollectionCaseAgreementInstallmentCreateManyInput | CollectionCaseAgreementInstallmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionCaseAgreementInstallment createManyAndReturn
   */
  export type CollectionCaseAgreementInstallmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionCaseAgreementInstallments.
     */
    data: CollectionCaseAgreementInstallmentCreateManyInput | CollectionCaseAgreementInstallmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCaseAgreementInstallment update
   */
  export type CollectionCaseAgreementInstallmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CollectionCaseAgreementInstallment.
     */
    data: XOR<CollectionCaseAgreementInstallmentUpdateInput, CollectionCaseAgreementInstallmentUncheckedUpdateInput>
    /**
     * Choose, which CollectionCaseAgreementInstallment to update.
     */
    where: CollectionCaseAgreementInstallmentWhereUniqueInput
  }

  /**
   * CollectionCaseAgreementInstallment updateMany
   */
  export type CollectionCaseAgreementInstallmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionCaseAgreementInstallments.
     */
    data: XOR<CollectionCaseAgreementInstallmentUpdateManyMutationInput, CollectionCaseAgreementInstallmentUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCaseAgreementInstallments to update
     */
    where?: CollectionCaseAgreementInstallmentWhereInput
    /**
     * Limit how many CollectionCaseAgreementInstallments to update.
     */
    limit?: number
  }

  /**
   * CollectionCaseAgreementInstallment updateManyAndReturn
   */
  export type CollectionCaseAgreementInstallmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * The data used to update CollectionCaseAgreementInstallments.
     */
    data: XOR<CollectionCaseAgreementInstallmentUpdateManyMutationInput, CollectionCaseAgreementInstallmentUncheckedUpdateManyInput>
    /**
     * Filter which CollectionCaseAgreementInstallments to update
     */
    where?: CollectionCaseAgreementInstallmentWhereInput
    /**
     * Limit how many CollectionCaseAgreementInstallments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionCaseAgreementInstallment upsert
   */
  export type CollectionCaseAgreementInstallmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CollectionCaseAgreementInstallment to update in case it exists.
     */
    where: CollectionCaseAgreementInstallmentWhereUniqueInput
    /**
     * In case the CollectionCaseAgreementInstallment found by the `where` argument doesn't exist, create a new CollectionCaseAgreementInstallment with this data.
     */
    create: XOR<CollectionCaseAgreementInstallmentCreateInput, CollectionCaseAgreementInstallmentUncheckedCreateInput>
    /**
     * In case the CollectionCaseAgreementInstallment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionCaseAgreementInstallmentUpdateInput, CollectionCaseAgreementInstallmentUncheckedUpdateInput>
  }

  /**
   * CollectionCaseAgreementInstallment delete
   */
  export type CollectionCaseAgreementInstallmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
    /**
     * Filter which CollectionCaseAgreementInstallment to delete.
     */
    where: CollectionCaseAgreementInstallmentWhereUniqueInput
  }

  /**
   * CollectionCaseAgreementInstallment deleteMany
   */
  export type CollectionCaseAgreementInstallmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionCaseAgreementInstallments to delete
     */
    where?: CollectionCaseAgreementInstallmentWhereInput
    /**
     * Limit how many CollectionCaseAgreementInstallments to delete.
     */
    limit?: number
  }

  /**
   * CollectionCaseAgreementInstallment.payment
   */
  export type CollectionCaseAgreementInstallment$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCasePayment
     */
    select?: CollectionCasePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCasePayment
     */
    omit?: CollectionCasePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCasePaymentInclude<ExtArgs> | null
    where?: CollectionCasePaymentWhereInput
  }

  /**
   * CollectionCaseAgreementInstallment without action
   */
  export type CollectionCaseAgreementInstallmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCaseAgreementInstallment
     */
    select?: CollectionCaseAgreementInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionCaseAgreementInstallment
     */
    omit?: CollectionCaseAgreementInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionCaseAgreementInstallmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subdomain: 'subdomain',
    contact_email: 'contact_email',
    country_code: 'country_code',
    kvk: 'kvk',
    legal_name: 'legal_name',
    address: 'address',
    city: 'city',
    logo_url: 'logo_url',
    number_of_employees: 'number_of_employees',
    phone: 'phone',
    website: 'website',
    terms_accepted: 'terms_accepted',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    fullname: 'fullname',
    phone: 'phone',
    tenant_id: 'tenant_id',
    role: 'role',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ParameterScalarFieldEnum: {
    id: 'id',
    collection_fee_rate: 'collection_fee_rate',
    abb_rate: 'abb_rate',
    company_aanmaning_term_days: 'company_aanmaning_term_days',
    consumer_aanmaning_term_days: 'consumer_aanmaning_term_days',
    company_sommatie_term_days: 'company_sommatie_term_days',
    consumer_sommatie_term_days: 'consumer_sommatie_term_days',
    small_company_price: 'small_company_price',
    small_company_pfc_contribution: 'small_company_pfc_contribution',
    large_company_price: 'large_company_price',
    large_company_pfc_contribution: 'large_company_pfc_contribution',
    company_aanmaning_penalty: 'company_aanmaning_penalty',
    natural_aanmaning_penalty: 'natural_aanmaning_penalty',
    company_sommatie_penalty: 'company_sommatie_penalty',
    natural_sommatie_penalty: 'natural_sommatie_penalty',
    company_reaction_limit_days: 'company_reaction_limit_days',
    company_no_reaction_penalty: 'company_no_reaction_penalty',
    natural_no_reaction_penalty: 'natural_no_reaction_penalty',
    company_payment_agreement_fee: 'company_payment_agreement_fee',
    natural_payment_agreement_fee: 'natural_payment_agreement_fee',
    invoice_number_length: 'invoice_number_length',
    invoice_prefix: 'invoice_prefix',
    invoice_sequence: 'invoice_sequence',
    bank_account: 'bank_account',
    bank_name: 'bank_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ParameterScalarFieldEnum = (typeof ParameterScalarFieldEnum)[keyof typeof ParameterScalarFieldEnum]


  export const VerdictScalarFieldEnum: {
    id: 'id',
    invoice_number: 'invoice_number',
    creditor_name: 'creditor_name',
    debtor_id: 'debtor_id',
    registration_number: 'registration_number',
    sentence_amount: 'sentence_amount',
    sentence_date: 'sentence_date',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    procesal_cost: 'procesal_cost',
    tenant_id: 'tenant_id',
    notes: 'notes',
    bailiff_id: 'bailiff_id'
  };

  export type VerdictScalarFieldEnum = (typeof VerdictScalarFieldEnum)[keyof typeof VerdictScalarFieldEnum]


  export const VerdictInterestScalarFieldEnum: {
    id: 'id',
    interest_type: 'interest_type',
    base_amount: 'base_amount',
    calculated_interest: 'calculated_interest',
    calculation_start: 'calculation_start',
    calculation_end: 'calculation_end',
    total_interest: 'total_interest',
    created_at: 'created_at',
    updated_at: 'updated_at',
    verdict_id: 'verdict_id'
  };

  export type VerdictInterestScalarFieldEnum = (typeof VerdictInterestScalarFieldEnum)[keyof typeof VerdictInterestScalarFieldEnum]


  export const VerdictInterestDetailsScalarFieldEnum: {
    id: 'id',
    period: 'period',
    period_start: 'period_start',
    period_end: 'period_end',
    days: 'days',
    annual_rate: 'annual_rate',
    proportional_rate: 'proportional_rate',
    base_amount: 'base_amount',
    interest: 'interest',
    total: 'total',
    verdict_interest_id: 'verdict_interest_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VerdictInterestDetailsScalarFieldEnum = (typeof VerdictInterestDetailsScalarFieldEnum)[keyof typeof VerdictInterestDetailsScalarFieldEnum]


  export const VerdictEmbargoScalarFieldEnum: {
    id: 'id',
    verdict_id: 'verdict_id',
    company_name: 'company_name',
    company_phone: 'company_phone',
    company_email: 'company_email',
    company_address: 'company_address',
    embargo_type: 'embargo_type',
    embargo_date: 'embargo_date',
    embargo_amount: 'embargo_amount',
    total_amount: 'total_amount',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VerdictEmbargoScalarFieldEnum = (typeof VerdictEmbargoScalarFieldEnum)[keyof typeof VerdictEmbargoScalarFieldEnum]


  export const VerdictBailiffServicesScalarFieldEnum: {
    id: 'id',
    verdict_id: 'verdict_id',
    service_type: 'service_type',
    service_cost: 'service_cost',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VerdictBailiffServicesScalarFieldEnum = (typeof VerdictBailiffServicesScalarFieldEnum)[keyof typeof VerdictBailiffServicesScalarFieldEnum]


  export const VerdictAttachmentScalarFieldEnum: {
    id: 'id',
    verdict_id: 'verdict_id',
    file_path: 'file_path',
    file_size: 'file_size',
    created_at: 'created_at',
    updated_at: 'updated_at',
    file_name: 'file_name'
  };

  export type VerdictAttachmentScalarFieldEnum = (typeof VerdictAttachmentScalarFieldEnum)[keyof typeof VerdictAttachmentScalarFieldEnum]


  export const InterestTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    calculation_type: 'calculation_type'
  };

  export type InterestTypeScalarFieldEnum = (typeof InterestTypeScalarFieldEnum)[keyof typeof InterestTypeScalarFieldEnum]


  export const InterestDetailScalarFieldEnum: {
    id: 'id',
    date: 'date',
    rate: 'rate',
    interest_type_id: 'interest_type_id'
  };

  export type InterestDetailScalarFieldEnum = (typeof InterestDetailScalarFieldEnum)[keyof typeof InterestDetailScalarFieldEnum]


  export const BillingInvoiceScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    invoice_number: 'invoice_number',
    amount: 'amount',
    currency: 'currency',
    issue_date: 'issue_date',
    due_date: 'due_date',
    description: 'description',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BillingInvoiceScalarFieldEnum = (typeof BillingInvoiceScalarFieldEnum)[keyof typeof BillingInvoiceScalarFieldEnum]


  export const BillingInvoiceDetailScalarFieldEnum: {
    id: 'id',
    item_description: 'item_description',
    item_quantity: 'item_quantity',
    item_unit_price: 'item_unit_price',
    item_total_price: 'item_total_price',
    item_tax_rate: 'item_tax_rate',
    item_tax_amount: 'item_tax_amount',
    item_total_with_tax: 'item_total_with_tax',
    created_at: 'created_at',
    updated_at: 'updated_at',
    billing_invoice_id: 'billing_invoice_id'
  };

  export type BillingInvoiceDetailScalarFieldEnum = (typeof BillingInvoiceDetailScalarFieldEnum)[keyof typeof BillingInvoiceDetailScalarFieldEnum]


  export const BillingPaymentScalarFieldEnum: {
    id: 'id',
    payment_date: 'payment_date',
    amount: 'amount',
    payment_method: 'payment_method',
    transaction_id: 'transaction_id',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    billing_invoice_id: 'billing_invoice_id'
  };

  export type BillingPaymentScalarFieldEnum = (typeof BillingPaymentScalarFieldEnum)[keyof typeof BillingPaymentScalarFieldEnum]


  export const CollectionCaseScalarFieldEnum: {
    id: 'id',
    reference_number: 'reference_number',
    issue_date: 'issue_date',
    due_date: 'due_date',
    reminder1_sent_at: 'reminder1_sent_at',
    reminder1_due_date: 'reminder1_due_date',
    reminder2_sent_at: 'reminder2_sent_at',
    reminder2_due_date: 'reminder2_due_date',
    tenant_id: 'tenant_id',
    debtor_id: 'debtor_id',
    amount_original: 'amount_original',
    amount_due: 'amount_due',
    amount_to_receive: 'amount_to_receive',
    status: 'status',
    notification_status: 'notification_status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CollectionCaseScalarFieldEnum = (typeof CollectionCaseScalarFieldEnum)[keyof typeof CollectionCaseScalarFieldEnum]


  export const CollectionCasePenaltyScalarFieldEnum: {
    id: 'id',
    collection_case_id: 'collection_case_id',
    description: 'description',
    amount: 'amount',
    date_applied: 'date_applied',
    is_paid: 'is_paid',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CollectionCasePenaltyScalarFieldEnum = (typeof CollectionCasePenaltyScalarFieldEnum)[keyof typeof CollectionCasePenaltyScalarFieldEnum]


  export const CollectionCaseNotificationScalarFieldEnum: {
    id: 'id',
    collection_case_id: 'collection_case_id',
    type: 'type',
    title: 'title',
    message: 'message',
    sent_at: 'sent_at',
    read: 'read',
    created_at: 'created_at'
  };

  export type CollectionCaseNotificationScalarFieldEnum = (typeof CollectionCaseNotificationScalarFieldEnum)[keyof typeof CollectionCaseNotificationScalarFieldEnum]


  export const CollectionCasePaymentScalarFieldEnum: {
    id: 'id',
    method: 'method',
    amount: 'amount',
    collection_case_id: 'collection_case_id',
    payment_date: 'payment_date',
    reference_number: 'reference_number',
    agreement_id: 'agreement_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CollectionCasePaymentScalarFieldEnum = (typeof CollectionCasePaymentScalarFieldEnum)[keyof typeof CollectionCasePaymentScalarFieldEnum]


  export const DebtorScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    user_id: 'user_id',
    fullname: 'fullname',
    email: 'email',
    phone: 'phone',
    address: 'address',
    person_type: 'person_type',
    identification_type: 'identification_type',
    identification: 'identification',
    total_income: 'total_income',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DebtorScalarFieldEnum = (typeof DebtorScalarFieldEnum)[keyof typeof DebtorScalarFieldEnum]


  export const ChatRoomScalarFieldEnum: {
    id: 'id',
    tenant_id: 'tenant_id',
    collection_case_id: 'collection_case_id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChatRoomScalarFieldEnum = (typeof ChatRoomScalarFieldEnum)[keyof typeof ChatRoomScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    room_id: 'room_id',
    sender_id: 'sender_id',
    message: 'message',
    file_url: 'file_url',
    file_name: 'file_name',
    timestamp: 'timestamp',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const DebtorIncomeScalarFieldEnum: {
    id: 'id',
    debtor_id: 'debtor_id',
    amount: 'amount',
    source: 'source',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DebtorIncomeScalarFieldEnum = (typeof DebtorIncomeScalarFieldEnum)[keyof typeof DebtorIncomeScalarFieldEnum]


  export const CollectionCaseAgreementScalarFieldEnum: {
    id: 'id',
    collection_case_id: 'collection_case_id',
    debtor_id: 'debtor_id',
    total_amount: 'total_amount',
    installment_amount: 'installment_amount',
    installments_count: 'installments_count',
    start_date: 'start_date',
    end_date: 'end_date',
    status: 'status',
    tenant_id: 'tenant_id',
    comment: 'comment',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CollectionCaseAgreementScalarFieldEnum = (typeof CollectionCaseAgreementScalarFieldEnum)[keyof typeof CollectionCaseAgreementScalarFieldEnum]


  export const CollectionCaseAgreementInstallmentScalarFieldEnum: {
    id: 'id',
    agreement_id: 'agreement_id',
    number: 'number',
    due_date: 'due_date',
    amount: 'amount',
    status: 'status',
    payment_id: 'payment_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CollectionCaseAgreementInstallmentScalarFieldEnum = (typeof CollectionCaseAgreementInstallmentScalarFieldEnum)[keyof typeof CollectionCaseAgreementInstallmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'roleEnum'
   */
  export type EnumroleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'roleEnum'>
    


  /**
   * Reference to a field of type 'roleEnum[]'
   */
  export type ListEnumroleEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'roleEnum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'VerdictStatus'
   */
  export type EnumVerdictStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerdictStatus'>
    


  /**
   * Reference to a field of type 'VerdictStatus[]'
   */
  export type ListEnumVerdictStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerdictStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'CalculationTypeEnum'
   */
  export type EnumCalculationTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalculationTypeEnum'>
    


  /**
   * Reference to a field of type 'CalculationTypeEnum[]'
   */
  export type ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalculationTypeEnum[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'CollectionCaseStatus'
   */
  export type EnumCollectionCaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CollectionCaseStatus'>
    


  /**
   * Reference to a field of type 'CollectionCaseStatus[]'
   */
  export type ListEnumCollectionCaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CollectionCaseStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PersonType'
   */
  export type EnumPersonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonType'>
    


  /**
   * Reference to a field of type 'PersonType[]'
   */
  export type ListEnumPersonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonType[]'>
    


  /**
   * Reference to a field of type 'IdentificationType'
   */
  export type EnumIdentificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentificationType'>
    


  /**
   * Reference to a field of type 'IdentificationType[]'
   */
  export type ListEnumIdentificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentificationType[]'>
    


  /**
   * Reference to a field of type 'AgreementStatus'
   */
  export type EnumAgreementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgreementStatus'>
    


  /**
   * Reference to a field of type 'AgreementStatus[]'
   */
  export type ListEnumAgreementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgreementStatus[]'>
    


  /**
   * Reference to a field of type 'InstallmentStatus'
   */
  export type EnumInstallmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstallmentStatus'>
    


  /**
   * Reference to a field of type 'InstallmentStatus[]'
   */
  export type ListEnumInstallmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstallmentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    subdomain?: StringFilter<"Tenant"> | string
    contact_email?: StringFilter<"Tenant"> | string
    country_code?: StringFilter<"Tenant"> | string
    kvk?: StringNullableFilter<"Tenant"> | string | null
    legal_name?: StringNullableFilter<"Tenant"> | string | null
    address?: StringNullableFilter<"Tenant"> | string | null
    city?: StringNullableFilter<"Tenant"> | string | null
    logo_url?: StringNullableFilter<"Tenant"> | string | null
    number_of_employees?: IntNullableFilter<"Tenant"> | number | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    website?: StringNullableFilter<"Tenant"> | string | null
    terms_accepted?: BoolFilter<"Tenant"> | boolean
    is_active?: BoolFilter<"Tenant"> | boolean
    created_at?: DateTimeFilter<"Tenant"> | Date | string
    updated_at?: DateTimeFilter<"Tenant"> | Date | string
    billing_invoice?: BillingInvoiceListRelationFilter
    collection_cases?: CollectionCaseListRelationFilter
    debtors?: DebtorListRelationFilter
    verdicts?: VerdictListRelationFilter
    users?: UserListRelationFilter
    chat_rooms?: ChatRoomListRelationFilter
    agreements?: CollectionCaseAgreementListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    contact_email?: SortOrder
    country_code?: SortOrder
    kvk?: SortOrderInput | SortOrder
    legal_name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    number_of_employees?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    terms_accepted?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_invoice?: BillingInvoiceOrderByRelationAggregateInput
    collection_cases?: CollectionCaseOrderByRelationAggregateInput
    debtors?: DebtorOrderByRelationAggregateInput
    verdicts?: VerdictOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    chat_rooms?: ChatRoomOrderByRelationAggregateInput
    agreements?: CollectionCaseAgreementOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subdomain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    contact_email?: StringFilter<"Tenant"> | string
    country_code?: StringFilter<"Tenant"> | string
    kvk?: StringNullableFilter<"Tenant"> | string | null
    legal_name?: StringNullableFilter<"Tenant"> | string | null
    address?: StringNullableFilter<"Tenant"> | string | null
    city?: StringNullableFilter<"Tenant"> | string | null
    logo_url?: StringNullableFilter<"Tenant"> | string | null
    number_of_employees?: IntNullableFilter<"Tenant"> | number | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    website?: StringNullableFilter<"Tenant"> | string | null
    terms_accepted?: BoolFilter<"Tenant"> | boolean
    is_active?: BoolFilter<"Tenant"> | boolean
    created_at?: DateTimeFilter<"Tenant"> | Date | string
    updated_at?: DateTimeFilter<"Tenant"> | Date | string
    billing_invoice?: BillingInvoiceListRelationFilter
    collection_cases?: CollectionCaseListRelationFilter
    debtors?: DebtorListRelationFilter
    verdicts?: VerdictListRelationFilter
    users?: UserListRelationFilter
    chat_rooms?: ChatRoomListRelationFilter
    agreements?: CollectionCaseAgreementListRelationFilter
  }, "id" | "subdomain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    contact_email?: SortOrder
    country_code?: SortOrder
    kvk?: SortOrderInput | SortOrder
    legal_name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    number_of_employees?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    terms_accepted?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _avg?: TenantAvgOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
    _sum?: TenantSumOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    subdomain?: StringWithAggregatesFilter<"Tenant"> | string
    contact_email?: StringWithAggregatesFilter<"Tenant"> | string
    country_code?: StringWithAggregatesFilter<"Tenant"> | string
    kvk?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    legal_name?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    address?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    city?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    logo_url?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    number_of_employees?: IntNullableWithAggregatesFilter<"Tenant"> | number | null
    phone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    website?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    terms_accepted?: BoolWithAggregatesFilter<"Tenant"> | boolean
    is_active?: BoolWithAggregatesFilter<"Tenant"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password_hash?: StringNullableFilter<"User"> | string | null
    fullname?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    tenant_id?: StringFilter<"User"> | string
    role?: EnumroleEnumFilter<"User"> | $Enums.roleEnum
    is_active?: BoolFilter<"User"> | boolean
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    debtors?: DebtorListRelationFilter
    verdict_bailiffs?: VerdictListRelationFilter
    messages?: ChatMessageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    tenant_id?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    debtors?: DebtorOrderByRelationAggregateInput
    verdict_bailiffs?: VerdictOrderByRelationAggregateInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringFilter<"User"> | string
    password_hash?: StringNullableFilter<"User"> | string | null
    fullname?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    tenant_id?: StringFilter<"User"> | string
    role?: EnumroleEnumFilter<"User"> | $Enums.roleEnum
    is_active?: BoolFilter<"User"> | boolean
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    debtors?: DebtorListRelationFilter
    verdict_bailiffs?: VerdictListRelationFilter
    messages?: ChatMessageListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrderInput | SortOrder
    fullname?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    tenant_id?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullname?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    tenant_id?: StringWithAggregatesFilter<"User"> | string
    role?: EnumroleEnumWithAggregatesFilter<"User"> | $Enums.roleEnum
    is_active?: BoolWithAggregatesFilter<"User"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ParameterWhereInput = {
    AND?: ParameterWhereInput | ParameterWhereInput[]
    OR?: ParameterWhereInput[]
    NOT?: ParameterWhereInput | ParameterWhereInput[]
    id?: StringFilter<"Parameter"> | string
    collection_fee_rate?: FloatFilter<"Parameter"> | number
    abb_rate?: FloatFilter<"Parameter"> | number
    company_aanmaning_term_days?: IntFilter<"Parameter"> | number
    consumer_aanmaning_term_days?: IntFilter<"Parameter"> | number
    company_sommatie_term_days?: IntFilter<"Parameter"> | number
    consumer_sommatie_term_days?: IntFilter<"Parameter"> | number
    small_company_price?: FloatFilter<"Parameter"> | number
    small_company_pfc_contribution?: FloatFilter<"Parameter"> | number
    large_company_price?: FloatFilter<"Parameter"> | number
    large_company_pfc_contribution?: FloatFilter<"Parameter"> | number
    company_aanmaning_penalty?: FloatFilter<"Parameter"> | number
    natural_aanmaning_penalty?: FloatFilter<"Parameter"> | number
    company_sommatie_penalty?: FloatFilter<"Parameter"> | number
    natural_sommatie_penalty?: FloatFilter<"Parameter"> | number
    company_reaction_limit_days?: IntFilter<"Parameter"> | number
    company_no_reaction_penalty?: FloatFilter<"Parameter"> | number
    natural_no_reaction_penalty?: FloatFilter<"Parameter"> | number
    company_payment_agreement_fee?: FloatFilter<"Parameter"> | number
    natural_payment_agreement_fee?: FloatFilter<"Parameter"> | number
    invoice_number_length?: IntFilter<"Parameter"> | number
    invoice_prefix?: StringFilter<"Parameter"> | string
    invoice_sequence?: IntFilter<"Parameter"> | number
    bank_account?: StringFilter<"Parameter"> | string
    bank_name?: StringFilter<"Parameter"> | string
    created_at?: DateTimeFilter<"Parameter"> | Date | string
    updated_at?: DateTimeFilter<"Parameter"> | Date | string
  }

  export type ParameterOrderByWithRelationInput = {
    id?: SortOrder
    collection_fee_rate?: SortOrder
    abb_rate?: SortOrder
    company_aanmaning_term_days?: SortOrder
    consumer_aanmaning_term_days?: SortOrder
    company_sommatie_term_days?: SortOrder
    consumer_sommatie_term_days?: SortOrder
    small_company_price?: SortOrder
    small_company_pfc_contribution?: SortOrder
    large_company_price?: SortOrder
    large_company_pfc_contribution?: SortOrder
    company_aanmaning_penalty?: SortOrder
    natural_aanmaning_penalty?: SortOrder
    company_sommatie_penalty?: SortOrder
    natural_sommatie_penalty?: SortOrder
    company_reaction_limit_days?: SortOrder
    company_no_reaction_penalty?: SortOrder
    natural_no_reaction_penalty?: SortOrder
    company_payment_agreement_fee?: SortOrder
    natural_payment_agreement_fee?: SortOrder
    invoice_number_length?: SortOrder
    invoice_prefix?: SortOrder
    invoice_sequence?: SortOrder
    bank_account?: SortOrder
    bank_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ParameterWhereInput | ParameterWhereInput[]
    OR?: ParameterWhereInput[]
    NOT?: ParameterWhereInput | ParameterWhereInput[]
    collection_fee_rate?: FloatFilter<"Parameter"> | number
    abb_rate?: FloatFilter<"Parameter"> | number
    company_aanmaning_term_days?: IntFilter<"Parameter"> | number
    consumer_aanmaning_term_days?: IntFilter<"Parameter"> | number
    company_sommatie_term_days?: IntFilter<"Parameter"> | number
    consumer_sommatie_term_days?: IntFilter<"Parameter"> | number
    small_company_price?: FloatFilter<"Parameter"> | number
    small_company_pfc_contribution?: FloatFilter<"Parameter"> | number
    large_company_price?: FloatFilter<"Parameter"> | number
    large_company_pfc_contribution?: FloatFilter<"Parameter"> | number
    company_aanmaning_penalty?: FloatFilter<"Parameter"> | number
    natural_aanmaning_penalty?: FloatFilter<"Parameter"> | number
    company_sommatie_penalty?: FloatFilter<"Parameter"> | number
    natural_sommatie_penalty?: FloatFilter<"Parameter"> | number
    company_reaction_limit_days?: IntFilter<"Parameter"> | number
    company_no_reaction_penalty?: FloatFilter<"Parameter"> | number
    natural_no_reaction_penalty?: FloatFilter<"Parameter"> | number
    company_payment_agreement_fee?: FloatFilter<"Parameter"> | number
    natural_payment_agreement_fee?: FloatFilter<"Parameter"> | number
    invoice_number_length?: IntFilter<"Parameter"> | number
    invoice_prefix?: StringFilter<"Parameter"> | string
    invoice_sequence?: IntFilter<"Parameter"> | number
    bank_account?: StringFilter<"Parameter"> | string
    bank_name?: StringFilter<"Parameter"> | string
    created_at?: DateTimeFilter<"Parameter"> | Date | string
    updated_at?: DateTimeFilter<"Parameter"> | Date | string
  }, "id">

  export type ParameterOrderByWithAggregationInput = {
    id?: SortOrder
    collection_fee_rate?: SortOrder
    abb_rate?: SortOrder
    company_aanmaning_term_days?: SortOrder
    consumer_aanmaning_term_days?: SortOrder
    company_sommatie_term_days?: SortOrder
    consumer_sommatie_term_days?: SortOrder
    small_company_price?: SortOrder
    small_company_pfc_contribution?: SortOrder
    large_company_price?: SortOrder
    large_company_pfc_contribution?: SortOrder
    company_aanmaning_penalty?: SortOrder
    natural_aanmaning_penalty?: SortOrder
    company_sommatie_penalty?: SortOrder
    natural_sommatie_penalty?: SortOrder
    company_reaction_limit_days?: SortOrder
    company_no_reaction_penalty?: SortOrder
    natural_no_reaction_penalty?: SortOrder
    company_payment_agreement_fee?: SortOrder
    natural_payment_agreement_fee?: SortOrder
    invoice_number_length?: SortOrder
    invoice_prefix?: SortOrder
    invoice_sequence?: SortOrder
    bank_account?: SortOrder
    bank_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ParameterCountOrderByAggregateInput
    _avg?: ParameterAvgOrderByAggregateInput
    _max?: ParameterMaxOrderByAggregateInput
    _min?: ParameterMinOrderByAggregateInput
    _sum?: ParameterSumOrderByAggregateInput
  }

  export type ParameterScalarWhereWithAggregatesInput = {
    AND?: ParameterScalarWhereWithAggregatesInput | ParameterScalarWhereWithAggregatesInput[]
    OR?: ParameterScalarWhereWithAggregatesInput[]
    NOT?: ParameterScalarWhereWithAggregatesInput | ParameterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parameter"> | string
    collection_fee_rate?: FloatWithAggregatesFilter<"Parameter"> | number
    abb_rate?: FloatWithAggregatesFilter<"Parameter"> | number
    company_aanmaning_term_days?: IntWithAggregatesFilter<"Parameter"> | number
    consumer_aanmaning_term_days?: IntWithAggregatesFilter<"Parameter"> | number
    company_sommatie_term_days?: IntWithAggregatesFilter<"Parameter"> | number
    consumer_sommatie_term_days?: IntWithAggregatesFilter<"Parameter"> | number
    small_company_price?: FloatWithAggregatesFilter<"Parameter"> | number
    small_company_pfc_contribution?: FloatWithAggregatesFilter<"Parameter"> | number
    large_company_price?: FloatWithAggregatesFilter<"Parameter"> | number
    large_company_pfc_contribution?: FloatWithAggregatesFilter<"Parameter"> | number
    company_aanmaning_penalty?: FloatWithAggregatesFilter<"Parameter"> | number
    natural_aanmaning_penalty?: FloatWithAggregatesFilter<"Parameter"> | number
    company_sommatie_penalty?: FloatWithAggregatesFilter<"Parameter"> | number
    natural_sommatie_penalty?: FloatWithAggregatesFilter<"Parameter"> | number
    company_reaction_limit_days?: IntWithAggregatesFilter<"Parameter"> | number
    company_no_reaction_penalty?: FloatWithAggregatesFilter<"Parameter"> | number
    natural_no_reaction_penalty?: FloatWithAggregatesFilter<"Parameter"> | number
    company_payment_agreement_fee?: FloatWithAggregatesFilter<"Parameter"> | number
    natural_payment_agreement_fee?: FloatWithAggregatesFilter<"Parameter"> | number
    invoice_number_length?: IntWithAggregatesFilter<"Parameter"> | number
    invoice_prefix?: StringWithAggregatesFilter<"Parameter"> | string
    invoice_sequence?: IntWithAggregatesFilter<"Parameter"> | number
    bank_account?: StringWithAggregatesFilter<"Parameter"> | string
    bank_name?: StringWithAggregatesFilter<"Parameter"> | string
    created_at?: DateTimeWithAggregatesFilter<"Parameter"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Parameter"> | Date | string
  }

  export type VerdictWhereInput = {
    AND?: VerdictWhereInput | VerdictWhereInput[]
    OR?: VerdictWhereInput[]
    NOT?: VerdictWhereInput | VerdictWhereInput[]
    id?: StringFilter<"Verdict"> | string
    invoice_number?: StringFilter<"Verdict"> | string
    creditor_name?: StringFilter<"Verdict"> | string
    debtor_id?: StringFilter<"Verdict"> | string
    registration_number?: StringFilter<"Verdict"> | string
    sentence_amount?: FloatFilter<"Verdict"> | number
    sentence_date?: DateTimeFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusFilter<"Verdict"> | $Enums.VerdictStatus
    created_at?: DateTimeFilter<"Verdict"> | Date | string
    updated_at?: DateTimeFilter<"Verdict"> | Date | string
    procesal_cost?: FloatNullableFilter<"Verdict"> | number | null
    tenant_id?: StringFilter<"Verdict"> | string
    notes?: StringNullableFilter<"Verdict"> | string | null
    bailiff_id?: StringNullableFilter<"Verdict"> | string | null
    bailiff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    attachments?: VerdictAttachmentListRelationFilter
    bailiff_services?: VerdictBailiffServicesListRelationFilter
    verdict_embargo?: VerdictEmbargoListRelationFilter
    verdict_interest?: VerdictInterestListRelationFilter
  }

  export type VerdictOrderByWithRelationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    creditor_name?: SortOrder
    debtor_id?: SortOrder
    registration_number?: SortOrder
    sentence_amount?: SortOrder
    sentence_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    procesal_cost?: SortOrderInput | SortOrder
    tenant_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    bailiff_id?: SortOrderInput | SortOrder
    bailiff?: UserOrderByWithRelationInput
    debtor?: DebtorOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    attachments?: VerdictAttachmentOrderByRelationAggregateInput
    bailiff_services?: VerdictBailiffServicesOrderByRelationAggregateInput
    verdict_embargo?: VerdictEmbargoOrderByRelationAggregateInput
    verdict_interest?: VerdictInterestOrderByRelationAggregateInput
  }

  export type VerdictWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictWhereInput | VerdictWhereInput[]
    OR?: VerdictWhereInput[]
    NOT?: VerdictWhereInput | VerdictWhereInput[]
    invoice_number?: StringFilter<"Verdict"> | string
    creditor_name?: StringFilter<"Verdict"> | string
    debtor_id?: StringFilter<"Verdict"> | string
    registration_number?: StringFilter<"Verdict"> | string
    sentence_amount?: FloatFilter<"Verdict"> | number
    sentence_date?: DateTimeFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusFilter<"Verdict"> | $Enums.VerdictStatus
    created_at?: DateTimeFilter<"Verdict"> | Date | string
    updated_at?: DateTimeFilter<"Verdict"> | Date | string
    procesal_cost?: FloatNullableFilter<"Verdict"> | number | null
    tenant_id?: StringFilter<"Verdict"> | string
    notes?: StringNullableFilter<"Verdict"> | string | null
    bailiff_id?: StringNullableFilter<"Verdict"> | string | null
    bailiff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    attachments?: VerdictAttachmentListRelationFilter
    bailiff_services?: VerdictBailiffServicesListRelationFilter
    verdict_embargo?: VerdictEmbargoListRelationFilter
    verdict_interest?: VerdictInterestListRelationFilter
  }, "id">

  export type VerdictOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    creditor_name?: SortOrder
    debtor_id?: SortOrder
    registration_number?: SortOrder
    sentence_amount?: SortOrder
    sentence_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    procesal_cost?: SortOrderInput | SortOrder
    tenant_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    bailiff_id?: SortOrderInput | SortOrder
    _count?: VerdictCountOrderByAggregateInput
    _avg?: VerdictAvgOrderByAggregateInput
    _max?: VerdictMaxOrderByAggregateInput
    _min?: VerdictMinOrderByAggregateInput
    _sum?: VerdictSumOrderByAggregateInput
  }

  export type VerdictScalarWhereWithAggregatesInput = {
    AND?: VerdictScalarWhereWithAggregatesInput | VerdictScalarWhereWithAggregatesInput[]
    OR?: VerdictScalarWhereWithAggregatesInput[]
    NOT?: VerdictScalarWhereWithAggregatesInput | VerdictScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verdict"> | string
    invoice_number?: StringWithAggregatesFilter<"Verdict"> | string
    creditor_name?: StringWithAggregatesFilter<"Verdict"> | string
    debtor_id?: StringWithAggregatesFilter<"Verdict"> | string
    registration_number?: StringWithAggregatesFilter<"Verdict"> | string
    sentence_amount?: FloatWithAggregatesFilter<"Verdict"> | number
    sentence_date?: DateTimeWithAggregatesFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusWithAggregatesFilter<"Verdict"> | $Enums.VerdictStatus
    created_at?: DateTimeWithAggregatesFilter<"Verdict"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Verdict"> | Date | string
    procesal_cost?: FloatNullableWithAggregatesFilter<"Verdict"> | number | null
    tenant_id?: StringWithAggregatesFilter<"Verdict"> | string
    notes?: StringNullableWithAggregatesFilter<"Verdict"> | string | null
    bailiff_id?: StringNullableWithAggregatesFilter<"Verdict"> | string | null
  }

  export type VerdictInterestWhereInput = {
    AND?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    OR?: VerdictInterestWhereInput[]
    NOT?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    id?: StringFilter<"VerdictInterest"> | string
    interest_type?: IntFilter<"VerdictInterest"> | number
    base_amount?: FloatFilter<"VerdictInterest"> | number
    calculated_interest?: FloatNullableFilter<"VerdictInterest"> | number | null
    calculation_start?: DateTimeFilter<"VerdictInterest"> | Date | string
    calculation_end?: DateTimeFilter<"VerdictInterest"> | Date | string
    total_interest?: FloatFilter<"VerdictInterest"> | number
    created_at?: DateTimeFilter<"VerdictInterest"> | Date | string
    updated_at?: DateTimeFilter<"VerdictInterest"> | Date | string
    verdict_id?: StringNullableFilter<"VerdictInterest"> | string | null
    verdict?: XOR<VerdictNullableScalarRelationFilter, VerdictWhereInput> | null
    details?: VerdictInterestDetailsListRelationFilter
  }

  export type VerdictInterestOrderByWithRelationInput = {
    id?: SortOrder
    interest_type?: SortOrder
    base_amount?: SortOrder
    calculated_interest?: SortOrderInput | SortOrder
    calculation_start?: SortOrder
    calculation_end?: SortOrder
    total_interest?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verdict_id?: SortOrderInput | SortOrder
    verdict?: VerdictOrderByWithRelationInput
    details?: VerdictInterestDetailsOrderByRelationAggregateInput
  }

  export type VerdictInterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    OR?: VerdictInterestWhereInput[]
    NOT?: VerdictInterestWhereInput | VerdictInterestWhereInput[]
    interest_type?: IntFilter<"VerdictInterest"> | number
    base_amount?: FloatFilter<"VerdictInterest"> | number
    calculated_interest?: FloatNullableFilter<"VerdictInterest"> | number | null
    calculation_start?: DateTimeFilter<"VerdictInterest"> | Date | string
    calculation_end?: DateTimeFilter<"VerdictInterest"> | Date | string
    total_interest?: FloatFilter<"VerdictInterest"> | number
    created_at?: DateTimeFilter<"VerdictInterest"> | Date | string
    updated_at?: DateTimeFilter<"VerdictInterest"> | Date | string
    verdict_id?: StringNullableFilter<"VerdictInterest"> | string | null
    verdict?: XOR<VerdictNullableScalarRelationFilter, VerdictWhereInput> | null
    details?: VerdictInterestDetailsListRelationFilter
  }, "id">

  export type VerdictInterestOrderByWithAggregationInput = {
    id?: SortOrder
    interest_type?: SortOrder
    base_amount?: SortOrder
    calculated_interest?: SortOrderInput | SortOrder
    calculation_start?: SortOrder
    calculation_end?: SortOrder
    total_interest?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verdict_id?: SortOrderInput | SortOrder
    _count?: VerdictInterestCountOrderByAggregateInput
    _avg?: VerdictInterestAvgOrderByAggregateInput
    _max?: VerdictInterestMaxOrderByAggregateInput
    _min?: VerdictInterestMinOrderByAggregateInput
    _sum?: VerdictInterestSumOrderByAggregateInput
  }

  export type VerdictInterestScalarWhereWithAggregatesInput = {
    AND?: VerdictInterestScalarWhereWithAggregatesInput | VerdictInterestScalarWhereWithAggregatesInput[]
    OR?: VerdictInterestScalarWhereWithAggregatesInput[]
    NOT?: VerdictInterestScalarWhereWithAggregatesInput | VerdictInterestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictInterest"> | string
    interest_type?: IntWithAggregatesFilter<"VerdictInterest"> | number
    base_amount?: FloatWithAggregatesFilter<"VerdictInterest"> | number
    calculated_interest?: FloatNullableWithAggregatesFilter<"VerdictInterest"> | number | null
    calculation_start?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    calculation_end?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    total_interest?: FloatWithAggregatesFilter<"VerdictInterest"> | number
    created_at?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VerdictInterest"> | Date | string
    verdict_id?: StringNullableWithAggregatesFilter<"VerdictInterest"> | string | null
  }

  export type VerdictInterestDetailsWhereInput = {
    AND?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    OR?: VerdictInterestDetailsWhereInput[]
    NOT?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    id?: StringFilter<"VerdictInterestDetails"> | string
    period?: StringFilter<"VerdictInterestDetails"> | string
    period_start?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    period_end?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    days?: IntFilter<"VerdictInterestDetails"> | number
    annual_rate?: FloatFilter<"VerdictInterestDetails"> | number
    proportional_rate?: FloatFilter<"VerdictInterestDetails"> | number
    base_amount?: FloatFilter<"VerdictInterestDetails"> | number
    interest?: FloatFilter<"VerdictInterestDetails"> | number
    total?: FloatFilter<"VerdictInterestDetails"> | number
    verdict_interest_id?: StringFilter<"VerdictInterestDetails"> | string
    created_at?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    updated_at?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    verdict_interest?: XOR<VerdictInterestScalarRelationFilter, VerdictInterestWhereInput>
  }

  export type VerdictInterestDetailsOrderByWithRelationInput = {
    id?: SortOrder
    period?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    days?: SortOrder
    annual_rate?: SortOrder
    proportional_rate?: SortOrder
    base_amount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdict_interest_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verdict_interest?: VerdictInterestOrderByWithRelationInput
  }

  export type VerdictInterestDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    OR?: VerdictInterestDetailsWhereInput[]
    NOT?: VerdictInterestDetailsWhereInput | VerdictInterestDetailsWhereInput[]
    period?: StringFilter<"VerdictInterestDetails"> | string
    period_start?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    period_end?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    days?: IntFilter<"VerdictInterestDetails"> | number
    annual_rate?: FloatFilter<"VerdictInterestDetails"> | number
    proportional_rate?: FloatFilter<"VerdictInterestDetails"> | number
    base_amount?: FloatFilter<"VerdictInterestDetails"> | number
    interest?: FloatFilter<"VerdictInterestDetails"> | number
    total?: FloatFilter<"VerdictInterestDetails"> | number
    verdict_interest_id?: StringFilter<"VerdictInterestDetails"> | string
    created_at?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    updated_at?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    verdict_interest?: XOR<VerdictInterestScalarRelationFilter, VerdictInterestWhereInput>
  }, "id">

  export type VerdictInterestDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    period?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    days?: SortOrder
    annual_rate?: SortOrder
    proportional_rate?: SortOrder
    base_amount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdict_interest_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VerdictInterestDetailsCountOrderByAggregateInput
    _avg?: VerdictInterestDetailsAvgOrderByAggregateInput
    _max?: VerdictInterestDetailsMaxOrderByAggregateInput
    _min?: VerdictInterestDetailsMinOrderByAggregateInput
    _sum?: VerdictInterestDetailsSumOrderByAggregateInput
  }

  export type VerdictInterestDetailsScalarWhereWithAggregatesInput = {
    AND?: VerdictInterestDetailsScalarWhereWithAggregatesInput | VerdictInterestDetailsScalarWhereWithAggregatesInput[]
    OR?: VerdictInterestDetailsScalarWhereWithAggregatesInput[]
    NOT?: VerdictInterestDetailsScalarWhereWithAggregatesInput | VerdictInterestDetailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictInterestDetails"> | string
    period?: StringWithAggregatesFilter<"VerdictInterestDetails"> | string
    period_start?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
    period_end?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
    days?: IntWithAggregatesFilter<"VerdictInterestDetails"> | number
    annual_rate?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    proportional_rate?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    base_amount?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    interest?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    total?: FloatWithAggregatesFilter<"VerdictInterestDetails"> | number
    verdict_interest_id?: StringWithAggregatesFilter<"VerdictInterestDetails"> | string
    created_at?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VerdictInterestDetails"> | Date | string
  }

  export type VerdictEmbargoWhereInput = {
    AND?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    OR?: VerdictEmbargoWhereInput[]
    NOT?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    id?: StringFilter<"VerdictEmbargo"> | string
    verdict_id?: StringFilter<"VerdictEmbargo"> | string
    company_name?: StringFilter<"VerdictEmbargo"> | string
    company_phone?: StringFilter<"VerdictEmbargo"> | string
    company_email?: StringFilter<"VerdictEmbargo"> | string
    company_address?: StringFilter<"VerdictEmbargo"> | string
    embargo_type?: StringFilter<"VerdictEmbargo"> | string
    embargo_date?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    embargo_amount?: FloatFilter<"VerdictEmbargo"> | number
    total_amount?: FloatFilter<"VerdictEmbargo"> | number
    created_at?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    updated_at?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }

  export type VerdictEmbargoOrderByWithRelationInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    company_name?: SortOrder
    company_phone?: SortOrder
    company_email?: SortOrder
    company_address?: SortOrder
    embargo_type?: SortOrder
    embargo_date?: SortOrder
    embargo_amount?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verdict?: VerdictOrderByWithRelationInput
  }

  export type VerdictEmbargoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    OR?: VerdictEmbargoWhereInput[]
    NOT?: VerdictEmbargoWhereInput | VerdictEmbargoWhereInput[]
    verdict_id?: StringFilter<"VerdictEmbargo"> | string
    company_name?: StringFilter<"VerdictEmbargo"> | string
    company_phone?: StringFilter<"VerdictEmbargo"> | string
    company_email?: StringFilter<"VerdictEmbargo"> | string
    company_address?: StringFilter<"VerdictEmbargo"> | string
    embargo_type?: StringFilter<"VerdictEmbargo"> | string
    embargo_date?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    embargo_amount?: FloatFilter<"VerdictEmbargo"> | number
    total_amount?: FloatFilter<"VerdictEmbargo"> | number
    created_at?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    updated_at?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }, "id">

  export type VerdictEmbargoOrderByWithAggregationInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    company_name?: SortOrder
    company_phone?: SortOrder
    company_email?: SortOrder
    company_address?: SortOrder
    embargo_type?: SortOrder
    embargo_date?: SortOrder
    embargo_amount?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VerdictEmbargoCountOrderByAggregateInput
    _avg?: VerdictEmbargoAvgOrderByAggregateInput
    _max?: VerdictEmbargoMaxOrderByAggregateInput
    _min?: VerdictEmbargoMinOrderByAggregateInput
    _sum?: VerdictEmbargoSumOrderByAggregateInput
  }

  export type VerdictEmbargoScalarWhereWithAggregatesInput = {
    AND?: VerdictEmbargoScalarWhereWithAggregatesInput | VerdictEmbargoScalarWhereWithAggregatesInput[]
    OR?: VerdictEmbargoScalarWhereWithAggregatesInput[]
    NOT?: VerdictEmbargoScalarWhereWithAggregatesInput | VerdictEmbargoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    verdict_id?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    company_name?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    company_phone?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    company_email?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    company_address?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    embargo_type?: StringWithAggregatesFilter<"VerdictEmbargo"> | string
    embargo_date?: DateTimeWithAggregatesFilter<"VerdictEmbargo"> | Date | string
    embargo_amount?: FloatWithAggregatesFilter<"VerdictEmbargo"> | number
    total_amount?: FloatWithAggregatesFilter<"VerdictEmbargo"> | number
    created_at?: DateTimeWithAggregatesFilter<"VerdictEmbargo"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VerdictEmbargo"> | Date | string
  }

  export type VerdictBailiffServicesWhereInput = {
    AND?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    OR?: VerdictBailiffServicesWhereInput[]
    NOT?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    id?: StringFilter<"VerdictBailiffServices"> | string
    verdict_id?: StringFilter<"VerdictBailiffServices"> | string
    service_type?: StringFilter<"VerdictBailiffServices"> | string
    service_cost?: FloatFilter<"VerdictBailiffServices"> | number
    created_at?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    updated_at?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }

  export type VerdictBailiffServicesOrderByWithRelationInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    service_type?: SortOrder
    service_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verdict?: VerdictOrderByWithRelationInput
  }

  export type VerdictBailiffServicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    OR?: VerdictBailiffServicesWhereInput[]
    NOT?: VerdictBailiffServicesWhereInput | VerdictBailiffServicesWhereInput[]
    verdict_id?: StringFilter<"VerdictBailiffServices"> | string
    service_type?: StringFilter<"VerdictBailiffServices"> | string
    service_cost?: FloatFilter<"VerdictBailiffServices"> | number
    created_at?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    updated_at?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }, "id">

  export type VerdictBailiffServicesOrderByWithAggregationInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    service_type?: SortOrder
    service_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VerdictBailiffServicesCountOrderByAggregateInput
    _avg?: VerdictBailiffServicesAvgOrderByAggregateInput
    _max?: VerdictBailiffServicesMaxOrderByAggregateInput
    _min?: VerdictBailiffServicesMinOrderByAggregateInput
    _sum?: VerdictBailiffServicesSumOrderByAggregateInput
  }

  export type VerdictBailiffServicesScalarWhereWithAggregatesInput = {
    AND?: VerdictBailiffServicesScalarWhereWithAggregatesInput | VerdictBailiffServicesScalarWhereWithAggregatesInput[]
    OR?: VerdictBailiffServicesScalarWhereWithAggregatesInput[]
    NOT?: VerdictBailiffServicesScalarWhereWithAggregatesInput | VerdictBailiffServicesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictBailiffServices"> | string
    verdict_id?: StringWithAggregatesFilter<"VerdictBailiffServices"> | string
    service_type?: StringWithAggregatesFilter<"VerdictBailiffServices"> | string
    service_cost?: FloatWithAggregatesFilter<"VerdictBailiffServices"> | number
    created_at?: DateTimeWithAggregatesFilter<"VerdictBailiffServices"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VerdictBailiffServices"> | Date | string
  }

  export type VerdictAttachmentWhereInput = {
    AND?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    OR?: VerdictAttachmentWhereInput[]
    NOT?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    id?: StringFilter<"VerdictAttachment"> | string
    verdict_id?: StringFilter<"VerdictAttachment"> | string
    file_path?: StringFilter<"VerdictAttachment"> | string
    file_size?: BigIntFilter<"VerdictAttachment"> | bigint | number
    created_at?: DateTimeFilter<"VerdictAttachment"> | Date | string
    updated_at?: DateTimeFilter<"VerdictAttachment"> | Date | string
    file_name?: StringFilter<"VerdictAttachment"> | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }

  export type VerdictAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    file_path?: SortOrder
    file_size?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    file_name?: SortOrder
    verdict?: VerdictOrderByWithRelationInput
  }

  export type VerdictAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    OR?: VerdictAttachmentWhereInput[]
    NOT?: VerdictAttachmentWhereInput | VerdictAttachmentWhereInput[]
    verdict_id?: StringFilter<"VerdictAttachment"> | string
    file_path?: StringFilter<"VerdictAttachment"> | string
    file_size?: BigIntFilter<"VerdictAttachment"> | bigint | number
    created_at?: DateTimeFilter<"VerdictAttachment"> | Date | string
    updated_at?: DateTimeFilter<"VerdictAttachment"> | Date | string
    file_name?: StringFilter<"VerdictAttachment"> | string
    verdict?: XOR<VerdictScalarRelationFilter, VerdictWhereInput>
  }, "id">

  export type VerdictAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    file_path?: SortOrder
    file_size?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    file_name?: SortOrder
    _count?: VerdictAttachmentCountOrderByAggregateInput
    _avg?: VerdictAttachmentAvgOrderByAggregateInput
    _max?: VerdictAttachmentMaxOrderByAggregateInput
    _min?: VerdictAttachmentMinOrderByAggregateInput
    _sum?: VerdictAttachmentSumOrderByAggregateInput
  }

  export type VerdictAttachmentScalarWhereWithAggregatesInput = {
    AND?: VerdictAttachmentScalarWhereWithAggregatesInput | VerdictAttachmentScalarWhereWithAggregatesInput[]
    OR?: VerdictAttachmentScalarWhereWithAggregatesInput[]
    NOT?: VerdictAttachmentScalarWhereWithAggregatesInput | VerdictAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerdictAttachment"> | string
    verdict_id?: StringWithAggregatesFilter<"VerdictAttachment"> | string
    file_path?: StringWithAggregatesFilter<"VerdictAttachment"> | string
    file_size?: BigIntWithAggregatesFilter<"VerdictAttachment"> | bigint | number
    created_at?: DateTimeWithAggregatesFilter<"VerdictAttachment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VerdictAttachment"> | Date | string
    file_name?: StringWithAggregatesFilter<"VerdictAttachment"> | string
  }

  export type InterestTypeWhereInput = {
    AND?: InterestTypeWhereInput | InterestTypeWhereInput[]
    OR?: InterestTypeWhereInput[]
    NOT?: InterestTypeWhereInput | InterestTypeWhereInput[]
    id?: IntFilter<"InterestType"> | number
    name?: StringFilter<"InterestType"> | string
    calculation_type?: EnumCalculationTypeEnumFilter<"InterestType"> | $Enums.CalculationTypeEnum
    details?: InterestDetailListRelationFilter
  }

  export type InterestTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    calculation_type?: SortOrder
    details?: InterestDetailOrderByRelationAggregateInput
  }

  export type InterestTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InterestTypeWhereInput | InterestTypeWhereInput[]
    OR?: InterestTypeWhereInput[]
    NOT?: InterestTypeWhereInput | InterestTypeWhereInput[]
    name?: StringFilter<"InterestType"> | string
    calculation_type?: EnumCalculationTypeEnumFilter<"InterestType"> | $Enums.CalculationTypeEnum
    details?: InterestDetailListRelationFilter
  }, "id">

  export type InterestTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    calculation_type?: SortOrder
    _count?: InterestTypeCountOrderByAggregateInput
    _avg?: InterestTypeAvgOrderByAggregateInput
    _max?: InterestTypeMaxOrderByAggregateInput
    _min?: InterestTypeMinOrderByAggregateInput
    _sum?: InterestTypeSumOrderByAggregateInput
  }

  export type InterestTypeScalarWhereWithAggregatesInput = {
    AND?: InterestTypeScalarWhereWithAggregatesInput | InterestTypeScalarWhereWithAggregatesInput[]
    OR?: InterestTypeScalarWhereWithAggregatesInput[]
    NOT?: InterestTypeScalarWhereWithAggregatesInput | InterestTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InterestType"> | number
    name?: StringWithAggregatesFilter<"InterestType"> | string
    calculation_type?: EnumCalculationTypeEnumWithAggregatesFilter<"InterestType"> | $Enums.CalculationTypeEnum
  }

  export type InterestDetailWhereInput = {
    AND?: InterestDetailWhereInput | InterestDetailWhereInput[]
    OR?: InterestDetailWhereInput[]
    NOT?: InterestDetailWhereInput | InterestDetailWhereInput[]
    id?: IntFilter<"InterestDetail"> | number
    date?: StringFilter<"InterestDetail"> | string
    rate?: FloatFilter<"InterestDetail"> | number
    interest_type_id?: IntFilter<"InterestDetail"> | number
    interest_type?: XOR<InterestTypeScalarRelationFilter, InterestTypeWhereInput>
  }

  export type InterestDetailOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interest_type_id?: SortOrder
    interest_type?: InterestTypeOrderByWithRelationInput
  }

  export type InterestDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InterestDetailWhereInput | InterestDetailWhereInput[]
    OR?: InterestDetailWhereInput[]
    NOT?: InterestDetailWhereInput | InterestDetailWhereInput[]
    date?: StringFilter<"InterestDetail"> | string
    rate?: FloatFilter<"InterestDetail"> | number
    interest_type_id?: IntFilter<"InterestDetail"> | number
    interest_type?: XOR<InterestTypeScalarRelationFilter, InterestTypeWhereInput>
  }, "id">

  export type InterestDetailOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interest_type_id?: SortOrder
    _count?: InterestDetailCountOrderByAggregateInput
    _avg?: InterestDetailAvgOrderByAggregateInput
    _max?: InterestDetailMaxOrderByAggregateInput
    _min?: InterestDetailMinOrderByAggregateInput
    _sum?: InterestDetailSumOrderByAggregateInput
  }

  export type InterestDetailScalarWhereWithAggregatesInput = {
    AND?: InterestDetailScalarWhereWithAggregatesInput | InterestDetailScalarWhereWithAggregatesInput[]
    OR?: InterestDetailScalarWhereWithAggregatesInput[]
    NOT?: InterestDetailScalarWhereWithAggregatesInput | InterestDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InterestDetail"> | number
    date?: StringWithAggregatesFilter<"InterestDetail"> | string
    rate?: FloatWithAggregatesFilter<"InterestDetail"> | number
    interest_type_id?: IntWithAggregatesFilter<"InterestDetail"> | number
  }

  export type BillingInvoiceWhereInput = {
    AND?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    OR?: BillingInvoiceWhereInput[]
    NOT?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    id?: StringFilter<"BillingInvoice"> | string
    tenant_id?: StringFilter<"BillingInvoice"> | string
    invoice_number?: StringFilter<"BillingInvoice"> | string
    amount?: FloatFilter<"BillingInvoice"> | number
    currency?: StringFilter<"BillingInvoice"> | string
    issue_date?: DateTimeFilter<"BillingInvoice"> | Date | string
    due_date?: DateTimeFilter<"BillingInvoice"> | Date | string
    description?: StringNullableFilter<"BillingInvoice"> | string | null
    status?: StringFilter<"BillingInvoice"> | string
    created_at?: DateTimeFilter<"BillingInvoice"> | Date | string
    updated_at?: DateTimeFilter<"BillingInvoice"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    details?: BillingInvoiceDetailListRelationFilter
    payments?: BillingPaymentListRelationFilter
  }

  export type BillingInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    invoice_number?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    details?: BillingInvoiceDetailOrderByRelationAggregateInput
    payments?: BillingPaymentOrderByRelationAggregateInput
  }

  export type BillingInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoice_number?: string
    AND?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    OR?: BillingInvoiceWhereInput[]
    NOT?: BillingInvoiceWhereInput | BillingInvoiceWhereInput[]
    tenant_id?: StringFilter<"BillingInvoice"> | string
    amount?: FloatFilter<"BillingInvoice"> | number
    currency?: StringFilter<"BillingInvoice"> | string
    issue_date?: DateTimeFilter<"BillingInvoice"> | Date | string
    due_date?: DateTimeFilter<"BillingInvoice"> | Date | string
    description?: StringNullableFilter<"BillingInvoice"> | string | null
    status?: StringFilter<"BillingInvoice"> | string
    created_at?: DateTimeFilter<"BillingInvoice"> | Date | string
    updated_at?: DateTimeFilter<"BillingInvoice"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    details?: BillingInvoiceDetailListRelationFilter
    payments?: BillingPaymentListRelationFilter
  }, "id" | "invoice_number">

  export type BillingInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    invoice_number?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BillingInvoiceCountOrderByAggregateInput
    _avg?: BillingInvoiceAvgOrderByAggregateInput
    _max?: BillingInvoiceMaxOrderByAggregateInput
    _min?: BillingInvoiceMinOrderByAggregateInput
    _sum?: BillingInvoiceSumOrderByAggregateInput
  }

  export type BillingInvoiceScalarWhereWithAggregatesInput = {
    AND?: BillingInvoiceScalarWhereWithAggregatesInput | BillingInvoiceScalarWhereWithAggregatesInput[]
    OR?: BillingInvoiceScalarWhereWithAggregatesInput[]
    NOT?: BillingInvoiceScalarWhereWithAggregatesInput | BillingInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingInvoice"> | string
    tenant_id?: StringWithAggregatesFilter<"BillingInvoice"> | string
    invoice_number?: StringWithAggregatesFilter<"BillingInvoice"> | string
    amount?: FloatWithAggregatesFilter<"BillingInvoice"> | number
    currency?: StringWithAggregatesFilter<"BillingInvoice"> | string
    issue_date?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
    due_date?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
    description?: StringNullableWithAggregatesFilter<"BillingInvoice"> | string | null
    status?: StringWithAggregatesFilter<"BillingInvoice"> | string
    created_at?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"BillingInvoice"> | Date | string
  }

  export type BillingInvoiceDetailWhereInput = {
    AND?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    OR?: BillingInvoiceDetailWhereInput[]
    NOT?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    id?: StringFilter<"BillingInvoiceDetail"> | string
    item_description?: StringFilter<"BillingInvoiceDetail"> | string
    item_quantity?: IntFilter<"BillingInvoiceDetail"> | number
    item_unit_price?: FloatFilter<"BillingInvoiceDetail"> | number
    item_total_price?: FloatFilter<"BillingInvoiceDetail"> | number
    item_tax_rate?: FloatFilter<"BillingInvoiceDetail"> | number
    item_tax_amount?: FloatFilter<"BillingInvoiceDetail"> | number
    item_total_with_tax?: FloatFilter<"BillingInvoiceDetail"> | number
    created_at?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    updated_at?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    billing_invoice_id?: StringNullableFilter<"BillingInvoiceDetail"> | string | null
    billing_invoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }

  export type BillingInvoiceDetailOrderByWithRelationInput = {
    id?: SortOrder
    item_description?: SortOrder
    item_quantity?: SortOrder
    item_unit_price?: SortOrder
    item_total_price?: SortOrder
    item_tax_rate?: SortOrder
    item_tax_amount?: SortOrder
    item_total_with_tax?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_invoice_id?: SortOrderInput | SortOrder
    billing_invoice?: BillingInvoiceOrderByWithRelationInput
  }

  export type BillingInvoiceDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    OR?: BillingInvoiceDetailWhereInput[]
    NOT?: BillingInvoiceDetailWhereInput | BillingInvoiceDetailWhereInput[]
    item_description?: StringFilter<"BillingInvoiceDetail"> | string
    item_quantity?: IntFilter<"BillingInvoiceDetail"> | number
    item_unit_price?: FloatFilter<"BillingInvoiceDetail"> | number
    item_total_price?: FloatFilter<"BillingInvoiceDetail"> | number
    item_tax_rate?: FloatFilter<"BillingInvoiceDetail"> | number
    item_tax_amount?: FloatFilter<"BillingInvoiceDetail"> | number
    item_total_with_tax?: FloatFilter<"BillingInvoiceDetail"> | number
    created_at?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    updated_at?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    billing_invoice_id?: StringNullableFilter<"BillingInvoiceDetail"> | string | null
    billing_invoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }, "id">

  export type BillingInvoiceDetailOrderByWithAggregationInput = {
    id?: SortOrder
    item_description?: SortOrder
    item_quantity?: SortOrder
    item_unit_price?: SortOrder
    item_total_price?: SortOrder
    item_tax_rate?: SortOrder
    item_tax_amount?: SortOrder
    item_total_with_tax?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_invoice_id?: SortOrderInput | SortOrder
    _count?: BillingInvoiceDetailCountOrderByAggregateInput
    _avg?: BillingInvoiceDetailAvgOrderByAggregateInput
    _max?: BillingInvoiceDetailMaxOrderByAggregateInput
    _min?: BillingInvoiceDetailMinOrderByAggregateInput
    _sum?: BillingInvoiceDetailSumOrderByAggregateInput
  }

  export type BillingInvoiceDetailScalarWhereWithAggregatesInput = {
    AND?: BillingInvoiceDetailScalarWhereWithAggregatesInput | BillingInvoiceDetailScalarWhereWithAggregatesInput[]
    OR?: BillingInvoiceDetailScalarWhereWithAggregatesInput[]
    NOT?: BillingInvoiceDetailScalarWhereWithAggregatesInput | BillingInvoiceDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingInvoiceDetail"> | string
    item_description?: StringWithAggregatesFilter<"BillingInvoiceDetail"> | string
    item_quantity?: IntWithAggregatesFilter<"BillingInvoiceDetail"> | number
    item_unit_price?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    item_total_price?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    item_tax_rate?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    item_tax_amount?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    item_total_with_tax?: FloatWithAggregatesFilter<"BillingInvoiceDetail"> | number
    created_at?: DateTimeWithAggregatesFilter<"BillingInvoiceDetail"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"BillingInvoiceDetail"> | Date | string
    billing_invoice_id?: StringNullableWithAggregatesFilter<"BillingInvoiceDetail"> | string | null
  }

  export type BillingPaymentWhereInput = {
    AND?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    OR?: BillingPaymentWhereInput[]
    NOT?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    id?: StringFilter<"BillingPayment"> | string
    payment_date?: DateTimeFilter<"BillingPayment"> | Date | string
    amount?: FloatFilter<"BillingPayment"> | number
    payment_method?: StringFilter<"BillingPayment"> | string
    transaction_id?: StringNullableFilter<"BillingPayment"> | string | null
    status?: StringFilter<"BillingPayment"> | string
    created_at?: DateTimeFilter<"BillingPayment"> | Date | string
    updated_at?: DateTimeFilter<"BillingPayment"> | Date | string
    billing_invoice_id?: StringNullableFilter<"BillingPayment"> | string | null
    billing_invoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }

  export type BillingPaymentOrderByWithRelationInput = {
    id?: SortOrder
    payment_date?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_invoice_id?: SortOrderInput | SortOrder
    billing_invoice?: BillingInvoiceOrderByWithRelationInput
  }

  export type BillingPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    OR?: BillingPaymentWhereInput[]
    NOT?: BillingPaymentWhereInput | BillingPaymentWhereInput[]
    payment_date?: DateTimeFilter<"BillingPayment"> | Date | string
    amount?: FloatFilter<"BillingPayment"> | number
    payment_method?: StringFilter<"BillingPayment"> | string
    transaction_id?: StringNullableFilter<"BillingPayment"> | string | null
    status?: StringFilter<"BillingPayment"> | string
    created_at?: DateTimeFilter<"BillingPayment"> | Date | string
    updated_at?: DateTimeFilter<"BillingPayment"> | Date | string
    billing_invoice_id?: StringNullableFilter<"BillingPayment"> | string | null
    billing_invoice?: XOR<BillingInvoiceNullableScalarRelationFilter, BillingInvoiceWhereInput> | null
  }, "id">

  export type BillingPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    payment_date?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_invoice_id?: SortOrderInput | SortOrder
    _count?: BillingPaymentCountOrderByAggregateInput
    _avg?: BillingPaymentAvgOrderByAggregateInput
    _max?: BillingPaymentMaxOrderByAggregateInput
    _min?: BillingPaymentMinOrderByAggregateInput
    _sum?: BillingPaymentSumOrderByAggregateInput
  }

  export type BillingPaymentScalarWhereWithAggregatesInput = {
    AND?: BillingPaymentScalarWhereWithAggregatesInput | BillingPaymentScalarWhereWithAggregatesInput[]
    OR?: BillingPaymentScalarWhereWithAggregatesInput[]
    NOT?: BillingPaymentScalarWhereWithAggregatesInput | BillingPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingPayment"> | string
    payment_date?: DateTimeWithAggregatesFilter<"BillingPayment"> | Date | string
    amount?: FloatWithAggregatesFilter<"BillingPayment"> | number
    payment_method?: StringWithAggregatesFilter<"BillingPayment"> | string
    transaction_id?: StringNullableWithAggregatesFilter<"BillingPayment"> | string | null
    status?: StringWithAggregatesFilter<"BillingPayment"> | string
    created_at?: DateTimeWithAggregatesFilter<"BillingPayment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"BillingPayment"> | Date | string
    billing_invoice_id?: StringNullableWithAggregatesFilter<"BillingPayment"> | string | null
  }

  export type CollectionCaseWhereInput = {
    AND?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    OR?: CollectionCaseWhereInput[]
    NOT?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    id?: StringFilter<"CollectionCase"> | string
    reference_number?: StringNullableFilter<"CollectionCase"> | string | null
    issue_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    due_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1_sent_at?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1_due_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2_sent_at?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2_due_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    tenant_id?: StringFilter<"CollectionCase"> | string
    debtor_id?: StringFilter<"CollectionCase"> | string
    amount_original?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFilter<"CollectionCase"> | $Enums.CollectionCaseStatus
    notification_status?: StringNullableFilter<"CollectionCase"> | string | null
    created_at?: DateTimeFilter<"CollectionCase"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCase"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    notifications?: CollectionCaseNotificationListRelationFilter
    payments?: CollectionCasePaymentListRelationFilter
    agreements?: CollectionCaseAgreementListRelationFilter
    penalties?: CollectionCasePenaltyListRelationFilter
    chat_rooms?: ChatRoomListRelationFilter
  }

  export type CollectionCaseOrderByWithRelationInput = {
    id?: SortOrder
    reference_number?: SortOrderInput | SortOrder
    issue_date?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    reminder1_sent_at?: SortOrderInput | SortOrder
    reminder1_due_date?: SortOrderInput | SortOrder
    reminder2_sent_at?: SortOrderInput | SortOrder
    reminder2_due_date?: SortOrderInput | SortOrder
    tenant_id?: SortOrder
    debtor_id?: SortOrder
    amount_original?: SortOrder
    amount_due?: SortOrder
    amount_to_receive?: SortOrder
    status?: SortOrder
    notification_status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    debtor?: DebtorOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    notifications?: CollectionCaseNotificationOrderByRelationAggregateInput
    payments?: CollectionCasePaymentOrderByRelationAggregateInput
    agreements?: CollectionCaseAgreementOrderByRelationAggregateInput
    penalties?: CollectionCasePenaltyOrderByRelationAggregateInput
    chat_rooms?: ChatRoomOrderByRelationAggregateInput
  }

  export type CollectionCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    OR?: CollectionCaseWhereInput[]
    NOT?: CollectionCaseWhereInput | CollectionCaseWhereInput[]
    reference_number?: StringNullableFilter<"CollectionCase"> | string | null
    issue_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    due_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1_sent_at?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1_due_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2_sent_at?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2_due_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    tenant_id?: StringFilter<"CollectionCase"> | string
    debtor_id?: StringFilter<"CollectionCase"> | string
    amount_original?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFilter<"CollectionCase"> | $Enums.CollectionCaseStatus
    notification_status?: StringNullableFilter<"CollectionCase"> | string | null
    created_at?: DateTimeFilter<"CollectionCase"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCase"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    notifications?: CollectionCaseNotificationListRelationFilter
    payments?: CollectionCasePaymentListRelationFilter
    agreements?: CollectionCaseAgreementListRelationFilter
    penalties?: CollectionCasePenaltyListRelationFilter
    chat_rooms?: ChatRoomListRelationFilter
  }, "id">

  export type CollectionCaseOrderByWithAggregationInput = {
    id?: SortOrder
    reference_number?: SortOrderInput | SortOrder
    issue_date?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    reminder1_sent_at?: SortOrderInput | SortOrder
    reminder1_due_date?: SortOrderInput | SortOrder
    reminder2_sent_at?: SortOrderInput | SortOrder
    reminder2_due_date?: SortOrderInput | SortOrder
    tenant_id?: SortOrder
    debtor_id?: SortOrder
    amount_original?: SortOrder
    amount_due?: SortOrder
    amount_to_receive?: SortOrder
    status?: SortOrder
    notification_status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CollectionCaseCountOrderByAggregateInput
    _avg?: CollectionCaseAvgOrderByAggregateInput
    _max?: CollectionCaseMaxOrderByAggregateInput
    _min?: CollectionCaseMinOrderByAggregateInput
    _sum?: CollectionCaseSumOrderByAggregateInput
  }

  export type CollectionCaseScalarWhereWithAggregatesInput = {
    AND?: CollectionCaseScalarWhereWithAggregatesInput | CollectionCaseScalarWhereWithAggregatesInput[]
    OR?: CollectionCaseScalarWhereWithAggregatesInput[]
    NOT?: CollectionCaseScalarWhereWithAggregatesInput | CollectionCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionCase"> | string
    reference_number?: StringNullableWithAggregatesFilter<"CollectionCase"> | string | null
    issue_date?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    due_date?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    reminder1_sent_at?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    reminder1_due_date?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    reminder2_sent_at?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    reminder2_due_date?: DateTimeNullableWithAggregatesFilter<"CollectionCase"> | Date | string | null
    tenant_id?: StringWithAggregatesFilter<"CollectionCase"> | string
    debtor_id?: StringWithAggregatesFilter<"CollectionCase"> | string
    amount_original?: DecimalWithAggregatesFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalWithAggregatesFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalWithAggregatesFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusWithAggregatesFilter<"CollectionCase"> | $Enums.CollectionCaseStatus
    notification_status?: StringNullableWithAggregatesFilter<"CollectionCase"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"CollectionCase"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CollectionCase"> | Date | string
  }

  export type CollectionCasePenaltyWhereInput = {
    AND?: CollectionCasePenaltyWhereInput | CollectionCasePenaltyWhereInput[]
    OR?: CollectionCasePenaltyWhereInput[]
    NOT?: CollectionCasePenaltyWhereInput | CollectionCasePenaltyWhereInput[]
    id?: StringFilter<"CollectionCasePenalty"> | string
    collection_case_id?: StringFilter<"CollectionCasePenalty"> | string
    description?: StringNullableFilter<"CollectionCasePenalty"> | string | null
    amount?: DecimalFilter<"CollectionCasePenalty"> | Decimal | DecimalJsLike | number | string
    date_applied?: DateTimeFilter<"CollectionCasePenalty"> | Date | string
    is_paid?: BoolFilter<"CollectionCasePenalty"> | boolean
    created_at?: DateTimeFilter<"CollectionCasePenalty"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCasePenalty"> | Date | string
    collection_case?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }

  export type CollectionCasePenaltyOrderByWithRelationInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    date_applied?: SortOrder
    is_paid?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    collection_case?: CollectionCaseOrderByWithRelationInput
  }

  export type CollectionCasePenaltyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionCasePenaltyWhereInput | CollectionCasePenaltyWhereInput[]
    OR?: CollectionCasePenaltyWhereInput[]
    NOT?: CollectionCasePenaltyWhereInput | CollectionCasePenaltyWhereInput[]
    collection_case_id?: StringFilter<"CollectionCasePenalty"> | string
    description?: StringNullableFilter<"CollectionCasePenalty"> | string | null
    amount?: DecimalFilter<"CollectionCasePenalty"> | Decimal | DecimalJsLike | number | string
    date_applied?: DateTimeFilter<"CollectionCasePenalty"> | Date | string
    is_paid?: BoolFilter<"CollectionCasePenalty"> | boolean
    created_at?: DateTimeFilter<"CollectionCasePenalty"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCasePenalty"> | Date | string
    collection_case?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }, "id">

  export type CollectionCasePenaltyOrderByWithAggregationInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    date_applied?: SortOrder
    is_paid?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CollectionCasePenaltyCountOrderByAggregateInput
    _avg?: CollectionCasePenaltyAvgOrderByAggregateInput
    _max?: CollectionCasePenaltyMaxOrderByAggregateInput
    _min?: CollectionCasePenaltyMinOrderByAggregateInput
    _sum?: CollectionCasePenaltySumOrderByAggregateInput
  }

  export type CollectionCasePenaltyScalarWhereWithAggregatesInput = {
    AND?: CollectionCasePenaltyScalarWhereWithAggregatesInput | CollectionCasePenaltyScalarWhereWithAggregatesInput[]
    OR?: CollectionCasePenaltyScalarWhereWithAggregatesInput[]
    NOT?: CollectionCasePenaltyScalarWhereWithAggregatesInput | CollectionCasePenaltyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionCasePenalty"> | string
    collection_case_id?: StringWithAggregatesFilter<"CollectionCasePenalty"> | string
    description?: StringNullableWithAggregatesFilter<"CollectionCasePenalty"> | string | null
    amount?: DecimalWithAggregatesFilter<"CollectionCasePenalty"> | Decimal | DecimalJsLike | number | string
    date_applied?: DateTimeWithAggregatesFilter<"CollectionCasePenalty"> | Date | string
    is_paid?: BoolWithAggregatesFilter<"CollectionCasePenalty"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"CollectionCasePenalty"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CollectionCasePenalty"> | Date | string
  }

  export type CollectionCaseNotificationWhereInput = {
    AND?: CollectionCaseNotificationWhereInput | CollectionCaseNotificationWhereInput[]
    OR?: CollectionCaseNotificationWhereInput[]
    NOT?: CollectionCaseNotificationWhereInput | CollectionCaseNotificationWhereInput[]
    id?: StringFilter<"CollectionCaseNotification"> | string
    collection_case_id?: StringFilter<"CollectionCaseNotification"> | string
    type?: EnumNotificationTypeFilter<"CollectionCaseNotification"> | $Enums.NotificationType
    title?: StringFilter<"CollectionCaseNotification"> | string
    message?: StringFilter<"CollectionCaseNotification"> | string
    sent_at?: DateTimeFilter<"CollectionCaseNotification"> | Date | string
    read?: BoolFilter<"CollectionCaseNotification"> | boolean
    created_at?: DateTimeFilter<"CollectionCaseNotification"> | Date | string
    collection_case?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }

  export type CollectionCaseNotificationOrderByWithRelationInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sent_at?: SortOrder
    read?: SortOrder
    created_at?: SortOrder
    collection_case?: CollectionCaseOrderByWithRelationInput
  }

  export type CollectionCaseNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionCaseNotificationWhereInput | CollectionCaseNotificationWhereInput[]
    OR?: CollectionCaseNotificationWhereInput[]
    NOT?: CollectionCaseNotificationWhereInput | CollectionCaseNotificationWhereInput[]
    collection_case_id?: StringFilter<"CollectionCaseNotification"> | string
    type?: EnumNotificationTypeFilter<"CollectionCaseNotification"> | $Enums.NotificationType
    title?: StringFilter<"CollectionCaseNotification"> | string
    message?: StringFilter<"CollectionCaseNotification"> | string
    sent_at?: DateTimeFilter<"CollectionCaseNotification"> | Date | string
    read?: BoolFilter<"CollectionCaseNotification"> | boolean
    created_at?: DateTimeFilter<"CollectionCaseNotification"> | Date | string
    collection_case?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
  }, "id">

  export type CollectionCaseNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sent_at?: SortOrder
    read?: SortOrder
    created_at?: SortOrder
    _count?: CollectionCaseNotificationCountOrderByAggregateInput
    _max?: CollectionCaseNotificationMaxOrderByAggregateInput
    _min?: CollectionCaseNotificationMinOrderByAggregateInput
  }

  export type CollectionCaseNotificationScalarWhereWithAggregatesInput = {
    AND?: CollectionCaseNotificationScalarWhereWithAggregatesInput | CollectionCaseNotificationScalarWhereWithAggregatesInput[]
    OR?: CollectionCaseNotificationScalarWhereWithAggregatesInput[]
    NOT?: CollectionCaseNotificationScalarWhereWithAggregatesInput | CollectionCaseNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionCaseNotification"> | string
    collection_case_id?: StringWithAggregatesFilter<"CollectionCaseNotification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"CollectionCaseNotification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"CollectionCaseNotification"> | string
    message?: StringWithAggregatesFilter<"CollectionCaseNotification"> | string
    sent_at?: DateTimeWithAggregatesFilter<"CollectionCaseNotification"> | Date | string
    read?: BoolWithAggregatesFilter<"CollectionCaseNotification"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"CollectionCaseNotification"> | Date | string
  }

  export type CollectionCasePaymentWhereInput = {
    AND?: CollectionCasePaymentWhereInput | CollectionCasePaymentWhereInput[]
    OR?: CollectionCasePaymentWhereInput[]
    NOT?: CollectionCasePaymentWhereInput | CollectionCasePaymentWhereInput[]
    id?: StringFilter<"CollectionCasePayment"> | string
    method?: EnumPaymentMethodFilter<"CollectionCasePayment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"CollectionCasePayment"> | Decimal | DecimalJsLike | number | string
    collection_case_id?: StringFilter<"CollectionCasePayment"> | string
    payment_date?: DateTimeFilter<"CollectionCasePayment"> | Date | string
    reference_number?: StringNullableFilter<"CollectionCasePayment"> | string | null
    agreement_id?: StringNullableFilter<"CollectionCasePayment"> | string | null
    created_at?: DateTimeFilter<"CollectionCasePayment"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCasePayment"> | Date | string
    collection_case?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    agreement?: XOR<CollectionCaseAgreementNullableScalarRelationFilter, CollectionCaseAgreementWhereInput> | null
    installments?: CollectionCaseAgreementInstallmentListRelationFilter
  }

  export type CollectionCasePaymentOrderByWithRelationInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    collection_case_id?: SortOrder
    payment_date?: SortOrder
    reference_number?: SortOrderInput | SortOrder
    agreement_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    collection_case?: CollectionCaseOrderByWithRelationInput
    agreement?: CollectionCaseAgreementOrderByWithRelationInput
    installments?: CollectionCaseAgreementInstallmentOrderByRelationAggregateInput
  }

  export type CollectionCasePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionCasePaymentWhereInput | CollectionCasePaymentWhereInput[]
    OR?: CollectionCasePaymentWhereInput[]
    NOT?: CollectionCasePaymentWhereInput | CollectionCasePaymentWhereInput[]
    method?: EnumPaymentMethodFilter<"CollectionCasePayment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"CollectionCasePayment"> | Decimal | DecimalJsLike | number | string
    collection_case_id?: StringFilter<"CollectionCasePayment"> | string
    payment_date?: DateTimeFilter<"CollectionCasePayment"> | Date | string
    reference_number?: StringNullableFilter<"CollectionCasePayment"> | string | null
    agreement_id?: StringNullableFilter<"CollectionCasePayment"> | string | null
    created_at?: DateTimeFilter<"CollectionCasePayment"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCasePayment"> | Date | string
    collection_case?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    agreement?: XOR<CollectionCaseAgreementNullableScalarRelationFilter, CollectionCaseAgreementWhereInput> | null
    installments?: CollectionCaseAgreementInstallmentListRelationFilter
  }, "id">

  export type CollectionCasePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    collection_case_id?: SortOrder
    payment_date?: SortOrder
    reference_number?: SortOrderInput | SortOrder
    agreement_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CollectionCasePaymentCountOrderByAggregateInput
    _avg?: CollectionCasePaymentAvgOrderByAggregateInput
    _max?: CollectionCasePaymentMaxOrderByAggregateInput
    _min?: CollectionCasePaymentMinOrderByAggregateInput
    _sum?: CollectionCasePaymentSumOrderByAggregateInput
  }

  export type CollectionCasePaymentScalarWhereWithAggregatesInput = {
    AND?: CollectionCasePaymentScalarWhereWithAggregatesInput | CollectionCasePaymentScalarWhereWithAggregatesInput[]
    OR?: CollectionCasePaymentScalarWhereWithAggregatesInput[]
    NOT?: CollectionCasePaymentScalarWhereWithAggregatesInput | CollectionCasePaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionCasePayment"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"CollectionCasePayment"> | $Enums.PaymentMethod
    amount?: DecimalWithAggregatesFilter<"CollectionCasePayment"> | Decimal | DecimalJsLike | number | string
    collection_case_id?: StringWithAggregatesFilter<"CollectionCasePayment"> | string
    payment_date?: DateTimeWithAggregatesFilter<"CollectionCasePayment"> | Date | string
    reference_number?: StringNullableWithAggregatesFilter<"CollectionCasePayment"> | string | null
    agreement_id?: StringNullableWithAggregatesFilter<"CollectionCasePayment"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"CollectionCasePayment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CollectionCasePayment"> | Date | string
  }

  export type DebtorWhereInput = {
    AND?: DebtorWhereInput | DebtorWhereInput[]
    OR?: DebtorWhereInput[]
    NOT?: DebtorWhereInput | DebtorWhereInput[]
    id?: StringFilter<"Debtor"> | string
    tenant_id?: StringFilter<"Debtor"> | string
    user_id?: StringNullableFilter<"Debtor"> | string | null
    fullname?: StringFilter<"Debtor"> | string
    email?: StringFilter<"Debtor"> | string
    phone?: StringNullableFilter<"Debtor"> | string | null
    address?: StringNullableFilter<"Debtor"> | string | null
    person_type?: EnumPersonTypeFilter<"Debtor"> | $Enums.PersonType
    identification_type?: EnumIdentificationTypeNullableFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableFilter<"Debtor"> | string | null
    total_income?: FloatNullableFilter<"Debtor"> | number | null
    created_at?: DateTimeFilter<"Debtor"> | Date | string
    updated_at?: DateTimeFilter<"Debtor"> | Date | string
    collection_cases?: CollectionCaseListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    incomes?: DebtorIncomeListRelationFilter
    payment_agreements?: CollectionCaseAgreementListRelationFilter
    verdicts?: VerdictListRelationFilter
  }

  export type DebtorOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    person_type?: SortOrder
    identification_type?: SortOrderInput | SortOrder
    identification?: SortOrderInput | SortOrder
    total_income?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    collection_cases?: CollectionCaseOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    incomes?: DebtorIncomeOrderByRelationAggregateInput
    payment_agreements?: CollectionCaseAgreementOrderByRelationAggregateInput
    verdicts?: VerdictOrderByRelationAggregateInput
  }

  export type DebtorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenant_id_email?: DebtorTenant_idEmailCompoundUniqueInput
    tenant_id_identification?: DebtorTenant_idIdentificationCompoundUniqueInput
    AND?: DebtorWhereInput | DebtorWhereInput[]
    OR?: DebtorWhereInput[]
    NOT?: DebtorWhereInput | DebtorWhereInput[]
    tenant_id?: StringFilter<"Debtor"> | string
    user_id?: StringNullableFilter<"Debtor"> | string | null
    fullname?: StringFilter<"Debtor"> | string
    email?: StringFilter<"Debtor"> | string
    phone?: StringNullableFilter<"Debtor"> | string | null
    address?: StringNullableFilter<"Debtor"> | string | null
    person_type?: EnumPersonTypeFilter<"Debtor"> | $Enums.PersonType
    identification_type?: EnumIdentificationTypeNullableFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableFilter<"Debtor"> | string | null
    total_income?: FloatNullableFilter<"Debtor"> | number | null
    created_at?: DateTimeFilter<"Debtor"> | Date | string
    updated_at?: DateTimeFilter<"Debtor"> | Date | string
    collection_cases?: CollectionCaseListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    incomes?: DebtorIncomeListRelationFilter
    payment_agreements?: CollectionCaseAgreementListRelationFilter
    verdicts?: VerdictListRelationFilter
  }, "id" | "tenant_id_email" | "tenant_id_identification">

  export type DebtorOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    person_type?: SortOrder
    identification_type?: SortOrderInput | SortOrder
    identification?: SortOrderInput | SortOrder
    total_income?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DebtorCountOrderByAggregateInput
    _avg?: DebtorAvgOrderByAggregateInput
    _max?: DebtorMaxOrderByAggregateInput
    _min?: DebtorMinOrderByAggregateInput
    _sum?: DebtorSumOrderByAggregateInput
  }

  export type DebtorScalarWhereWithAggregatesInput = {
    AND?: DebtorScalarWhereWithAggregatesInput | DebtorScalarWhereWithAggregatesInput[]
    OR?: DebtorScalarWhereWithAggregatesInput[]
    NOT?: DebtorScalarWhereWithAggregatesInput | DebtorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Debtor"> | string
    tenant_id?: StringWithAggregatesFilter<"Debtor"> | string
    user_id?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    fullname?: StringWithAggregatesFilter<"Debtor"> | string
    email?: StringWithAggregatesFilter<"Debtor"> | string
    phone?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    address?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    person_type?: EnumPersonTypeWithAggregatesFilter<"Debtor"> | $Enums.PersonType
    identification_type?: EnumIdentificationTypeNullableWithAggregatesFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableWithAggregatesFilter<"Debtor"> | string | null
    total_income?: FloatNullableWithAggregatesFilter<"Debtor"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Debtor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Debtor"> | Date | string
  }

  export type ChatRoomWhereInput = {
    AND?: ChatRoomWhereInput | ChatRoomWhereInput[]
    OR?: ChatRoomWhereInput[]
    NOT?: ChatRoomWhereInput | ChatRoomWhereInput[]
    id?: StringFilter<"ChatRoom"> | string
    tenant_id?: StringFilter<"ChatRoom"> | string
    collection_case_id?: StringFilter<"ChatRoom"> | string
    name?: StringFilter<"ChatRoom"> | string
    created_at?: DateTimeFilter<"ChatRoom"> | Date | string
    updated_at?: DateTimeFilter<"ChatRoom"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    collection_case?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    messages?: ChatMessageListRelationFilter
  }

  export type ChatRoomOrderByWithRelationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    collection_case_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    collection_case?: CollectionCaseOrderByWithRelationInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type ChatRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatRoomWhereInput | ChatRoomWhereInput[]
    OR?: ChatRoomWhereInput[]
    NOT?: ChatRoomWhereInput | ChatRoomWhereInput[]
    tenant_id?: StringFilter<"ChatRoom"> | string
    collection_case_id?: StringFilter<"ChatRoom"> | string
    name?: StringFilter<"ChatRoom"> | string
    created_at?: DateTimeFilter<"ChatRoom"> | Date | string
    updated_at?: DateTimeFilter<"ChatRoom"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    collection_case?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    messages?: ChatMessageListRelationFilter
  }, "id">

  export type ChatRoomOrderByWithAggregationInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    collection_case_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ChatRoomCountOrderByAggregateInput
    _max?: ChatRoomMaxOrderByAggregateInput
    _min?: ChatRoomMinOrderByAggregateInput
  }

  export type ChatRoomScalarWhereWithAggregatesInput = {
    AND?: ChatRoomScalarWhereWithAggregatesInput | ChatRoomScalarWhereWithAggregatesInput[]
    OR?: ChatRoomScalarWhereWithAggregatesInput[]
    NOT?: ChatRoomScalarWhereWithAggregatesInput | ChatRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatRoom"> | string
    tenant_id?: StringWithAggregatesFilter<"ChatRoom"> | string
    collection_case_id?: StringWithAggregatesFilter<"ChatRoom"> | string
    name?: StringWithAggregatesFilter<"ChatRoom"> | string
    created_at?: DateTimeWithAggregatesFilter<"ChatRoom"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ChatRoom"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    room_id?: StringFilter<"ChatMessage"> | string
    sender_id?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    file_url?: StringNullableFilter<"ChatMessage"> | string | null
    file_name?: StringNullableFilter<"ChatMessage"> | string | null
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
    created_at?: DateTimeFilter<"ChatMessage"> | Date | string
    updated_at?: DateTimeFilter<"ChatMessage"> | Date | string
    room?: XOR<ChatRoomScalarRelationFilter, ChatRoomWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    room_id?: SortOrder
    sender_id?: SortOrder
    message?: SortOrder
    file_url?: SortOrderInput | SortOrder
    file_name?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    room?: ChatRoomOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    room_id?: StringFilter<"ChatMessage"> | string
    sender_id?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    file_url?: StringNullableFilter<"ChatMessage"> | string | null
    file_name?: StringNullableFilter<"ChatMessage"> | string | null
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
    created_at?: DateTimeFilter<"ChatMessage"> | Date | string
    updated_at?: DateTimeFilter<"ChatMessage"> | Date | string
    room?: XOR<ChatRoomScalarRelationFilter, ChatRoomWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    room_id?: SortOrder
    sender_id?: SortOrder
    message?: SortOrder
    file_url?: SortOrderInput | SortOrder
    file_name?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    room_id?: StringWithAggregatesFilter<"ChatMessage"> | string
    sender_id?: StringWithAggregatesFilter<"ChatMessage"> | string
    message?: StringWithAggregatesFilter<"ChatMessage"> | string
    file_url?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    file_name?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type DebtorIncomeWhereInput = {
    AND?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    OR?: DebtorIncomeWhereInput[]
    NOT?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    id?: StringFilter<"DebtorIncome"> | string
    debtor_id?: StringFilter<"DebtorIncome"> | string
    amount?: FloatFilter<"DebtorIncome"> | number
    source?: StringFilter<"DebtorIncome"> | string
    created_at?: DateTimeFilter<"DebtorIncome"> | Date | string
    updated_at?: DateTimeFilter<"DebtorIncome"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
  }

  export type DebtorIncomeOrderByWithRelationInput = {
    id?: SortOrder
    debtor_id?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    debtor?: DebtorOrderByWithRelationInput
  }

  export type DebtorIncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    OR?: DebtorIncomeWhereInput[]
    NOT?: DebtorIncomeWhereInput | DebtorIncomeWhereInput[]
    debtor_id?: StringFilter<"DebtorIncome"> | string
    amount?: FloatFilter<"DebtorIncome"> | number
    source?: StringFilter<"DebtorIncome"> | string
    created_at?: DateTimeFilter<"DebtorIncome"> | Date | string
    updated_at?: DateTimeFilter<"DebtorIncome"> | Date | string
    debtor?: XOR<DebtorScalarRelationFilter, DebtorWhereInput>
  }, "id">

  export type DebtorIncomeOrderByWithAggregationInput = {
    id?: SortOrder
    debtor_id?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DebtorIncomeCountOrderByAggregateInput
    _avg?: DebtorIncomeAvgOrderByAggregateInput
    _max?: DebtorIncomeMaxOrderByAggregateInput
    _min?: DebtorIncomeMinOrderByAggregateInput
    _sum?: DebtorIncomeSumOrderByAggregateInput
  }

  export type DebtorIncomeScalarWhereWithAggregatesInput = {
    AND?: DebtorIncomeScalarWhereWithAggregatesInput | DebtorIncomeScalarWhereWithAggregatesInput[]
    OR?: DebtorIncomeScalarWhereWithAggregatesInput[]
    NOT?: DebtorIncomeScalarWhereWithAggregatesInput | DebtorIncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DebtorIncome"> | string
    debtor_id?: StringWithAggregatesFilter<"DebtorIncome"> | string
    amount?: FloatWithAggregatesFilter<"DebtorIncome"> | number
    source?: StringWithAggregatesFilter<"DebtorIncome"> | string
    created_at?: DateTimeWithAggregatesFilter<"DebtorIncome"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"DebtorIncome"> | Date | string
  }

  export type CollectionCaseAgreementWhereInput = {
    AND?: CollectionCaseAgreementWhereInput | CollectionCaseAgreementWhereInput[]
    OR?: CollectionCaseAgreementWhereInput[]
    NOT?: CollectionCaseAgreementWhereInput | CollectionCaseAgreementWhereInput[]
    id?: StringFilter<"CollectionCaseAgreement"> | string
    collection_case_id?: StringFilter<"CollectionCaseAgreement"> | string
    debtor_id?: StringNullableFilter<"CollectionCaseAgreement"> | string | null
    total_amount?: DecimalFilter<"CollectionCaseAgreement"> | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFilter<"CollectionCaseAgreement"> | Decimal | DecimalJsLike | number | string
    installments_count?: IntFilter<"CollectionCaseAgreement"> | number
    start_date?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
    end_date?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
    status?: EnumAgreementStatusFilter<"CollectionCaseAgreement"> | $Enums.AgreementStatus
    tenant_id?: StringFilter<"CollectionCaseAgreement"> | string
    comment?: StringNullableFilter<"CollectionCaseAgreement"> | string | null
    created_at?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    debtor?: XOR<DebtorNullableScalarRelationFilter, DebtorWhereInput> | null
    collection_case?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    installments?: CollectionCaseAgreementInstallmentListRelationFilter
    payments?: CollectionCasePaymentListRelationFilter
  }

  export type CollectionCaseAgreementOrderByWithRelationInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    debtor_id?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    installment_amount?: SortOrder
    installments_count?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    tenant_id?: SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    debtor?: DebtorOrderByWithRelationInput
    collection_case?: CollectionCaseOrderByWithRelationInput
    installments?: CollectionCaseAgreementInstallmentOrderByRelationAggregateInput
    payments?: CollectionCasePaymentOrderByRelationAggregateInput
  }

  export type CollectionCaseAgreementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionCaseAgreementWhereInput | CollectionCaseAgreementWhereInput[]
    OR?: CollectionCaseAgreementWhereInput[]
    NOT?: CollectionCaseAgreementWhereInput | CollectionCaseAgreementWhereInput[]
    collection_case_id?: StringFilter<"CollectionCaseAgreement"> | string
    debtor_id?: StringNullableFilter<"CollectionCaseAgreement"> | string | null
    total_amount?: DecimalFilter<"CollectionCaseAgreement"> | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFilter<"CollectionCaseAgreement"> | Decimal | DecimalJsLike | number | string
    installments_count?: IntFilter<"CollectionCaseAgreement"> | number
    start_date?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
    end_date?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
    status?: EnumAgreementStatusFilter<"CollectionCaseAgreement"> | $Enums.AgreementStatus
    tenant_id?: StringFilter<"CollectionCaseAgreement"> | string
    comment?: StringNullableFilter<"CollectionCaseAgreement"> | string | null
    created_at?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    debtor?: XOR<DebtorNullableScalarRelationFilter, DebtorWhereInput> | null
    collection_case?: XOR<CollectionCaseScalarRelationFilter, CollectionCaseWhereInput>
    installments?: CollectionCaseAgreementInstallmentListRelationFilter
    payments?: CollectionCasePaymentListRelationFilter
  }, "id">

  export type CollectionCaseAgreementOrderByWithAggregationInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    debtor_id?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    installment_amount?: SortOrder
    installments_count?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    tenant_id?: SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CollectionCaseAgreementCountOrderByAggregateInput
    _avg?: CollectionCaseAgreementAvgOrderByAggregateInput
    _max?: CollectionCaseAgreementMaxOrderByAggregateInput
    _min?: CollectionCaseAgreementMinOrderByAggregateInput
    _sum?: CollectionCaseAgreementSumOrderByAggregateInput
  }

  export type CollectionCaseAgreementScalarWhereWithAggregatesInput = {
    AND?: CollectionCaseAgreementScalarWhereWithAggregatesInput | CollectionCaseAgreementScalarWhereWithAggregatesInput[]
    OR?: CollectionCaseAgreementScalarWhereWithAggregatesInput[]
    NOT?: CollectionCaseAgreementScalarWhereWithAggregatesInput | CollectionCaseAgreementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionCaseAgreement"> | string
    collection_case_id?: StringWithAggregatesFilter<"CollectionCaseAgreement"> | string
    debtor_id?: StringNullableWithAggregatesFilter<"CollectionCaseAgreement"> | string | null
    total_amount?: DecimalWithAggregatesFilter<"CollectionCaseAgreement"> | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalWithAggregatesFilter<"CollectionCaseAgreement"> | Decimal | DecimalJsLike | number | string
    installments_count?: IntWithAggregatesFilter<"CollectionCaseAgreement"> | number
    start_date?: DateTimeWithAggregatesFilter<"CollectionCaseAgreement"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"CollectionCaseAgreement"> | Date | string
    status?: EnumAgreementStatusWithAggregatesFilter<"CollectionCaseAgreement"> | $Enums.AgreementStatus
    tenant_id?: StringWithAggregatesFilter<"CollectionCaseAgreement"> | string
    comment?: StringNullableWithAggregatesFilter<"CollectionCaseAgreement"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"CollectionCaseAgreement"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CollectionCaseAgreement"> | Date | string
  }

  export type CollectionCaseAgreementInstallmentWhereInput = {
    AND?: CollectionCaseAgreementInstallmentWhereInput | CollectionCaseAgreementInstallmentWhereInput[]
    OR?: CollectionCaseAgreementInstallmentWhereInput[]
    NOT?: CollectionCaseAgreementInstallmentWhereInput | CollectionCaseAgreementInstallmentWhereInput[]
    id?: StringFilter<"CollectionCaseAgreementInstallment"> | string
    agreement_id?: StringFilter<"CollectionCaseAgreementInstallment"> | string
    number?: IntFilter<"CollectionCaseAgreementInstallment"> | number
    due_date?: DateTimeFilter<"CollectionCaseAgreementInstallment"> | Date | string
    amount?: DecimalFilter<"CollectionCaseAgreementInstallment"> | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFilter<"CollectionCaseAgreementInstallment"> | $Enums.InstallmentStatus
    payment_id?: StringNullableFilter<"CollectionCaseAgreementInstallment"> | string | null
    created_at?: DateTimeFilter<"CollectionCaseAgreementInstallment"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCaseAgreementInstallment"> | Date | string
    agreement?: XOR<CollectionCaseAgreementScalarRelationFilter, CollectionCaseAgreementWhereInput>
    payment?: XOR<CollectionCasePaymentNullableScalarRelationFilter, CollectionCasePaymentWhereInput> | null
  }

  export type CollectionCaseAgreementInstallmentOrderByWithRelationInput = {
    id?: SortOrder
    agreement_id?: SortOrder
    number?: SortOrder
    due_date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    payment_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agreement?: CollectionCaseAgreementOrderByWithRelationInput
    payment?: CollectionCasePaymentOrderByWithRelationInput
  }

  export type CollectionCaseAgreementInstallmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionCaseAgreementInstallmentWhereInput | CollectionCaseAgreementInstallmentWhereInput[]
    OR?: CollectionCaseAgreementInstallmentWhereInput[]
    NOT?: CollectionCaseAgreementInstallmentWhereInput | CollectionCaseAgreementInstallmentWhereInput[]
    agreement_id?: StringFilter<"CollectionCaseAgreementInstallment"> | string
    number?: IntFilter<"CollectionCaseAgreementInstallment"> | number
    due_date?: DateTimeFilter<"CollectionCaseAgreementInstallment"> | Date | string
    amount?: DecimalFilter<"CollectionCaseAgreementInstallment"> | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFilter<"CollectionCaseAgreementInstallment"> | $Enums.InstallmentStatus
    payment_id?: StringNullableFilter<"CollectionCaseAgreementInstallment"> | string | null
    created_at?: DateTimeFilter<"CollectionCaseAgreementInstallment"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCaseAgreementInstallment"> | Date | string
    agreement?: XOR<CollectionCaseAgreementScalarRelationFilter, CollectionCaseAgreementWhereInput>
    payment?: XOR<CollectionCasePaymentNullableScalarRelationFilter, CollectionCasePaymentWhereInput> | null
  }, "id">

  export type CollectionCaseAgreementInstallmentOrderByWithAggregationInput = {
    id?: SortOrder
    agreement_id?: SortOrder
    number?: SortOrder
    due_date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    payment_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CollectionCaseAgreementInstallmentCountOrderByAggregateInput
    _avg?: CollectionCaseAgreementInstallmentAvgOrderByAggregateInput
    _max?: CollectionCaseAgreementInstallmentMaxOrderByAggregateInput
    _min?: CollectionCaseAgreementInstallmentMinOrderByAggregateInput
    _sum?: CollectionCaseAgreementInstallmentSumOrderByAggregateInput
  }

  export type CollectionCaseAgreementInstallmentScalarWhereWithAggregatesInput = {
    AND?: CollectionCaseAgreementInstallmentScalarWhereWithAggregatesInput | CollectionCaseAgreementInstallmentScalarWhereWithAggregatesInput[]
    OR?: CollectionCaseAgreementInstallmentScalarWhereWithAggregatesInput[]
    NOT?: CollectionCaseAgreementInstallmentScalarWhereWithAggregatesInput | CollectionCaseAgreementInstallmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionCaseAgreementInstallment"> | string
    agreement_id?: StringWithAggregatesFilter<"CollectionCaseAgreementInstallment"> | string
    number?: IntWithAggregatesFilter<"CollectionCaseAgreementInstallment"> | number
    due_date?: DateTimeWithAggregatesFilter<"CollectionCaseAgreementInstallment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"CollectionCaseAgreementInstallment"> | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusWithAggregatesFilter<"CollectionCaseAgreementInstallment"> | $Enums.InstallmentStatus
    payment_id?: StringNullableWithAggregatesFilter<"CollectionCaseAgreementInstallment"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"CollectionCaseAgreementInstallment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CollectionCaseAgreementInstallment"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    debtors?: DebtorCreateNestedManyWithoutUserInput
    verdict_bailiffs?: VerdictCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    tenant_id: string
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    verdict_bailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    verdict_bailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    verdict_bailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    tenant_id: string
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParameterCreateInput = {
    id?: string
    collection_fee_rate?: number
    abb_rate?: number
    company_aanmaning_term_days?: number
    consumer_aanmaning_term_days?: number
    company_sommatie_term_days?: number
    consumer_sommatie_term_days?: number
    small_company_price?: number
    small_company_pfc_contribution?: number
    large_company_price?: number
    large_company_pfc_contribution?: number
    company_aanmaning_penalty?: number
    natural_aanmaning_penalty?: number
    company_sommatie_penalty?: number
    natural_sommatie_penalty?: number
    company_reaction_limit_days?: number
    company_no_reaction_penalty?: number
    natural_no_reaction_penalty?: number
    company_payment_agreement_fee?: number
    natural_payment_agreement_fee?: number
    invoice_number_length?: number
    invoice_prefix?: string
    invoice_sequence?: number
    bank_account?: string
    bank_name?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ParameterUncheckedCreateInput = {
    id?: string
    collection_fee_rate?: number
    abb_rate?: number
    company_aanmaning_term_days?: number
    consumer_aanmaning_term_days?: number
    company_sommatie_term_days?: number
    consumer_sommatie_term_days?: number
    small_company_price?: number
    small_company_pfc_contribution?: number
    large_company_price?: number
    large_company_pfc_contribution?: number
    company_aanmaning_penalty?: number
    natural_aanmaning_penalty?: number
    company_sommatie_penalty?: number
    natural_sommatie_penalty?: number
    company_reaction_limit_days?: number
    company_no_reaction_penalty?: number
    natural_no_reaction_penalty?: number
    company_payment_agreement_fee?: number
    natural_payment_agreement_fee?: number
    invoice_number_length?: number
    invoice_prefix?: string
    invoice_sequence?: number
    bank_account?: string
    bank_name?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ParameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_fee_rate?: FloatFieldUpdateOperationsInput | number
    abb_rate?: FloatFieldUpdateOperationsInput | number
    company_aanmaning_term_days?: IntFieldUpdateOperationsInput | number
    consumer_aanmaning_term_days?: IntFieldUpdateOperationsInput | number
    company_sommatie_term_days?: IntFieldUpdateOperationsInput | number
    consumer_sommatie_term_days?: IntFieldUpdateOperationsInput | number
    small_company_price?: FloatFieldUpdateOperationsInput | number
    small_company_pfc_contribution?: FloatFieldUpdateOperationsInput | number
    large_company_price?: FloatFieldUpdateOperationsInput | number
    large_company_pfc_contribution?: FloatFieldUpdateOperationsInput | number
    company_aanmaning_penalty?: FloatFieldUpdateOperationsInput | number
    natural_aanmaning_penalty?: FloatFieldUpdateOperationsInput | number
    company_sommatie_penalty?: FloatFieldUpdateOperationsInput | number
    natural_sommatie_penalty?: FloatFieldUpdateOperationsInput | number
    company_reaction_limit_days?: IntFieldUpdateOperationsInput | number
    company_no_reaction_penalty?: FloatFieldUpdateOperationsInput | number
    natural_no_reaction_penalty?: FloatFieldUpdateOperationsInput | number
    company_payment_agreement_fee?: FloatFieldUpdateOperationsInput | number
    natural_payment_agreement_fee?: FloatFieldUpdateOperationsInput | number
    invoice_number_length?: IntFieldUpdateOperationsInput | number
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    bank_account?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_fee_rate?: FloatFieldUpdateOperationsInput | number
    abb_rate?: FloatFieldUpdateOperationsInput | number
    company_aanmaning_term_days?: IntFieldUpdateOperationsInput | number
    consumer_aanmaning_term_days?: IntFieldUpdateOperationsInput | number
    company_sommatie_term_days?: IntFieldUpdateOperationsInput | number
    consumer_sommatie_term_days?: IntFieldUpdateOperationsInput | number
    small_company_price?: FloatFieldUpdateOperationsInput | number
    small_company_pfc_contribution?: FloatFieldUpdateOperationsInput | number
    large_company_price?: FloatFieldUpdateOperationsInput | number
    large_company_pfc_contribution?: FloatFieldUpdateOperationsInput | number
    company_aanmaning_penalty?: FloatFieldUpdateOperationsInput | number
    natural_aanmaning_penalty?: FloatFieldUpdateOperationsInput | number
    company_sommatie_penalty?: FloatFieldUpdateOperationsInput | number
    natural_sommatie_penalty?: FloatFieldUpdateOperationsInput | number
    company_reaction_limit_days?: IntFieldUpdateOperationsInput | number
    company_no_reaction_penalty?: FloatFieldUpdateOperationsInput | number
    natural_no_reaction_penalty?: FloatFieldUpdateOperationsInput | number
    company_payment_agreement_fee?: FloatFieldUpdateOperationsInput | number
    natural_payment_agreement_fee?: FloatFieldUpdateOperationsInput | number
    invoice_number_length?: IntFieldUpdateOperationsInput | number
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    bank_account?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParameterCreateManyInput = {
    id?: string
    collection_fee_rate?: number
    abb_rate?: number
    company_aanmaning_term_days?: number
    consumer_aanmaning_term_days?: number
    company_sommatie_term_days?: number
    consumer_sommatie_term_days?: number
    small_company_price?: number
    small_company_pfc_contribution?: number
    large_company_price?: number
    large_company_pfc_contribution?: number
    company_aanmaning_penalty?: number
    natural_aanmaning_penalty?: number
    company_sommatie_penalty?: number
    natural_sommatie_penalty?: number
    company_reaction_limit_days?: number
    company_no_reaction_penalty?: number
    natural_no_reaction_penalty?: number
    company_payment_agreement_fee?: number
    natural_payment_agreement_fee?: number
    invoice_number_length?: number
    invoice_prefix?: string
    invoice_sequence?: number
    bank_account?: string
    bank_name?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ParameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_fee_rate?: FloatFieldUpdateOperationsInput | number
    abb_rate?: FloatFieldUpdateOperationsInput | number
    company_aanmaning_term_days?: IntFieldUpdateOperationsInput | number
    consumer_aanmaning_term_days?: IntFieldUpdateOperationsInput | number
    company_sommatie_term_days?: IntFieldUpdateOperationsInput | number
    consumer_sommatie_term_days?: IntFieldUpdateOperationsInput | number
    small_company_price?: FloatFieldUpdateOperationsInput | number
    small_company_pfc_contribution?: FloatFieldUpdateOperationsInput | number
    large_company_price?: FloatFieldUpdateOperationsInput | number
    large_company_pfc_contribution?: FloatFieldUpdateOperationsInput | number
    company_aanmaning_penalty?: FloatFieldUpdateOperationsInput | number
    natural_aanmaning_penalty?: FloatFieldUpdateOperationsInput | number
    company_sommatie_penalty?: FloatFieldUpdateOperationsInput | number
    natural_sommatie_penalty?: FloatFieldUpdateOperationsInput | number
    company_reaction_limit_days?: IntFieldUpdateOperationsInput | number
    company_no_reaction_penalty?: FloatFieldUpdateOperationsInput | number
    natural_no_reaction_penalty?: FloatFieldUpdateOperationsInput | number
    company_payment_agreement_fee?: FloatFieldUpdateOperationsInput | number
    natural_payment_agreement_fee?: FloatFieldUpdateOperationsInput | number
    invoice_number_length?: IntFieldUpdateOperationsInput | number
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    bank_account?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_fee_rate?: FloatFieldUpdateOperationsInput | number
    abb_rate?: FloatFieldUpdateOperationsInput | number
    company_aanmaning_term_days?: IntFieldUpdateOperationsInput | number
    consumer_aanmaning_term_days?: IntFieldUpdateOperationsInput | number
    company_sommatie_term_days?: IntFieldUpdateOperationsInput | number
    consumer_sommatie_term_days?: IntFieldUpdateOperationsInput | number
    small_company_price?: FloatFieldUpdateOperationsInput | number
    small_company_pfc_contribution?: FloatFieldUpdateOperationsInput | number
    large_company_price?: FloatFieldUpdateOperationsInput | number
    large_company_pfc_contribution?: FloatFieldUpdateOperationsInput | number
    company_aanmaning_penalty?: FloatFieldUpdateOperationsInput | number
    natural_aanmaning_penalty?: FloatFieldUpdateOperationsInput | number
    company_sommatie_penalty?: FloatFieldUpdateOperationsInput | number
    natural_sommatie_penalty?: FloatFieldUpdateOperationsInput | number
    company_reaction_limit_days?: IntFieldUpdateOperationsInput | number
    company_no_reaction_penalty?: FloatFieldUpdateOperationsInput | number
    natural_no_reaction_penalty?: FloatFieldUpdateOperationsInput | number
    company_payment_agreement_fee?: FloatFieldUpdateOperationsInput | number
    natural_payment_agreement_fee?: FloatFieldUpdateOperationsInput | number
    invoice_number_length?: IntFieldUpdateOperationsInput | number
    invoice_prefix?: StringFieldUpdateOperationsInput | string
    invoice_sequence?: IntFieldUpdateOperationsInput | number
    bank_account?: StringFieldUpdateOperationsInput | string
    bank_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictCreateInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdict_bailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    debtor_id: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    tenant_id: string
    notes?: string | null
    bailiff_id?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdict_bailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff_id?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictCreateManyInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    debtor_id: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    tenant_id: string
    notes?: string | null
    bailiff_id?: string | null
  }

  export type VerdictUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictInterestCreateInput = {
    id?: string
    interest_type: number
    base_amount: number
    calculated_interest?: number | null
    calculation_start: Date | string
    calculation_end: Date | string
    total_interest: number
    created_at?: Date | string
    updated_at?: Date | string
    verdict?: VerdictCreateNestedOneWithoutVerdict_interestInput
    details?: VerdictInterestDetailsCreateNestedManyWithoutVerdict_interestInput
  }

  export type VerdictInterestUncheckedCreateInput = {
    id?: string
    interest_type: number
    base_amount: number
    calculated_interest?: number | null
    calculation_start: Date | string
    calculation_end: Date | string
    total_interest: number
    created_at?: Date | string
    updated_at?: Date | string
    verdict_id?: string | null
    details?: VerdictInterestDetailsUncheckedCreateNestedManyWithoutVerdict_interestInput
  }

  export type VerdictInterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest_type?: IntFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    calculated_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculation_start?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_end?: DateTimeFieldUpdateOperationsInput | Date | string
    total_interest?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneWithoutVerdict_interestNestedInput
    details?: VerdictInterestDetailsUpdateManyWithoutVerdict_interestNestedInput
  }

  export type VerdictInterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest_type?: IntFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    calculated_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculation_start?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_end?: DateTimeFieldUpdateOperationsInput | Date | string
    total_interest?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict_id?: NullableStringFieldUpdateOperationsInput | string | null
    details?: VerdictInterestDetailsUncheckedUpdateManyWithoutVerdict_interestNestedInput
  }

  export type VerdictInterestCreateManyInput = {
    id?: string
    interest_type: number
    base_amount: number
    calculated_interest?: number | null
    calculation_start: Date | string
    calculation_end: Date | string
    total_interest: number
    created_at?: Date | string
    updated_at?: Date | string
    verdict_id?: string | null
  }

  export type VerdictInterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest_type?: IntFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    calculated_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculation_start?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_end?: DateTimeFieldUpdateOperationsInput | Date | string
    total_interest?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest_type?: IntFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    calculated_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculation_start?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_end?: DateTimeFieldUpdateOperationsInput | Date | string
    total_interest?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictInterestDetailsCreateInput = {
    id?: string
    period: string
    period_start: Date | string
    period_end: Date | string
    days: number
    annual_rate: number
    proportional_rate: number
    base_amount: number
    interest: number
    total: number
    created_at?: Date | string
    updated_at?: Date | string
    verdict_interest: VerdictInterestCreateNestedOneWithoutDetailsInput
  }

  export type VerdictInterestDetailsUncheckedCreateInput = {
    id?: string
    period: string
    period_start: Date | string
    period_end: Date | string
    days: number
    annual_rate: number
    proportional_rate: number
    base_amount: number
    interest: number
    total: number
    verdict_interest_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictInterestDetailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annual_rate?: FloatFieldUpdateOperationsInput | number
    proportional_rate?: FloatFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict_interest?: VerdictInterestUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type VerdictInterestDetailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annual_rate?: FloatFieldUpdateOperationsInput | number
    proportional_rate?: FloatFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    verdict_interest_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsCreateManyInput = {
    id?: string
    period: string
    period_start: Date | string
    period_end: Date | string
    days: number
    annual_rate: number
    proportional_rate: number
    base_amount: number
    interest: number
    total: number
    verdict_interest_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictInterestDetailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annual_rate?: FloatFieldUpdateOperationsInput | number
    proportional_rate?: FloatFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annual_rate?: FloatFieldUpdateOperationsInput | number
    proportional_rate?: FloatFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    verdict_interest_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoCreateInput = {
    id?: string
    company_name: string
    company_phone: string
    company_email: string
    company_address: string
    embargo_type: string
    embargo_date: Date | string
    embargo_amount: number
    total_amount: number
    created_at?: Date | string
    updated_at?: Date | string
    verdict: VerdictCreateNestedOneWithoutVerdict_embargoInput
  }

  export type VerdictEmbargoUncheckedCreateInput = {
    id?: string
    verdict_id: string
    company_name: string
    company_phone: string
    company_email: string
    company_address: string
    embargo_type: string
    embargo_date: Date | string
    embargo_amount: number
    total_amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictEmbargoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_phone?: StringFieldUpdateOperationsInput | string
    company_email?: StringFieldUpdateOperationsInput | string
    company_address?: StringFieldUpdateOperationsInput | string
    embargo_type?: StringFieldUpdateOperationsInput | string
    embargo_date?: DateTimeFieldUpdateOperationsInput | Date | string
    embargo_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneRequiredWithoutVerdict_embargoNestedInput
  }

  export type VerdictEmbargoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdict_id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_phone?: StringFieldUpdateOperationsInput | string
    company_email?: StringFieldUpdateOperationsInput | string
    company_address?: StringFieldUpdateOperationsInput | string
    embargo_type?: StringFieldUpdateOperationsInput | string
    embargo_date?: DateTimeFieldUpdateOperationsInput | Date | string
    embargo_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoCreateManyInput = {
    id?: string
    verdict_id: string
    company_name: string
    company_phone: string
    company_email: string
    company_address: string
    embargo_type: string
    embargo_date: Date | string
    embargo_amount: number
    total_amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictEmbargoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_phone?: StringFieldUpdateOperationsInput | string
    company_email?: StringFieldUpdateOperationsInput | string
    company_address?: StringFieldUpdateOperationsInput | string
    embargo_type?: StringFieldUpdateOperationsInput | string
    embargo_date?: DateTimeFieldUpdateOperationsInput | Date | string
    embargo_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdict_id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_phone?: StringFieldUpdateOperationsInput | string
    company_email?: StringFieldUpdateOperationsInput | string
    company_address?: StringFieldUpdateOperationsInput | string
    embargo_type?: StringFieldUpdateOperationsInput | string
    embargo_date?: DateTimeFieldUpdateOperationsInput | Date | string
    embargo_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesCreateInput = {
    id?: string
    service_type: string
    service_cost: number
    created_at?: Date | string
    updated_at?: Date | string
    verdict: VerdictCreateNestedOneWithoutBailiff_servicesInput
  }

  export type VerdictBailiffServicesUncheckedCreateInput = {
    id?: string
    verdict_id: string
    service_type: string
    service_cost: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictBailiffServicesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    service_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneRequiredWithoutBailiff_servicesNestedInput
  }

  export type VerdictBailiffServicesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdict_id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    service_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesCreateManyInput = {
    id?: string
    verdict_id: string
    service_type: string
    service_cost: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictBailiffServicesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    service_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdict_id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    service_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictAttachmentCreateInput = {
    id?: string
    file_path: string
    file_size: bigint | number
    created_at?: Date | string
    updated_at?: Date | string
    file_name: string
    verdict: VerdictCreateNestedOneWithoutAttachmentsInput
  }

  export type VerdictAttachmentUncheckedCreateInput = {
    id?: string
    verdict_id: string
    file_path: string
    file_size: bigint | number
    created_at?: Date | string
    updated_at?: Date | string
    file_name: string
  }

  export type VerdictAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    file_name?: StringFieldUpdateOperationsInput | string
    verdict?: VerdictUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type VerdictAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdict_id?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    file_name?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentCreateManyInput = {
    id?: string
    verdict_id: string
    file_path: string
    file_size: bigint | number
    created_at?: Date | string
    updated_at?: Date | string
    file_name: string
  }

  export type VerdictAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    file_name?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    verdict_id?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    file_name?: StringFieldUpdateOperationsInput | string
  }

  export type InterestTypeCreateInput = {
    name: string
    calculation_type: $Enums.CalculationTypeEnum
    details?: InterestDetailCreateNestedManyWithoutInterest_typeInput
  }

  export type InterestTypeUncheckedCreateInput = {
    id?: number
    name: string
    calculation_type: $Enums.CalculationTypeEnum
    details?: InterestDetailUncheckedCreateNestedManyWithoutInterest_typeInput
  }

  export type InterestTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    calculation_type?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
    details?: InterestDetailUpdateManyWithoutInterest_typeNestedInput
  }

  export type InterestTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calculation_type?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
    details?: InterestDetailUncheckedUpdateManyWithoutInterest_typeNestedInput
  }

  export type InterestTypeCreateManyInput = {
    id?: number
    name: string
    calculation_type: $Enums.CalculationTypeEnum
  }

  export type InterestTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    calculation_type?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type InterestTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calculation_type?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type InterestDetailCreateInput = {
    date: string
    rate: number
    interest_type: InterestTypeCreateNestedOneWithoutDetailsInput
  }

  export type InterestDetailUncheckedCreateInput = {
    id?: number
    date: string
    rate: number
    interest_type_id: number
  }

  export type InterestDetailUpdateInput = {
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    interest_type?: InterestTypeUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type InterestDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    interest_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type InterestDetailCreateManyInput = {
    id?: number
    date: string
    rate: number
    interest_type_id: number
  }

  export type InterestDetailUpdateManyMutationInput = {
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type InterestDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    interest_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type BillingInvoiceCreateInput = {
    id?: string
    invoice_number: string
    amount: number
    currency?: string
    issue_date: Date | string
    due_date: Date | string
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutBilling_invoiceInput
    details?: BillingInvoiceDetailCreateNestedManyWithoutBilling_invoiceInput
    payments?: BillingPaymentCreateNestedManyWithoutBilling_invoiceInput
  }

  export type BillingInvoiceUncheckedCreateInput = {
    id?: string
    tenant_id: string
    invoice_number: string
    amount: number
    currency?: string
    issue_date: Date | string
    due_date: Date | string
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    details?: BillingInvoiceDetailUncheckedCreateNestedManyWithoutBilling_invoiceInput
    payments?: BillingPaymentUncheckedCreateNestedManyWithoutBilling_invoiceInput
  }

  export type BillingInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBilling_invoiceNestedInput
    details?: BillingInvoiceDetailUpdateManyWithoutBilling_invoiceNestedInput
    payments?: BillingPaymentUpdateManyWithoutBilling_invoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUncheckedUpdateManyWithoutBilling_invoiceNestedInput
    payments?: BillingPaymentUncheckedUpdateManyWithoutBilling_invoiceNestedInput
  }

  export type BillingInvoiceCreateManyInput = {
    id?: string
    tenant_id: string
    invoice_number: string
    amount: number
    currency?: string
    issue_date: Date | string
    due_date: Date | string
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BillingInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailCreateInput = {
    id?: string
    item_description: string
    item_quantity: number
    item_unit_price: number
    item_total_price: number
    item_tax_rate: number
    item_tax_amount: number
    item_total_with_tax: number
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceCreateNestedOneWithoutDetailsInput
  }

  export type BillingInvoiceDetailUncheckedCreateInput = {
    id?: string
    item_description: string
    item_quantity: number
    item_unit_price: number
    item_total_price: number
    item_tax_rate: number
    item_tax_amount: number
    item_total_with_tax: number
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice_id?: string | null
  }

  export type BillingInvoiceDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_description?: StringFieldUpdateOperationsInput | string
    item_quantity?: IntFieldUpdateOperationsInput | number
    item_unit_price?: FloatFieldUpdateOperationsInput | number
    item_total_price?: FloatFieldUpdateOperationsInput | number
    item_tax_rate?: FloatFieldUpdateOperationsInput | number
    item_tax_amount?: FloatFieldUpdateOperationsInput | number
    item_total_with_tax?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUpdateOneWithoutDetailsNestedInput
  }

  export type BillingInvoiceDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_description?: StringFieldUpdateOperationsInput | string
    item_quantity?: IntFieldUpdateOperationsInput | number
    item_unit_price?: FloatFieldUpdateOperationsInput | number
    item_total_price?: FloatFieldUpdateOperationsInput | number
    item_tax_rate?: FloatFieldUpdateOperationsInput | number
    item_tax_amount?: FloatFieldUpdateOperationsInput | number
    item_total_with_tax?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingInvoiceDetailCreateManyInput = {
    id?: string
    item_description: string
    item_quantity: number
    item_unit_price: number
    item_total_price: number
    item_tax_rate: number
    item_tax_amount: number
    item_total_with_tax: number
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice_id?: string | null
  }

  export type BillingInvoiceDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_description?: StringFieldUpdateOperationsInput | string
    item_quantity?: IntFieldUpdateOperationsInput | number
    item_unit_price?: FloatFieldUpdateOperationsInput | number
    item_total_price?: FloatFieldUpdateOperationsInput | number
    item_tax_rate?: FloatFieldUpdateOperationsInput | number
    item_tax_amount?: FloatFieldUpdateOperationsInput | number
    item_total_with_tax?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_description?: StringFieldUpdateOperationsInput | string
    item_quantity?: IntFieldUpdateOperationsInput | number
    item_unit_price?: FloatFieldUpdateOperationsInput | number
    item_total_price?: FloatFieldUpdateOperationsInput | number
    item_tax_rate?: FloatFieldUpdateOperationsInput | number
    item_tax_amount?: FloatFieldUpdateOperationsInput | number
    item_total_with_tax?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingPaymentCreateInput = {
    id?: string
    payment_date: Date | string
    amount: number
    payment_method: string
    transaction_id?: string | null
    status: string
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type BillingPaymentUncheckedCreateInput = {
    id?: string
    payment_date: Date | string
    amount: number
    payment_method: string
    transaction_id?: string | null
    status: string
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice_id?: string | null
  }

  export type BillingPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type BillingPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillingPaymentCreateManyInput = {
    id?: string
    payment_date: Date | string
    amount: number
    payment_method: string
    transaction_id?: string | null
    status: string
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice_id?: string | null
  }

  export type BillingPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CollectionCaseCreateInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollection_casesInput
    tenant: TenantCreateNestedOneWithoutCollection_casesInput
    notifications?: CollectionCaseNotificationCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseUncheckedCreateInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    tenant_id: string
    debtor_id: string
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notifications?: CollectionCaseNotificationUncheckedCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyUncheckedCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollection_casesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollection_casesNestedInput
    notifications?: CollectionCaseNotificationUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: CollectionCaseNotificationUncheckedUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUncheckedUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseCreateManyInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    tenant_id: string
    debtor_id: string
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCasePenaltyCreateInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    date_applied?: Date | string
    is_paid?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    collection_case: CollectionCaseCreateNestedOneWithoutPenaltiesInput
  }

  export type CollectionCasePenaltyUncheckedCreateInput = {
    id?: string
    collection_case_id: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    date_applied?: Date | string
    is_paid?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCasePenaltyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_applied?: DateTimeFieldUpdateOperationsInput | Date | string
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_case?: CollectionCaseUpdateOneRequiredWithoutPenaltiesNestedInput
  }

  export type CollectionCasePenaltyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_applied?: DateTimeFieldUpdateOperationsInput | Date | string
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCasePenaltyCreateManyInput = {
    id?: string
    collection_case_id: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    date_applied?: Date | string
    is_paid?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCasePenaltyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_applied?: DateTimeFieldUpdateOperationsInput | Date | string
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCasePenaltyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_applied?: DateTimeFieldUpdateOperationsInput | Date | string
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseNotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sent_at?: Date | string
    read?: boolean
    created_at?: Date | string
    collection_case: CollectionCaseCreateNestedOneWithoutNotificationsInput
  }

  export type CollectionCaseNotificationUncheckedCreateInput = {
    id?: string
    collection_case_id: string
    type: $Enums.NotificationType
    title: string
    message: string
    sent_at?: Date | string
    read?: boolean
    created_at?: Date | string
  }

  export type CollectionCaseNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_case?: CollectionCaseUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type CollectionCaseNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseNotificationCreateManyInput = {
    id?: string
    collection_case_id: string
    type: $Enums.NotificationType
    title: string
    message: string
    sent_at?: Date | string
    read?: boolean
    created_at?: Date | string
  }

  export type CollectionCaseNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCasePaymentCreateInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    payment_date: Date | string
    reference_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_case: CollectionCaseCreateNestedOneWithoutPaymentsInput
    agreement?: CollectionCaseAgreementCreateNestedOneWithoutPaymentsInput
    installments?: CollectionCaseAgreementInstallmentCreateNestedManyWithoutPaymentInput
  }

  export type CollectionCasePaymentUncheckedCreateInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    collection_case_id: string
    payment_date: Date | string
    reference_number?: string | null
    agreement_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type CollectionCasePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_case?: CollectionCaseUpdateOneRequiredWithoutPaymentsNestedInput
    agreement?: CollectionCaseAgreementUpdateOneWithoutPaymentsNestedInput
    installments?: CollectionCaseAgreementInstallmentUpdateManyWithoutPaymentNestedInput
  }

  export type CollectionCasePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type CollectionCasePaymentCreateManyInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    collection_case_id: string
    payment_date: Date | string
    reference_number?: string | null
    agreement_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCasePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCasePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorCreateInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    payment_agreements?: CollectionCaseAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateInput = {
    id?: string
    tenant_id: string
    user_id?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    payment_agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    payment_agreements?: CollectionCaseAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    payment_agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorCreateManyInput = {
    id?: string
    tenant_id: string
    user_id?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DebtorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatRoomCreateInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutChat_roomsInput
    collection_case: CollectionCaseCreateNestedOneWithoutChat_roomsInput
    messages?: ChatMessageCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomUncheckedCreateInput = {
    id?: string
    tenant_id: string
    collection_case_id: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutChat_roomsNestedInput
    collection_case?: CollectionCaseUpdateOneRequiredWithoutChat_roomsNestedInput
    messages?: ChatMessageUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomCreateManyInput = {
    id?: string
    tenant_id: string
    collection_case_id: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    message: string
    file_url?: string | null
    file_name?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    room: ChatRoomCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    room_id: string
    sender_id: string
    message: string
    file_url?: string | null
    file_name?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: ChatRoomUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    room_id: string
    sender_id: string
    message: string
    file_url?: string | null
    file_name?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeCreateInput = {
    id?: string
    amount: number
    source: string
    created_at?: Date | string
    updated_at?: Date | string
    debtor: DebtorCreateNestedOneWithoutIncomesInput
  }

  export type DebtorIncomeUncheckedCreateInput = {
    id?: string
    debtor_id: string
    amount: number
    source: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DebtorIncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutIncomesNestedInput
  }

  export type DebtorIncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeCreateManyInput = {
    id?: string
    debtor_id: string
    amount: number
    source: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DebtorIncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementCreateInput = {
    id?: string
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutAgreementsInput
    debtor?: DebtorCreateNestedOneWithoutPayment_agreementsInput
    collection_case: CollectionCaseCreateNestedOneWithoutAgreementsInput
    installments?: CollectionCaseAgreementInstallmentCreateNestedManyWithoutAgreementInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementUncheckedCreateInput = {
    id?: string
    collection_case_id: string
    debtor_id?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    tenant_id: string
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedCreateNestedManyWithoutAgreementInput
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAgreementsNestedInput
    debtor?: DebtorUpdateOneWithoutPayment_agreementsNestedInput
    collection_case?: CollectionCaseUpdateOneRequiredWithoutAgreementsNestedInput
    installments?: CollectionCaseAgreementInstallmentUpdateManyWithoutAgreementNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCaseAgreementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    tenant_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutAgreementNestedInput
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCaseAgreementCreateManyInput = {
    id?: string
    collection_case_id: string
    debtor_id?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    tenant_id: string
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseAgreementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    tenant_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementInstallmentCreateInput = {
    id?: string
    number: number
    due_date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    created_at?: Date | string
    updated_at?: Date | string
    agreement: CollectionCaseAgreementCreateNestedOneWithoutInstallmentsInput
    payment?: CollectionCasePaymentCreateNestedOneWithoutInstallmentsInput
  }

  export type CollectionCaseAgreementInstallmentUncheckedCreateInput = {
    id?: string
    agreement_id: string
    number: number
    due_date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    payment_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseAgreementInstallmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: CollectionCaseAgreementUpdateOneRequiredWithoutInstallmentsNestedInput
    payment?: CollectionCasePaymentUpdateOneWithoutInstallmentsNestedInput
  }

  export type CollectionCaseAgreementInstallmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreement_id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementInstallmentCreateManyInput = {
    id?: string
    agreement_id: string
    number: number
    due_date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    payment_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseAgreementInstallmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementInstallmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreement_id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BillingInvoiceListRelationFilter = {
    every?: BillingInvoiceWhereInput
    some?: BillingInvoiceWhereInput
    none?: BillingInvoiceWhereInput
  }

  export type CollectionCaseListRelationFilter = {
    every?: CollectionCaseWhereInput
    some?: CollectionCaseWhereInput
    none?: CollectionCaseWhereInput
  }

  export type DebtorListRelationFilter = {
    every?: DebtorWhereInput
    some?: DebtorWhereInput
    none?: DebtorWhereInput
  }

  export type VerdictListRelationFilter = {
    every?: VerdictWhereInput
    some?: VerdictWhereInput
    none?: VerdictWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ChatRoomListRelationFilter = {
    every?: ChatRoomWhereInput
    some?: ChatRoomWhereInput
    none?: ChatRoomWhereInput
  }

  export type CollectionCaseAgreementListRelationFilter = {
    every?: CollectionCaseAgreementWhereInput
    some?: CollectionCaseAgreementWhereInput
    none?: CollectionCaseAgreementWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BillingInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCaseAgreementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    contact_email?: SortOrder
    country_code?: SortOrder
    kvk?: SortOrder
    legal_name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    logo_url?: SortOrder
    number_of_employees?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    terms_accepted?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TenantAvgOrderByAggregateInput = {
    number_of_employees?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    contact_email?: SortOrder
    country_code?: SortOrder
    kvk?: SortOrder
    legal_name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    logo_url?: SortOrder
    number_of_employees?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    terms_accepted?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    contact_email?: SortOrder
    country_code?: SortOrder
    kvk?: SortOrder
    legal_name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    logo_url?: SortOrder
    number_of_employees?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    terms_accepted?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TenantSumOrderByAggregateInput = {
    number_of_employees?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumroleEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumFilter<$PrismaModel> | $Enums.roleEnum
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    fullname?: SortOrder
    phone?: SortOrder
    tenant_id?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    fullname?: SortOrder
    phone?: SortOrder
    tenant_id?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    fullname?: SortOrder
    phone?: SortOrder
    tenant_id?: SortOrder
    role?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumroleEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumWithAggregatesFilter<$PrismaModel> | $Enums.roleEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleEnumFilter<$PrismaModel>
    _max?: NestedEnumroleEnumFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ParameterCountOrderByAggregateInput = {
    id?: SortOrder
    collection_fee_rate?: SortOrder
    abb_rate?: SortOrder
    company_aanmaning_term_days?: SortOrder
    consumer_aanmaning_term_days?: SortOrder
    company_sommatie_term_days?: SortOrder
    consumer_sommatie_term_days?: SortOrder
    small_company_price?: SortOrder
    small_company_pfc_contribution?: SortOrder
    large_company_price?: SortOrder
    large_company_pfc_contribution?: SortOrder
    company_aanmaning_penalty?: SortOrder
    natural_aanmaning_penalty?: SortOrder
    company_sommatie_penalty?: SortOrder
    natural_sommatie_penalty?: SortOrder
    company_reaction_limit_days?: SortOrder
    company_no_reaction_penalty?: SortOrder
    natural_no_reaction_penalty?: SortOrder
    company_payment_agreement_fee?: SortOrder
    natural_payment_agreement_fee?: SortOrder
    invoice_number_length?: SortOrder
    invoice_prefix?: SortOrder
    invoice_sequence?: SortOrder
    bank_account?: SortOrder
    bank_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ParameterAvgOrderByAggregateInput = {
    collection_fee_rate?: SortOrder
    abb_rate?: SortOrder
    company_aanmaning_term_days?: SortOrder
    consumer_aanmaning_term_days?: SortOrder
    company_sommatie_term_days?: SortOrder
    consumer_sommatie_term_days?: SortOrder
    small_company_price?: SortOrder
    small_company_pfc_contribution?: SortOrder
    large_company_price?: SortOrder
    large_company_pfc_contribution?: SortOrder
    company_aanmaning_penalty?: SortOrder
    natural_aanmaning_penalty?: SortOrder
    company_sommatie_penalty?: SortOrder
    natural_sommatie_penalty?: SortOrder
    company_reaction_limit_days?: SortOrder
    company_no_reaction_penalty?: SortOrder
    natural_no_reaction_penalty?: SortOrder
    company_payment_agreement_fee?: SortOrder
    natural_payment_agreement_fee?: SortOrder
    invoice_number_length?: SortOrder
    invoice_sequence?: SortOrder
  }

  export type ParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    collection_fee_rate?: SortOrder
    abb_rate?: SortOrder
    company_aanmaning_term_days?: SortOrder
    consumer_aanmaning_term_days?: SortOrder
    company_sommatie_term_days?: SortOrder
    consumer_sommatie_term_days?: SortOrder
    small_company_price?: SortOrder
    small_company_pfc_contribution?: SortOrder
    large_company_price?: SortOrder
    large_company_pfc_contribution?: SortOrder
    company_aanmaning_penalty?: SortOrder
    natural_aanmaning_penalty?: SortOrder
    company_sommatie_penalty?: SortOrder
    natural_sommatie_penalty?: SortOrder
    company_reaction_limit_days?: SortOrder
    company_no_reaction_penalty?: SortOrder
    natural_no_reaction_penalty?: SortOrder
    company_payment_agreement_fee?: SortOrder
    natural_payment_agreement_fee?: SortOrder
    invoice_number_length?: SortOrder
    invoice_prefix?: SortOrder
    invoice_sequence?: SortOrder
    bank_account?: SortOrder
    bank_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ParameterMinOrderByAggregateInput = {
    id?: SortOrder
    collection_fee_rate?: SortOrder
    abb_rate?: SortOrder
    company_aanmaning_term_days?: SortOrder
    consumer_aanmaning_term_days?: SortOrder
    company_sommatie_term_days?: SortOrder
    consumer_sommatie_term_days?: SortOrder
    small_company_price?: SortOrder
    small_company_pfc_contribution?: SortOrder
    large_company_price?: SortOrder
    large_company_pfc_contribution?: SortOrder
    company_aanmaning_penalty?: SortOrder
    natural_aanmaning_penalty?: SortOrder
    company_sommatie_penalty?: SortOrder
    natural_sommatie_penalty?: SortOrder
    company_reaction_limit_days?: SortOrder
    company_no_reaction_penalty?: SortOrder
    natural_no_reaction_penalty?: SortOrder
    company_payment_agreement_fee?: SortOrder
    natural_payment_agreement_fee?: SortOrder
    invoice_number_length?: SortOrder
    invoice_prefix?: SortOrder
    invoice_sequence?: SortOrder
    bank_account?: SortOrder
    bank_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ParameterSumOrderByAggregateInput = {
    collection_fee_rate?: SortOrder
    abb_rate?: SortOrder
    company_aanmaning_term_days?: SortOrder
    consumer_aanmaning_term_days?: SortOrder
    company_sommatie_term_days?: SortOrder
    consumer_sommatie_term_days?: SortOrder
    small_company_price?: SortOrder
    small_company_pfc_contribution?: SortOrder
    large_company_price?: SortOrder
    large_company_pfc_contribution?: SortOrder
    company_aanmaning_penalty?: SortOrder
    natural_aanmaning_penalty?: SortOrder
    company_sommatie_penalty?: SortOrder
    natural_sommatie_penalty?: SortOrder
    company_reaction_limit_days?: SortOrder
    company_no_reaction_penalty?: SortOrder
    natural_no_reaction_penalty?: SortOrder
    company_payment_agreement_fee?: SortOrder
    natural_payment_agreement_fee?: SortOrder
    invoice_number_length?: SortOrder
    invoice_sequence?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumVerdictStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusFilter<$PrismaModel> | $Enums.VerdictStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DebtorScalarRelationFilter = {
    is?: DebtorWhereInput
    isNot?: DebtorWhereInput
  }

  export type VerdictAttachmentListRelationFilter = {
    every?: VerdictAttachmentWhereInput
    some?: VerdictAttachmentWhereInput
    none?: VerdictAttachmentWhereInput
  }

  export type VerdictBailiffServicesListRelationFilter = {
    every?: VerdictBailiffServicesWhereInput
    some?: VerdictBailiffServicesWhereInput
    none?: VerdictBailiffServicesWhereInput
  }

  export type VerdictEmbargoListRelationFilter = {
    every?: VerdictEmbargoWhereInput
    some?: VerdictEmbargoWhereInput
    none?: VerdictEmbargoWhereInput
  }

  export type VerdictInterestListRelationFilter = {
    every?: VerdictInterestWhereInput
    some?: VerdictInterestWhereInput
    none?: VerdictInterestWhereInput
  }

  export type VerdictAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictBailiffServicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictEmbargoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    creditor_name?: SortOrder
    debtor_id?: SortOrder
    registration_number?: SortOrder
    sentence_amount?: SortOrder
    sentence_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    procesal_cost?: SortOrder
    tenant_id?: SortOrder
    notes?: SortOrder
    bailiff_id?: SortOrder
  }

  export type VerdictAvgOrderByAggregateInput = {
    sentence_amount?: SortOrder
    procesal_cost?: SortOrder
  }

  export type VerdictMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    creditor_name?: SortOrder
    debtor_id?: SortOrder
    registration_number?: SortOrder
    sentence_amount?: SortOrder
    sentence_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    procesal_cost?: SortOrder
    tenant_id?: SortOrder
    notes?: SortOrder
    bailiff_id?: SortOrder
  }

  export type VerdictMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    creditor_name?: SortOrder
    debtor_id?: SortOrder
    registration_number?: SortOrder
    sentence_amount?: SortOrder
    sentence_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    procesal_cost?: SortOrder
    tenant_id?: SortOrder
    notes?: SortOrder
    bailiff_id?: SortOrder
  }

  export type VerdictSumOrderByAggregateInput = {
    sentence_amount?: SortOrder
    procesal_cost?: SortOrder
  }

  export type EnumVerdictStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerdictStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerdictStatusFilter<$PrismaModel>
    _max?: NestedEnumVerdictStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type VerdictNullableScalarRelationFilter = {
    is?: VerdictWhereInput | null
    isNot?: VerdictWhereInput | null
  }

  export type VerdictInterestDetailsListRelationFilter = {
    every?: VerdictInterestDetailsWhereInput
    some?: VerdictInterestDetailsWhereInput
    none?: VerdictInterestDetailsWhereInput
  }

  export type VerdictInterestDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerdictInterestCountOrderByAggregateInput = {
    id?: SortOrder
    interest_type?: SortOrder
    base_amount?: SortOrder
    calculated_interest?: SortOrder
    calculation_start?: SortOrder
    calculation_end?: SortOrder
    total_interest?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verdict_id?: SortOrder
  }

  export type VerdictInterestAvgOrderByAggregateInput = {
    interest_type?: SortOrder
    base_amount?: SortOrder
    calculated_interest?: SortOrder
    total_interest?: SortOrder
  }

  export type VerdictInterestMaxOrderByAggregateInput = {
    id?: SortOrder
    interest_type?: SortOrder
    base_amount?: SortOrder
    calculated_interest?: SortOrder
    calculation_start?: SortOrder
    calculation_end?: SortOrder
    total_interest?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verdict_id?: SortOrder
  }

  export type VerdictInterestMinOrderByAggregateInput = {
    id?: SortOrder
    interest_type?: SortOrder
    base_amount?: SortOrder
    calculated_interest?: SortOrder
    calculation_start?: SortOrder
    calculation_end?: SortOrder
    total_interest?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    verdict_id?: SortOrder
  }

  export type VerdictInterestSumOrderByAggregateInput = {
    interest_type?: SortOrder
    base_amount?: SortOrder
    calculated_interest?: SortOrder
    total_interest?: SortOrder
  }

  export type VerdictInterestScalarRelationFilter = {
    is?: VerdictInterestWhereInput
    isNot?: VerdictInterestWhereInput
  }

  export type VerdictInterestDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    days?: SortOrder
    annual_rate?: SortOrder
    proportional_rate?: SortOrder
    base_amount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdict_interest_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VerdictInterestDetailsAvgOrderByAggregateInput = {
    days?: SortOrder
    annual_rate?: SortOrder
    proportional_rate?: SortOrder
    base_amount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
  }

  export type VerdictInterestDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    days?: SortOrder
    annual_rate?: SortOrder
    proportional_rate?: SortOrder
    base_amount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdict_interest_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VerdictInterestDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    days?: SortOrder
    annual_rate?: SortOrder
    proportional_rate?: SortOrder
    base_amount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
    verdict_interest_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VerdictInterestDetailsSumOrderByAggregateInput = {
    days?: SortOrder
    annual_rate?: SortOrder
    proportional_rate?: SortOrder
    base_amount?: SortOrder
    interest?: SortOrder
    total?: SortOrder
  }

  export type VerdictScalarRelationFilter = {
    is?: VerdictWhereInput
    isNot?: VerdictWhereInput
  }

  export type VerdictEmbargoCountOrderByAggregateInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    company_name?: SortOrder
    company_phone?: SortOrder
    company_email?: SortOrder
    company_address?: SortOrder
    embargo_type?: SortOrder
    embargo_date?: SortOrder
    embargo_amount?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VerdictEmbargoAvgOrderByAggregateInput = {
    embargo_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type VerdictEmbargoMaxOrderByAggregateInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    company_name?: SortOrder
    company_phone?: SortOrder
    company_email?: SortOrder
    company_address?: SortOrder
    embargo_type?: SortOrder
    embargo_date?: SortOrder
    embargo_amount?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VerdictEmbargoMinOrderByAggregateInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    company_name?: SortOrder
    company_phone?: SortOrder
    company_email?: SortOrder
    company_address?: SortOrder
    embargo_type?: SortOrder
    embargo_date?: SortOrder
    embargo_amount?: SortOrder
    total_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VerdictEmbargoSumOrderByAggregateInput = {
    embargo_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type VerdictBailiffServicesCountOrderByAggregateInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    service_type?: SortOrder
    service_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VerdictBailiffServicesAvgOrderByAggregateInput = {
    service_cost?: SortOrder
  }

  export type VerdictBailiffServicesMaxOrderByAggregateInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    service_type?: SortOrder
    service_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VerdictBailiffServicesMinOrderByAggregateInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    service_type?: SortOrder
    service_cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VerdictBailiffServicesSumOrderByAggregateInput = {
    service_cost?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type VerdictAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    file_path?: SortOrder
    file_size?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    file_name?: SortOrder
  }

  export type VerdictAttachmentAvgOrderByAggregateInput = {
    file_size?: SortOrder
  }

  export type VerdictAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    file_path?: SortOrder
    file_size?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    file_name?: SortOrder
  }

  export type VerdictAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    verdict_id?: SortOrder
    file_path?: SortOrder
    file_size?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    file_name?: SortOrder
  }

  export type VerdictAttachmentSumOrderByAggregateInput = {
    file_size?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumCalculationTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumFilter<$PrismaModel> | $Enums.CalculationTypeEnum
  }

  export type InterestDetailListRelationFilter = {
    every?: InterestDetailWhereInput
    some?: InterestDetailWhereInput
    none?: InterestDetailWhereInput
  }

  export type InterestDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterestTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calculation_type?: SortOrder
  }

  export type InterestTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InterestTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calculation_type?: SortOrder
  }

  export type InterestTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    calculation_type?: SortOrder
  }

  export type InterestTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.CalculationTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
  }

  export type InterestTypeScalarRelationFilter = {
    is?: InterestTypeWhereInput
    isNot?: InterestTypeWhereInput
  }

  export type InterestDetailCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interest_type_id?: SortOrder
  }

  export type InterestDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    interest_type_id?: SortOrder
  }

  export type InterestDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interest_type_id?: SortOrder
  }

  export type InterestDetailMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    rate?: SortOrder
    interest_type_id?: SortOrder
  }

  export type InterestDetailSumOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    interest_type_id?: SortOrder
  }

  export type BillingInvoiceDetailListRelationFilter = {
    every?: BillingInvoiceDetailWhereInput
    some?: BillingInvoiceDetailWhereInput
    none?: BillingInvoiceDetailWhereInput
  }

  export type BillingPaymentListRelationFilter = {
    every?: BillingPaymentWhereInput
    some?: BillingPaymentWhereInput
    none?: BillingPaymentWhereInput
  }

  export type BillingInvoiceDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillingInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    invoice_number?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BillingInvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    invoice_number?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BillingInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    invoice_number?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BillingInvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingInvoiceNullableScalarRelationFilter = {
    is?: BillingInvoiceWhereInput | null
    isNot?: BillingInvoiceWhereInput | null
  }

  export type BillingInvoiceDetailCountOrderByAggregateInput = {
    id?: SortOrder
    item_description?: SortOrder
    item_quantity?: SortOrder
    item_unit_price?: SortOrder
    item_total_price?: SortOrder
    item_tax_rate?: SortOrder
    item_tax_amount?: SortOrder
    item_total_with_tax?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_invoice_id?: SortOrder
  }

  export type BillingInvoiceDetailAvgOrderByAggregateInput = {
    item_quantity?: SortOrder
    item_unit_price?: SortOrder
    item_total_price?: SortOrder
    item_tax_rate?: SortOrder
    item_tax_amount?: SortOrder
    item_total_with_tax?: SortOrder
  }

  export type BillingInvoiceDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    item_description?: SortOrder
    item_quantity?: SortOrder
    item_unit_price?: SortOrder
    item_total_price?: SortOrder
    item_tax_rate?: SortOrder
    item_tax_amount?: SortOrder
    item_total_with_tax?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_invoice_id?: SortOrder
  }

  export type BillingInvoiceDetailMinOrderByAggregateInput = {
    id?: SortOrder
    item_description?: SortOrder
    item_quantity?: SortOrder
    item_unit_price?: SortOrder
    item_total_price?: SortOrder
    item_tax_rate?: SortOrder
    item_tax_amount?: SortOrder
    item_total_with_tax?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_invoice_id?: SortOrder
  }

  export type BillingInvoiceDetailSumOrderByAggregateInput = {
    item_quantity?: SortOrder
    item_unit_price?: SortOrder
    item_total_price?: SortOrder
    item_tax_rate?: SortOrder
    item_tax_amount?: SortOrder
    item_total_with_tax?: SortOrder
  }

  export type BillingPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    payment_date?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_invoice_id?: SortOrder
  }

  export type BillingPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillingPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    payment_date?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_invoice_id?: SortOrder
  }

  export type BillingPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    payment_date?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    billing_invoice_id?: SortOrder
  }

  export type BillingPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumCollectionCaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionCaseStatus | EnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionCaseStatus[] | ListEnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionCaseStatus[] | ListEnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionCaseStatusFilter<$PrismaModel> | $Enums.CollectionCaseStatus
  }

  export type CollectionCaseNotificationListRelationFilter = {
    every?: CollectionCaseNotificationWhereInput
    some?: CollectionCaseNotificationWhereInput
    none?: CollectionCaseNotificationWhereInput
  }

  export type CollectionCasePaymentListRelationFilter = {
    every?: CollectionCasePaymentWhereInput
    some?: CollectionCasePaymentWhereInput
    none?: CollectionCasePaymentWhereInput
  }

  export type CollectionCasePenaltyListRelationFilter = {
    every?: CollectionCasePenaltyWhereInput
    some?: CollectionCasePenaltyWhereInput
    none?: CollectionCasePenaltyWhereInput
  }

  export type CollectionCaseNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCasePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCasePenaltyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCaseCountOrderByAggregateInput = {
    id?: SortOrder
    reference_number?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    reminder1_sent_at?: SortOrder
    reminder1_due_date?: SortOrder
    reminder2_sent_at?: SortOrder
    reminder2_due_date?: SortOrder
    tenant_id?: SortOrder
    debtor_id?: SortOrder
    amount_original?: SortOrder
    amount_due?: SortOrder
    amount_to_receive?: SortOrder
    status?: SortOrder
    notification_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCaseAvgOrderByAggregateInput = {
    amount_original?: SortOrder
    amount_due?: SortOrder
    amount_to_receive?: SortOrder
  }

  export type CollectionCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    reference_number?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    reminder1_sent_at?: SortOrder
    reminder1_due_date?: SortOrder
    reminder2_sent_at?: SortOrder
    reminder2_due_date?: SortOrder
    tenant_id?: SortOrder
    debtor_id?: SortOrder
    amount_original?: SortOrder
    amount_due?: SortOrder
    amount_to_receive?: SortOrder
    status?: SortOrder
    notification_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCaseMinOrderByAggregateInput = {
    id?: SortOrder
    reference_number?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    reminder1_sent_at?: SortOrder
    reminder1_due_date?: SortOrder
    reminder2_sent_at?: SortOrder
    reminder2_due_date?: SortOrder
    tenant_id?: SortOrder
    debtor_id?: SortOrder
    amount_original?: SortOrder
    amount_due?: SortOrder
    amount_to_receive?: SortOrder
    status?: SortOrder
    notification_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCaseSumOrderByAggregateInput = {
    amount_original?: SortOrder
    amount_due?: SortOrder
    amount_to_receive?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumCollectionCaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionCaseStatus | EnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionCaseStatus[] | ListEnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionCaseStatus[] | ListEnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionCaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CollectionCaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCollectionCaseStatusFilter<$PrismaModel>
    _max?: NestedEnumCollectionCaseStatusFilter<$PrismaModel>
  }

  export type CollectionCaseScalarRelationFilter = {
    is?: CollectionCaseWhereInput
    isNot?: CollectionCaseWhereInput
  }

  export type CollectionCasePenaltyCountOrderByAggregateInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    date_applied?: SortOrder
    is_paid?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCasePenaltyAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CollectionCasePenaltyMaxOrderByAggregateInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    date_applied?: SortOrder
    is_paid?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCasePenaltyMinOrderByAggregateInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    date_applied?: SortOrder
    is_paid?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCasePenaltySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type CollectionCaseNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sent_at?: SortOrder
    read?: SortOrder
    created_at?: SortOrder
  }

  export type CollectionCaseNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sent_at?: SortOrder
    read?: SortOrder
    created_at?: SortOrder
  }

  export type CollectionCaseNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    sent_at?: SortOrder
    read?: SortOrder
    created_at?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type CollectionCaseAgreementNullableScalarRelationFilter = {
    is?: CollectionCaseAgreementWhereInput | null
    isNot?: CollectionCaseAgreementWhereInput | null
  }

  export type CollectionCaseAgreementInstallmentListRelationFilter = {
    every?: CollectionCaseAgreementInstallmentWhereInput
    some?: CollectionCaseAgreementInstallmentWhereInput
    none?: CollectionCaseAgreementInstallmentWhereInput
  }

  export type CollectionCaseAgreementInstallmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCasePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    collection_case_id?: SortOrder
    payment_date?: SortOrder
    reference_number?: SortOrder
    agreement_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCasePaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CollectionCasePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    collection_case_id?: SortOrder
    payment_date?: SortOrder
    reference_number?: SortOrder
    agreement_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCasePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    collection_case_id?: SortOrder
    payment_date?: SortOrder
    reference_number?: SortOrder
    agreement_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCasePaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPersonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeFilter<$PrismaModel> | $Enums.PersonType
  }

  export type EnumIdentificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel> | $Enums.IdentificationType | null
  }

  export type DebtorIncomeListRelationFilter = {
    every?: DebtorIncomeWhereInput
    some?: DebtorIncomeWhereInput
    none?: DebtorIncomeWhereInput
  }

  export type DebtorIncomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DebtorTenant_idEmailCompoundUniqueInput = {
    tenant_id: string
    email: string
  }

  export type DebtorTenant_idIdentificationCompoundUniqueInput = {
    tenant_id: string
    identification: string
  }

  export type DebtorCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    person_type?: SortOrder
    identification_type?: SortOrder
    identification?: SortOrder
    total_income?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DebtorAvgOrderByAggregateInput = {
    total_income?: SortOrder
  }

  export type DebtorMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    person_type?: SortOrder
    identification_type?: SortOrder
    identification?: SortOrder
    total_income?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DebtorMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    user_id?: SortOrder
    fullname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    person_type?: SortOrder
    identification_type?: SortOrder
    identification?: SortOrder
    total_income?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DebtorSumOrderByAggregateInput = {
    total_income?: SortOrder
  }

  export type EnumPersonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel> | $Enums.PersonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonTypeFilter<$PrismaModel>
    _max?: NestedEnumPersonTypeFilter<$PrismaModel>
  }

  export type EnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.IdentificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
  }

  export type ChatRoomCountOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    collection_case_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChatRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    collection_case_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChatRoomMinOrderByAggregateInput = {
    id?: SortOrder
    tenant_id?: SortOrder
    collection_case_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChatRoomScalarRelationFilter = {
    is?: ChatRoomWhereInput
    isNot?: ChatRoomWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    room_id?: SortOrder
    sender_id?: SortOrder
    message?: SortOrder
    file_url?: SortOrder
    file_name?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    room_id?: SortOrder
    sender_id?: SortOrder
    message?: SortOrder
    file_url?: SortOrder
    file_name?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    room_id?: SortOrder
    sender_id?: SortOrder
    message?: SortOrder
    file_url?: SortOrder
    file_name?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DebtorIncomeCountOrderByAggregateInput = {
    id?: SortOrder
    debtor_id?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DebtorIncomeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DebtorIncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    debtor_id?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DebtorIncomeMinOrderByAggregateInput = {
    id?: SortOrder
    debtor_id?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DebtorIncomeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumAgreementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusFilter<$PrismaModel> | $Enums.AgreementStatus
  }

  export type DebtorNullableScalarRelationFilter = {
    is?: DebtorWhereInput | null
    isNot?: DebtorWhereInput | null
  }

  export type CollectionCaseAgreementCountOrderByAggregateInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    debtor_id?: SortOrder
    total_amount?: SortOrder
    installment_amount?: SortOrder
    installments_count?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    tenant_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCaseAgreementAvgOrderByAggregateInput = {
    total_amount?: SortOrder
    installment_amount?: SortOrder
    installments_count?: SortOrder
  }

  export type CollectionCaseAgreementMaxOrderByAggregateInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    debtor_id?: SortOrder
    total_amount?: SortOrder
    installment_amount?: SortOrder
    installments_count?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    tenant_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCaseAgreementMinOrderByAggregateInput = {
    id?: SortOrder
    collection_case_id?: SortOrder
    debtor_id?: SortOrder
    total_amount?: SortOrder
    installment_amount?: SortOrder
    installments_count?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    tenant_id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCaseAgreementSumOrderByAggregateInput = {
    total_amount?: SortOrder
    installment_amount?: SortOrder
    installments_count?: SortOrder
  }

  export type EnumAgreementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgreementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgreementStatusFilter<$PrismaModel>
    _max?: NestedEnumAgreementStatusFilter<$PrismaModel>
  }

  export type EnumInstallmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusFilter<$PrismaModel> | $Enums.InstallmentStatus
  }

  export type CollectionCaseAgreementScalarRelationFilter = {
    is?: CollectionCaseAgreementWhereInput
    isNot?: CollectionCaseAgreementWhereInput
  }

  export type CollectionCasePaymentNullableScalarRelationFilter = {
    is?: CollectionCasePaymentWhereInput | null
    isNot?: CollectionCasePaymentWhereInput | null
  }

  export type CollectionCaseAgreementInstallmentCountOrderByAggregateInput = {
    id?: SortOrder
    agreement_id?: SortOrder
    number?: SortOrder
    due_date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    payment_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCaseAgreementInstallmentAvgOrderByAggregateInput = {
    number?: SortOrder
    amount?: SortOrder
  }

  export type CollectionCaseAgreementInstallmentMaxOrderByAggregateInput = {
    id?: SortOrder
    agreement_id?: SortOrder
    number?: SortOrder
    due_date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    payment_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCaseAgreementInstallmentMinOrderByAggregateInput = {
    id?: SortOrder
    agreement_id?: SortOrder
    number?: SortOrder
    due_date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    payment_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CollectionCaseAgreementInstallmentSumOrderByAggregateInput = {
    number?: SortOrder
    amount?: SortOrder
  }

  export type EnumInstallmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstallmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstallmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInstallmentStatusFilter<$PrismaModel>
  }

  export type BillingInvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
  }

  export type CollectionCaseCreateNestedManyWithoutTenantInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type DebtorCreateNestedManyWithoutTenantInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type VerdictCreateNestedManyWithoutTenantInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ChatRoomCreateNestedManyWithoutTenantInput = {
    create?: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput> | ChatRoomCreateWithoutTenantInput[] | ChatRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutTenantInput | ChatRoomCreateOrConnectWithoutTenantInput[]
    createMany?: ChatRoomCreateManyTenantInputEnvelope
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
  }

  export type CollectionCaseAgreementCreateNestedManyWithoutTenantInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutTenantInput, CollectionCaseAgreementUncheckedCreateWithoutTenantInput> | CollectionCaseAgreementCreateWithoutTenantInput[] | CollectionCaseAgreementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutTenantInput | CollectionCaseAgreementCreateOrConnectWithoutTenantInput[]
    createMany?: CollectionCaseAgreementCreateManyTenantInputEnvelope
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
  }

  export type BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
  }

  export type CollectionCaseUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type DebtorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type VerdictUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ChatRoomUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput> | ChatRoomCreateWithoutTenantInput[] | ChatRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutTenantInput | ChatRoomCreateOrConnectWithoutTenantInput[]
    createMany?: ChatRoomCreateManyTenantInputEnvelope
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
  }

  export type CollectionCaseAgreementUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutTenantInput, CollectionCaseAgreementUncheckedCreateWithoutTenantInput> | CollectionCaseAgreementCreateWithoutTenantInput[] | CollectionCaseAgreementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutTenantInput | CollectionCaseAgreementCreateOrConnectWithoutTenantInput[]
    createMany?: CollectionCaseAgreementCreateManyTenantInputEnvelope
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BillingInvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput | BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    set?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    disconnect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    delete?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    update?: BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput | BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BillingInvoiceUpdateManyWithWhereWithoutTenantInput | BillingInvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
  }

  export type CollectionCaseUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutTenantInput | CollectionCaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutTenantInput | CollectionCaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutTenantInput | CollectionCaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type DebtorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutTenantInput | DebtorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutTenantInput | DebtorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutTenantInput | DebtorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type VerdictUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutTenantInput | VerdictUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutTenantInput | VerdictUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutTenantInput | VerdictUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ChatRoomUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput> | ChatRoomCreateWithoutTenantInput[] | ChatRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutTenantInput | ChatRoomCreateOrConnectWithoutTenantInput[]
    upsert?: ChatRoomUpsertWithWhereUniqueWithoutTenantInput | ChatRoomUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ChatRoomCreateManyTenantInputEnvelope
    set?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    disconnect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    delete?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    update?: ChatRoomUpdateWithWhereUniqueWithoutTenantInput | ChatRoomUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ChatRoomUpdateManyWithWhereWithoutTenantInput | ChatRoomUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
  }

  export type CollectionCaseAgreementUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutTenantInput, CollectionCaseAgreementUncheckedCreateWithoutTenantInput> | CollectionCaseAgreementCreateWithoutTenantInput[] | CollectionCaseAgreementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutTenantInput | CollectionCaseAgreementCreateOrConnectWithoutTenantInput[]
    upsert?: CollectionCaseAgreementUpsertWithWhereUniqueWithoutTenantInput | CollectionCaseAgreementUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CollectionCaseAgreementCreateManyTenantInputEnvelope
    set?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    disconnect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    delete?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    update?: CollectionCaseAgreementUpdateWithWhereUniqueWithoutTenantInput | CollectionCaseAgreementUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CollectionCaseAgreementUpdateManyWithWhereWithoutTenantInput | CollectionCaseAgreementUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CollectionCaseAgreementScalarWhereInput | CollectionCaseAgreementScalarWhereInput[]
  }

  export type BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput> | BillingInvoiceCreateWithoutTenantInput[] | BillingInvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutTenantInput | BillingInvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput | BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BillingInvoiceCreateManyTenantInputEnvelope
    set?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    disconnect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    delete?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    connect?: BillingInvoiceWhereUniqueInput | BillingInvoiceWhereUniqueInput[]
    update?: BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput | BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BillingInvoiceUpdateManyWithWhereWithoutTenantInput | BillingInvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
  }

  export type CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput> | CollectionCaseCreateWithoutTenantInput[] | CollectionCaseUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutTenantInput | CollectionCaseCreateOrConnectWithoutTenantInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutTenantInput | CollectionCaseUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CollectionCaseCreateManyTenantInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutTenantInput | CollectionCaseUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutTenantInput | CollectionCaseUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type DebtorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput> | DebtorCreateWithoutTenantInput[] | DebtorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutTenantInput | DebtorCreateOrConnectWithoutTenantInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutTenantInput | DebtorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DebtorCreateManyTenantInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutTenantInput | DebtorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutTenantInput | DebtorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type VerdictUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput> | VerdictCreateWithoutTenantInput[] | VerdictUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutTenantInput | VerdictCreateOrConnectWithoutTenantInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutTenantInput | VerdictUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VerdictCreateManyTenantInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutTenantInput | VerdictUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutTenantInput | VerdictUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ChatRoomUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput> | ChatRoomCreateWithoutTenantInput[] | ChatRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutTenantInput | ChatRoomCreateOrConnectWithoutTenantInput[]
    upsert?: ChatRoomUpsertWithWhereUniqueWithoutTenantInput | ChatRoomUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ChatRoomCreateManyTenantInputEnvelope
    set?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    disconnect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    delete?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    update?: ChatRoomUpdateWithWhereUniqueWithoutTenantInput | ChatRoomUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ChatRoomUpdateManyWithWhereWithoutTenantInput | ChatRoomUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
  }

  export type CollectionCaseAgreementUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutTenantInput, CollectionCaseAgreementUncheckedCreateWithoutTenantInput> | CollectionCaseAgreementCreateWithoutTenantInput[] | CollectionCaseAgreementUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutTenantInput | CollectionCaseAgreementCreateOrConnectWithoutTenantInput[]
    upsert?: CollectionCaseAgreementUpsertWithWhereUniqueWithoutTenantInput | CollectionCaseAgreementUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CollectionCaseAgreementCreateManyTenantInputEnvelope
    set?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    disconnect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    delete?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    update?: CollectionCaseAgreementUpdateWithWhereUniqueWithoutTenantInput | CollectionCaseAgreementUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CollectionCaseAgreementUpdateManyWithWhereWithoutTenantInput | CollectionCaseAgreementUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CollectionCaseAgreementScalarWhereInput | CollectionCaseAgreementScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type DebtorCreateNestedManyWithoutUserInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type VerdictCreateNestedManyWithoutBailiffInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type DebtorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
  }

  export type VerdictUncheckedCreateNestedManyWithoutBailiffInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type EnumroleEnumFieldUpdateOperationsInput = {
    set?: $Enums.roleEnum
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type DebtorUpdateManyWithoutUserNestedInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutUserInput | DebtorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutUserInput | DebtorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutUserInput | DebtorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type VerdictUpdateManyWithoutBailiffNestedInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutBailiffInput | VerdictUpsertWithWhereUniqueWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutBailiffInput | VerdictUpdateWithWhereUniqueWithoutBailiffInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutBailiffInput | VerdictUpdateManyWithWhereWithoutBailiffInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type DebtorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput> | DebtorCreateWithoutUserInput[] | DebtorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DebtorCreateOrConnectWithoutUserInput | DebtorCreateOrConnectWithoutUserInput[]
    upsert?: DebtorUpsertWithWhereUniqueWithoutUserInput | DebtorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DebtorCreateManyUserInputEnvelope
    set?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    disconnect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    delete?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    connect?: DebtorWhereUniqueInput | DebtorWhereUniqueInput[]
    update?: DebtorUpdateWithWhereUniqueWithoutUserInput | DebtorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DebtorUpdateManyWithWhereWithoutUserInput | DebtorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
  }

  export type VerdictUncheckedUpdateManyWithoutBailiffNestedInput = {
    create?: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput> | VerdictCreateWithoutBailiffInput[] | VerdictUncheckedCreateWithoutBailiffInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiffInput | VerdictCreateOrConnectWithoutBailiffInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutBailiffInput | VerdictUpsertWithWhereUniqueWithoutBailiffInput[]
    createMany?: VerdictCreateManyBailiffInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutBailiffInput | VerdictUpdateWithWhereUniqueWithoutBailiffInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutBailiffInput | VerdictUpdateManyWithWhereWithoutBailiffInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutVerdict_bailiffsInput = {
    create?: XOR<UserCreateWithoutVerdict_bailiffsInput, UserUncheckedCreateWithoutVerdict_bailiffsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerdict_bailiffsInput
    connect?: UserWhereUniqueInput
  }

  export type DebtorCreateNestedOneWithoutVerdictsInput = {
    create?: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutVerdictsInput
    connect?: DebtorWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutVerdictsInput = {
    create?: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVerdictsInput
    connect?: TenantWhereUniqueInput
  }

  export type VerdictAttachmentCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
  }

  export type VerdictBailiffServicesCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
  }

  export type VerdictEmbargoCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
  }

  export type VerdictInterestCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
  }

  export type VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
  }

  export type VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
  }

  export type VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
  }

  export type VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
  }

  export type EnumVerdictStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerdictStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutVerdict_bailiffsNestedInput = {
    create?: XOR<UserCreateWithoutVerdict_bailiffsInput, UserUncheckedCreateWithoutVerdict_bailiffsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerdict_bailiffsInput
    upsert?: UserUpsertWithoutVerdict_bailiffsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerdict_bailiffsInput, UserUpdateWithoutVerdict_bailiffsInput>, UserUncheckedUpdateWithoutVerdict_bailiffsInput>
  }

  export type DebtorUpdateOneRequiredWithoutVerdictsNestedInput = {
    create?: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutVerdictsInput
    upsert?: DebtorUpsertWithoutVerdictsInput
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutVerdictsInput, DebtorUpdateWithoutVerdictsInput>, DebtorUncheckedUpdateWithoutVerdictsInput>
  }

  export type TenantUpdateOneRequiredWithoutVerdictsNestedInput = {
    create?: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVerdictsInput
    upsert?: TenantUpsertWithoutVerdictsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVerdictsInput, TenantUpdateWithoutVerdictsInput>, TenantUncheckedUpdateWithoutVerdictsInput>
  }

  export type VerdictAttachmentUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    set?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    disconnect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    delete?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    update?: VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput | VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
  }

  export type VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    set?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    disconnect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    delete?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    update?: VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput | VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
  }

  export type VerdictEmbargoUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    set?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    disconnect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    delete?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    update?: VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput | VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
  }

  export type VerdictInterestUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput | VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    set?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    disconnect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    delete?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    update?: VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput | VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictInterestUpdateManyWithWhereWithoutVerdictInput | VerdictInterestUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
  }

  export type VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput> | VerdictAttachmentCreateWithoutVerdictInput[] | VerdictAttachmentUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictAttachmentCreateOrConnectWithoutVerdictInput | VerdictAttachmentCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictAttachmentCreateManyVerdictInputEnvelope
    set?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    disconnect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    delete?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    connect?: VerdictAttachmentWhereUniqueInput | VerdictAttachmentWhereUniqueInput[]
    update?: VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput | VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput | VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
  }

  export type VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput> | VerdictBailiffServicesCreateWithoutVerdictInput[] | VerdictBailiffServicesUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictBailiffServicesCreateOrConnectWithoutVerdictInput | VerdictBailiffServicesCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictBailiffServicesCreateManyVerdictInputEnvelope
    set?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    disconnect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    delete?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    connect?: VerdictBailiffServicesWhereUniqueInput | VerdictBailiffServicesWhereUniqueInput[]
    update?: VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput | VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput | VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
  }

  export type VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput> | VerdictEmbargoCreateWithoutVerdictInput[] | VerdictEmbargoUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictEmbargoCreateOrConnectWithoutVerdictInput | VerdictEmbargoCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictEmbargoCreateManyVerdictInputEnvelope
    set?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    disconnect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    delete?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    connect?: VerdictEmbargoWhereUniqueInput | VerdictEmbargoWhereUniqueInput[]
    update?: VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput | VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput | VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
  }

  export type VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput = {
    create?: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput> | VerdictInterestCreateWithoutVerdictInput[] | VerdictInterestUncheckedCreateWithoutVerdictInput[]
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutVerdictInput | VerdictInterestCreateOrConnectWithoutVerdictInput[]
    upsert?: VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput | VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput[]
    createMany?: VerdictInterestCreateManyVerdictInputEnvelope
    set?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    disconnect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    delete?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    connect?: VerdictInterestWhereUniqueInput | VerdictInterestWhereUniqueInput[]
    update?: VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput | VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput[]
    updateMany?: VerdictInterestUpdateManyWithWhereWithoutVerdictInput | VerdictInterestUpdateManyWithWhereWithoutVerdictInput[]
    deleteMany?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
  }

  export type VerdictCreateNestedOneWithoutVerdict_interestInput = {
    create?: XOR<VerdictCreateWithoutVerdict_interestInput, VerdictUncheckedCreateWithoutVerdict_interestInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdict_interestInput
    connect?: VerdictWhereUniqueInput
  }

  export type VerdictInterestDetailsCreateNestedManyWithoutVerdict_interestInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdict_interestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdict_interestInput> | VerdictInterestDetailsCreateWithoutVerdict_interestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdict_interestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdict_interestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdict_interestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdict_interestInputEnvelope
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
  }

  export type VerdictInterestDetailsUncheckedCreateNestedManyWithoutVerdict_interestInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdict_interestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdict_interestInput> | VerdictInterestDetailsCreateWithoutVerdict_interestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdict_interestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdict_interestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdict_interestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdict_interestInputEnvelope
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
  }

  export type VerdictUpdateOneWithoutVerdict_interestNestedInput = {
    create?: XOR<VerdictCreateWithoutVerdict_interestInput, VerdictUncheckedCreateWithoutVerdict_interestInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdict_interestInput
    upsert?: VerdictUpsertWithoutVerdict_interestInput
    disconnect?: VerdictWhereInput | boolean
    delete?: VerdictWhereInput | boolean
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutVerdict_interestInput, VerdictUpdateWithoutVerdict_interestInput>, VerdictUncheckedUpdateWithoutVerdict_interestInput>
  }

  export type VerdictInterestDetailsUpdateManyWithoutVerdict_interestNestedInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdict_interestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdict_interestInput> | VerdictInterestDetailsCreateWithoutVerdict_interestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdict_interestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdict_interestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdict_interestInput[]
    upsert?: VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdict_interestInput | VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdict_interestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdict_interestInputEnvelope
    set?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    disconnect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    delete?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    update?: VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdict_interestInput | VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdict_interestInput[]
    updateMany?: VerdictInterestDetailsUpdateManyWithWhereWithoutVerdict_interestInput | VerdictInterestDetailsUpdateManyWithWhereWithoutVerdict_interestInput[]
    deleteMany?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
  }

  export type VerdictInterestDetailsUncheckedUpdateManyWithoutVerdict_interestNestedInput = {
    create?: XOR<VerdictInterestDetailsCreateWithoutVerdict_interestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdict_interestInput> | VerdictInterestDetailsCreateWithoutVerdict_interestInput[] | VerdictInterestDetailsUncheckedCreateWithoutVerdict_interestInput[]
    connectOrCreate?: VerdictInterestDetailsCreateOrConnectWithoutVerdict_interestInput | VerdictInterestDetailsCreateOrConnectWithoutVerdict_interestInput[]
    upsert?: VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdict_interestInput | VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdict_interestInput[]
    createMany?: VerdictInterestDetailsCreateManyVerdict_interestInputEnvelope
    set?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    disconnect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    delete?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    connect?: VerdictInterestDetailsWhereUniqueInput | VerdictInterestDetailsWhereUniqueInput[]
    update?: VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdict_interestInput | VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdict_interestInput[]
    updateMany?: VerdictInterestDetailsUpdateManyWithWhereWithoutVerdict_interestInput | VerdictInterestDetailsUpdateManyWithWhereWithoutVerdict_interestInput[]
    deleteMany?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
  }

  export type VerdictInterestCreateNestedOneWithoutDetailsInput = {
    create?: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutDetailsInput
    connect?: VerdictInterestWhereUniqueInput
  }

  export type VerdictInterestUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: VerdictInterestCreateOrConnectWithoutDetailsInput
    upsert?: VerdictInterestUpsertWithoutDetailsInput
    connect?: VerdictInterestWhereUniqueInput
    update?: XOR<XOR<VerdictInterestUpdateToOneWithWhereWithoutDetailsInput, VerdictInterestUpdateWithoutDetailsInput>, VerdictInterestUncheckedUpdateWithoutDetailsInput>
  }

  export type VerdictCreateNestedOneWithoutVerdict_embargoInput = {
    create?: XOR<VerdictCreateWithoutVerdict_embargoInput, VerdictUncheckedCreateWithoutVerdict_embargoInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdict_embargoInput
    connect?: VerdictWhereUniqueInput
  }

  export type VerdictUpdateOneRequiredWithoutVerdict_embargoNestedInput = {
    create?: XOR<VerdictCreateWithoutVerdict_embargoInput, VerdictUncheckedCreateWithoutVerdict_embargoInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutVerdict_embargoInput
    upsert?: VerdictUpsertWithoutVerdict_embargoInput
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutVerdict_embargoInput, VerdictUpdateWithoutVerdict_embargoInput>, VerdictUncheckedUpdateWithoutVerdict_embargoInput>
  }

  export type VerdictCreateNestedOneWithoutBailiff_servicesInput = {
    create?: XOR<VerdictCreateWithoutBailiff_servicesInput, VerdictUncheckedCreateWithoutBailiff_servicesInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiff_servicesInput
    connect?: VerdictWhereUniqueInput
  }

  export type VerdictUpdateOneRequiredWithoutBailiff_servicesNestedInput = {
    create?: XOR<VerdictCreateWithoutBailiff_servicesInput, VerdictUncheckedCreateWithoutBailiff_servicesInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutBailiff_servicesInput
    upsert?: VerdictUpsertWithoutBailiff_servicesInput
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutBailiff_servicesInput, VerdictUpdateWithoutBailiff_servicesInput>, VerdictUncheckedUpdateWithoutBailiff_servicesInput>
  }

  export type VerdictCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutAttachmentsInput
    connect?: VerdictWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type VerdictUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: VerdictCreateOrConnectWithoutAttachmentsInput
    upsert?: VerdictUpsertWithoutAttachmentsInput
    connect?: VerdictWhereUniqueInput
    update?: XOR<XOR<VerdictUpdateToOneWithWhereWithoutAttachmentsInput, VerdictUpdateWithoutAttachmentsInput>, VerdictUncheckedUpdateWithoutAttachmentsInput>
  }

  export type InterestDetailCreateNestedManyWithoutInterest_typeInput = {
    create?: XOR<InterestDetailCreateWithoutInterest_typeInput, InterestDetailUncheckedCreateWithoutInterest_typeInput> | InterestDetailCreateWithoutInterest_typeInput[] | InterestDetailUncheckedCreateWithoutInterest_typeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterest_typeInput | InterestDetailCreateOrConnectWithoutInterest_typeInput[]
    createMany?: InterestDetailCreateManyInterest_typeInputEnvelope
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
  }

  export type InterestDetailUncheckedCreateNestedManyWithoutInterest_typeInput = {
    create?: XOR<InterestDetailCreateWithoutInterest_typeInput, InterestDetailUncheckedCreateWithoutInterest_typeInput> | InterestDetailCreateWithoutInterest_typeInput[] | InterestDetailUncheckedCreateWithoutInterest_typeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterest_typeInput | InterestDetailCreateOrConnectWithoutInterest_typeInput[]
    createMany?: InterestDetailCreateManyInterest_typeInputEnvelope
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
  }

  export type EnumCalculationTypeEnumFieldUpdateOperationsInput = {
    set?: $Enums.CalculationTypeEnum
  }

  export type InterestDetailUpdateManyWithoutInterest_typeNestedInput = {
    create?: XOR<InterestDetailCreateWithoutInterest_typeInput, InterestDetailUncheckedCreateWithoutInterest_typeInput> | InterestDetailCreateWithoutInterest_typeInput[] | InterestDetailUncheckedCreateWithoutInterest_typeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterest_typeInput | InterestDetailCreateOrConnectWithoutInterest_typeInput[]
    upsert?: InterestDetailUpsertWithWhereUniqueWithoutInterest_typeInput | InterestDetailUpsertWithWhereUniqueWithoutInterest_typeInput[]
    createMany?: InterestDetailCreateManyInterest_typeInputEnvelope
    set?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    disconnect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    delete?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    update?: InterestDetailUpdateWithWhereUniqueWithoutInterest_typeInput | InterestDetailUpdateWithWhereUniqueWithoutInterest_typeInput[]
    updateMany?: InterestDetailUpdateManyWithWhereWithoutInterest_typeInput | InterestDetailUpdateManyWithWhereWithoutInterest_typeInput[]
    deleteMany?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
  }

  export type InterestDetailUncheckedUpdateManyWithoutInterest_typeNestedInput = {
    create?: XOR<InterestDetailCreateWithoutInterest_typeInput, InterestDetailUncheckedCreateWithoutInterest_typeInput> | InterestDetailCreateWithoutInterest_typeInput[] | InterestDetailUncheckedCreateWithoutInterest_typeInput[]
    connectOrCreate?: InterestDetailCreateOrConnectWithoutInterest_typeInput | InterestDetailCreateOrConnectWithoutInterest_typeInput[]
    upsert?: InterestDetailUpsertWithWhereUniqueWithoutInterest_typeInput | InterestDetailUpsertWithWhereUniqueWithoutInterest_typeInput[]
    createMany?: InterestDetailCreateManyInterest_typeInputEnvelope
    set?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    disconnect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    delete?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    connect?: InterestDetailWhereUniqueInput | InterestDetailWhereUniqueInput[]
    update?: InterestDetailUpdateWithWhereUniqueWithoutInterest_typeInput | InterestDetailUpdateWithWhereUniqueWithoutInterest_typeInput[]
    updateMany?: InterestDetailUpdateManyWithWhereWithoutInterest_typeInput | InterestDetailUpdateManyWithWhereWithoutInterest_typeInput[]
    deleteMany?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
  }

  export type InterestTypeCreateNestedOneWithoutDetailsInput = {
    create?: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: InterestTypeCreateOrConnectWithoutDetailsInput
    connect?: InterestTypeWhereUniqueInput
  }

  export type InterestTypeUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: InterestTypeCreateOrConnectWithoutDetailsInput
    upsert?: InterestTypeUpsertWithoutDetailsInput
    connect?: InterestTypeWhereUniqueInput
    update?: XOR<XOR<InterestTypeUpdateToOneWithWhereWithoutDetailsInput, InterestTypeUpdateWithoutDetailsInput>, InterestTypeUncheckedUpdateWithoutDetailsInput>
  }

  export type TenantCreateNestedOneWithoutBilling_invoiceInput = {
    create?: XOR<TenantCreateWithoutBilling_invoiceInput, TenantUncheckedCreateWithoutBilling_invoiceInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBilling_invoiceInput
    connect?: TenantWhereUniqueInput
  }

  export type BillingInvoiceDetailCreateNestedManyWithoutBilling_invoiceInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBilling_invoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBilling_invoiceInput> | BillingInvoiceDetailCreateWithoutBilling_invoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBilling_invoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBilling_invoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBilling_invoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBilling_invoiceInputEnvelope
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
  }

  export type BillingPaymentCreateNestedManyWithoutBilling_invoiceInput = {
    create?: XOR<BillingPaymentCreateWithoutBilling_invoiceInput, BillingPaymentUncheckedCreateWithoutBilling_invoiceInput> | BillingPaymentCreateWithoutBilling_invoiceInput[] | BillingPaymentUncheckedCreateWithoutBilling_invoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBilling_invoiceInput | BillingPaymentCreateOrConnectWithoutBilling_invoiceInput[]
    createMany?: BillingPaymentCreateManyBilling_invoiceInputEnvelope
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
  }

  export type BillingInvoiceDetailUncheckedCreateNestedManyWithoutBilling_invoiceInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBilling_invoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBilling_invoiceInput> | BillingInvoiceDetailCreateWithoutBilling_invoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBilling_invoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBilling_invoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBilling_invoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBilling_invoiceInputEnvelope
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
  }

  export type BillingPaymentUncheckedCreateNestedManyWithoutBilling_invoiceInput = {
    create?: XOR<BillingPaymentCreateWithoutBilling_invoiceInput, BillingPaymentUncheckedCreateWithoutBilling_invoiceInput> | BillingPaymentCreateWithoutBilling_invoiceInput[] | BillingPaymentUncheckedCreateWithoutBilling_invoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBilling_invoiceInput | BillingPaymentCreateOrConnectWithoutBilling_invoiceInput[]
    createMany?: BillingPaymentCreateManyBilling_invoiceInputEnvelope
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutBilling_invoiceNestedInput = {
    create?: XOR<TenantCreateWithoutBilling_invoiceInput, TenantUncheckedCreateWithoutBilling_invoiceInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBilling_invoiceInput
    upsert?: TenantUpsertWithoutBilling_invoiceInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBilling_invoiceInput, TenantUpdateWithoutBilling_invoiceInput>, TenantUncheckedUpdateWithoutBilling_invoiceInput>
  }

  export type BillingInvoiceDetailUpdateManyWithoutBilling_invoiceNestedInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBilling_invoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBilling_invoiceInput> | BillingInvoiceDetailCreateWithoutBilling_invoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBilling_invoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBilling_invoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBilling_invoiceInput[]
    upsert?: BillingInvoiceDetailUpsertWithWhereUniqueWithoutBilling_invoiceInput | BillingInvoiceDetailUpsertWithWhereUniqueWithoutBilling_invoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBilling_invoiceInputEnvelope
    set?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    disconnect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    delete?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    update?: BillingInvoiceDetailUpdateWithWhereUniqueWithoutBilling_invoiceInput | BillingInvoiceDetailUpdateWithWhereUniqueWithoutBilling_invoiceInput[]
    updateMany?: BillingInvoiceDetailUpdateManyWithWhereWithoutBilling_invoiceInput | BillingInvoiceDetailUpdateManyWithWhereWithoutBilling_invoiceInput[]
    deleteMany?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
  }

  export type BillingPaymentUpdateManyWithoutBilling_invoiceNestedInput = {
    create?: XOR<BillingPaymentCreateWithoutBilling_invoiceInput, BillingPaymentUncheckedCreateWithoutBilling_invoiceInput> | BillingPaymentCreateWithoutBilling_invoiceInput[] | BillingPaymentUncheckedCreateWithoutBilling_invoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBilling_invoiceInput | BillingPaymentCreateOrConnectWithoutBilling_invoiceInput[]
    upsert?: BillingPaymentUpsertWithWhereUniqueWithoutBilling_invoiceInput | BillingPaymentUpsertWithWhereUniqueWithoutBilling_invoiceInput[]
    createMany?: BillingPaymentCreateManyBilling_invoiceInputEnvelope
    set?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    disconnect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    delete?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    update?: BillingPaymentUpdateWithWhereUniqueWithoutBilling_invoiceInput | BillingPaymentUpdateWithWhereUniqueWithoutBilling_invoiceInput[]
    updateMany?: BillingPaymentUpdateManyWithWhereWithoutBilling_invoiceInput | BillingPaymentUpdateManyWithWhereWithoutBilling_invoiceInput[]
    deleteMany?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
  }

  export type BillingInvoiceDetailUncheckedUpdateManyWithoutBilling_invoiceNestedInput = {
    create?: XOR<BillingInvoiceDetailCreateWithoutBilling_invoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBilling_invoiceInput> | BillingInvoiceDetailCreateWithoutBilling_invoiceInput[] | BillingInvoiceDetailUncheckedCreateWithoutBilling_invoiceInput[]
    connectOrCreate?: BillingInvoiceDetailCreateOrConnectWithoutBilling_invoiceInput | BillingInvoiceDetailCreateOrConnectWithoutBilling_invoiceInput[]
    upsert?: BillingInvoiceDetailUpsertWithWhereUniqueWithoutBilling_invoiceInput | BillingInvoiceDetailUpsertWithWhereUniqueWithoutBilling_invoiceInput[]
    createMany?: BillingInvoiceDetailCreateManyBilling_invoiceInputEnvelope
    set?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    disconnect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    delete?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    connect?: BillingInvoiceDetailWhereUniqueInput | BillingInvoiceDetailWhereUniqueInput[]
    update?: BillingInvoiceDetailUpdateWithWhereUniqueWithoutBilling_invoiceInput | BillingInvoiceDetailUpdateWithWhereUniqueWithoutBilling_invoiceInput[]
    updateMany?: BillingInvoiceDetailUpdateManyWithWhereWithoutBilling_invoiceInput | BillingInvoiceDetailUpdateManyWithWhereWithoutBilling_invoiceInput[]
    deleteMany?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
  }

  export type BillingPaymentUncheckedUpdateManyWithoutBilling_invoiceNestedInput = {
    create?: XOR<BillingPaymentCreateWithoutBilling_invoiceInput, BillingPaymentUncheckedCreateWithoutBilling_invoiceInput> | BillingPaymentCreateWithoutBilling_invoiceInput[] | BillingPaymentUncheckedCreateWithoutBilling_invoiceInput[]
    connectOrCreate?: BillingPaymentCreateOrConnectWithoutBilling_invoiceInput | BillingPaymentCreateOrConnectWithoutBilling_invoiceInput[]
    upsert?: BillingPaymentUpsertWithWhereUniqueWithoutBilling_invoiceInput | BillingPaymentUpsertWithWhereUniqueWithoutBilling_invoiceInput[]
    createMany?: BillingPaymentCreateManyBilling_invoiceInputEnvelope
    set?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    disconnect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    delete?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    connect?: BillingPaymentWhereUniqueInput | BillingPaymentWhereUniqueInput[]
    update?: BillingPaymentUpdateWithWhereUniqueWithoutBilling_invoiceInput | BillingPaymentUpdateWithWhereUniqueWithoutBilling_invoiceInput[]
    updateMany?: BillingPaymentUpdateManyWithWhereWithoutBilling_invoiceInput | BillingPaymentUpdateManyWithWhereWithoutBilling_invoiceInput[]
    deleteMany?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
  }

  export type BillingInvoiceCreateNestedOneWithoutDetailsInput = {
    create?: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutDetailsInput
    connect?: BillingInvoiceWhereUniqueInput
  }

  export type BillingInvoiceUpdateOneWithoutDetailsNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutDetailsInput
    upsert?: BillingInvoiceUpsertWithoutDetailsInput
    disconnect?: BillingInvoiceWhereInput | boolean
    delete?: BillingInvoiceWhereInput | boolean
    connect?: BillingInvoiceWhereUniqueInput
    update?: XOR<XOR<BillingInvoiceUpdateToOneWithWhereWithoutDetailsInput, BillingInvoiceUpdateWithoutDetailsInput>, BillingInvoiceUncheckedUpdateWithoutDetailsInput>
  }

  export type BillingInvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutPaymentsInput
    connect?: BillingInvoiceWhereUniqueInput
  }

  export type BillingInvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillingInvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: BillingInvoiceUpsertWithoutPaymentsInput
    disconnect?: BillingInvoiceWhereInput | boolean
    delete?: BillingInvoiceWhereInput | boolean
    connect?: BillingInvoiceWhereUniqueInput
    update?: XOR<XOR<BillingInvoiceUpdateToOneWithWhereWithoutPaymentsInput, BillingInvoiceUpdateWithoutPaymentsInput>, BillingInvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type DebtorCreateNestedOneWithoutCollection_casesInput = {
    create?: XOR<DebtorCreateWithoutCollection_casesInput, DebtorUncheckedCreateWithoutCollection_casesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutCollection_casesInput
    connect?: DebtorWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutCollection_casesInput = {
    create?: XOR<TenantCreateWithoutCollection_casesInput, TenantUncheckedCreateWithoutCollection_casesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCollection_casesInput
    connect?: TenantWhereUniqueInput
  }

  export type CollectionCaseNotificationCreateNestedManyWithoutCollection_caseInput = {
    create?: XOR<CollectionCaseNotificationCreateWithoutCollection_caseInput, CollectionCaseNotificationUncheckedCreateWithoutCollection_caseInput> | CollectionCaseNotificationCreateWithoutCollection_caseInput[] | CollectionCaseNotificationUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCaseNotificationCreateOrConnectWithoutCollection_caseInput | CollectionCaseNotificationCreateOrConnectWithoutCollection_caseInput[]
    createMany?: CollectionCaseNotificationCreateManyCollection_caseInputEnvelope
    connect?: CollectionCaseNotificationWhereUniqueInput | CollectionCaseNotificationWhereUniqueInput[]
  }

  export type CollectionCasePaymentCreateNestedManyWithoutCollection_caseInput = {
    create?: XOR<CollectionCasePaymentCreateWithoutCollection_caseInput, CollectionCasePaymentUncheckedCreateWithoutCollection_caseInput> | CollectionCasePaymentCreateWithoutCollection_caseInput[] | CollectionCasePaymentUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCasePaymentCreateOrConnectWithoutCollection_caseInput | CollectionCasePaymentCreateOrConnectWithoutCollection_caseInput[]
    createMany?: CollectionCasePaymentCreateManyCollection_caseInputEnvelope
    connect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
  }

  export type CollectionCaseAgreementCreateNestedManyWithoutCollection_caseInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutCollection_caseInput, CollectionCaseAgreementUncheckedCreateWithoutCollection_caseInput> | CollectionCaseAgreementCreateWithoutCollection_caseInput[] | CollectionCaseAgreementUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutCollection_caseInput | CollectionCaseAgreementCreateOrConnectWithoutCollection_caseInput[]
    createMany?: CollectionCaseAgreementCreateManyCollection_caseInputEnvelope
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
  }

  export type CollectionCasePenaltyCreateNestedManyWithoutCollection_caseInput = {
    create?: XOR<CollectionCasePenaltyCreateWithoutCollection_caseInput, CollectionCasePenaltyUncheckedCreateWithoutCollection_caseInput> | CollectionCasePenaltyCreateWithoutCollection_caseInput[] | CollectionCasePenaltyUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCasePenaltyCreateOrConnectWithoutCollection_caseInput | CollectionCasePenaltyCreateOrConnectWithoutCollection_caseInput[]
    createMany?: CollectionCasePenaltyCreateManyCollection_caseInputEnvelope
    connect?: CollectionCasePenaltyWhereUniqueInput | CollectionCasePenaltyWhereUniqueInput[]
  }

  export type ChatRoomCreateNestedManyWithoutCollection_caseInput = {
    create?: XOR<ChatRoomCreateWithoutCollection_caseInput, ChatRoomUncheckedCreateWithoutCollection_caseInput> | ChatRoomCreateWithoutCollection_caseInput[] | ChatRoomUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutCollection_caseInput | ChatRoomCreateOrConnectWithoutCollection_caseInput[]
    createMany?: ChatRoomCreateManyCollection_caseInputEnvelope
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
  }

  export type CollectionCaseNotificationUncheckedCreateNestedManyWithoutCollection_caseInput = {
    create?: XOR<CollectionCaseNotificationCreateWithoutCollection_caseInput, CollectionCaseNotificationUncheckedCreateWithoutCollection_caseInput> | CollectionCaseNotificationCreateWithoutCollection_caseInput[] | CollectionCaseNotificationUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCaseNotificationCreateOrConnectWithoutCollection_caseInput | CollectionCaseNotificationCreateOrConnectWithoutCollection_caseInput[]
    createMany?: CollectionCaseNotificationCreateManyCollection_caseInputEnvelope
    connect?: CollectionCaseNotificationWhereUniqueInput | CollectionCaseNotificationWhereUniqueInput[]
  }

  export type CollectionCasePaymentUncheckedCreateNestedManyWithoutCollection_caseInput = {
    create?: XOR<CollectionCasePaymentCreateWithoutCollection_caseInput, CollectionCasePaymentUncheckedCreateWithoutCollection_caseInput> | CollectionCasePaymentCreateWithoutCollection_caseInput[] | CollectionCasePaymentUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCasePaymentCreateOrConnectWithoutCollection_caseInput | CollectionCasePaymentCreateOrConnectWithoutCollection_caseInput[]
    createMany?: CollectionCasePaymentCreateManyCollection_caseInputEnvelope
    connect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
  }

  export type CollectionCaseAgreementUncheckedCreateNestedManyWithoutCollection_caseInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutCollection_caseInput, CollectionCaseAgreementUncheckedCreateWithoutCollection_caseInput> | CollectionCaseAgreementCreateWithoutCollection_caseInput[] | CollectionCaseAgreementUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutCollection_caseInput | CollectionCaseAgreementCreateOrConnectWithoutCollection_caseInput[]
    createMany?: CollectionCaseAgreementCreateManyCollection_caseInputEnvelope
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
  }

  export type CollectionCasePenaltyUncheckedCreateNestedManyWithoutCollection_caseInput = {
    create?: XOR<CollectionCasePenaltyCreateWithoutCollection_caseInput, CollectionCasePenaltyUncheckedCreateWithoutCollection_caseInput> | CollectionCasePenaltyCreateWithoutCollection_caseInput[] | CollectionCasePenaltyUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCasePenaltyCreateOrConnectWithoutCollection_caseInput | CollectionCasePenaltyCreateOrConnectWithoutCollection_caseInput[]
    createMany?: CollectionCasePenaltyCreateManyCollection_caseInputEnvelope
    connect?: CollectionCasePenaltyWhereUniqueInput | CollectionCasePenaltyWhereUniqueInput[]
  }

  export type ChatRoomUncheckedCreateNestedManyWithoutCollection_caseInput = {
    create?: XOR<ChatRoomCreateWithoutCollection_caseInput, ChatRoomUncheckedCreateWithoutCollection_caseInput> | ChatRoomCreateWithoutCollection_caseInput[] | ChatRoomUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutCollection_caseInput | ChatRoomCreateOrConnectWithoutCollection_caseInput[]
    createMany?: ChatRoomCreateManyCollection_caseInputEnvelope
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumCollectionCaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.CollectionCaseStatus
  }

  export type DebtorUpdateOneRequiredWithoutCollection_casesNestedInput = {
    create?: XOR<DebtorCreateWithoutCollection_casesInput, DebtorUncheckedCreateWithoutCollection_casesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutCollection_casesInput
    upsert?: DebtorUpsertWithoutCollection_casesInput
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutCollection_casesInput, DebtorUpdateWithoutCollection_casesInput>, DebtorUncheckedUpdateWithoutCollection_casesInput>
  }

  export type TenantUpdateOneRequiredWithoutCollection_casesNestedInput = {
    create?: XOR<TenantCreateWithoutCollection_casesInput, TenantUncheckedCreateWithoutCollection_casesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCollection_casesInput
    upsert?: TenantUpsertWithoutCollection_casesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCollection_casesInput, TenantUpdateWithoutCollection_casesInput>, TenantUncheckedUpdateWithoutCollection_casesInput>
  }

  export type CollectionCaseNotificationUpdateManyWithoutCollection_caseNestedInput = {
    create?: XOR<CollectionCaseNotificationCreateWithoutCollection_caseInput, CollectionCaseNotificationUncheckedCreateWithoutCollection_caseInput> | CollectionCaseNotificationCreateWithoutCollection_caseInput[] | CollectionCaseNotificationUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCaseNotificationCreateOrConnectWithoutCollection_caseInput | CollectionCaseNotificationCreateOrConnectWithoutCollection_caseInput[]
    upsert?: CollectionCaseNotificationUpsertWithWhereUniqueWithoutCollection_caseInput | CollectionCaseNotificationUpsertWithWhereUniqueWithoutCollection_caseInput[]
    createMany?: CollectionCaseNotificationCreateManyCollection_caseInputEnvelope
    set?: CollectionCaseNotificationWhereUniqueInput | CollectionCaseNotificationWhereUniqueInput[]
    disconnect?: CollectionCaseNotificationWhereUniqueInput | CollectionCaseNotificationWhereUniqueInput[]
    delete?: CollectionCaseNotificationWhereUniqueInput | CollectionCaseNotificationWhereUniqueInput[]
    connect?: CollectionCaseNotificationWhereUniqueInput | CollectionCaseNotificationWhereUniqueInput[]
    update?: CollectionCaseNotificationUpdateWithWhereUniqueWithoutCollection_caseInput | CollectionCaseNotificationUpdateWithWhereUniqueWithoutCollection_caseInput[]
    updateMany?: CollectionCaseNotificationUpdateManyWithWhereWithoutCollection_caseInput | CollectionCaseNotificationUpdateManyWithWhereWithoutCollection_caseInput[]
    deleteMany?: CollectionCaseNotificationScalarWhereInput | CollectionCaseNotificationScalarWhereInput[]
  }

  export type CollectionCasePaymentUpdateManyWithoutCollection_caseNestedInput = {
    create?: XOR<CollectionCasePaymentCreateWithoutCollection_caseInput, CollectionCasePaymentUncheckedCreateWithoutCollection_caseInput> | CollectionCasePaymentCreateWithoutCollection_caseInput[] | CollectionCasePaymentUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCasePaymentCreateOrConnectWithoutCollection_caseInput | CollectionCasePaymentCreateOrConnectWithoutCollection_caseInput[]
    upsert?: CollectionCasePaymentUpsertWithWhereUniqueWithoutCollection_caseInput | CollectionCasePaymentUpsertWithWhereUniqueWithoutCollection_caseInput[]
    createMany?: CollectionCasePaymentCreateManyCollection_caseInputEnvelope
    set?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    disconnect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    delete?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    connect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    update?: CollectionCasePaymentUpdateWithWhereUniqueWithoutCollection_caseInput | CollectionCasePaymentUpdateWithWhereUniqueWithoutCollection_caseInput[]
    updateMany?: CollectionCasePaymentUpdateManyWithWhereWithoutCollection_caseInput | CollectionCasePaymentUpdateManyWithWhereWithoutCollection_caseInput[]
    deleteMany?: CollectionCasePaymentScalarWhereInput | CollectionCasePaymentScalarWhereInput[]
  }

  export type CollectionCaseAgreementUpdateManyWithoutCollection_caseNestedInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutCollection_caseInput, CollectionCaseAgreementUncheckedCreateWithoutCollection_caseInput> | CollectionCaseAgreementCreateWithoutCollection_caseInput[] | CollectionCaseAgreementUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutCollection_caseInput | CollectionCaseAgreementCreateOrConnectWithoutCollection_caseInput[]
    upsert?: CollectionCaseAgreementUpsertWithWhereUniqueWithoutCollection_caseInput | CollectionCaseAgreementUpsertWithWhereUniqueWithoutCollection_caseInput[]
    createMany?: CollectionCaseAgreementCreateManyCollection_caseInputEnvelope
    set?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    disconnect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    delete?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    update?: CollectionCaseAgreementUpdateWithWhereUniqueWithoutCollection_caseInput | CollectionCaseAgreementUpdateWithWhereUniqueWithoutCollection_caseInput[]
    updateMany?: CollectionCaseAgreementUpdateManyWithWhereWithoutCollection_caseInput | CollectionCaseAgreementUpdateManyWithWhereWithoutCollection_caseInput[]
    deleteMany?: CollectionCaseAgreementScalarWhereInput | CollectionCaseAgreementScalarWhereInput[]
  }

  export type CollectionCasePenaltyUpdateManyWithoutCollection_caseNestedInput = {
    create?: XOR<CollectionCasePenaltyCreateWithoutCollection_caseInput, CollectionCasePenaltyUncheckedCreateWithoutCollection_caseInput> | CollectionCasePenaltyCreateWithoutCollection_caseInput[] | CollectionCasePenaltyUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCasePenaltyCreateOrConnectWithoutCollection_caseInput | CollectionCasePenaltyCreateOrConnectWithoutCollection_caseInput[]
    upsert?: CollectionCasePenaltyUpsertWithWhereUniqueWithoutCollection_caseInput | CollectionCasePenaltyUpsertWithWhereUniqueWithoutCollection_caseInput[]
    createMany?: CollectionCasePenaltyCreateManyCollection_caseInputEnvelope
    set?: CollectionCasePenaltyWhereUniqueInput | CollectionCasePenaltyWhereUniqueInput[]
    disconnect?: CollectionCasePenaltyWhereUniqueInput | CollectionCasePenaltyWhereUniqueInput[]
    delete?: CollectionCasePenaltyWhereUniqueInput | CollectionCasePenaltyWhereUniqueInput[]
    connect?: CollectionCasePenaltyWhereUniqueInput | CollectionCasePenaltyWhereUniqueInput[]
    update?: CollectionCasePenaltyUpdateWithWhereUniqueWithoutCollection_caseInput | CollectionCasePenaltyUpdateWithWhereUniqueWithoutCollection_caseInput[]
    updateMany?: CollectionCasePenaltyUpdateManyWithWhereWithoutCollection_caseInput | CollectionCasePenaltyUpdateManyWithWhereWithoutCollection_caseInput[]
    deleteMany?: CollectionCasePenaltyScalarWhereInput | CollectionCasePenaltyScalarWhereInput[]
  }

  export type ChatRoomUpdateManyWithoutCollection_caseNestedInput = {
    create?: XOR<ChatRoomCreateWithoutCollection_caseInput, ChatRoomUncheckedCreateWithoutCollection_caseInput> | ChatRoomCreateWithoutCollection_caseInput[] | ChatRoomUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutCollection_caseInput | ChatRoomCreateOrConnectWithoutCollection_caseInput[]
    upsert?: ChatRoomUpsertWithWhereUniqueWithoutCollection_caseInput | ChatRoomUpsertWithWhereUniqueWithoutCollection_caseInput[]
    createMany?: ChatRoomCreateManyCollection_caseInputEnvelope
    set?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    disconnect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    delete?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    update?: ChatRoomUpdateWithWhereUniqueWithoutCollection_caseInput | ChatRoomUpdateWithWhereUniqueWithoutCollection_caseInput[]
    updateMany?: ChatRoomUpdateManyWithWhereWithoutCollection_caseInput | ChatRoomUpdateManyWithWhereWithoutCollection_caseInput[]
    deleteMany?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
  }

  export type CollectionCaseNotificationUncheckedUpdateManyWithoutCollection_caseNestedInput = {
    create?: XOR<CollectionCaseNotificationCreateWithoutCollection_caseInput, CollectionCaseNotificationUncheckedCreateWithoutCollection_caseInput> | CollectionCaseNotificationCreateWithoutCollection_caseInput[] | CollectionCaseNotificationUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCaseNotificationCreateOrConnectWithoutCollection_caseInput | CollectionCaseNotificationCreateOrConnectWithoutCollection_caseInput[]
    upsert?: CollectionCaseNotificationUpsertWithWhereUniqueWithoutCollection_caseInput | CollectionCaseNotificationUpsertWithWhereUniqueWithoutCollection_caseInput[]
    createMany?: CollectionCaseNotificationCreateManyCollection_caseInputEnvelope
    set?: CollectionCaseNotificationWhereUniqueInput | CollectionCaseNotificationWhereUniqueInput[]
    disconnect?: CollectionCaseNotificationWhereUniqueInput | CollectionCaseNotificationWhereUniqueInput[]
    delete?: CollectionCaseNotificationWhereUniqueInput | CollectionCaseNotificationWhereUniqueInput[]
    connect?: CollectionCaseNotificationWhereUniqueInput | CollectionCaseNotificationWhereUniqueInput[]
    update?: CollectionCaseNotificationUpdateWithWhereUniqueWithoutCollection_caseInput | CollectionCaseNotificationUpdateWithWhereUniqueWithoutCollection_caseInput[]
    updateMany?: CollectionCaseNotificationUpdateManyWithWhereWithoutCollection_caseInput | CollectionCaseNotificationUpdateManyWithWhereWithoutCollection_caseInput[]
    deleteMany?: CollectionCaseNotificationScalarWhereInput | CollectionCaseNotificationScalarWhereInput[]
  }

  export type CollectionCasePaymentUncheckedUpdateManyWithoutCollection_caseNestedInput = {
    create?: XOR<CollectionCasePaymentCreateWithoutCollection_caseInput, CollectionCasePaymentUncheckedCreateWithoutCollection_caseInput> | CollectionCasePaymentCreateWithoutCollection_caseInput[] | CollectionCasePaymentUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCasePaymentCreateOrConnectWithoutCollection_caseInput | CollectionCasePaymentCreateOrConnectWithoutCollection_caseInput[]
    upsert?: CollectionCasePaymentUpsertWithWhereUniqueWithoutCollection_caseInput | CollectionCasePaymentUpsertWithWhereUniqueWithoutCollection_caseInput[]
    createMany?: CollectionCasePaymentCreateManyCollection_caseInputEnvelope
    set?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    disconnect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    delete?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    connect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    update?: CollectionCasePaymentUpdateWithWhereUniqueWithoutCollection_caseInput | CollectionCasePaymentUpdateWithWhereUniqueWithoutCollection_caseInput[]
    updateMany?: CollectionCasePaymentUpdateManyWithWhereWithoutCollection_caseInput | CollectionCasePaymentUpdateManyWithWhereWithoutCollection_caseInput[]
    deleteMany?: CollectionCasePaymentScalarWhereInput | CollectionCasePaymentScalarWhereInput[]
  }

  export type CollectionCaseAgreementUncheckedUpdateManyWithoutCollection_caseNestedInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutCollection_caseInput, CollectionCaseAgreementUncheckedCreateWithoutCollection_caseInput> | CollectionCaseAgreementCreateWithoutCollection_caseInput[] | CollectionCaseAgreementUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutCollection_caseInput | CollectionCaseAgreementCreateOrConnectWithoutCollection_caseInput[]
    upsert?: CollectionCaseAgreementUpsertWithWhereUniqueWithoutCollection_caseInput | CollectionCaseAgreementUpsertWithWhereUniqueWithoutCollection_caseInput[]
    createMany?: CollectionCaseAgreementCreateManyCollection_caseInputEnvelope
    set?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    disconnect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    delete?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    update?: CollectionCaseAgreementUpdateWithWhereUniqueWithoutCollection_caseInput | CollectionCaseAgreementUpdateWithWhereUniqueWithoutCollection_caseInput[]
    updateMany?: CollectionCaseAgreementUpdateManyWithWhereWithoutCollection_caseInput | CollectionCaseAgreementUpdateManyWithWhereWithoutCollection_caseInput[]
    deleteMany?: CollectionCaseAgreementScalarWhereInput | CollectionCaseAgreementScalarWhereInput[]
  }

  export type CollectionCasePenaltyUncheckedUpdateManyWithoutCollection_caseNestedInput = {
    create?: XOR<CollectionCasePenaltyCreateWithoutCollection_caseInput, CollectionCasePenaltyUncheckedCreateWithoutCollection_caseInput> | CollectionCasePenaltyCreateWithoutCollection_caseInput[] | CollectionCasePenaltyUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: CollectionCasePenaltyCreateOrConnectWithoutCollection_caseInput | CollectionCasePenaltyCreateOrConnectWithoutCollection_caseInput[]
    upsert?: CollectionCasePenaltyUpsertWithWhereUniqueWithoutCollection_caseInput | CollectionCasePenaltyUpsertWithWhereUniqueWithoutCollection_caseInput[]
    createMany?: CollectionCasePenaltyCreateManyCollection_caseInputEnvelope
    set?: CollectionCasePenaltyWhereUniqueInput | CollectionCasePenaltyWhereUniqueInput[]
    disconnect?: CollectionCasePenaltyWhereUniqueInput | CollectionCasePenaltyWhereUniqueInput[]
    delete?: CollectionCasePenaltyWhereUniqueInput | CollectionCasePenaltyWhereUniqueInput[]
    connect?: CollectionCasePenaltyWhereUniqueInput | CollectionCasePenaltyWhereUniqueInput[]
    update?: CollectionCasePenaltyUpdateWithWhereUniqueWithoutCollection_caseInput | CollectionCasePenaltyUpdateWithWhereUniqueWithoutCollection_caseInput[]
    updateMany?: CollectionCasePenaltyUpdateManyWithWhereWithoutCollection_caseInput | CollectionCasePenaltyUpdateManyWithWhereWithoutCollection_caseInput[]
    deleteMany?: CollectionCasePenaltyScalarWhereInput | CollectionCasePenaltyScalarWhereInput[]
  }

  export type ChatRoomUncheckedUpdateManyWithoutCollection_caseNestedInput = {
    create?: XOR<ChatRoomCreateWithoutCollection_caseInput, ChatRoomUncheckedCreateWithoutCollection_caseInput> | ChatRoomCreateWithoutCollection_caseInput[] | ChatRoomUncheckedCreateWithoutCollection_caseInput[]
    connectOrCreate?: ChatRoomCreateOrConnectWithoutCollection_caseInput | ChatRoomCreateOrConnectWithoutCollection_caseInput[]
    upsert?: ChatRoomUpsertWithWhereUniqueWithoutCollection_caseInput | ChatRoomUpsertWithWhereUniqueWithoutCollection_caseInput[]
    createMany?: ChatRoomCreateManyCollection_caseInputEnvelope
    set?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    disconnect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    delete?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    connect?: ChatRoomWhereUniqueInput | ChatRoomWhereUniqueInput[]
    update?: ChatRoomUpdateWithWhereUniqueWithoutCollection_caseInput | ChatRoomUpdateWithWhereUniqueWithoutCollection_caseInput[]
    updateMany?: ChatRoomUpdateManyWithWhereWithoutCollection_caseInput | ChatRoomUpdateManyWithWhereWithoutCollection_caseInput[]
    deleteMany?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
  }

  export type CollectionCaseCreateNestedOneWithoutPenaltiesInput = {
    create?: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPenaltiesInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type CollectionCaseUpdateOneRequiredWithoutPenaltiesNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPenaltiesInput
    upsert?: CollectionCaseUpsertWithoutPenaltiesInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutPenaltiesInput, CollectionCaseUpdateWithoutPenaltiesInput>, CollectionCaseUncheckedUpdateWithoutPenaltiesInput>
  }

  export type CollectionCaseCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutNotificationsInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type CollectionCaseUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutNotificationsInput
    upsert?: CollectionCaseUpsertWithoutNotificationsInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutNotificationsInput, CollectionCaseUpdateWithoutNotificationsInput>, CollectionCaseUncheckedUpdateWithoutNotificationsInput>
  }

  export type CollectionCaseCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPaymentsInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type CollectionCaseAgreementCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutPaymentsInput, CollectionCaseAgreementUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutPaymentsInput
    connect?: CollectionCaseAgreementWhereUniqueInput
  }

  export type CollectionCaseAgreementInstallmentCreateNestedManyWithoutPaymentInput = {
    create?: XOR<CollectionCaseAgreementInstallmentCreateWithoutPaymentInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutPaymentInput> | CollectionCaseAgreementInstallmentCreateWithoutPaymentInput[] | CollectionCaseAgreementInstallmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: CollectionCaseAgreementInstallmentCreateOrConnectWithoutPaymentInput | CollectionCaseAgreementInstallmentCreateOrConnectWithoutPaymentInput[]
    createMany?: CollectionCaseAgreementInstallmentCreateManyPaymentInputEnvelope
    connect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
  }

  export type CollectionCaseAgreementInstallmentUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<CollectionCaseAgreementInstallmentCreateWithoutPaymentInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutPaymentInput> | CollectionCaseAgreementInstallmentCreateWithoutPaymentInput[] | CollectionCaseAgreementInstallmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: CollectionCaseAgreementInstallmentCreateOrConnectWithoutPaymentInput | CollectionCaseAgreementInstallmentCreateOrConnectWithoutPaymentInput[]
    createMany?: CollectionCaseAgreementInstallmentCreateManyPaymentInputEnvelope
    connect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type CollectionCaseUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutPaymentsInput
    upsert?: CollectionCaseUpsertWithoutPaymentsInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutPaymentsInput, CollectionCaseUpdateWithoutPaymentsInput>, CollectionCaseUncheckedUpdateWithoutPaymentsInput>
  }

  export type CollectionCaseAgreementUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutPaymentsInput, CollectionCaseAgreementUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutPaymentsInput
    upsert?: CollectionCaseAgreementUpsertWithoutPaymentsInput
    disconnect?: CollectionCaseAgreementWhereInput | boolean
    delete?: CollectionCaseAgreementWhereInput | boolean
    connect?: CollectionCaseAgreementWhereUniqueInput
    update?: XOR<XOR<CollectionCaseAgreementUpdateToOneWithWhereWithoutPaymentsInput, CollectionCaseAgreementUpdateWithoutPaymentsInput>, CollectionCaseAgreementUncheckedUpdateWithoutPaymentsInput>
  }

  export type CollectionCaseAgreementInstallmentUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<CollectionCaseAgreementInstallmentCreateWithoutPaymentInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutPaymentInput> | CollectionCaseAgreementInstallmentCreateWithoutPaymentInput[] | CollectionCaseAgreementInstallmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: CollectionCaseAgreementInstallmentCreateOrConnectWithoutPaymentInput | CollectionCaseAgreementInstallmentCreateOrConnectWithoutPaymentInput[]
    upsert?: CollectionCaseAgreementInstallmentUpsertWithWhereUniqueWithoutPaymentInput | CollectionCaseAgreementInstallmentUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: CollectionCaseAgreementInstallmentCreateManyPaymentInputEnvelope
    set?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    disconnect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    delete?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    connect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    update?: CollectionCaseAgreementInstallmentUpdateWithWhereUniqueWithoutPaymentInput | CollectionCaseAgreementInstallmentUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: CollectionCaseAgreementInstallmentUpdateManyWithWhereWithoutPaymentInput | CollectionCaseAgreementInstallmentUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: CollectionCaseAgreementInstallmentScalarWhereInput | CollectionCaseAgreementInstallmentScalarWhereInput[]
  }

  export type CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<CollectionCaseAgreementInstallmentCreateWithoutPaymentInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutPaymentInput> | CollectionCaseAgreementInstallmentCreateWithoutPaymentInput[] | CollectionCaseAgreementInstallmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: CollectionCaseAgreementInstallmentCreateOrConnectWithoutPaymentInput | CollectionCaseAgreementInstallmentCreateOrConnectWithoutPaymentInput[]
    upsert?: CollectionCaseAgreementInstallmentUpsertWithWhereUniqueWithoutPaymentInput | CollectionCaseAgreementInstallmentUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: CollectionCaseAgreementInstallmentCreateManyPaymentInputEnvelope
    set?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    disconnect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    delete?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    connect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    update?: CollectionCaseAgreementInstallmentUpdateWithWhereUniqueWithoutPaymentInput | CollectionCaseAgreementInstallmentUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: CollectionCaseAgreementInstallmentUpdateManyWithWhereWithoutPaymentInput | CollectionCaseAgreementInstallmentUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: CollectionCaseAgreementInstallmentScalarWhereInput | CollectionCaseAgreementInstallmentScalarWhereInput[]
  }

  export type CollectionCaseCreateNestedManyWithoutDebtorInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutDebtorsInput = {
    create?: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDebtorsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDebtorsInput = {
    create?: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtorsInput
    connect?: UserWhereUniqueInput
  }

  export type DebtorIncomeCreateNestedManyWithoutDebtorInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
  }

  export type CollectionCaseAgreementCreateNestedManyWithoutDebtorInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutDebtorInput, CollectionCaseAgreementUncheckedCreateWithoutDebtorInput> | CollectionCaseAgreementCreateWithoutDebtorInput[] | CollectionCaseAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutDebtorInput | CollectionCaseAgreementCreateOrConnectWithoutDebtorInput[]
    createMany?: CollectionCaseAgreementCreateManyDebtorInputEnvelope
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
  }

  export type VerdictCreateNestedManyWithoutDebtorInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
  }

  export type DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
  }

  export type CollectionCaseAgreementUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutDebtorInput, CollectionCaseAgreementUncheckedCreateWithoutDebtorInput> | CollectionCaseAgreementCreateWithoutDebtorInput[] | CollectionCaseAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutDebtorInput | CollectionCaseAgreementCreateOrConnectWithoutDebtorInput[]
    createMany?: CollectionCaseAgreementCreateManyDebtorInputEnvelope
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
  }

  export type VerdictUncheckedCreateNestedManyWithoutDebtorInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
  }

  export type EnumPersonTypeFieldUpdateOperationsInput = {
    set?: $Enums.PersonType
  }

  export type NullableEnumIdentificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.IdentificationType | null
  }

  export type CollectionCaseUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput | CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput | CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutDebtorInput | CollectionCaseUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutDebtorsNestedInput = {
    create?: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDebtorsInput
    upsert?: TenantUpsertWithoutDebtorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDebtorsInput, TenantUpdateWithoutDebtorsInput>, TenantUncheckedUpdateWithoutDebtorsInput>
  }

  export type UserUpdateOneWithoutDebtorsNestedInput = {
    create?: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDebtorsInput
    upsert?: UserUpsertWithoutDebtorsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDebtorsInput, UserUpdateWithoutDebtorsInput>, UserUncheckedUpdateWithoutDebtorsInput>
  }

  export type DebtorIncomeUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    upsert?: DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    set?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    disconnect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    delete?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    update?: DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: DebtorIncomeUpdateManyWithWhereWithoutDebtorInput | DebtorIncomeUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
  }

  export type CollectionCaseAgreementUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutDebtorInput, CollectionCaseAgreementUncheckedCreateWithoutDebtorInput> | CollectionCaseAgreementCreateWithoutDebtorInput[] | CollectionCaseAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutDebtorInput | CollectionCaseAgreementCreateOrConnectWithoutDebtorInput[]
    upsert?: CollectionCaseAgreementUpsertWithWhereUniqueWithoutDebtorInput | CollectionCaseAgreementUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: CollectionCaseAgreementCreateManyDebtorInputEnvelope
    set?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    disconnect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    delete?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    update?: CollectionCaseAgreementUpdateWithWhereUniqueWithoutDebtorInput | CollectionCaseAgreementUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: CollectionCaseAgreementUpdateManyWithWhereWithoutDebtorInput | CollectionCaseAgreementUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: CollectionCaseAgreementScalarWhereInput | CollectionCaseAgreementScalarWhereInput[]
  }

  export type VerdictUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutDebtorInput | VerdictUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutDebtorInput | VerdictUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutDebtorInput | VerdictUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput> | CollectionCaseCreateWithoutDebtorInput[] | CollectionCaseUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutDebtorInput | CollectionCaseCreateOrConnectWithoutDebtorInput[]
    upsert?: CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput | CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: CollectionCaseCreateManyDebtorInputEnvelope
    set?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    disconnect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    delete?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    connect?: CollectionCaseWhereUniqueInput | CollectionCaseWhereUniqueInput[]
    update?: CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput | CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: CollectionCaseUpdateManyWithWhereWithoutDebtorInput | CollectionCaseUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
  }

  export type DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput> | DebtorIncomeCreateWithoutDebtorInput[] | DebtorIncomeUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: DebtorIncomeCreateOrConnectWithoutDebtorInput | DebtorIncomeCreateOrConnectWithoutDebtorInput[]
    upsert?: DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: DebtorIncomeCreateManyDebtorInputEnvelope
    set?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    disconnect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    delete?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    connect?: DebtorIncomeWhereUniqueInput | DebtorIncomeWhereUniqueInput[]
    update?: DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput | DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: DebtorIncomeUpdateManyWithWhereWithoutDebtorInput | DebtorIncomeUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
  }

  export type CollectionCaseAgreementUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutDebtorInput, CollectionCaseAgreementUncheckedCreateWithoutDebtorInput> | CollectionCaseAgreementCreateWithoutDebtorInput[] | CollectionCaseAgreementUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutDebtorInput | CollectionCaseAgreementCreateOrConnectWithoutDebtorInput[]
    upsert?: CollectionCaseAgreementUpsertWithWhereUniqueWithoutDebtorInput | CollectionCaseAgreementUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: CollectionCaseAgreementCreateManyDebtorInputEnvelope
    set?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    disconnect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    delete?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    connect?: CollectionCaseAgreementWhereUniqueInput | CollectionCaseAgreementWhereUniqueInput[]
    update?: CollectionCaseAgreementUpdateWithWhereUniqueWithoutDebtorInput | CollectionCaseAgreementUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: CollectionCaseAgreementUpdateManyWithWhereWithoutDebtorInput | CollectionCaseAgreementUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: CollectionCaseAgreementScalarWhereInput | CollectionCaseAgreementScalarWhereInput[]
  }

  export type VerdictUncheckedUpdateManyWithoutDebtorNestedInput = {
    create?: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput> | VerdictCreateWithoutDebtorInput[] | VerdictUncheckedCreateWithoutDebtorInput[]
    connectOrCreate?: VerdictCreateOrConnectWithoutDebtorInput | VerdictCreateOrConnectWithoutDebtorInput[]
    upsert?: VerdictUpsertWithWhereUniqueWithoutDebtorInput | VerdictUpsertWithWhereUniqueWithoutDebtorInput[]
    createMany?: VerdictCreateManyDebtorInputEnvelope
    set?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    disconnect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    delete?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    connect?: VerdictWhereUniqueInput | VerdictWhereUniqueInput[]
    update?: VerdictUpdateWithWhereUniqueWithoutDebtorInput | VerdictUpdateWithWhereUniqueWithoutDebtorInput[]
    updateMany?: VerdictUpdateManyWithWhereWithoutDebtorInput | VerdictUpdateManyWithWhereWithoutDebtorInput[]
    deleteMany?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutChat_roomsInput = {
    create?: XOR<TenantCreateWithoutChat_roomsInput, TenantUncheckedCreateWithoutChat_roomsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutChat_roomsInput
    connect?: TenantWhereUniqueInput
  }

  export type CollectionCaseCreateNestedOneWithoutChat_roomsInput = {
    create?: XOR<CollectionCaseCreateWithoutChat_roomsInput, CollectionCaseUncheckedCreateWithoutChat_roomsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutChat_roomsInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutRoomInput = {
    create?: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput> | ChatMessageCreateWithoutRoomInput[] | ChatMessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRoomInput | ChatMessageCreateOrConnectWithoutRoomInput[]
    createMany?: ChatMessageCreateManyRoomInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput> | ChatMessageCreateWithoutRoomInput[] | ChatMessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRoomInput | ChatMessageCreateOrConnectWithoutRoomInput[]
    createMany?: ChatMessageCreateManyRoomInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutChat_roomsNestedInput = {
    create?: XOR<TenantCreateWithoutChat_roomsInput, TenantUncheckedCreateWithoutChat_roomsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutChat_roomsInput
    upsert?: TenantUpsertWithoutChat_roomsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutChat_roomsInput, TenantUpdateWithoutChat_roomsInput>, TenantUncheckedUpdateWithoutChat_roomsInput>
  }

  export type CollectionCaseUpdateOneRequiredWithoutChat_roomsNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutChat_roomsInput, CollectionCaseUncheckedCreateWithoutChat_roomsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutChat_roomsInput
    upsert?: CollectionCaseUpsertWithoutChat_roomsInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutChat_roomsInput, CollectionCaseUpdateWithoutChat_roomsInput>, CollectionCaseUncheckedUpdateWithoutChat_roomsInput>
  }

  export type ChatMessageUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput> | ChatMessageCreateWithoutRoomInput[] | ChatMessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRoomInput | ChatMessageCreateOrConnectWithoutRoomInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutRoomInput | ChatMessageUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ChatMessageCreateManyRoomInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutRoomInput | ChatMessageUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutRoomInput | ChatMessageUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput> | ChatMessageCreateWithoutRoomInput[] | ChatMessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutRoomInput | ChatMessageCreateOrConnectWithoutRoomInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutRoomInput | ChatMessageUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: ChatMessageCreateManyRoomInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutRoomInput | ChatMessageUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutRoomInput | ChatMessageUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatRoomCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatRoomCreateOrConnectWithoutMessagesInput
    connect?: ChatRoomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ChatRoomUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatRoomCreateOrConnectWithoutMessagesInput
    upsert?: ChatRoomUpsertWithoutMessagesInput
    connect?: ChatRoomWhereUniqueInput
    update?: XOR<XOR<ChatRoomUpdateToOneWithWhereWithoutMessagesInput, ChatRoomUpdateWithoutMessagesInput>, ChatRoomUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type DebtorCreateNestedOneWithoutIncomesInput = {
    create?: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutIncomesInput
    connect?: DebtorWhereUniqueInput
  }

  export type DebtorUpdateOneRequiredWithoutIncomesNestedInput = {
    create?: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutIncomesInput
    upsert?: DebtorUpsertWithoutIncomesInput
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutIncomesInput, DebtorUpdateWithoutIncomesInput>, DebtorUncheckedUpdateWithoutIncomesInput>
  }

  export type TenantCreateNestedOneWithoutAgreementsInput = {
    create?: XOR<TenantCreateWithoutAgreementsInput, TenantUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAgreementsInput
    connect?: TenantWhereUniqueInput
  }

  export type DebtorCreateNestedOneWithoutPayment_agreementsInput = {
    create?: XOR<DebtorCreateWithoutPayment_agreementsInput, DebtorUncheckedCreateWithoutPayment_agreementsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutPayment_agreementsInput
    connect?: DebtorWhereUniqueInput
  }

  export type CollectionCaseCreateNestedOneWithoutAgreementsInput = {
    create?: XOR<CollectionCaseCreateWithoutAgreementsInput, CollectionCaseUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutAgreementsInput
    connect?: CollectionCaseWhereUniqueInput
  }

  export type CollectionCaseAgreementInstallmentCreateNestedManyWithoutAgreementInput = {
    create?: XOR<CollectionCaseAgreementInstallmentCreateWithoutAgreementInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutAgreementInput> | CollectionCaseAgreementInstallmentCreateWithoutAgreementInput[] | CollectionCaseAgreementInstallmentUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: CollectionCaseAgreementInstallmentCreateOrConnectWithoutAgreementInput | CollectionCaseAgreementInstallmentCreateOrConnectWithoutAgreementInput[]
    createMany?: CollectionCaseAgreementInstallmentCreateManyAgreementInputEnvelope
    connect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
  }

  export type CollectionCasePaymentCreateNestedManyWithoutAgreementInput = {
    create?: XOR<CollectionCasePaymentCreateWithoutAgreementInput, CollectionCasePaymentUncheckedCreateWithoutAgreementInput> | CollectionCasePaymentCreateWithoutAgreementInput[] | CollectionCasePaymentUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: CollectionCasePaymentCreateOrConnectWithoutAgreementInput | CollectionCasePaymentCreateOrConnectWithoutAgreementInput[]
    createMany?: CollectionCasePaymentCreateManyAgreementInputEnvelope
    connect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
  }

  export type CollectionCaseAgreementInstallmentUncheckedCreateNestedManyWithoutAgreementInput = {
    create?: XOR<CollectionCaseAgreementInstallmentCreateWithoutAgreementInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutAgreementInput> | CollectionCaseAgreementInstallmentCreateWithoutAgreementInput[] | CollectionCaseAgreementInstallmentUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: CollectionCaseAgreementInstallmentCreateOrConnectWithoutAgreementInput | CollectionCaseAgreementInstallmentCreateOrConnectWithoutAgreementInput[]
    createMany?: CollectionCaseAgreementInstallmentCreateManyAgreementInputEnvelope
    connect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
  }

  export type CollectionCasePaymentUncheckedCreateNestedManyWithoutAgreementInput = {
    create?: XOR<CollectionCasePaymentCreateWithoutAgreementInput, CollectionCasePaymentUncheckedCreateWithoutAgreementInput> | CollectionCasePaymentCreateWithoutAgreementInput[] | CollectionCasePaymentUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: CollectionCasePaymentCreateOrConnectWithoutAgreementInput | CollectionCasePaymentCreateOrConnectWithoutAgreementInput[]
    createMany?: CollectionCasePaymentCreateManyAgreementInputEnvelope
    connect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
  }

  export type EnumAgreementStatusFieldUpdateOperationsInput = {
    set?: $Enums.AgreementStatus
  }

  export type TenantUpdateOneRequiredWithoutAgreementsNestedInput = {
    create?: XOR<TenantCreateWithoutAgreementsInput, TenantUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAgreementsInput
    upsert?: TenantUpsertWithoutAgreementsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAgreementsInput, TenantUpdateWithoutAgreementsInput>, TenantUncheckedUpdateWithoutAgreementsInput>
  }

  export type DebtorUpdateOneWithoutPayment_agreementsNestedInput = {
    create?: XOR<DebtorCreateWithoutPayment_agreementsInput, DebtorUncheckedCreateWithoutPayment_agreementsInput>
    connectOrCreate?: DebtorCreateOrConnectWithoutPayment_agreementsInput
    upsert?: DebtorUpsertWithoutPayment_agreementsInput
    disconnect?: DebtorWhereInput | boolean
    delete?: DebtorWhereInput | boolean
    connect?: DebtorWhereUniqueInput
    update?: XOR<XOR<DebtorUpdateToOneWithWhereWithoutPayment_agreementsInput, DebtorUpdateWithoutPayment_agreementsInput>, DebtorUncheckedUpdateWithoutPayment_agreementsInput>
  }

  export type CollectionCaseUpdateOneRequiredWithoutAgreementsNestedInput = {
    create?: XOR<CollectionCaseCreateWithoutAgreementsInput, CollectionCaseUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: CollectionCaseCreateOrConnectWithoutAgreementsInput
    upsert?: CollectionCaseUpsertWithoutAgreementsInput
    connect?: CollectionCaseWhereUniqueInput
    update?: XOR<XOR<CollectionCaseUpdateToOneWithWhereWithoutAgreementsInput, CollectionCaseUpdateWithoutAgreementsInput>, CollectionCaseUncheckedUpdateWithoutAgreementsInput>
  }

  export type CollectionCaseAgreementInstallmentUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<CollectionCaseAgreementInstallmentCreateWithoutAgreementInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutAgreementInput> | CollectionCaseAgreementInstallmentCreateWithoutAgreementInput[] | CollectionCaseAgreementInstallmentUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: CollectionCaseAgreementInstallmentCreateOrConnectWithoutAgreementInput | CollectionCaseAgreementInstallmentCreateOrConnectWithoutAgreementInput[]
    upsert?: CollectionCaseAgreementInstallmentUpsertWithWhereUniqueWithoutAgreementInput | CollectionCaseAgreementInstallmentUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: CollectionCaseAgreementInstallmentCreateManyAgreementInputEnvelope
    set?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    disconnect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    delete?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    connect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    update?: CollectionCaseAgreementInstallmentUpdateWithWhereUniqueWithoutAgreementInput | CollectionCaseAgreementInstallmentUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: CollectionCaseAgreementInstallmentUpdateManyWithWhereWithoutAgreementInput | CollectionCaseAgreementInstallmentUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: CollectionCaseAgreementInstallmentScalarWhereInput | CollectionCaseAgreementInstallmentScalarWhereInput[]
  }

  export type CollectionCasePaymentUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<CollectionCasePaymentCreateWithoutAgreementInput, CollectionCasePaymentUncheckedCreateWithoutAgreementInput> | CollectionCasePaymentCreateWithoutAgreementInput[] | CollectionCasePaymentUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: CollectionCasePaymentCreateOrConnectWithoutAgreementInput | CollectionCasePaymentCreateOrConnectWithoutAgreementInput[]
    upsert?: CollectionCasePaymentUpsertWithWhereUniqueWithoutAgreementInput | CollectionCasePaymentUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: CollectionCasePaymentCreateManyAgreementInputEnvelope
    set?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    disconnect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    delete?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    connect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    update?: CollectionCasePaymentUpdateWithWhereUniqueWithoutAgreementInput | CollectionCasePaymentUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: CollectionCasePaymentUpdateManyWithWhereWithoutAgreementInput | CollectionCasePaymentUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: CollectionCasePaymentScalarWhereInput | CollectionCasePaymentScalarWhereInput[]
  }

  export type CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<CollectionCaseAgreementInstallmentCreateWithoutAgreementInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutAgreementInput> | CollectionCaseAgreementInstallmentCreateWithoutAgreementInput[] | CollectionCaseAgreementInstallmentUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: CollectionCaseAgreementInstallmentCreateOrConnectWithoutAgreementInput | CollectionCaseAgreementInstallmentCreateOrConnectWithoutAgreementInput[]
    upsert?: CollectionCaseAgreementInstallmentUpsertWithWhereUniqueWithoutAgreementInput | CollectionCaseAgreementInstallmentUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: CollectionCaseAgreementInstallmentCreateManyAgreementInputEnvelope
    set?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    disconnect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    delete?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    connect?: CollectionCaseAgreementInstallmentWhereUniqueInput | CollectionCaseAgreementInstallmentWhereUniqueInput[]
    update?: CollectionCaseAgreementInstallmentUpdateWithWhereUniqueWithoutAgreementInput | CollectionCaseAgreementInstallmentUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: CollectionCaseAgreementInstallmentUpdateManyWithWhereWithoutAgreementInput | CollectionCaseAgreementInstallmentUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: CollectionCaseAgreementInstallmentScalarWhereInput | CollectionCaseAgreementInstallmentScalarWhereInput[]
  }

  export type CollectionCasePaymentUncheckedUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<CollectionCasePaymentCreateWithoutAgreementInput, CollectionCasePaymentUncheckedCreateWithoutAgreementInput> | CollectionCasePaymentCreateWithoutAgreementInput[] | CollectionCasePaymentUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: CollectionCasePaymentCreateOrConnectWithoutAgreementInput | CollectionCasePaymentCreateOrConnectWithoutAgreementInput[]
    upsert?: CollectionCasePaymentUpsertWithWhereUniqueWithoutAgreementInput | CollectionCasePaymentUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: CollectionCasePaymentCreateManyAgreementInputEnvelope
    set?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    disconnect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    delete?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    connect?: CollectionCasePaymentWhereUniqueInput | CollectionCasePaymentWhereUniqueInput[]
    update?: CollectionCasePaymentUpdateWithWhereUniqueWithoutAgreementInput | CollectionCasePaymentUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: CollectionCasePaymentUpdateManyWithWhereWithoutAgreementInput | CollectionCasePaymentUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: CollectionCasePaymentScalarWhereInput | CollectionCasePaymentScalarWhereInput[]
  }

  export type CollectionCaseAgreementCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutInstallmentsInput, CollectionCaseAgreementUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutInstallmentsInput
    connect?: CollectionCaseAgreementWhereUniqueInput
  }

  export type CollectionCasePaymentCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<CollectionCasePaymentCreateWithoutInstallmentsInput, CollectionCasePaymentUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: CollectionCasePaymentCreateOrConnectWithoutInstallmentsInput
    connect?: CollectionCasePaymentWhereUniqueInput
  }

  export type EnumInstallmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.InstallmentStatus
  }

  export type CollectionCaseAgreementUpdateOneRequiredWithoutInstallmentsNestedInput = {
    create?: XOR<CollectionCaseAgreementCreateWithoutInstallmentsInput, CollectionCaseAgreementUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: CollectionCaseAgreementCreateOrConnectWithoutInstallmentsInput
    upsert?: CollectionCaseAgreementUpsertWithoutInstallmentsInput
    connect?: CollectionCaseAgreementWhereUniqueInput
    update?: XOR<XOR<CollectionCaseAgreementUpdateToOneWithWhereWithoutInstallmentsInput, CollectionCaseAgreementUpdateWithoutInstallmentsInput>, CollectionCaseAgreementUncheckedUpdateWithoutInstallmentsInput>
  }

  export type CollectionCasePaymentUpdateOneWithoutInstallmentsNestedInput = {
    create?: XOR<CollectionCasePaymentCreateWithoutInstallmentsInput, CollectionCasePaymentUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: CollectionCasePaymentCreateOrConnectWithoutInstallmentsInput
    upsert?: CollectionCasePaymentUpsertWithoutInstallmentsInput
    disconnect?: CollectionCasePaymentWhereInput | boolean
    delete?: CollectionCasePaymentWhereInput | boolean
    connect?: CollectionCasePaymentWhereUniqueInput
    update?: XOR<XOR<CollectionCasePaymentUpdateToOneWithWhereWithoutInstallmentsInput, CollectionCasePaymentUpdateWithoutInstallmentsInput>, CollectionCasePaymentUncheckedUpdateWithoutInstallmentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumroleEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumFilter<$PrismaModel> | $Enums.roleEnum
  }

  export type NestedEnumroleEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roleEnum | EnumroleEnumFieldRefInput<$PrismaModel>
    in?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.roleEnum[] | ListEnumroleEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumroleEnumWithAggregatesFilter<$PrismaModel> | $Enums.roleEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleEnumFilter<$PrismaModel>
    _max?: NestedEnumroleEnumFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumVerdictStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusFilter<$PrismaModel> | $Enums.VerdictStatus
  }

  export type NestedEnumVerdictStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerdictStatus | EnumVerdictStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerdictStatus[] | ListEnumVerdictStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerdictStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerdictStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerdictStatusFilter<$PrismaModel>
    _max?: NestedEnumVerdictStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumCalculationTypeEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumFilter<$PrismaModel> | $Enums.CalculationTypeEnum
  }

  export type NestedEnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalculationTypeEnum | EnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    in?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalculationTypeEnum[] | ListEnumCalculationTypeEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumCalculationTypeEnumWithAggregatesFilter<$PrismaModel> | $Enums.CalculationTypeEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
    _max?: NestedEnumCalculationTypeEnumFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumCollectionCaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionCaseStatus | EnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionCaseStatus[] | ListEnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionCaseStatus[] | ListEnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionCaseStatusFilter<$PrismaModel> | $Enums.CollectionCaseStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumCollectionCaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CollectionCaseStatus | EnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CollectionCaseStatus[] | ListEnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CollectionCaseStatus[] | ListEnumCollectionCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCollectionCaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CollectionCaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCollectionCaseStatusFilter<$PrismaModel>
    _max?: NestedEnumCollectionCaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPersonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeFilter<$PrismaModel> | $Enums.PersonType
  }

  export type NestedEnumIdentificationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel> | $Enums.IdentificationType | null
  }

  export type NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonType | EnumPersonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonType[] | ListEnumPersonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonTypeWithAggregatesFilter<$PrismaModel> | $Enums.PersonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonTypeFilter<$PrismaModel>
    _max?: NestedEnumPersonTypeFilter<$PrismaModel>
  }

  export type NestedEnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentificationType | EnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IdentificationType[] | ListEnumIdentificationTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIdentificationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.IdentificationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumIdentificationTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAgreementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusFilter<$PrismaModel> | $Enums.AgreementStatus
  }

  export type NestedEnumAgreementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementStatus | EnumAgreementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementStatus[] | ListEnumAgreementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgreementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgreementStatusFilter<$PrismaModel>
    _max?: NestedEnumAgreementStatusFilter<$PrismaModel>
  }

  export type NestedEnumInstallmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusFilter<$PrismaModel> | $Enums.InstallmentStatus
  }

  export type NestedEnumInstallmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstallmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstallmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInstallmentStatusFilter<$PrismaModel>
  }

  export type BillingInvoiceCreateWithoutTenantInput = {
    id?: string
    invoice_number: string
    amount: number
    currency?: string
    issue_date: Date | string
    due_date: Date | string
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    details?: BillingInvoiceDetailCreateNestedManyWithoutBilling_invoiceInput
    payments?: BillingPaymentCreateNestedManyWithoutBilling_invoiceInput
  }

  export type BillingInvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    invoice_number: string
    amount: number
    currency?: string
    issue_date: Date | string
    due_date: Date | string
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    details?: BillingInvoiceDetailUncheckedCreateNestedManyWithoutBilling_invoiceInput
    payments?: BillingPaymentUncheckedCreateNestedManyWithoutBilling_invoiceInput
  }

  export type BillingInvoiceCreateOrConnectWithoutTenantInput = {
    where: BillingInvoiceWhereUniqueInput
    create: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput>
  }

  export type BillingInvoiceCreateManyTenantInputEnvelope = {
    data: BillingInvoiceCreateManyTenantInput | BillingInvoiceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCaseCreateWithoutTenantInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollection_casesInput
    notifications?: CollectionCaseNotificationCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseUncheckedCreateWithoutTenantInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    debtor_id: string
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notifications?: CollectionCaseNotificationUncheckedCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyUncheckedCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseCreateOrConnectWithoutTenantInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput>
  }

  export type CollectionCaseCreateManyTenantInputEnvelope = {
    data: CollectionCaseCreateManyTenantInput | CollectionCaseCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DebtorCreateWithoutTenantInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    payment_agreements?: CollectionCaseAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutTenantInput = {
    id?: string
    user_id?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    payment_agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutTenantInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput>
  }

  export type DebtorCreateManyTenantInputEnvelope = {
    data: DebtorCreateManyTenantInput | DebtorCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type VerdictCreateWithoutTenantInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdict_bailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutTenantInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    debtor_id: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    notes?: string | null
    bailiff_id?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutTenantInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput>
  }

  export type VerdictCreateManyTenantInputEnvelope = {
    data: VerdictCreateManyTenantInput | VerdictCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    debtors?: DebtorCreateNestedManyWithoutUserInput
    verdict_bailiffs?: VerdictCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    verdict_bailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ChatRoomCreateWithoutTenantInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    collection_case: CollectionCaseCreateNestedOneWithoutChat_roomsInput
    messages?: ChatMessageCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomUncheckedCreateWithoutTenantInput = {
    id?: string
    collection_case_id: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomCreateOrConnectWithoutTenantInput = {
    where: ChatRoomWhereUniqueInput
    create: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput>
  }

  export type ChatRoomCreateManyTenantInputEnvelope = {
    data: ChatRoomCreateManyTenantInput | ChatRoomCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCaseAgreementCreateWithoutTenantInput = {
    id?: string
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    debtor?: DebtorCreateNestedOneWithoutPayment_agreementsInput
    collection_case: CollectionCaseCreateNestedOneWithoutAgreementsInput
    installments?: CollectionCaseAgreementInstallmentCreateNestedManyWithoutAgreementInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementUncheckedCreateWithoutTenantInput = {
    id?: string
    collection_case_id: string
    debtor_id?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedCreateNestedManyWithoutAgreementInput
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementCreateOrConnectWithoutTenantInput = {
    where: CollectionCaseAgreementWhereUniqueInput
    create: XOR<CollectionCaseAgreementCreateWithoutTenantInput, CollectionCaseAgreementUncheckedCreateWithoutTenantInput>
  }

  export type CollectionCaseAgreementCreateManyTenantInputEnvelope = {
    data: CollectionCaseAgreementCreateManyTenantInput | CollectionCaseAgreementCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type BillingInvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: BillingInvoiceWhereUniqueInput
    update: XOR<BillingInvoiceUpdateWithoutTenantInput, BillingInvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<BillingInvoiceCreateWithoutTenantInput, BillingInvoiceUncheckedCreateWithoutTenantInput>
  }

  export type BillingInvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: BillingInvoiceWhereUniqueInput
    data: XOR<BillingInvoiceUpdateWithoutTenantInput, BillingInvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type BillingInvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: BillingInvoiceScalarWhereInput
    data: XOR<BillingInvoiceUpdateManyMutationInput, BillingInvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type BillingInvoiceScalarWhereInput = {
    AND?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
    OR?: BillingInvoiceScalarWhereInput[]
    NOT?: BillingInvoiceScalarWhereInput | BillingInvoiceScalarWhereInput[]
    id?: StringFilter<"BillingInvoice"> | string
    tenant_id?: StringFilter<"BillingInvoice"> | string
    invoice_number?: StringFilter<"BillingInvoice"> | string
    amount?: FloatFilter<"BillingInvoice"> | number
    currency?: StringFilter<"BillingInvoice"> | string
    issue_date?: DateTimeFilter<"BillingInvoice"> | Date | string
    due_date?: DateTimeFilter<"BillingInvoice"> | Date | string
    description?: StringNullableFilter<"BillingInvoice"> | string | null
    status?: StringFilter<"BillingInvoice"> | string
    created_at?: DateTimeFilter<"BillingInvoice"> | Date | string
    updated_at?: DateTimeFilter<"BillingInvoice"> | Date | string
  }

  export type CollectionCaseUpsertWithWhereUniqueWithoutTenantInput = {
    where: CollectionCaseWhereUniqueInput
    update: XOR<CollectionCaseUpdateWithoutTenantInput, CollectionCaseUncheckedUpdateWithoutTenantInput>
    create: XOR<CollectionCaseCreateWithoutTenantInput, CollectionCaseUncheckedCreateWithoutTenantInput>
  }

  export type CollectionCaseUpdateWithWhereUniqueWithoutTenantInput = {
    where: CollectionCaseWhereUniqueInput
    data: XOR<CollectionCaseUpdateWithoutTenantInput, CollectionCaseUncheckedUpdateWithoutTenantInput>
  }

  export type CollectionCaseUpdateManyWithWhereWithoutTenantInput = {
    where: CollectionCaseScalarWhereInput
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyWithoutTenantInput>
  }

  export type CollectionCaseScalarWhereInput = {
    AND?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
    OR?: CollectionCaseScalarWhereInput[]
    NOT?: CollectionCaseScalarWhereInput | CollectionCaseScalarWhereInput[]
    id?: StringFilter<"CollectionCase"> | string
    reference_number?: StringNullableFilter<"CollectionCase"> | string | null
    issue_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    due_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1_sent_at?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder1_due_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2_sent_at?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    reminder2_due_date?: DateTimeNullableFilter<"CollectionCase"> | Date | string | null
    tenant_id?: StringFilter<"CollectionCase"> | string
    debtor_id?: StringFilter<"CollectionCase"> | string
    amount_original?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFilter<"CollectionCase"> | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFilter<"CollectionCase"> | $Enums.CollectionCaseStatus
    notification_status?: StringNullableFilter<"CollectionCase"> | string | null
    created_at?: DateTimeFilter<"CollectionCase"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCase"> | Date | string
  }

  export type DebtorUpsertWithWhereUniqueWithoutTenantInput = {
    where: DebtorWhereUniqueInput
    update: XOR<DebtorUpdateWithoutTenantInput, DebtorUncheckedUpdateWithoutTenantInput>
    create: XOR<DebtorCreateWithoutTenantInput, DebtorUncheckedCreateWithoutTenantInput>
  }

  export type DebtorUpdateWithWhereUniqueWithoutTenantInput = {
    where: DebtorWhereUniqueInput
    data: XOR<DebtorUpdateWithoutTenantInput, DebtorUncheckedUpdateWithoutTenantInput>
  }

  export type DebtorUpdateManyWithWhereWithoutTenantInput = {
    where: DebtorScalarWhereInput
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyWithoutTenantInput>
  }

  export type DebtorScalarWhereInput = {
    AND?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
    OR?: DebtorScalarWhereInput[]
    NOT?: DebtorScalarWhereInput | DebtorScalarWhereInput[]
    id?: StringFilter<"Debtor"> | string
    tenant_id?: StringFilter<"Debtor"> | string
    user_id?: StringNullableFilter<"Debtor"> | string | null
    fullname?: StringFilter<"Debtor"> | string
    email?: StringFilter<"Debtor"> | string
    phone?: StringNullableFilter<"Debtor"> | string | null
    address?: StringNullableFilter<"Debtor"> | string | null
    person_type?: EnumPersonTypeFilter<"Debtor"> | $Enums.PersonType
    identification_type?: EnumIdentificationTypeNullableFilter<"Debtor"> | $Enums.IdentificationType | null
    identification?: StringNullableFilter<"Debtor"> | string | null
    total_income?: FloatNullableFilter<"Debtor"> | number | null
    created_at?: DateTimeFilter<"Debtor"> | Date | string
    updated_at?: DateTimeFilter<"Debtor"> | Date | string
  }

  export type VerdictUpsertWithWhereUniqueWithoutTenantInput = {
    where: VerdictWhereUniqueInput
    update: XOR<VerdictUpdateWithoutTenantInput, VerdictUncheckedUpdateWithoutTenantInput>
    create: XOR<VerdictCreateWithoutTenantInput, VerdictUncheckedCreateWithoutTenantInput>
  }

  export type VerdictUpdateWithWhereUniqueWithoutTenantInput = {
    where: VerdictWhereUniqueInput
    data: XOR<VerdictUpdateWithoutTenantInput, VerdictUncheckedUpdateWithoutTenantInput>
  }

  export type VerdictUpdateManyWithWhereWithoutTenantInput = {
    where: VerdictScalarWhereInput
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyWithoutTenantInput>
  }

  export type VerdictScalarWhereInput = {
    AND?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
    OR?: VerdictScalarWhereInput[]
    NOT?: VerdictScalarWhereInput | VerdictScalarWhereInput[]
    id?: StringFilter<"Verdict"> | string
    invoice_number?: StringFilter<"Verdict"> | string
    creditor_name?: StringFilter<"Verdict"> | string
    debtor_id?: StringFilter<"Verdict"> | string
    registration_number?: StringFilter<"Verdict"> | string
    sentence_amount?: FloatFilter<"Verdict"> | number
    sentence_date?: DateTimeFilter<"Verdict"> | Date | string
    status?: EnumVerdictStatusFilter<"Verdict"> | $Enums.VerdictStatus
    created_at?: DateTimeFilter<"Verdict"> | Date | string
    updated_at?: DateTimeFilter<"Verdict"> | Date | string
    procesal_cost?: FloatNullableFilter<"Verdict"> | number | null
    tenant_id?: StringFilter<"Verdict"> | string
    notes?: StringNullableFilter<"Verdict"> | string | null
    bailiff_id?: StringNullableFilter<"Verdict"> | string | null
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password_hash?: StringNullableFilter<"User"> | string | null
    fullname?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    tenant_id?: StringFilter<"User"> | string
    role?: EnumroleEnumFilter<"User"> | $Enums.roleEnum
    is_active?: BoolFilter<"User"> | boolean
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
  }

  export type ChatRoomUpsertWithWhereUniqueWithoutTenantInput = {
    where: ChatRoomWhereUniqueInput
    update: XOR<ChatRoomUpdateWithoutTenantInput, ChatRoomUncheckedUpdateWithoutTenantInput>
    create: XOR<ChatRoomCreateWithoutTenantInput, ChatRoomUncheckedCreateWithoutTenantInput>
  }

  export type ChatRoomUpdateWithWhereUniqueWithoutTenantInput = {
    where: ChatRoomWhereUniqueInput
    data: XOR<ChatRoomUpdateWithoutTenantInput, ChatRoomUncheckedUpdateWithoutTenantInput>
  }

  export type ChatRoomUpdateManyWithWhereWithoutTenantInput = {
    where: ChatRoomScalarWhereInput
    data: XOR<ChatRoomUpdateManyMutationInput, ChatRoomUncheckedUpdateManyWithoutTenantInput>
  }

  export type ChatRoomScalarWhereInput = {
    AND?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
    OR?: ChatRoomScalarWhereInput[]
    NOT?: ChatRoomScalarWhereInput | ChatRoomScalarWhereInput[]
    id?: StringFilter<"ChatRoom"> | string
    tenant_id?: StringFilter<"ChatRoom"> | string
    collection_case_id?: StringFilter<"ChatRoom"> | string
    name?: StringFilter<"ChatRoom"> | string
    created_at?: DateTimeFilter<"ChatRoom"> | Date | string
    updated_at?: DateTimeFilter<"ChatRoom"> | Date | string
  }

  export type CollectionCaseAgreementUpsertWithWhereUniqueWithoutTenantInput = {
    where: CollectionCaseAgreementWhereUniqueInput
    update: XOR<CollectionCaseAgreementUpdateWithoutTenantInput, CollectionCaseAgreementUncheckedUpdateWithoutTenantInput>
    create: XOR<CollectionCaseAgreementCreateWithoutTenantInput, CollectionCaseAgreementUncheckedCreateWithoutTenantInput>
  }

  export type CollectionCaseAgreementUpdateWithWhereUniqueWithoutTenantInput = {
    where: CollectionCaseAgreementWhereUniqueInput
    data: XOR<CollectionCaseAgreementUpdateWithoutTenantInput, CollectionCaseAgreementUncheckedUpdateWithoutTenantInput>
  }

  export type CollectionCaseAgreementUpdateManyWithWhereWithoutTenantInput = {
    where: CollectionCaseAgreementScalarWhereInput
    data: XOR<CollectionCaseAgreementUpdateManyMutationInput, CollectionCaseAgreementUncheckedUpdateManyWithoutTenantInput>
  }

  export type CollectionCaseAgreementScalarWhereInput = {
    AND?: CollectionCaseAgreementScalarWhereInput | CollectionCaseAgreementScalarWhereInput[]
    OR?: CollectionCaseAgreementScalarWhereInput[]
    NOT?: CollectionCaseAgreementScalarWhereInput | CollectionCaseAgreementScalarWhereInput[]
    id?: StringFilter<"CollectionCaseAgreement"> | string
    collection_case_id?: StringFilter<"CollectionCaseAgreement"> | string
    debtor_id?: StringNullableFilter<"CollectionCaseAgreement"> | string | null
    total_amount?: DecimalFilter<"CollectionCaseAgreement"> | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFilter<"CollectionCaseAgreement"> | Decimal | DecimalJsLike | number | string
    installments_count?: IntFilter<"CollectionCaseAgreement"> | number
    start_date?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
    end_date?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
    status?: EnumAgreementStatusFilter<"CollectionCaseAgreement"> | $Enums.AgreementStatus
    tenant_id?: StringFilter<"CollectionCaseAgreement"> | string
    comment?: StringNullableFilter<"CollectionCaseAgreement"> | string | null
    created_at?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCaseAgreement"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type DebtorCreateWithoutUserInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    payment_agreements?: CollectionCaseAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutUserInput = {
    id?: string
    tenant_id: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    payment_agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutUserInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput>
  }

  export type DebtorCreateManyUserInputEnvelope = {
    data: DebtorCreateManyUserInput | DebtorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VerdictCreateWithoutBailiffInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    notes?: string | null
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutBailiffInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    debtor_id: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    tenant_id: string
    notes?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutBailiffInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput>
  }

  export type VerdictCreateManyBailiffInputEnvelope = {
    data: VerdictCreateManyBailiffInput | VerdictCreateManyBailiffInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutSenderInput = {
    id?: string
    message: string
    file_url?: string | null
    file_name?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    room: ChatRoomCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    room_id: string
    message: string
    file_url?: string | null
    file_name?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageCreateManySenderInputEnvelope = {
    data: ChatMessageCreateManySenderInput | ChatMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DebtorUpsertWithWhereUniqueWithoutUserInput = {
    where: DebtorWhereUniqueInput
    update: XOR<DebtorUpdateWithoutUserInput, DebtorUncheckedUpdateWithoutUserInput>
    create: XOR<DebtorCreateWithoutUserInput, DebtorUncheckedCreateWithoutUserInput>
  }

  export type DebtorUpdateWithWhereUniqueWithoutUserInput = {
    where: DebtorWhereUniqueInput
    data: XOR<DebtorUpdateWithoutUserInput, DebtorUncheckedUpdateWithoutUserInput>
  }

  export type DebtorUpdateManyWithWhereWithoutUserInput = {
    where: DebtorScalarWhereInput
    data: XOR<DebtorUpdateManyMutationInput, DebtorUncheckedUpdateManyWithoutUserInput>
  }

  export type VerdictUpsertWithWhereUniqueWithoutBailiffInput = {
    where: VerdictWhereUniqueInput
    update: XOR<VerdictUpdateWithoutBailiffInput, VerdictUncheckedUpdateWithoutBailiffInput>
    create: XOR<VerdictCreateWithoutBailiffInput, VerdictUncheckedCreateWithoutBailiffInput>
  }

  export type VerdictUpdateWithWhereUniqueWithoutBailiffInput = {
    where: VerdictWhereUniqueInput
    data: XOR<VerdictUpdateWithoutBailiffInput, VerdictUncheckedUpdateWithoutBailiffInput>
  }

  export type VerdictUpdateManyWithWhereWithoutBailiffInput = {
    where: VerdictScalarWhereInput
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyWithoutBailiffInput>
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    room_id?: StringFilter<"ChatMessage"> | string
    sender_id?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    file_url?: StringNullableFilter<"ChatMessage"> | string | null
    file_name?: StringNullableFilter<"ChatMessage"> | string | null
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
    created_at?: DateTimeFilter<"ChatMessage"> | Date | string
    updated_at?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type UserCreateWithoutVerdict_bailiffsInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    debtors?: DebtorCreateNestedManyWithoutUserInput
    messages?: ChatMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutVerdict_bailiffsInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    tenant_id: string
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutVerdict_bailiffsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerdict_bailiffsInput, UserUncheckedCreateWithoutVerdict_bailiffsInput>
  }

  export type DebtorCreateWithoutVerdictsInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    payment_agreements?: CollectionCaseAgreementCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutVerdictsInput = {
    id?: string
    tenant_id: string
    user_id?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    payment_agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutVerdictsInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
  }

  export type TenantCreateWithoutVerdictsInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVerdictsInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVerdictsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
  }

  export type VerdictAttachmentCreateWithoutVerdictInput = {
    id?: string
    file_path: string
    file_size: bigint | number
    created_at?: Date | string
    updated_at?: Date | string
    file_name: string
  }

  export type VerdictAttachmentUncheckedCreateWithoutVerdictInput = {
    id?: string
    file_path: string
    file_size: bigint | number
    created_at?: Date | string
    updated_at?: Date | string
    file_name: string
  }

  export type VerdictAttachmentCreateOrConnectWithoutVerdictInput = {
    where: VerdictAttachmentWhereUniqueInput
    create: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictAttachmentCreateManyVerdictInputEnvelope = {
    data: VerdictAttachmentCreateManyVerdictInput | VerdictAttachmentCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type VerdictBailiffServicesCreateWithoutVerdictInput = {
    id?: string
    service_type: string
    service_cost: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictBailiffServicesUncheckedCreateWithoutVerdictInput = {
    id?: string
    service_type: string
    service_cost: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictBailiffServicesCreateOrConnectWithoutVerdictInput = {
    where: VerdictBailiffServicesWhereUniqueInput
    create: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictBailiffServicesCreateManyVerdictInputEnvelope = {
    data: VerdictBailiffServicesCreateManyVerdictInput | VerdictBailiffServicesCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type VerdictEmbargoCreateWithoutVerdictInput = {
    id?: string
    company_name: string
    company_phone: string
    company_email: string
    company_address: string
    embargo_type: string
    embargo_date: Date | string
    embargo_amount: number
    total_amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictEmbargoUncheckedCreateWithoutVerdictInput = {
    id?: string
    company_name: string
    company_phone: string
    company_email: string
    company_address: string
    embargo_type: string
    embargo_date: Date | string
    embargo_amount: number
    total_amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictEmbargoCreateOrConnectWithoutVerdictInput = {
    where: VerdictEmbargoWhereUniqueInput
    create: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictEmbargoCreateManyVerdictInputEnvelope = {
    data: VerdictEmbargoCreateManyVerdictInput | VerdictEmbargoCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type VerdictInterestCreateWithoutVerdictInput = {
    id?: string
    interest_type: number
    base_amount: number
    calculated_interest?: number | null
    calculation_start: Date | string
    calculation_end: Date | string
    total_interest: number
    created_at?: Date | string
    updated_at?: Date | string
    details?: VerdictInterestDetailsCreateNestedManyWithoutVerdict_interestInput
  }

  export type VerdictInterestUncheckedCreateWithoutVerdictInput = {
    id?: string
    interest_type: number
    base_amount: number
    calculated_interest?: number | null
    calculation_start: Date | string
    calculation_end: Date | string
    total_interest: number
    created_at?: Date | string
    updated_at?: Date | string
    details?: VerdictInterestDetailsUncheckedCreateNestedManyWithoutVerdict_interestInput
  }

  export type VerdictInterestCreateOrConnectWithoutVerdictInput = {
    where: VerdictInterestWhereUniqueInput
    create: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictInterestCreateManyVerdictInputEnvelope = {
    data: VerdictInterestCreateManyVerdictInput | VerdictInterestCreateManyVerdictInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutVerdict_bailiffsInput = {
    update: XOR<UserUpdateWithoutVerdict_bailiffsInput, UserUncheckedUpdateWithoutVerdict_bailiffsInput>
    create: XOR<UserCreateWithoutVerdict_bailiffsInput, UserUncheckedCreateWithoutVerdict_bailiffsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerdict_bailiffsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerdict_bailiffsInput, UserUncheckedUpdateWithoutVerdict_bailiffsInput>
  }

  export type UserUpdateWithoutVerdict_bailiffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    messages?: ChatMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutVerdict_bailiffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    messages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type DebtorUpsertWithoutVerdictsInput = {
    update: XOR<DebtorUpdateWithoutVerdictsInput, DebtorUncheckedUpdateWithoutVerdictsInput>
    create: XOR<DebtorCreateWithoutVerdictsInput, DebtorUncheckedCreateWithoutVerdictsInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutVerdictsInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutVerdictsInput, DebtorUncheckedUpdateWithoutVerdictsInput>
  }

  export type DebtorUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    payment_agreements?: CollectionCaseAgreementUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    payment_agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type TenantUpsertWithoutVerdictsInput = {
    update: XOR<TenantUpdateWithoutVerdictsInput, TenantUncheckedUpdateWithoutVerdictsInput>
    create: XOR<TenantCreateWithoutVerdictsInput, TenantUncheckedCreateWithoutVerdictsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVerdictsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVerdictsInput, TenantUncheckedUpdateWithoutVerdictsInput>
  }

  export type TenantUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVerdictsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type VerdictAttachmentUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictAttachmentWhereUniqueInput
    update: XOR<VerdictAttachmentUpdateWithoutVerdictInput, VerdictAttachmentUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictAttachmentCreateWithoutVerdictInput, VerdictAttachmentUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictAttachmentUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictAttachmentWhereUniqueInput
    data: XOR<VerdictAttachmentUpdateWithoutVerdictInput, VerdictAttachmentUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictAttachmentUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictAttachmentScalarWhereInput
    data: XOR<VerdictAttachmentUpdateManyMutationInput, VerdictAttachmentUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictAttachmentScalarWhereInput = {
    AND?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
    OR?: VerdictAttachmentScalarWhereInput[]
    NOT?: VerdictAttachmentScalarWhereInput | VerdictAttachmentScalarWhereInput[]
    id?: StringFilter<"VerdictAttachment"> | string
    verdict_id?: StringFilter<"VerdictAttachment"> | string
    file_path?: StringFilter<"VerdictAttachment"> | string
    file_size?: BigIntFilter<"VerdictAttachment"> | bigint | number
    created_at?: DateTimeFilter<"VerdictAttachment"> | Date | string
    updated_at?: DateTimeFilter<"VerdictAttachment"> | Date | string
    file_name?: StringFilter<"VerdictAttachment"> | string
  }

  export type VerdictBailiffServicesUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictBailiffServicesWhereUniqueInput
    update: XOR<VerdictBailiffServicesUpdateWithoutVerdictInput, VerdictBailiffServicesUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictBailiffServicesCreateWithoutVerdictInput, VerdictBailiffServicesUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictBailiffServicesUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictBailiffServicesWhereUniqueInput
    data: XOR<VerdictBailiffServicesUpdateWithoutVerdictInput, VerdictBailiffServicesUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictBailiffServicesUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictBailiffServicesScalarWhereInput
    data: XOR<VerdictBailiffServicesUpdateManyMutationInput, VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictBailiffServicesScalarWhereInput = {
    AND?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
    OR?: VerdictBailiffServicesScalarWhereInput[]
    NOT?: VerdictBailiffServicesScalarWhereInput | VerdictBailiffServicesScalarWhereInput[]
    id?: StringFilter<"VerdictBailiffServices"> | string
    verdict_id?: StringFilter<"VerdictBailiffServices"> | string
    service_type?: StringFilter<"VerdictBailiffServices"> | string
    service_cost?: FloatFilter<"VerdictBailiffServices"> | number
    created_at?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
    updated_at?: DateTimeFilter<"VerdictBailiffServices"> | Date | string
  }

  export type VerdictEmbargoUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictEmbargoWhereUniqueInput
    update: XOR<VerdictEmbargoUpdateWithoutVerdictInput, VerdictEmbargoUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictEmbargoCreateWithoutVerdictInput, VerdictEmbargoUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictEmbargoUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictEmbargoWhereUniqueInput
    data: XOR<VerdictEmbargoUpdateWithoutVerdictInput, VerdictEmbargoUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictEmbargoUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictEmbargoScalarWhereInput
    data: XOR<VerdictEmbargoUpdateManyMutationInput, VerdictEmbargoUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictEmbargoScalarWhereInput = {
    AND?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
    OR?: VerdictEmbargoScalarWhereInput[]
    NOT?: VerdictEmbargoScalarWhereInput | VerdictEmbargoScalarWhereInput[]
    id?: StringFilter<"VerdictEmbargo"> | string
    verdict_id?: StringFilter<"VerdictEmbargo"> | string
    company_name?: StringFilter<"VerdictEmbargo"> | string
    company_phone?: StringFilter<"VerdictEmbargo"> | string
    company_email?: StringFilter<"VerdictEmbargo"> | string
    company_address?: StringFilter<"VerdictEmbargo"> | string
    embargo_type?: StringFilter<"VerdictEmbargo"> | string
    embargo_date?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    embargo_amount?: FloatFilter<"VerdictEmbargo"> | number
    total_amount?: FloatFilter<"VerdictEmbargo"> | number
    created_at?: DateTimeFilter<"VerdictEmbargo"> | Date | string
    updated_at?: DateTimeFilter<"VerdictEmbargo"> | Date | string
  }

  export type VerdictInterestUpsertWithWhereUniqueWithoutVerdictInput = {
    where: VerdictInterestWhereUniqueInput
    update: XOR<VerdictInterestUpdateWithoutVerdictInput, VerdictInterestUncheckedUpdateWithoutVerdictInput>
    create: XOR<VerdictInterestCreateWithoutVerdictInput, VerdictInterestUncheckedCreateWithoutVerdictInput>
  }

  export type VerdictInterestUpdateWithWhereUniqueWithoutVerdictInput = {
    where: VerdictInterestWhereUniqueInput
    data: XOR<VerdictInterestUpdateWithoutVerdictInput, VerdictInterestUncheckedUpdateWithoutVerdictInput>
  }

  export type VerdictInterestUpdateManyWithWhereWithoutVerdictInput = {
    where: VerdictInterestScalarWhereInput
    data: XOR<VerdictInterestUpdateManyMutationInput, VerdictInterestUncheckedUpdateManyWithoutVerdictInput>
  }

  export type VerdictInterestScalarWhereInput = {
    AND?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
    OR?: VerdictInterestScalarWhereInput[]
    NOT?: VerdictInterestScalarWhereInput | VerdictInterestScalarWhereInput[]
    id?: StringFilter<"VerdictInterest"> | string
    interest_type?: IntFilter<"VerdictInterest"> | number
    base_amount?: FloatFilter<"VerdictInterest"> | number
    calculated_interest?: FloatNullableFilter<"VerdictInterest"> | number | null
    calculation_start?: DateTimeFilter<"VerdictInterest"> | Date | string
    calculation_end?: DateTimeFilter<"VerdictInterest"> | Date | string
    total_interest?: FloatFilter<"VerdictInterest"> | number
    created_at?: DateTimeFilter<"VerdictInterest"> | Date | string
    updated_at?: DateTimeFilter<"VerdictInterest"> | Date | string
    verdict_id?: StringNullableFilter<"VerdictInterest"> | string | null
  }

  export type VerdictCreateWithoutVerdict_interestInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdict_bailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutVerdict_interestInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    debtor_id: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    tenant_id: string
    notes?: string | null
    bailiff_id?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutVerdict_interestInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutVerdict_interestInput, VerdictUncheckedCreateWithoutVerdict_interestInput>
  }

  export type VerdictInterestDetailsCreateWithoutVerdict_interestInput = {
    id?: string
    period: string
    period_start: Date | string
    period_end: Date | string
    days: number
    annual_rate: number
    proportional_rate: number
    base_amount: number
    interest: number
    total: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictInterestDetailsUncheckedCreateWithoutVerdict_interestInput = {
    id?: string
    period: string
    period_start: Date | string
    period_end: Date | string
    days: number
    annual_rate: number
    proportional_rate: number
    base_amount: number
    interest: number
    total: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictInterestDetailsCreateOrConnectWithoutVerdict_interestInput = {
    where: VerdictInterestDetailsWhereUniqueInput
    create: XOR<VerdictInterestDetailsCreateWithoutVerdict_interestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdict_interestInput>
  }

  export type VerdictInterestDetailsCreateManyVerdict_interestInputEnvelope = {
    data: VerdictInterestDetailsCreateManyVerdict_interestInput | VerdictInterestDetailsCreateManyVerdict_interestInput[]
    skipDuplicates?: boolean
  }

  export type VerdictUpsertWithoutVerdict_interestInput = {
    update: XOR<VerdictUpdateWithoutVerdict_interestInput, VerdictUncheckedUpdateWithoutVerdict_interestInput>
    create: XOR<VerdictCreateWithoutVerdict_interestInput, VerdictUncheckedCreateWithoutVerdict_interestInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutVerdict_interestInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutVerdict_interestInput, VerdictUncheckedUpdateWithoutVerdict_interestInput>
  }

  export type VerdictUpdateWithoutVerdict_interestInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdict_bailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutVerdict_interestInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff_id?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictInterestDetailsUpsertWithWhereUniqueWithoutVerdict_interestInput = {
    where: VerdictInterestDetailsWhereUniqueInput
    update: XOR<VerdictInterestDetailsUpdateWithoutVerdict_interestInput, VerdictInterestDetailsUncheckedUpdateWithoutVerdict_interestInput>
    create: XOR<VerdictInterestDetailsCreateWithoutVerdict_interestInput, VerdictInterestDetailsUncheckedCreateWithoutVerdict_interestInput>
  }

  export type VerdictInterestDetailsUpdateWithWhereUniqueWithoutVerdict_interestInput = {
    where: VerdictInterestDetailsWhereUniqueInput
    data: XOR<VerdictInterestDetailsUpdateWithoutVerdict_interestInput, VerdictInterestDetailsUncheckedUpdateWithoutVerdict_interestInput>
  }

  export type VerdictInterestDetailsUpdateManyWithWhereWithoutVerdict_interestInput = {
    where: VerdictInterestDetailsScalarWhereInput
    data: XOR<VerdictInterestDetailsUpdateManyMutationInput, VerdictInterestDetailsUncheckedUpdateManyWithoutVerdict_interestInput>
  }

  export type VerdictInterestDetailsScalarWhereInput = {
    AND?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
    OR?: VerdictInterestDetailsScalarWhereInput[]
    NOT?: VerdictInterestDetailsScalarWhereInput | VerdictInterestDetailsScalarWhereInput[]
    id?: StringFilter<"VerdictInterestDetails"> | string
    period?: StringFilter<"VerdictInterestDetails"> | string
    period_start?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    period_end?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    days?: IntFilter<"VerdictInterestDetails"> | number
    annual_rate?: FloatFilter<"VerdictInterestDetails"> | number
    proportional_rate?: FloatFilter<"VerdictInterestDetails"> | number
    base_amount?: FloatFilter<"VerdictInterestDetails"> | number
    interest?: FloatFilter<"VerdictInterestDetails"> | number
    total?: FloatFilter<"VerdictInterestDetails"> | number
    verdict_interest_id?: StringFilter<"VerdictInterestDetails"> | string
    created_at?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
    updated_at?: DateTimeFilter<"VerdictInterestDetails"> | Date | string
  }

  export type VerdictInterestCreateWithoutDetailsInput = {
    id?: string
    interest_type: number
    base_amount: number
    calculated_interest?: number | null
    calculation_start: Date | string
    calculation_end: Date | string
    total_interest: number
    created_at?: Date | string
    updated_at?: Date | string
    verdict?: VerdictCreateNestedOneWithoutVerdict_interestInput
  }

  export type VerdictInterestUncheckedCreateWithoutDetailsInput = {
    id?: string
    interest_type: number
    base_amount: number
    calculated_interest?: number | null
    calculation_start: Date | string
    calculation_end: Date | string
    total_interest: number
    created_at?: Date | string
    updated_at?: Date | string
    verdict_id?: string | null
  }

  export type VerdictInterestCreateOrConnectWithoutDetailsInput = {
    where: VerdictInterestWhereUniqueInput
    create: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
  }

  export type VerdictInterestUpsertWithoutDetailsInput = {
    update: XOR<VerdictInterestUpdateWithoutDetailsInput, VerdictInterestUncheckedUpdateWithoutDetailsInput>
    create: XOR<VerdictInterestCreateWithoutDetailsInput, VerdictInterestUncheckedCreateWithoutDetailsInput>
    where?: VerdictInterestWhereInput
  }

  export type VerdictInterestUpdateToOneWithWhereWithoutDetailsInput = {
    where?: VerdictInterestWhereInput
    data: XOR<VerdictInterestUpdateWithoutDetailsInput, VerdictInterestUncheckedUpdateWithoutDetailsInput>
  }

  export type VerdictInterestUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest_type?: IntFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    calculated_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculation_start?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_end?: DateTimeFieldUpdateOperationsInput | Date | string
    total_interest?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict?: VerdictUpdateOneWithoutVerdict_interestNestedInput
  }

  export type VerdictInterestUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest_type?: IntFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    calculated_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculation_start?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_end?: DateTimeFieldUpdateOperationsInput | Date | string
    total_interest?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerdictCreateWithoutVerdict_embargoInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdict_bailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutVerdict_embargoInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    debtor_id: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    tenant_id: string
    notes?: string | null
    bailiff_id?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutVerdict_embargoInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutVerdict_embargoInput, VerdictUncheckedCreateWithoutVerdict_embargoInput>
  }

  export type VerdictUpsertWithoutVerdict_embargoInput = {
    update: XOR<VerdictUpdateWithoutVerdict_embargoInput, VerdictUncheckedUpdateWithoutVerdict_embargoInput>
    create: XOR<VerdictCreateWithoutVerdict_embargoInput, VerdictUncheckedCreateWithoutVerdict_embargoInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutVerdict_embargoInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutVerdict_embargoInput, VerdictUncheckedUpdateWithoutVerdict_embargoInput>
  }

  export type VerdictUpdateWithoutVerdict_embargoInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdict_bailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutVerdict_embargoInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff_id?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictCreateWithoutBailiff_servicesInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdict_bailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutBailiff_servicesInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    debtor_id: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    tenant_id: string
    notes?: string | null
    bailiff_id?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutBailiff_servicesInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutBailiff_servicesInput, VerdictUncheckedCreateWithoutBailiff_servicesInput>
  }

  export type VerdictUpsertWithoutBailiff_servicesInput = {
    update: XOR<VerdictUpdateWithoutBailiff_servicesInput, VerdictUncheckedUpdateWithoutBailiff_servicesInput>
    create: XOR<VerdictCreateWithoutBailiff_servicesInput, VerdictUncheckedCreateWithoutBailiff_servicesInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutBailiff_servicesInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutBailiff_servicesInput, VerdictUncheckedUpdateWithoutBailiff_servicesInput>
  }

  export type VerdictUpdateWithoutBailiff_servicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdict_bailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutBailiff_servicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff_id?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictCreateWithoutAttachmentsInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdict_bailiffsInput
    debtor: DebtorCreateNestedOneWithoutVerdictsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    bailiff_services?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    debtor_id: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    tenant_id: string
    notes?: string | null
    bailiff_id?: string | null
    bailiff_services?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutAttachmentsInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
  }

  export type VerdictUpsertWithoutAttachmentsInput = {
    update: XOR<VerdictUpdateWithoutAttachmentsInput, VerdictUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<VerdictCreateWithoutAttachmentsInput, VerdictUncheckedCreateWithoutAttachmentsInput>
    where?: VerdictWhereInput
  }

  export type VerdictUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: VerdictWhereInput
    data: XOR<VerdictUpdateWithoutAttachmentsInput, VerdictUncheckedUpdateWithoutAttachmentsInput>
  }

  export type VerdictUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdict_bailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    bailiff_services?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff_id?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff_services?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type InterestDetailCreateWithoutInterest_typeInput = {
    date: string
    rate: number
  }

  export type InterestDetailUncheckedCreateWithoutInterest_typeInput = {
    id?: number
    date: string
    rate: number
  }

  export type InterestDetailCreateOrConnectWithoutInterest_typeInput = {
    where: InterestDetailWhereUniqueInput
    create: XOR<InterestDetailCreateWithoutInterest_typeInput, InterestDetailUncheckedCreateWithoutInterest_typeInput>
  }

  export type InterestDetailCreateManyInterest_typeInputEnvelope = {
    data: InterestDetailCreateManyInterest_typeInput | InterestDetailCreateManyInterest_typeInput[]
    skipDuplicates?: boolean
  }

  export type InterestDetailUpsertWithWhereUniqueWithoutInterest_typeInput = {
    where: InterestDetailWhereUniqueInput
    update: XOR<InterestDetailUpdateWithoutInterest_typeInput, InterestDetailUncheckedUpdateWithoutInterest_typeInput>
    create: XOR<InterestDetailCreateWithoutInterest_typeInput, InterestDetailUncheckedCreateWithoutInterest_typeInput>
  }

  export type InterestDetailUpdateWithWhereUniqueWithoutInterest_typeInput = {
    where: InterestDetailWhereUniqueInput
    data: XOR<InterestDetailUpdateWithoutInterest_typeInput, InterestDetailUncheckedUpdateWithoutInterest_typeInput>
  }

  export type InterestDetailUpdateManyWithWhereWithoutInterest_typeInput = {
    where: InterestDetailScalarWhereInput
    data: XOR<InterestDetailUpdateManyMutationInput, InterestDetailUncheckedUpdateManyWithoutInterest_typeInput>
  }

  export type InterestDetailScalarWhereInput = {
    AND?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
    OR?: InterestDetailScalarWhereInput[]
    NOT?: InterestDetailScalarWhereInput | InterestDetailScalarWhereInput[]
    id?: IntFilter<"InterestDetail"> | number
    date?: StringFilter<"InterestDetail"> | string
    rate?: FloatFilter<"InterestDetail"> | number
    interest_type_id?: IntFilter<"InterestDetail"> | number
  }

  export type InterestTypeCreateWithoutDetailsInput = {
    name: string
    calculation_type: $Enums.CalculationTypeEnum
  }

  export type InterestTypeUncheckedCreateWithoutDetailsInput = {
    id?: number
    name: string
    calculation_type: $Enums.CalculationTypeEnum
  }

  export type InterestTypeCreateOrConnectWithoutDetailsInput = {
    where: InterestTypeWhereUniqueInput
    create: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
  }

  export type InterestTypeUpsertWithoutDetailsInput = {
    update: XOR<InterestTypeUpdateWithoutDetailsInput, InterestTypeUncheckedUpdateWithoutDetailsInput>
    create: XOR<InterestTypeCreateWithoutDetailsInput, InterestTypeUncheckedCreateWithoutDetailsInput>
    where?: InterestTypeWhereInput
  }

  export type InterestTypeUpdateToOneWithWhereWithoutDetailsInput = {
    where?: InterestTypeWhereInput
    data: XOR<InterestTypeUpdateWithoutDetailsInput, InterestTypeUncheckedUpdateWithoutDetailsInput>
  }

  export type InterestTypeUpdateWithoutDetailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    calculation_type?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type InterestTypeUncheckedUpdateWithoutDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calculation_type?: EnumCalculationTypeEnumFieldUpdateOperationsInput | $Enums.CalculationTypeEnum
  }

  export type TenantCreateWithoutBilling_invoiceInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBilling_invoiceInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBilling_invoiceInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBilling_invoiceInput, TenantUncheckedCreateWithoutBilling_invoiceInput>
  }

  export type BillingInvoiceDetailCreateWithoutBilling_invoiceInput = {
    id?: string
    item_description: string
    item_quantity: number
    item_unit_price: number
    item_total_price: number
    item_tax_rate: number
    item_tax_amount: number
    item_total_with_tax: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BillingInvoiceDetailUncheckedCreateWithoutBilling_invoiceInput = {
    id?: string
    item_description: string
    item_quantity: number
    item_unit_price: number
    item_total_price: number
    item_tax_rate: number
    item_tax_amount: number
    item_total_with_tax: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BillingInvoiceDetailCreateOrConnectWithoutBilling_invoiceInput = {
    where: BillingInvoiceDetailWhereUniqueInput
    create: XOR<BillingInvoiceDetailCreateWithoutBilling_invoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBilling_invoiceInput>
  }

  export type BillingInvoiceDetailCreateManyBilling_invoiceInputEnvelope = {
    data: BillingInvoiceDetailCreateManyBilling_invoiceInput | BillingInvoiceDetailCreateManyBilling_invoiceInput[]
    skipDuplicates?: boolean
  }

  export type BillingPaymentCreateWithoutBilling_invoiceInput = {
    id?: string
    payment_date: Date | string
    amount: number
    payment_method: string
    transaction_id?: string | null
    status: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BillingPaymentUncheckedCreateWithoutBilling_invoiceInput = {
    id?: string
    payment_date: Date | string
    amount: number
    payment_method: string
    transaction_id?: string | null
    status: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BillingPaymentCreateOrConnectWithoutBilling_invoiceInput = {
    where: BillingPaymentWhereUniqueInput
    create: XOR<BillingPaymentCreateWithoutBilling_invoiceInput, BillingPaymentUncheckedCreateWithoutBilling_invoiceInput>
  }

  export type BillingPaymentCreateManyBilling_invoiceInputEnvelope = {
    data: BillingPaymentCreateManyBilling_invoiceInput | BillingPaymentCreateManyBilling_invoiceInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutBilling_invoiceInput = {
    update: XOR<TenantUpdateWithoutBilling_invoiceInput, TenantUncheckedUpdateWithoutBilling_invoiceInput>
    create: XOR<TenantCreateWithoutBilling_invoiceInput, TenantUncheckedCreateWithoutBilling_invoiceInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBilling_invoiceInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBilling_invoiceInput, TenantUncheckedUpdateWithoutBilling_invoiceInput>
  }

  export type TenantUpdateWithoutBilling_invoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBilling_invoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BillingInvoiceDetailUpsertWithWhereUniqueWithoutBilling_invoiceInput = {
    where: BillingInvoiceDetailWhereUniqueInput
    update: XOR<BillingInvoiceDetailUpdateWithoutBilling_invoiceInput, BillingInvoiceDetailUncheckedUpdateWithoutBilling_invoiceInput>
    create: XOR<BillingInvoiceDetailCreateWithoutBilling_invoiceInput, BillingInvoiceDetailUncheckedCreateWithoutBilling_invoiceInput>
  }

  export type BillingInvoiceDetailUpdateWithWhereUniqueWithoutBilling_invoiceInput = {
    where: BillingInvoiceDetailWhereUniqueInput
    data: XOR<BillingInvoiceDetailUpdateWithoutBilling_invoiceInput, BillingInvoiceDetailUncheckedUpdateWithoutBilling_invoiceInput>
  }

  export type BillingInvoiceDetailUpdateManyWithWhereWithoutBilling_invoiceInput = {
    where: BillingInvoiceDetailScalarWhereInput
    data: XOR<BillingInvoiceDetailUpdateManyMutationInput, BillingInvoiceDetailUncheckedUpdateManyWithoutBilling_invoiceInput>
  }

  export type BillingInvoiceDetailScalarWhereInput = {
    AND?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
    OR?: BillingInvoiceDetailScalarWhereInput[]
    NOT?: BillingInvoiceDetailScalarWhereInput | BillingInvoiceDetailScalarWhereInput[]
    id?: StringFilter<"BillingInvoiceDetail"> | string
    item_description?: StringFilter<"BillingInvoiceDetail"> | string
    item_quantity?: IntFilter<"BillingInvoiceDetail"> | number
    item_unit_price?: FloatFilter<"BillingInvoiceDetail"> | number
    item_total_price?: FloatFilter<"BillingInvoiceDetail"> | number
    item_tax_rate?: FloatFilter<"BillingInvoiceDetail"> | number
    item_tax_amount?: FloatFilter<"BillingInvoiceDetail"> | number
    item_total_with_tax?: FloatFilter<"BillingInvoiceDetail"> | number
    created_at?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    updated_at?: DateTimeFilter<"BillingInvoiceDetail"> | Date | string
    billing_invoice_id?: StringNullableFilter<"BillingInvoiceDetail"> | string | null
  }

  export type BillingPaymentUpsertWithWhereUniqueWithoutBilling_invoiceInput = {
    where: BillingPaymentWhereUniqueInput
    update: XOR<BillingPaymentUpdateWithoutBilling_invoiceInput, BillingPaymentUncheckedUpdateWithoutBilling_invoiceInput>
    create: XOR<BillingPaymentCreateWithoutBilling_invoiceInput, BillingPaymentUncheckedCreateWithoutBilling_invoiceInput>
  }

  export type BillingPaymentUpdateWithWhereUniqueWithoutBilling_invoiceInput = {
    where: BillingPaymentWhereUniqueInput
    data: XOR<BillingPaymentUpdateWithoutBilling_invoiceInput, BillingPaymentUncheckedUpdateWithoutBilling_invoiceInput>
  }

  export type BillingPaymentUpdateManyWithWhereWithoutBilling_invoiceInput = {
    where: BillingPaymentScalarWhereInput
    data: XOR<BillingPaymentUpdateManyMutationInput, BillingPaymentUncheckedUpdateManyWithoutBilling_invoiceInput>
  }

  export type BillingPaymentScalarWhereInput = {
    AND?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
    OR?: BillingPaymentScalarWhereInput[]
    NOT?: BillingPaymentScalarWhereInput | BillingPaymentScalarWhereInput[]
    id?: StringFilter<"BillingPayment"> | string
    payment_date?: DateTimeFilter<"BillingPayment"> | Date | string
    amount?: FloatFilter<"BillingPayment"> | number
    payment_method?: StringFilter<"BillingPayment"> | string
    transaction_id?: StringNullableFilter<"BillingPayment"> | string | null
    status?: StringFilter<"BillingPayment"> | string
    created_at?: DateTimeFilter<"BillingPayment"> | Date | string
    updated_at?: DateTimeFilter<"BillingPayment"> | Date | string
    billing_invoice_id?: StringNullableFilter<"BillingPayment"> | string | null
  }

  export type BillingInvoiceCreateWithoutDetailsInput = {
    id?: string
    invoice_number: string
    amount: number
    currency?: string
    issue_date: Date | string
    due_date: Date | string
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutBilling_invoiceInput
    payments?: BillingPaymentCreateNestedManyWithoutBilling_invoiceInput
  }

  export type BillingInvoiceUncheckedCreateWithoutDetailsInput = {
    id?: string
    tenant_id: string
    invoice_number: string
    amount: number
    currency?: string
    issue_date: Date | string
    due_date: Date | string
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    payments?: BillingPaymentUncheckedCreateNestedManyWithoutBilling_invoiceInput
  }

  export type BillingInvoiceCreateOrConnectWithoutDetailsInput = {
    where: BillingInvoiceWhereUniqueInput
    create: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
  }

  export type BillingInvoiceUpsertWithoutDetailsInput = {
    update: XOR<BillingInvoiceUpdateWithoutDetailsInput, BillingInvoiceUncheckedUpdateWithoutDetailsInput>
    create: XOR<BillingInvoiceCreateWithoutDetailsInput, BillingInvoiceUncheckedCreateWithoutDetailsInput>
    where?: BillingInvoiceWhereInput
  }

  export type BillingInvoiceUpdateToOneWithWhereWithoutDetailsInput = {
    where?: BillingInvoiceWhereInput
    data: XOR<BillingInvoiceUpdateWithoutDetailsInput, BillingInvoiceUncheckedUpdateWithoutDetailsInput>
  }

  export type BillingInvoiceUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBilling_invoiceNestedInput
    payments?: BillingPaymentUpdateManyWithoutBilling_invoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: BillingPaymentUncheckedUpdateManyWithoutBilling_invoiceNestedInput
  }

  export type BillingInvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoice_number: string
    amount: number
    currency?: string
    issue_date: Date | string
    due_date: Date | string
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutBilling_invoiceInput
    details?: BillingInvoiceDetailCreateNestedManyWithoutBilling_invoiceInput
  }

  export type BillingInvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenant_id: string
    invoice_number: string
    amount: number
    currency?: string
    issue_date: Date | string
    due_date: Date | string
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    details?: BillingInvoiceDetailUncheckedCreateNestedManyWithoutBilling_invoiceInput
  }

  export type BillingInvoiceCreateOrConnectWithoutPaymentsInput = {
    where: BillingInvoiceWhereUniqueInput
    create: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type BillingInvoiceUpsertWithoutPaymentsInput = {
    update: XOR<BillingInvoiceUpdateWithoutPaymentsInput, BillingInvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BillingInvoiceCreateWithoutPaymentsInput, BillingInvoiceUncheckedCreateWithoutPaymentsInput>
    where?: BillingInvoiceWhereInput
  }

  export type BillingInvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BillingInvoiceWhereInput
    data: XOR<BillingInvoiceUpdateWithoutPaymentsInput, BillingInvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type BillingInvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBilling_invoiceNestedInput
    details?: BillingInvoiceDetailUpdateManyWithoutBilling_invoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUncheckedUpdateManyWithoutBilling_invoiceNestedInput
  }

  export type DebtorCreateWithoutCollection_casesInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    payment_agreements?: CollectionCaseAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutCollection_casesInput = {
    id?: string
    tenant_id: string
    user_id?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    payment_agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutCollection_casesInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutCollection_casesInput, DebtorUncheckedCreateWithoutCollection_casesInput>
  }

  export type TenantCreateWithoutCollection_casesInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCollection_casesInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCollection_casesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCollection_casesInput, TenantUncheckedCreateWithoutCollection_casesInput>
  }

  export type CollectionCaseNotificationCreateWithoutCollection_caseInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sent_at?: Date | string
    read?: boolean
    created_at?: Date | string
  }

  export type CollectionCaseNotificationUncheckedCreateWithoutCollection_caseInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sent_at?: Date | string
    read?: boolean
    created_at?: Date | string
  }

  export type CollectionCaseNotificationCreateOrConnectWithoutCollection_caseInput = {
    where: CollectionCaseNotificationWhereUniqueInput
    create: XOR<CollectionCaseNotificationCreateWithoutCollection_caseInput, CollectionCaseNotificationUncheckedCreateWithoutCollection_caseInput>
  }

  export type CollectionCaseNotificationCreateManyCollection_caseInputEnvelope = {
    data: CollectionCaseNotificationCreateManyCollection_caseInput | CollectionCaseNotificationCreateManyCollection_caseInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCasePaymentCreateWithoutCollection_caseInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    payment_date: Date | string
    reference_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    agreement?: CollectionCaseAgreementCreateNestedOneWithoutPaymentsInput
    installments?: CollectionCaseAgreementInstallmentCreateNestedManyWithoutPaymentInput
  }

  export type CollectionCasePaymentUncheckedCreateWithoutCollection_caseInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    payment_date: Date | string
    reference_number?: string | null
    agreement_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type CollectionCasePaymentCreateOrConnectWithoutCollection_caseInput = {
    where: CollectionCasePaymentWhereUniqueInput
    create: XOR<CollectionCasePaymentCreateWithoutCollection_caseInput, CollectionCasePaymentUncheckedCreateWithoutCollection_caseInput>
  }

  export type CollectionCasePaymentCreateManyCollection_caseInputEnvelope = {
    data: CollectionCasePaymentCreateManyCollection_caseInput | CollectionCasePaymentCreateManyCollection_caseInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCaseAgreementCreateWithoutCollection_caseInput = {
    id?: string
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutAgreementsInput
    debtor?: DebtorCreateNestedOneWithoutPayment_agreementsInput
    installments?: CollectionCaseAgreementInstallmentCreateNestedManyWithoutAgreementInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementUncheckedCreateWithoutCollection_caseInput = {
    id?: string
    debtor_id?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    tenant_id: string
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedCreateNestedManyWithoutAgreementInput
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementCreateOrConnectWithoutCollection_caseInput = {
    where: CollectionCaseAgreementWhereUniqueInput
    create: XOR<CollectionCaseAgreementCreateWithoutCollection_caseInput, CollectionCaseAgreementUncheckedCreateWithoutCollection_caseInput>
  }

  export type CollectionCaseAgreementCreateManyCollection_caseInputEnvelope = {
    data: CollectionCaseAgreementCreateManyCollection_caseInput | CollectionCaseAgreementCreateManyCollection_caseInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCasePenaltyCreateWithoutCollection_caseInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    date_applied?: Date | string
    is_paid?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCasePenaltyUncheckedCreateWithoutCollection_caseInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    date_applied?: Date | string
    is_paid?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCasePenaltyCreateOrConnectWithoutCollection_caseInput = {
    where: CollectionCasePenaltyWhereUniqueInput
    create: XOR<CollectionCasePenaltyCreateWithoutCollection_caseInput, CollectionCasePenaltyUncheckedCreateWithoutCollection_caseInput>
  }

  export type CollectionCasePenaltyCreateManyCollection_caseInputEnvelope = {
    data: CollectionCasePenaltyCreateManyCollection_caseInput | CollectionCasePenaltyCreateManyCollection_caseInput[]
    skipDuplicates?: boolean
  }

  export type ChatRoomCreateWithoutCollection_caseInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutChat_roomsInput
    messages?: ChatMessageCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomUncheckedCreateWithoutCollection_caseInput = {
    id?: string
    tenant_id: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutRoomInput
  }

  export type ChatRoomCreateOrConnectWithoutCollection_caseInput = {
    where: ChatRoomWhereUniqueInput
    create: XOR<ChatRoomCreateWithoutCollection_caseInput, ChatRoomUncheckedCreateWithoutCollection_caseInput>
  }

  export type ChatRoomCreateManyCollection_caseInputEnvelope = {
    data: ChatRoomCreateManyCollection_caseInput | ChatRoomCreateManyCollection_caseInput[]
    skipDuplicates?: boolean
  }

  export type DebtorUpsertWithoutCollection_casesInput = {
    update: XOR<DebtorUpdateWithoutCollection_casesInput, DebtorUncheckedUpdateWithoutCollection_casesInput>
    create: XOR<DebtorCreateWithoutCollection_casesInput, DebtorUncheckedCreateWithoutCollection_casesInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutCollection_casesInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutCollection_casesInput, DebtorUncheckedUpdateWithoutCollection_casesInput>
  }

  export type DebtorUpdateWithoutCollection_casesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    payment_agreements?: CollectionCaseAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutCollection_casesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    payment_agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type TenantUpsertWithoutCollection_casesInput = {
    update: XOR<TenantUpdateWithoutCollection_casesInput, TenantUncheckedUpdateWithoutCollection_casesInput>
    create: XOR<TenantCreateWithoutCollection_casesInput, TenantUncheckedCreateWithoutCollection_casesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCollection_casesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCollection_casesInput, TenantUncheckedUpdateWithoutCollection_casesInput>
  }

  export type TenantUpdateWithoutCollection_casesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCollection_casesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CollectionCaseNotificationUpsertWithWhereUniqueWithoutCollection_caseInput = {
    where: CollectionCaseNotificationWhereUniqueInput
    update: XOR<CollectionCaseNotificationUpdateWithoutCollection_caseInput, CollectionCaseNotificationUncheckedUpdateWithoutCollection_caseInput>
    create: XOR<CollectionCaseNotificationCreateWithoutCollection_caseInput, CollectionCaseNotificationUncheckedCreateWithoutCollection_caseInput>
  }

  export type CollectionCaseNotificationUpdateWithWhereUniqueWithoutCollection_caseInput = {
    where: CollectionCaseNotificationWhereUniqueInput
    data: XOR<CollectionCaseNotificationUpdateWithoutCollection_caseInput, CollectionCaseNotificationUncheckedUpdateWithoutCollection_caseInput>
  }

  export type CollectionCaseNotificationUpdateManyWithWhereWithoutCollection_caseInput = {
    where: CollectionCaseNotificationScalarWhereInput
    data: XOR<CollectionCaseNotificationUpdateManyMutationInput, CollectionCaseNotificationUncheckedUpdateManyWithoutCollection_caseInput>
  }

  export type CollectionCaseNotificationScalarWhereInput = {
    AND?: CollectionCaseNotificationScalarWhereInput | CollectionCaseNotificationScalarWhereInput[]
    OR?: CollectionCaseNotificationScalarWhereInput[]
    NOT?: CollectionCaseNotificationScalarWhereInput | CollectionCaseNotificationScalarWhereInput[]
    id?: StringFilter<"CollectionCaseNotification"> | string
    collection_case_id?: StringFilter<"CollectionCaseNotification"> | string
    type?: EnumNotificationTypeFilter<"CollectionCaseNotification"> | $Enums.NotificationType
    title?: StringFilter<"CollectionCaseNotification"> | string
    message?: StringFilter<"CollectionCaseNotification"> | string
    sent_at?: DateTimeFilter<"CollectionCaseNotification"> | Date | string
    read?: BoolFilter<"CollectionCaseNotification"> | boolean
    created_at?: DateTimeFilter<"CollectionCaseNotification"> | Date | string
  }

  export type CollectionCasePaymentUpsertWithWhereUniqueWithoutCollection_caseInput = {
    where: CollectionCasePaymentWhereUniqueInput
    update: XOR<CollectionCasePaymentUpdateWithoutCollection_caseInput, CollectionCasePaymentUncheckedUpdateWithoutCollection_caseInput>
    create: XOR<CollectionCasePaymentCreateWithoutCollection_caseInput, CollectionCasePaymentUncheckedCreateWithoutCollection_caseInput>
  }

  export type CollectionCasePaymentUpdateWithWhereUniqueWithoutCollection_caseInput = {
    where: CollectionCasePaymentWhereUniqueInput
    data: XOR<CollectionCasePaymentUpdateWithoutCollection_caseInput, CollectionCasePaymentUncheckedUpdateWithoutCollection_caseInput>
  }

  export type CollectionCasePaymentUpdateManyWithWhereWithoutCollection_caseInput = {
    where: CollectionCasePaymentScalarWhereInput
    data: XOR<CollectionCasePaymentUpdateManyMutationInput, CollectionCasePaymentUncheckedUpdateManyWithoutCollection_caseInput>
  }

  export type CollectionCasePaymentScalarWhereInput = {
    AND?: CollectionCasePaymentScalarWhereInput | CollectionCasePaymentScalarWhereInput[]
    OR?: CollectionCasePaymentScalarWhereInput[]
    NOT?: CollectionCasePaymentScalarWhereInput | CollectionCasePaymentScalarWhereInput[]
    id?: StringFilter<"CollectionCasePayment"> | string
    method?: EnumPaymentMethodFilter<"CollectionCasePayment"> | $Enums.PaymentMethod
    amount?: DecimalFilter<"CollectionCasePayment"> | Decimal | DecimalJsLike | number | string
    collection_case_id?: StringFilter<"CollectionCasePayment"> | string
    payment_date?: DateTimeFilter<"CollectionCasePayment"> | Date | string
    reference_number?: StringNullableFilter<"CollectionCasePayment"> | string | null
    agreement_id?: StringNullableFilter<"CollectionCasePayment"> | string | null
    created_at?: DateTimeFilter<"CollectionCasePayment"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCasePayment"> | Date | string
  }

  export type CollectionCaseAgreementUpsertWithWhereUniqueWithoutCollection_caseInput = {
    where: CollectionCaseAgreementWhereUniqueInput
    update: XOR<CollectionCaseAgreementUpdateWithoutCollection_caseInput, CollectionCaseAgreementUncheckedUpdateWithoutCollection_caseInput>
    create: XOR<CollectionCaseAgreementCreateWithoutCollection_caseInput, CollectionCaseAgreementUncheckedCreateWithoutCollection_caseInput>
  }

  export type CollectionCaseAgreementUpdateWithWhereUniqueWithoutCollection_caseInput = {
    where: CollectionCaseAgreementWhereUniqueInput
    data: XOR<CollectionCaseAgreementUpdateWithoutCollection_caseInput, CollectionCaseAgreementUncheckedUpdateWithoutCollection_caseInput>
  }

  export type CollectionCaseAgreementUpdateManyWithWhereWithoutCollection_caseInput = {
    where: CollectionCaseAgreementScalarWhereInput
    data: XOR<CollectionCaseAgreementUpdateManyMutationInput, CollectionCaseAgreementUncheckedUpdateManyWithoutCollection_caseInput>
  }

  export type CollectionCasePenaltyUpsertWithWhereUniqueWithoutCollection_caseInput = {
    where: CollectionCasePenaltyWhereUniqueInput
    update: XOR<CollectionCasePenaltyUpdateWithoutCollection_caseInput, CollectionCasePenaltyUncheckedUpdateWithoutCollection_caseInput>
    create: XOR<CollectionCasePenaltyCreateWithoutCollection_caseInput, CollectionCasePenaltyUncheckedCreateWithoutCollection_caseInput>
  }

  export type CollectionCasePenaltyUpdateWithWhereUniqueWithoutCollection_caseInput = {
    where: CollectionCasePenaltyWhereUniqueInput
    data: XOR<CollectionCasePenaltyUpdateWithoutCollection_caseInput, CollectionCasePenaltyUncheckedUpdateWithoutCollection_caseInput>
  }

  export type CollectionCasePenaltyUpdateManyWithWhereWithoutCollection_caseInput = {
    where: CollectionCasePenaltyScalarWhereInput
    data: XOR<CollectionCasePenaltyUpdateManyMutationInput, CollectionCasePenaltyUncheckedUpdateManyWithoutCollection_caseInput>
  }

  export type CollectionCasePenaltyScalarWhereInput = {
    AND?: CollectionCasePenaltyScalarWhereInput | CollectionCasePenaltyScalarWhereInput[]
    OR?: CollectionCasePenaltyScalarWhereInput[]
    NOT?: CollectionCasePenaltyScalarWhereInput | CollectionCasePenaltyScalarWhereInput[]
    id?: StringFilter<"CollectionCasePenalty"> | string
    collection_case_id?: StringFilter<"CollectionCasePenalty"> | string
    description?: StringNullableFilter<"CollectionCasePenalty"> | string | null
    amount?: DecimalFilter<"CollectionCasePenalty"> | Decimal | DecimalJsLike | number | string
    date_applied?: DateTimeFilter<"CollectionCasePenalty"> | Date | string
    is_paid?: BoolFilter<"CollectionCasePenalty"> | boolean
    created_at?: DateTimeFilter<"CollectionCasePenalty"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCasePenalty"> | Date | string
  }

  export type ChatRoomUpsertWithWhereUniqueWithoutCollection_caseInput = {
    where: ChatRoomWhereUniqueInput
    update: XOR<ChatRoomUpdateWithoutCollection_caseInput, ChatRoomUncheckedUpdateWithoutCollection_caseInput>
    create: XOR<ChatRoomCreateWithoutCollection_caseInput, ChatRoomUncheckedCreateWithoutCollection_caseInput>
  }

  export type ChatRoomUpdateWithWhereUniqueWithoutCollection_caseInput = {
    where: ChatRoomWhereUniqueInput
    data: XOR<ChatRoomUpdateWithoutCollection_caseInput, ChatRoomUncheckedUpdateWithoutCollection_caseInput>
  }

  export type ChatRoomUpdateManyWithWhereWithoutCollection_caseInput = {
    where: ChatRoomScalarWhereInput
    data: XOR<ChatRoomUpdateManyMutationInput, ChatRoomUncheckedUpdateManyWithoutCollection_caseInput>
  }

  export type CollectionCaseCreateWithoutPenaltiesInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollection_casesInput
    tenant: TenantCreateNestedOneWithoutCollection_casesInput
    notifications?: CollectionCaseNotificationCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseUncheckedCreateWithoutPenaltiesInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    tenant_id: string
    debtor_id: string
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notifications?: CollectionCaseNotificationUncheckedCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseCreateOrConnectWithoutPenaltiesInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
  }

  export type CollectionCaseUpsertWithoutPenaltiesInput = {
    update: XOR<CollectionCaseUpdateWithoutPenaltiesInput, CollectionCaseUncheckedUpdateWithoutPenaltiesInput>
    create: XOR<CollectionCaseCreateWithoutPenaltiesInput, CollectionCaseUncheckedCreateWithoutPenaltiesInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutPenaltiesInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutPenaltiesInput, CollectionCaseUncheckedUpdateWithoutPenaltiesInput>
  }

  export type CollectionCaseUpdateWithoutPenaltiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollection_casesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollection_casesNestedInput
    notifications?: CollectionCaseNotificationUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutPenaltiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: CollectionCaseNotificationUncheckedUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseCreateWithoutNotificationsInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollection_casesInput
    tenant: TenantCreateNestedOneWithoutCollection_casesInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseUncheckedCreateWithoutNotificationsInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    tenant_id: string
    debtor_id: string
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyUncheckedCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseCreateOrConnectWithoutNotificationsInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
  }

  export type CollectionCaseUpsertWithoutNotificationsInput = {
    update: XOR<CollectionCaseUpdateWithoutNotificationsInput, CollectionCaseUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CollectionCaseCreateWithoutNotificationsInput, CollectionCaseUncheckedCreateWithoutNotificationsInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutNotificationsInput, CollectionCaseUncheckedUpdateWithoutNotificationsInput>
  }

  export type CollectionCaseUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollection_casesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollection_casesNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUncheckedUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseCreateWithoutPaymentsInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollection_casesInput
    tenant: TenantCreateNestedOneWithoutCollection_casesInput
    notifications?: CollectionCaseNotificationCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseUncheckedCreateWithoutPaymentsInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    tenant_id: string
    debtor_id: string
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notifications?: CollectionCaseNotificationUncheckedCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyUncheckedCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseCreateOrConnectWithoutPaymentsInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
  }

  export type CollectionCaseAgreementCreateWithoutPaymentsInput = {
    id?: string
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutAgreementsInput
    debtor?: DebtorCreateNestedOneWithoutPayment_agreementsInput
    collection_case: CollectionCaseCreateNestedOneWithoutAgreementsInput
    installments?: CollectionCaseAgreementInstallmentCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementUncheckedCreateWithoutPaymentsInput = {
    id?: string
    collection_case_id: string
    debtor_id?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    tenant_id: string
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementCreateOrConnectWithoutPaymentsInput = {
    where: CollectionCaseAgreementWhereUniqueInput
    create: XOR<CollectionCaseAgreementCreateWithoutPaymentsInput, CollectionCaseAgreementUncheckedCreateWithoutPaymentsInput>
  }

  export type CollectionCaseAgreementInstallmentCreateWithoutPaymentInput = {
    id?: string
    number: number
    due_date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    created_at?: Date | string
    updated_at?: Date | string
    agreement: CollectionCaseAgreementCreateNestedOneWithoutInstallmentsInput
  }

  export type CollectionCaseAgreementInstallmentUncheckedCreateWithoutPaymentInput = {
    id?: string
    agreement_id: string
    number: number
    due_date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseAgreementInstallmentCreateOrConnectWithoutPaymentInput = {
    where: CollectionCaseAgreementInstallmentWhereUniqueInput
    create: XOR<CollectionCaseAgreementInstallmentCreateWithoutPaymentInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutPaymentInput>
  }

  export type CollectionCaseAgreementInstallmentCreateManyPaymentInputEnvelope = {
    data: CollectionCaseAgreementInstallmentCreateManyPaymentInput | CollectionCaseAgreementInstallmentCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCaseUpsertWithoutPaymentsInput = {
    update: XOR<CollectionCaseUpdateWithoutPaymentsInput, CollectionCaseUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CollectionCaseCreateWithoutPaymentsInput, CollectionCaseUncheckedCreateWithoutPaymentsInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutPaymentsInput, CollectionCaseUncheckedUpdateWithoutPaymentsInput>
  }

  export type CollectionCaseUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollection_casesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollection_casesNestedInput
    notifications?: CollectionCaseNotificationUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: CollectionCaseNotificationUncheckedUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUncheckedUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseAgreementUpsertWithoutPaymentsInput = {
    update: XOR<CollectionCaseAgreementUpdateWithoutPaymentsInput, CollectionCaseAgreementUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CollectionCaseAgreementCreateWithoutPaymentsInput, CollectionCaseAgreementUncheckedCreateWithoutPaymentsInput>
    where?: CollectionCaseAgreementWhereInput
  }

  export type CollectionCaseAgreementUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CollectionCaseAgreementWhereInput
    data: XOR<CollectionCaseAgreementUpdateWithoutPaymentsInput, CollectionCaseAgreementUncheckedUpdateWithoutPaymentsInput>
  }

  export type CollectionCaseAgreementUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAgreementsNestedInput
    debtor?: DebtorUpdateOneWithoutPayment_agreementsNestedInput
    collection_case?: CollectionCaseUpdateOneRequiredWithoutAgreementsNestedInput
    installments?: CollectionCaseAgreementInstallmentUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCaseAgreementUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    tenant_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCaseAgreementInstallmentUpsertWithWhereUniqueWithoutPaymentInput = {
    where: CollectionCaseAgreementInstallmentWhereUniqueInput
    update: XOR<CollectionCaseAgreementInstallmentUpdateWithoutPaymentInput, CollectionCaseAgreementInstallmentUncheckedUpdateWithoutPaymentInput>
    create: XOR<CollectionCaseAgreementInstallmentCreateWithoutPaymentInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutPaymentInput>
  }

  export type CollectionCaseAgreementInstallmentUpdateWithWhereUniqueWithoutPaymentInput = {
    where: CollectionCaseAgreementInstallmentWhereUniqueInput
    data: XOR<CollectionCaseAgreementInstallmentUpdateWithoutPaymentInput, CollectionCaseAgreementInstallmentUncheckedUpdateWithoutPaymentInput>
  }

  export type CollectionCaseAgreementInstallmentUpdateManyWithWhereWithoutPaymentInput = {
    where: CollectionCaseAgreementInstallmentScalarWhereInput
    data: XOR<CollectionCaseAgreementInstallmentUpdateManyMutationInput, CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type CollectionCaseAgreementInstallmentScalarWhereInput = {
    AND?: CollectionCaseAgreementInstallmentScalarWhereInput | CollectionCaseAgreementInstallmentScalarWhereInput[]
    OR?: CollectionCaseAgreementInstallmentScalarWhereInput[]
    NOT?: CollectionCaseAgreementInstallmentScalarWhereInput | CollectionCaseAgreementInstallmentScalarWhereInput[]
    id?: StringFilter<"CollectionCaseAgreementInstallment"> | string
    agreement_id?: StringFilter<"CollectionCaseAgreementInstallment"> | string
    number?: IntFilter<"CollectionCaseAgreementInstallment"> | number
    due_date?: DateTimeFilter<"CollectionCaseAgreementInstallment"> | Date | string
    amount?: DecimalFilter<"CollectionCaseAgreementInstallment"> | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFilter<"CollectionCaseAgreementInstallment"> | $Enums.InstallmentStatus
    payment_id?: StringNullableFilter<"CollectionCaseAgreementInstallment"> | string | null
    created_at?: DateTimeFilter<"CollectionCaseAgreementInstallment"> | Date | string
    updated_at?: DateTimeFilter<"CollectionCaseAgreementInstallment"> | Date | string
  }

  export type CollectionCaseCreateWithoutDebtorInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutCollection_casesInput
    notifications?: CollectionCaseNotificationCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseUncheckedCreateWithoutDebtorInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    tenant_id: string
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notifications?: CollectionCaseNotificationUncheckedCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyUncheckedCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseCreateOrConnectWithoutDebtorInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput>
  }

  export type CollectionCaseCreateManyDebtorInputEnvelope = {
    data: CollectionCaseCreateManyDebtorInput | CollectionCaseCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutDebtorsInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseCreateNestedManyWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDebtorsInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDebtorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
  }

  export type UserCreateWithoutDebtorsInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    verdict_bailiffs?: VerdictCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutDebtorsInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    tenant_id: string
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    verdict_bailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutDebtorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
  }

  export type DebtorIncomeCreateWithoutDebtorInput = {
    id?: string
    amount: number
    source: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DebtorIncomeUncheckedCreateWithoutDebtorInput = {
    id?: string
    amount: number
    source: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DebtorIncomeCreateOrConnectWithoutDebtorInput = {
    where: DebtorIncomeWhereUniqueInput
    create: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput>
  }

  export type DebtorIncomeCreateManyDebtorInputEnvelope = {
    data: DebtorIncomeCreateManyDebtorInput | DebtorIncomeCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCaseAgreementCreateWithoutDebtorInput = {
    id?: string
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutAgreementsInput
    collection_case: CollectionCaseCreateNestedOneWithoutAgreementsInput
    installments?: CollectionCaseAgreementInstallmentCreateNestedManyWithoutAgreementInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementUncheckedCreateWithoutDebtorInput = {
    id?: string
    collection_case_id: string
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    tenant_id: string
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedCreateNestedManyWithoutAgreementInput
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementCreateOrConnectWithoutDebtorInput = {
    where: CollectionCaseAgreementWhereUniqueInput
    create: XOR<CollectionCaseAgreementCreateWithoutDebtorInput, CollectionCaseAgreementUncheckedCreateWithoutDebtorInput>
  }

  export type CollectionCaseAgreementCreateManyDebtorInputEnvelope = {
    data: CollectionCaseAgreementCreateManyDebtorInput | CollectionCaseAgreementCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type VerdictCreateWithoutDebtorInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    notes?: string | null
    bailiff?: UserCreateNestedOneWithoutVerdict_bailiffsInput
    tenant: TenantCreateNestedOneWithoutVerdictsInput
    attachments?: VerdictAttachmentCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestCreateNestedManyWithoutVerdictInput
  }

  export type VerdictUncheckedCreateWithoutDebtorInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    tenant_id: string
    notes?: string | null
    bailiff_id?: string | null
    attachments?: VerdictAttachmentUncheckedCreateNestedManyWithoutVerdictInput
    bailiff_services?: VerdictBailiffServicesUncheckedCreateNestedManyWithoutVerdictInput
    verdict_embargo?: VerdictEmbargoUncheckedCreateNestedManyWithoutVerdictInput
    verdict_interest?: VerdictInterestUncheckedCreateNestedManyWithoutVerdictInput
  }

  export type VerdictCreateOrConnectWithoutDebtorInput = {
    where: VerdictWhereUniqueInput
    create: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput>
  }

  export type VerdictCreateManyDebtorInputEnvelope = {
    data: VerdictCreateManyDebtorInput | VerdictCreateManyDebtorInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCaseUpsertWithWhereUniqueWithoutDebtorInput = {
    where: CollectionCaseWhereUniqueInput
    update: XOR<CollectionCaseUpdateWithoutDebtorInput, CollectionCaseUncheckedUpdateWithoutDebtorInput>
    create: XOR<CollectionCaseCreateWithoutDebtorInput, CollectionCaseUncheckedCreateWithoutDebtorInput>
  }

  export type CollectionCaseUpdateWithWhereUniqueWithoutDebtorInput = {
    where: CollectionCaseWhereUniqueInput
    data: XOR<CollectionCaseUpdateWithoutDebtorInput, CollectionCaseUncheckedUpdateWithoutDebtorInput>
  }

  export type CollectionCaseUpdateManyWithWhereWithoutDebtorInput = {
    where: CollectionCaseScalarWhereInput
    data: XOR<CollectionCaseUpdateManyMutationInput, CollectionCaseUncheckedUpdateManyWithoutDebtorInput>
  }

  export type TenantUpsertWithoutDebtorsInput = {
    update: XOR<TenantUpdateWithoutDebtorsInput, TenantUncheckedUpdateWithoutDebtorsInput>
    create: XOR<TenantCreateWithoutDebtorsInput, TenantUncheckedCreateWithoutDebtorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDebtorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDebtorsInput, TenantUncheckedUpdateWithoutDebtorsInput>
  }

  export type TenantUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutDebtorsInput = {
    update: XOR<UserUpdateWithoutDebtorsInput, UserUncheckedUpdateWithoutDebtorsInput>
    create: XOR<UserCreateWithoutDebtorsInput, UserUncheckedCreateWithoutDebtorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDebtorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDebtorsInput, UserUncheckedUpdateWithoutDebtorsInput>
  }

  export type UserUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    verdict_bailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutDebtorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verdict_bailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type DebtorIncomeUpsertWithWhereUniqueWithoutDebtorInput = {
    where: DebtorIncomeWhereUniqueInput
    update: XOR<DebtorIncomeUpdateWithoutDebtorInput, DebtorIncomeUncheckedUpdateWithoutDebtorInput>
    create: XOR<DebtorIncomeCreateWithoutDebtorInput, DebtorIncomeUncheckedCreateWithoutDebtorInput>
  }

  export type DebtorIncomeUpdateWithWhereUniqueWithoutDebtorInput = {
    where: DebtorIncomeWhereUniqueInput
    data: XOR<DebtorIncomeUpdateWithoutDebtorInput, DebtorIncomeUncheckedUpdateWithoutDebtorInput>
  }

  export type DebtorIncomeUpdateManyWithWhereWithoutDebtorInput = {
    where: DebtorIncomeScalarWhereInput
    data: XOR<DebtorIncomeUpdateManyMutationInput, DebtorIncomeUncheckedUpdateManyWithoutDebtorInput>
  }

  export type DebtorIncomeScalarWhereInput = {
    AND?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
    OR?: DebtorIncomeScalarWhereInput[]
    NOT?: DebtorIncomeScalarWhereInput | DebtorIncomeScalarWhereInput[]
    id?: StringFilter<"DebtorIncome"> | string
    debtor_id?: StringFilter<"DebtorIncome"> | string
    amount?: FloatFilter<"DebtorIncome"> | number
    source?: StringFilter<"DebtorIncome"> | string
    created_at?: DateTimeFilter<"DebtorIncome"> | Date | string
    updated_at?: DateTimeFilter<"DebtorIncome"> | Date | string
  }

  export type CollectionCaseAgreementUpsertWithWhereUniqueWithoutDebtorInput = {
    where: CollectionCaseAgreementWhereUniqueInput
    update: XOR<CollectionCaseAgreementUpdateWithoutDebtorInput, CollectionCaseAgreementUncheckedUpdateWithoutDebtorInput>
    create: XOR<CollectionCaseAgreementCreateWithoutDebtorInput, CollectionCaseAgreementUncheckedCreateWithoutDebtorInput>
  }

  export type CollectionCaseAgreementUpdateWithWhereUniqueWithoutDebtorInput = {
    where: CollectionCaseAgreementWhereUniqueInput
    data: XOR<CollectionCaseAgreementUpdateWithoutDebtorInput, CollectionCaseAgreementUncheckedUpdateWithoutDebtorInput>
  }

  export type CollectionCaseAgreementUpdateManyWithWhereWithoutDebtorInput = {
    where: CollectionCaseAgreementScalarWhereInput
    data: XOR<CollectionCaseAgreementUpdateManyMutationInput, CollectionCaseAgreementUncheckedUpdateManyWithoutDebtorInput>
  }

  export type VerdictUpsertWithWhereUniqueWithoutDebtorInput = {
    where: VerdictWhereUniqueInput
    update: XOR<VerdictUpdateWithoutDebtorInput, VerdictUncheckedUpdateWithoutDebtorInput>
    create: XOR<VerdictCreateWithoutDebtorInput, VerdictUncheckedCreateWithoutDebtorInput>
  }

  export type VerdictUpdateWithWhereUniqueWithoutDebtorInput = {
    where: VerdictWhereUniqueInput
    data: XOR<VerdictUpdateWithoutDebtorInput, VerdictUncheckedUpdateWithoutDebtorInput>
  }

  export type VerdictUpdateManyWithWhereWithoutDebtorInput = {
    where: VerdictScalarWhereInput
    data: XOR<VerdictUpdateManyMutationInput, VerdictUncheckedUpdateManyWithoutDebtorInput>
  }

  export type TenantCreateWithoutChat_roomsInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutChat_roomsInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutChat_roomsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutChat_roomsInput, TenantUncheckedCreateWithoutChat_roomsInput>
  }

  export type CollectionCaseCreateWithoutChat_roomsInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollection_casesInput
    tenant: TenantCreateNestedOneWithoutCollection_casesInput
    notifications?: CollectionCaseNotificationCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseUncheckedCreateWithoutChat_roomsInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    tenant_id: string
    debtor_id: string
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notifications?: CollectionCaseNotificationUncheckedCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutCollection_caseInput
    agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyUncheckedCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseCreateOrConnectWithoutChat_roomsInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutChat_roomsInput, CollectionCaseUncheckedCreateWithoutChat_roomsInput>
  }

  export type ChatMessageCreateWithoutRoomInput = {
    id?: string
    message: string
    file_url?: string | null
    file_name?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutRoomInput = {
    id?: string
    sender_id: string
    message: string
    file_url?: string | null
    file_name?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutRoomInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput>
  }

  export type ChatMessageCreateManyRoomInputEnvelope = {
    data: ChatMessageCreateManyRoomInput | ChatMessageCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutChat_roomsInput = {
    update: XOR<TenantUpdateWithoutChat_roomsInput, TenantUncheckedUpdateWithoutChat_roomsInput>
    create: XOR<TenantCreateWithoutChat_roomsInput, TenantUncheckedCreateWithoutChat_roomsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutChat_roomsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutChat_roomsInput, TenantUncheckedUpdateWithoutChat_roomsInput>
  }

  export type TenantUpdateWithoutChat_roomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutChat_roomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CollectionCaseUpsertWithoutChat_roomsInput = {
    update: XOR<CollectionCaseUpdateWithoutChat_roomsInput, CollectionCaseUncheckedUpdateWithoutChat_roomsInput>
    create: XOR<CollectionCaseCreateWithoutChat_roomsInput, CollectionCaseUncheckedCreateWithoutChat_roomsInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutChat_roomsInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutChat_roomsInput, CollectionCaseUncheckedUpdateWithoutChat_roomsInput>
  }

  export type CollectionCaseUpdateWithoutChat_roomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollection_casesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollection_casesNestedInput
    notifications?: CollectionCaseNotificationUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutChat_roomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: CollectionCaseNotificationUncheckedUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUncheckedUpdateManyWithoutCollection_caseNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutRoomInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutRoomInput, ChatMessageUncheckedUpdateWithoutRoomInput>
    create: XOR<ChatMessageCreateWithoutRoomInput, ChatMessageUncheckedCreateWithoutRoomInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutRoomInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutRoomInput, ChatMessageUncheckedUpdateWithoutRoomInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutRoomInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutRoomInput>
  }

  export type ChatRoomCreateWithoutMessagesInput = {
    id?: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutChat_roomsInput
    collection_case: CollectionCaseCreateNestedOneWithoutChat_roomsInput
  }

  export type ChatRoomUncheckedCreateWithoutMessagesInput = {
    id?: string
    tenant_id: string
    collection_case_id: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatRoomCreateOrConnectWithoutMessagesInput = {
    where: ChatRoomWhereUniqueInput
    create: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    debtors?: DebtorCreateNestedManyWithoutUserInput
    verdict_bailiffs?: VerdictCreateNestedManyWithoutBailiffInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    tenant_id: string
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    debtors?: DebtorUncheckedCreateNestedManyWithoutUserInput
    verdict_bailiffs?: VerdictUncheckedCreateNestedManyWithoutBailiffInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ChatRoomUpsertWithoutMessagesInput = {
    update: XOR<ChatRoomUpdateWithoutMessagesInput, ChatRoomUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatRoomCreateWithoutMessagesInput, ChatRoomUncheckedCreateWithoutMessagesInput>
    where?: ChatRoomWhereInput
  }

  export type ChatRoomUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatRoomWhereInput
    data: XOR<ChatRoomUpdateWithoutMessagesInput, ChatRoomUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatRoomUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutChat_roomsNestedInput
    collection_case?: CollectionCaseUpdateOneRequiredWithoutChat_roomsNestedInput
  }

  export type ChatRoomUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    verdict_bailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    verdict_bailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
  }

  export type DebtorCreateWithoutIncomesInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    payment_agreements?: CollectionCaseAgreementCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutIncomesInput = {
    id?: string
    tenant_id: string
    user_id?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    payment_agreements?: CollectionCaseAgreementUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutIncomesInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
  }

  export type DebtorUpsertWithoutIncomesInput = {
    update: XOR<DebtorUpdateWithoutIncomesInput, DebtorUncheckedUpdateWithoutIncomesInput>
    create: XOR<DebtorCreateWithoutIncomesInput, DebtorUncheckedCreateWithoutIncomesInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutIncomesInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutIncomesInput, DebtorUncheckedUpdateWithoutIncomesInput>
  }

  export type DebtorUpdateWithoutIncomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    payment_agreements?: CollectionCaseAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutIncomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    payment_agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type TenantCreateWithoutAgreementsInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseCreateNestedManyWithoutTenantInput
    debtors?: DebtorCreateNestedManyWithoutTenantInput
    verdicts?: VerdictCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAgreementsInput = {
    id?: string
    name: string
    subdomain: string
    contact_email: string
    country_code: string
    kvk?: string | null
    legal_name?: string | null
    address?: string | null
    city?: string | null
    logo_url?: string | null
    number_of_employees?: number | null
    phone?: string | null
    website?: string | null
    terms_accepted?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    billing_invoice?: BillingInvoiceUncheckedCreateNestedManyWithoutTenantInput
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutTenantInput
    debtors?: DebtorUncheckedCreateNestedManyWithoutTenantInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAgreementsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAgreementsInput, TenantUncheckedCreateWithoutAgreementsInput>
  }

  export type DebtorCreateWithoutPayment_agreementsInput = {
    id?: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseCreateNestedManyWithoutDebtorInput
    tenant: TenantCreateNestedOneWithoutDebtorsInput
    user?: UserCreateNestedOneWithoutDebtorsInput
    incomes?: DebtorIncomeCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictCreateNestedManyWithoutDebtorInput
  }

  export type DebtorUncheckedCreateWithoutPayment_agreementsInput = {
    id?: string
    tenant_id: string
    user_id?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_cases?: CollectionCaseUncheckedCreateNestedManyWithoutDebtorInput
    incomes?: DebtorIncomeUncheckedCreateNestedManyWithoutDebtorInput
    verdicts?: VerdictUncheckedCreateNestedManyWithoutDebtorInput
  }

  export type DebtorCreateOrConnectWithoutPayment_agreementsInput = {
    where: DebtorWhereUniqueInput
    create: XOR<DebtorCreateWithoutPayment_agreementsInput, DebtorUncheckedCreateWithoutPayment_agreementsInput>
  }

  export type CollectionCaseCreateWithoutAgreementsInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    debtor: DebtorCreateNestedOneWithoutCollection_casesInput
    tenant: TenantCreateNestedOneWithoutCollection_casesInput
    notifications?: CollectionCaseNotificationCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseUncheckedCreateWithoutAgreementsInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    tenant_id: string
    debtor_id: string
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    notifications?: CollectionCaseNotificationUncheckedCreateNestedManyWithoutCollection_caseInput
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutCollection_caseInput
    penalties?: CollectionCasePenaltyUncheckedCreateNestedManyWithoutCollection_caseInput
    chat_rooms?: ChatRoomUncheckedCreateNestedManyWithoutCollection_caseInput
  }

  export type CollectionCaseCreateOrConnectWithoutAgreementsInput = {
    where: CollectionCaseWhereUniqueInput
    create: XOR<CollectionCaseCreateWithoutAgreementsInput, CollectionCaseUncheckedCreateWithoutAgreementsInput>
  }

  export type CollectionCaseAgreementInstallmentCreateWithoutAgreementInput = {
    id?: string
    number: number
    due_date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    created_at?: Date | string
    updated_at?: Date | string
    payment?: CollectionCasePaymentCreateNestedOneWithoutInstallmentsInput
  }

  export type CollectionCaseAgreementInstallmentUncheckedCreateWithoutAgreementInput = {
    id?: string
    number: number
    due_date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    payment_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseAgreementInstallmentCreateOrConnectWithoutAgreementInput = {
    where: CollectionCaseAgreementInstallmentWhereUniqueInput
    create: XOR<CollectionCaseAgreementInstallmentCreateWithoutAgreementInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutAgreementInput>
  }

  export type CollectionCaseAgreementInstallmentCreateManyAgreementInputEnvelope = {
    data: CollectionCaseAgreementInstallmentCreateManyAgreementInput | CollectionCaseAgreementInstallmentCreateManyAgreementInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCasePaymentCreateWithoutAgreementInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    payment_date: Date | string
    reference_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_case: CollectionCaseCreateNestedOneWithoutPaymentsInput
    installments?: CollectionCaseAgreementInstallmentCreateNestedManyWithoutPaymentInput
  }

  export type CollectionCasePaymentUncheckedCreateWithoutAgreementInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    collection_case_id: string
    payment_date: Date | string
    reference_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type CollectionCasePaymentCreateOrConnectWithoutAgreementInput = {
    where: CollectionCasePaymentWhereUniqueInput
    create: XOR<CollectionCasePaymentCreateWithoutAgreementInput, CollectionCasePaymentUncheckedCreateWithoutAgreementInput>
  }

  export type CollectionCasePaymentCreateManyAgreementInputEnvelope = {
    data: CollectionCasePaymentCreateManyAgreementInput | CollectionCasePaymentCreateManyAgreementInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutAgreementsInput = {
    update: XOR<TenantUpdateWithoutAgreementsInput, TenantUncheckedUpdateWithoutAgreementsInput>
    create: XOR<TenantCreateWithoutAgreementsInput, TenantUncheckedCreateWithoutAgreementsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAgreementsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAgreementsInput, TenantUncheckedUpdateWithoutAgreementsInput>
  }

  export type TenantUpdateWithoutAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    kvk?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    number_of_employees?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    terms_accepted?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    billing_invoice?: BillingInvoiceUncheckedUpdateManyWithoutTenantNestedInput
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutTenantNestedInput
    debtors?: DebtorUncheckedUpdateManyWithoutTenantNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DebtorUpsertWithoutPayment_agreementsInput = {
    update: XOR<DebtorUpdateWithoutPayment_agreementsInput, DebtorUncheckedUpdateWithoutPayment_agreementsInput>
    create: XOR<DebtorCreateWithoutPayment_agreementsInput, DebtorUncheckedCreateWithoutPayment_agreementsInput>
    where?: DebtorWhereInput
  }

  export type DebtorUpdateToOneWithWhereWithoutPayment_agreementsInput = {
    where?: DebtorWhereInput
    data: XOR<DebtorUpdateWithoutPayment_agreementsInput, DebtorUncheckedUpdateWithoutPayment_agreementsInput>
  }

  export type DebtorUpdateWithoutPayment_agreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutPayment_agreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type CollectionCaseUpsertWithoutAgreementsInput = {
    update: XOR<CollectionCaseUpdateWithoutAgreementsInput, CollectionCaseUncheckedUpdateWithoutAgreementsInput>
    create: XOR<CollectionCaseCreateWithoutAgreementsInput, CollectionCaseUncheckedCreateWithoutAgreementsInput>
    where?: CollectionCaseWhereInput
  }

  export type CollectionCaseUpdateToOneWithWhereWithoutAgreementsInput = {
    where?: CollectionCaseWhereInput
    data: XOR<CollectionCaseUpdateWithoutAgreementsInput, CollectionCaseUncheckedUpdateWithoutAgreementsInput>
  }

  export type CollectionCaseUpdateWithoutAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollection_casesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCollection_casesNestedInput
    notifications?: CollectionCaseNotificationUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: CollectionCaseNotificationUncheckedUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUncheckedUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseAgreementInstallmentUpsertWithWhereUniqueWithoutAgreementInput = {
    where: CollectionCaseAgreementInstallmentWhereUniqueInput
    update: XOR<CollectionCaseAgreementInstallmentUpdateWithoutAgreementInput, CollectionCaseAgreementInstallmentUncheckedUpdateWithoutAgreementInput>
    create: XOR<CollectionCaseAgreementInstallmentCreateWithoutAgreementInput, CollectionCaseAgreementInstallmentUncheckedCreateWithoutAgreementInput>
  }

  export type CollectionCaseAgreementInstallmentUpdateWithWhereUniqueWithoutAgreementInput = {
    where: CollectionCaseAgreementInstallmentWhereUniqueInput
    data: XOR<CollectionCaseAgreementInstallmentUpdateWithoutAgreementInput, CollectionCaseAgreementInstallmentUncheckedUpdateWithoutAgreementInput>
  }

  export type CollectionCaseAgreementInstallmentUpdateManyWithWhereWithoutAgreementInput = {
    where: CollectionCaseAgreementInstallmentScalarWhereInput
    data: XOR<CollectionCaseAgreementInstallmentUpdateManyMutationInput, CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutAgreementInput>
  }

  export type CollectionCasePaymentUpsertWithWhereUniqueWithoutAgreementInput = {
    where: CollectionCasePaymentWhereUniqueInput
    update: XOR<CollectionCasePaymentUpdateWithoutAgreementInput, CollectionCasePaymentUncheckedUpdateWithoutAgreementInput>
    create: XOR<CollectionCasePaymentCreateWithoutAgreementInput, CollectionCasePaymentUncheckedCreateWithoutAgreementInput>
  }

  export type CollectionCasePaymentUpdateWithWhereUniqueWithoutAgreementInput = {
    where: CollectionCasePaymentWhereUniqueInput
    data: XOR<CollectionCasePaymentUpdateWithoutAgreementInput, CollectionCasePaymentUncheckedUpdateWithoutAgreementInput>
  }

  export type CollectionCasePaymentUpdateManyWithWhereWithoutAgreementInput = {
    where: CollectionCasePaymentScalarWhereInput
    data: XOR<CollectionCasePaymentUpdateManyMutationInput, CollectionCasePaymentUncheckedUpdateManyWithoutAgreementInput>
  }

  export type CollectionCaseAgreementCreateWithoutInstallmentsInput = {
    id?: string
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    tenant: TenantCreateNestedOneWithoutAgreementsInput
    debtor?: DebtorCreateNestedOneWithoutPayment_agreementsInput
    collection_case: CollectionCaseCreateNestedOneWithoutAgreementsInput
    payments?: CollectionCasePaymentCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementUncheckedCreateWithoutInstallmentsInput = {
    id?: string
    collection_case_id: string
    debtor_id?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    tenant_id: string
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    payments?: CollectionCasePaymentUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type CollectionCaseAgreementCreateOrConnectWithoutInstallmentsInput = {
    where: CollectionCaseAgreementWhereUniqueInput
    create: XOR<CollectionCaseAgreementCreateWithoutInstallmentsInput, CollectionCaseAgreementUncheckedCreateWithoutInstallmentsInput>
  }

  export type CollectionCasePaymentCreateWithoutInstallmentsInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    payment_date: Date | string
    reference_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    collection_case: CollectionCaseCreateNestedOneWithoutPaymentsInput
    agreement?: CollectionCaseAgreementCreateNestedOneWithoutPaymentsInput
  }

  export type CollectionCasePaymentUncheckedCreateWithoutInstallmentsInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    collection_case_id: string
    payment_date: Date | string
    reference_number?: string | null
    agreement_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCasePaymentCreateOrConnectWithoutInstallmentsInput = {
    where: CollectionCasePaymentWhereUniqueInput
    create: XOR<CollectionCasePaymentCreateWithoutInstallmentsInput, CollectionCasePaymentUncheckedCreateWithoutInstallmentsInput>
  }

  export type CollectionCaseAgreementUpsertWithoutInstallmentsInput = {
    update: XOR<CollectionCaseAgreementUpdateWithoutInstallmentsInput, CollectionCaseAgreementUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<CollectionCaseAgreementCreateWithoutInstallmentsInput, CollectionCaseAgreementUncheckedCreateWithoutInstallmentsInput>
    where?: CollectionCaseAgreementWhereInput
  }

  export type CollectionCaseAgreementUpdateToOneWithWhereWithoutInstallmentsInput = {
    where?: CollectionCaseAgreementWhereInput
    data: XOR<CollectionCaseAgreementUpdateWithoutInstallmentsInput, CollectionCaseAgreementUncheckedUpdateWithoutInstallmentsInput>
  }

  export type CollectionCaseAgreementUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAgreementsNestedInput
    debtor?: DebtorUpdateOneWithoutPayment_agreementsNestedInput
    collection_case?: CollectionCaseUpdateOneRequiredWithoutAgreementsNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCaseAgreementUncheckedUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    tenant_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCasePaymentUpsertWithoutInstallmentsInput = {
    update: XOR<CollectionCasePaymentUpdateWithoutInstallmentsInput, CollectionCasePaymentUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<CollectionCasePaymentCreateWithoutInstallmentsInput, CollectionCasePaymentUncheckedCreateWithoutInstallmentsInput>
    where?: CollectionCasePaymentWhereInput
  }

  export type CollectionCasePaymentUpdateToOneWithWhereWithoutInstallmentsInput = {
    where?: CollectionCasePaymentWhereInput
    data: XOR<CollectionCasePaymentUpdateWithoutInstallmentsInput, CollectionCasePaymentUncheckedUpdateWithoutInstallmentsInput>
  }

  export type CollectionCasePaymentUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_case?: CollectionCaseUpdateOneRequiredWithoutPaymentsNestedInput
    agreement?: CollectionCaseAgreementUpdateOneWithoutPaymentsNestedInput
  }

  export type CollectionCasePaymentUncheckedUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceCreateManyTenantInput = {
    id?: string
    invoice_number: string
    amount: number
    currency?: string
    issue_date: Date | string
    due_date: Date | string
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseCreateManyTenantInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    debtor_id: string
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DebtorCreateManyTenantInput = {
    id?: string
    user_id?: string | null
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictCreateManyTenantInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    debtor_id: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    notes?: string | null
    bailiff_id?: string | null
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    password_hash?: string | null
    fullname?: string | null
    phone?: string | null
    role?: $Enums.roleEnum
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatRoomCreateManyTenantInput = {
    id?: string
    collection_case_id: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseAgreementCreateManyTenantInput = {
    id?: string
    collection_case_id: string
    debtor_id?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BillingInvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUpdateManyWithoutBilling_invoiceNestedInput
    payments?: BillingPaymentUpdateManyWithoutBilling_invoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BillingInvoiceDetailUncheckedUpdateManyWithoutBilling_invoiceNestedInput
    payments?: BillingPaymentUncheckedUpdateManyWithoutBilling_invoiceNestedInput
  }

  export type BillingInvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneRequiredWithoutCollection_casesNestedInput
    notifications?: CollectionCaseNotificationUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debtor_id?: StringFieldUpdateOperationsInput | string
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: CollectionCaseNotificationUncheckedUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUncheckedUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    debtor_id?: StringFieldUpdateOperationsInput | string
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    user?: UserUpdateOneWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    payment_agreements?: CollectionCaseAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    payment_agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdict_bailiffsNestedInput
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff_id?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUpdateManyWithoutUserNestedInput
    verdict_bailiffs?: VerdictUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtors?: DebtorUncheckedUpdateManyWithoutUserNestedInput
    verdict_bailiffs?: VerdictUncheckedUpdateManyWithoutBailiffNestedInput
    messages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    fullname?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumroleEnumFieldUpdateOperationsInput | $Enums.roleEnum
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatRoomUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_case?: CollectionCaseUpdateOneRequiredWithoutChat_roomsNestedInput
    messages?: ChatMessageUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debtor?: DebtorUpdateOneWithoutPayment_agreementsNestedInput
    collection_case?: CollectionCaseUpdateOneRequiredWithoutAgreementsNestedInput
    installments?: CollectionCaseAgreementInstallmentUpdateManyWithoutAgreementNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCaseAgreementUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutAgreementNestedInput
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCaseAgreementUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    debtor_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorCreateManyUserInput = {
    id?: string
    tenant_id: string
    fullname: string
    email: string
    phone?: string | null
    address?: string | null
    person_type?: $Enums.PersonType
    identification_type?: $Enums.IdentificationType | null
    identification?: string | null
    total_income?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictCreateManyBailiffInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    debtor_id: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    tenant_id: string
    notes?: string | null
  }

  export type ChatMessageCreateManySenderInput = {
    id?: string
    room_id: string
    message: string
    file_url?: string | null
    file_name?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DebtorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUpdateManyWithoutDebtorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDebtorsNestedInput
    incomes?: DebtorIncomeUpdateManyWithoutDebtorNestedInput
    payment_agreements?: CollectionCaseAgreementUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_cases?: CollectionCaseUncheckedUpdateManyWithoutDebtorNestedInput
    incomes?: DebtorIncomeUncheckedUpdateManyWithoutDebtorNestedInput
    payment_agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutDebtorNestedInput
    verdicts?: VerdictUncheckedUpdateManyWithoutDebtorNestedInput
  }

  export type DebtorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    fullname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    person_type?: EnumPersonTypeFieldUpdateOperationsInput | $Enums.PersonType
    identification_type?: NullableEnumIdentificationTypeFieldUpdateOperationsInput | $Enums.IdentificationType | null
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    total_income?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUpdateWithoutBailiffInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    debtor?: DebtorUpdateOneRequiredWithoutVerdictsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutBailiffInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateManyWithoutBailiffInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    debtor_id?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: ChatRoomUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    room_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictAttachmentCreateManyVerdictInput = {
    id?: string
    file_path: string
    file_size: bigint | number
    created_at?: Date | string
    updated_at?: Date | string
    file_name: string
  }

  export type VerdictBailiffServicesCreateManyVerdictInput = {
    id?: string
    service_type: string
    service_cost: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictEmbargoCreateManyVerdictInput = {
    id?: string
    company_name: string
    company_phone: string
    company_email: string
    company_address: string
    embargo_type: string
    embargo_date: Date | string
    embargo_amount: number
    total_amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictInterestCreateManyVerdictInput = {
    id?: string
    interest_type: number
    base_amount: number
    calculated_interest?: number | null
    calculation_start: Date | string
    calculation_end: Date | string
    total_interest: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictAttachmentUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    file_name?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    file_name?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictAttachmentUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    file_name?: StringFieldUpdateOperationsInput | string
  }

  export type VerdictBailiffServicesUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    service_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    service_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_type?: StringFieldUpdateOperationsInput | string
    service_cost?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_phone?: StringFieldUpdateOperationsInput | string
    company_email?: StringFieldUpdateOperationsInput | string
    company_address?: StringFieldUpdateOperationsInput | string
    embargo_type?: StringFieldUpdateOperationsInput | string
    embargo_date?: DateTimeFieldUpdateOperationsInput | Date | string
    embargo_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_phone?: StringFieldUpdateOperationsInput | string
    company_email?: StringFieldUpdateOperationsInput | string
    company_address?: StringFieldUpdateOperationsInput | string
    embargo_type?: StringFieldUpdateOperationsInput | string
    embargo_date?: DateTimeFieldUpdateOperationsInput | Date | string
    embargo_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictEmbargoUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_phone?: StringFieldUpdateOperationsInput | string
    company_email?: StringFieldUpdateOperationsInput | string
    company_address?: StringFieldUpdateOperationsInput | string
    embargo_type?: StringFieldUpdateOperationsInput | string
    embargo_date?: DateTimeFieldUpdateOperationsInput | Date | string
    embargo_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest_type?: IntFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    calculated_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculation_start?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_end?: DateTimeFieldUpdateOperationsInput | Date | string
    total_interest?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: VerdictInterestDetailsUpdateManyWithoutVerdict_interestNestedInput
  }

  export type VerdictInterestUncheckedUpdateWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest_type?: IntFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    calculated_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculation_start?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_end?: DateTimeFieldUpdateOperationsInput | Date | string
    total_interest?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: VerdictInterestDetailsUncheckedUpdateManyWithoutVerdict_interestNestedInput
  }

  export type VerdictInterestUncheckedUpdateManyWithoutVerdictInput = {
    id?: StringFieldUpdateOperationsInput | string
    interest_type?: IntFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    calculated_interest?: NullableFloatFieldUpdateOperationsInput | number | null
    calculation_start?: DateTimeFieldUpdateOperationsInput | Date | string
    calculation_end?: DateTimeFieldUpdateOperationsInput | Date | string
    total_interest?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsCreateManyVerdict_interestInput = {
    id?: string
    period: string
    period_start: Date | string
    period_end: Date | string
    days: number
    annual_rate: number
    proportional_rate: number
    base_amount: number
    interest: number
    total: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictInterestDetailsUpdateWithoutVerdict_interestInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annual_rate?: FloatFieldUpdateOperationsInput | number
    proportional_rate?: FloatFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsUncheckedUpdateWithoutVerdict_interestInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annual_rate?: FloatFieldUpdateOperationsInput | number
    proportional_rate?: FloatFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictInterestDetailsUncheckedUpdateManyWithoutVerdict_interestInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    days?: IntFieldUpdateOperationsInput | number
    annual_rate?: FloatFieldUpdateOperationsInput | number
    proportional_rate?: FloatFieldUpdateOperationsInput | number
    base_amount?: FloatFieldUpdateOperationsInput | number
    interest?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestDetailCreateManyInterest_typeInput = {
    id?: number
    date: string
    rate: number
  }

  export type InterestDetailUpdateWithoutInterest_typeInput = {
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type InterestDetailUncheckedUpdateWithoutInterest_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type InterestDetailUncheckedUpdateManyWithoutInterest_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
  }

  export type BillingInvoiceDetailCreateManyBilling_invoiceInput = {
    id?: string
    item_description: string
    item_quantity: number
    item_unit_price: number
    item_total_price: number
    item_tax_rate: number
    item_tax_amount: number
    item_total_with_tax: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BillingPaymentCreateManyBilling_invoiceInput = {
    id?: string
    payment_date: Date | string
    amount: number
    payment_method: string
    transaction_id?: string | null
    status: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BillingInvoiceDetailUpdateWithoutBilling_invoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_description?: StringFieldUpdateOperationsInput | string
    item_quantity?: IntFieldUpdateOperationsInput | number
    item_unit_price?: FloatFieldUpdateOperationsInput | number
    item_total_price?: FloatFieldUpdateOperationsInput | number
    item_tax_rate?: FloatFieldUpdateOperationsInput | number
    item_tax_amount?: FloatFieldUpdateOperationsInput | number
    item_total_with_tax?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailUncheckedUpdateWithoutBilling_invoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_description?: StringFieldUpdateOperationsInput | string
    item_quantity?: IntFieldUpdateOperationsInput | number
    item_unit_price?: FloatFieldUpdateOperationsInput | number
    item_total_price?: FloatFieldUpdateOperationsInput | number
    item_tax_rate?: FloatFieldUpdateOperationsInput | number
    item_tax_amount?: FloatFieldUpdateOperationsInput | number
    item_total_with_tax?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingInvoiceDetailUncheckedUpdateManyWithoutBilling_invoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_description?: StringFieldUpdateOperationsInput | string
    item_quantity?: IntFieldUpdateOperationsInput | number
    item_unit_price?: FloatFieldUpdateOperationsInput | number
    item_total_price?: FloatFieldUpdateOperationsInput | number
    item_tax_rate?: FloatFieldUpdateOperationsInput | number
    item_tax_amount?: FloatFieldUpdateOperationsInput | number
    item_total_with_tax?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUpdateWithoutBilling_invoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUncheckedUpdateWithoutBilling_invoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillingPaymentUncheckedUpdateManyWithoutBilling_invoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseNotificationCreateManyCollection_caseInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    sent_at?: Date | string
    read?: boolean
    created_at?: Date | string
  }

  export type CollectionCasePaymentCreateManyCollection_caseInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    payment_date: Date | string
    reference_number?: string | null
    agreement_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseAgreementCreateManyCollection_caseInput = {
    id?: string
    debtor_id?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    tenant_id: string
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCasePenaltyCreateManyCollection_caseInput = {
    id?: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    date_applied?: Date | string
    is_paid?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatRoomCreateManyCollection_caseInput = {
    id?: string
    tenant_id: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseNotificationUpdateWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseNotificationUncheckedUpdateWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseNotificationUncheckedUpdateManyWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCasePaymentUpdateWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: CollectionCaseAgreementUpdateOneWithoutPaymentsNestedInput
    installments?: CollectionCaseAgreementInstallmentUpdateManyWithoutPaymentNestedInput
  }

  export type CollectionCasePaymentUncheckedUpdateWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type CollectionCasePaymentUncheckedUpdateManyWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    agreement_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementUpdateWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAgreementsNestedInput
    debtor?: DebtorUpdateOneWithoutPayment_agreementsNestedInput
    installments?: CollectionCaseAgreementInstallmentUpdateManyWithoutAgreementNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCaseAgreementUncheckedUpdateWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtor_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    tenant_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutAgreementNestedInput
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCaseAgreementUncheckedUpdateManyWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    debtor_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    tenant_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCasePenaltyUpdateWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_applied?: DateTimeFieldUpdateOperationsInput | Date | string
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCasePenaltyUncheckedUpdateWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_applied?: DateTimeFieldUpdateOperationsInput | Date | string
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCasePenaltyUncheckedUpdateManyWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date_applied?: DateTimeFieldUpdateOperationsInput | Date | string
    is_paid?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatRoomUpdateWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutChat_roomsNestedInput
    messages?: ChatMessageUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ChatRoomUncheckedUpdateManyWithoutCollection_caseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenant_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementInstallmentCreateManyPaymentInput = {
    id?: string
    agreement_id: string
    number: number
    due_date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseAgreementInstallmentUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: CollectionCaseAgreementUpdateOneRequiredWithoutInstallmentsNestedInput
  }

  export type CollectionCaseAgreementInstallmentUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreement_id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreement_id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseCreateManyDebtorInput = {
    id?: string
    reference_number?: string | null
    issue_date?: Date | string | null
    due_date?: Date | string | null
    reminder1_sent_at?: Date | string | null
    reminder1_due_date?: Date | string | null
    reminder2_sent_at?: Date | string | null
    reminder2_due_date?: Date | string | null
    tenant_id: string
    amount_original: Decimal | DecimalJsLike | number | string
    amount_due: Decimal | DecimalJsLike | number | string
    amount_to_receive: Decimal | DecimalJsLike | number | string
    status?: $Enums.CollectionCaseStatus
    notification_status?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DebtorIncomeCreateManyDebtorInput = {
    id?: string
    amount: number
    source: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseAgreementCreateManyDebtorInput = {
    id?: string
    collection_case_id: string
    total_amount: Decimal | DecimalJsLike | number | string
    installment_amount: Decimal | DecimalJsLike | number | string
    installments_count: number
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.AgreementStatus
    tenant_id: string
    comment?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VerdictCreateManyDebtorInput = {
    id?: string
    invoice_number: string
    creditor_name: string
    registration_number: string
    sentence_amount: number
    sentence_date: Date | string
    status?: $Enums.VerdictStatus
    created_at?: Date | string
    updated_at?: Date | string
    procesal_cost?: number | null
    tenant_id: string
    notes?: string | null
    bailiff_id?: string | null
  }

  export type CollectionCaseUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCollection_casesNestedInput
    notifications?: CollectionCaseNotificationUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: CollectionCaseNotificationUncheckedUpdateManyWithoutCollection_caseNestedInput
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutCollection_caseNestedInput
    agreements?: CollectionCaseAgreementUncheckedUpdateManyWithoutCollection_caseNestedInput
    penalties?: CollectionCasePenaltyUncheckedUpdateManyWithoutCollection_caseNestedInput
    chat_rooms?: ChatRoomUncheckedUpdateManyWithoutCollection_caseNestedInput
  }

  export type CollectionCaseUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder1_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminder2_due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    amount_original?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_due?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount_to_receive?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumCollectionCaseStatusFieldUpdateOperationsInput | $Enums.CollectionCaseStatus
    notification_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DebtorIncomeUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAgreementsNestedInput
    collection_case?: CollectionCaseUpdateOneRequiredWithoutAgreementsNestedInput
    installments?: CollectionCaseAgreementInstallmentUpdateManyWithoutAgreementNestedInput
    payments?: CollectionCasePaymentUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCaseAgreementUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    tenant_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutAgreementNestedInput
    payments?: CollectionCasePaymentUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type CollectionCaseAgreementUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installment_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installments_count?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAgreementStatusFieldUpdateOperationsInput | $Enums.AgreementStatus
    tenant_id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerdictUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff?: UserUpdateOneWithoutVerdict_bailiffsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVerdictsNestedInput
    attachments?: VerdictAttachmentUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff_id?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: VerdictAttachmentUncheckedUpdateManyWithoutVerdictNestedInput
    bailiff_services?: VerdictBailiffServicesUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_embargo?: VerdictEmbargoUncheckedUpdateManyWithoutVerdictNestedInput
    verdict_interest?: VerdictInterestUncheckedUpdateManyWithoutVerdictNestedInput
  }

  export type VerdictUncheckedUpdateManyWithoutDebtorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    creditor_name?: StringFieldUpdateOperationsInput | string
    registration_number?: StringFieldUpdateOperationsInput | string
    sentence_amount?: FloatFieldUpdateOperationsInput | number
    sentence_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerdictStatusFieldUpdateOperationsInput | $Enums.VerdictStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    procesal_cost?: NullableFloatFieldUpdateOperationsInput | number | null
    tenant_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    bailiff_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatMessageCreateManyRoomInput = {
    id?: string
    sender_id: string
    message: string
    file_url?: string | null
    file_name?: string | null
    timestamp?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ChatMessageUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementInstallmentCreateManyAgreementInput = {
    id?: string
    number: number
    due_date: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.InstallmentStatus
    payment_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCasePaymentCreateManyAgreementInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    collection_case_id: string
    payment_date: Date | string
    reference_number?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CollectionCaseAgreementInstallmentUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: CollectionCasePaymentUpdateOneWithoutInstallmentsNestedInput
  }

  export type CollectionCaseAgreementInstallmentUncheckedUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    payment_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCasePaymentUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collection_case?: CollectionCaseUpdateOneRequiredWithoutPaymentsNestedInput
    installments?: CollectionCaseAgreementInstallmentUpdateManyWithoutPaymentNestedInput
  }

  export type CollectionCasePaymentUncheckedUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: CollectionCaseAgreementInstallmentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type CollectionCasePaymentUncheckedUpdateManyWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    collection_case_id?: StringFieldUpdateOperationsInput | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}